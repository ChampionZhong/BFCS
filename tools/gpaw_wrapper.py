"""
Regenerated Google-style docstrings for module 'gpaw'.
README source: others/readme/gpaw/README.rst
Generated at: 2025-12-02T06:09:09.344678Z

Total functions: 266
"""


import numpy
from typing import List

################################################################################
# Source: gpaw.benchmark.parse_git_status
# File: gpaw/benchmark/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_benchmark_parse_git_status(text: str):
    """Parse the branch name from the textual output of the git status command.
    
    This function is used in GPAW's benchmarking and logging code to determine
    which Git branch produced a particular run or result. It accepts the complete
    multi-line output of the git status command as a single string and extracts
    the branch name by looking for the first line that begins with the exact,
    case-sensitive prefix "On branch". It is a pure, side-effect-free parser and
    does not invoke Git or perform any I/O; it only examines the provided text.
    
    Args:
        text (str): The full output of a git status command as a single string.
            In the GPAW benchmarking context this is typically the stdout captured
            from running "git status" in the repository that produced the
            benchmark. The function splits this string on newline characters
            (text.split('\n')) and inspects each resulting line in order. The
            implementation checks for lines that start exactly with "On branch"
            (no leading whitespace, case-sensitive). When such a line is found the
            function returns the last whitespace-separated token of that line
            (line.split()[-1]) as the branch name. Because it uses startswith,
            lines that contain leading spaces or are localized into other
            languages will not match; such inputs will be treated as if no branch
            line were present. If multiple matching lines exist, the first match
            encountered (first line in text order) is returned. The function does
            not validate the token further (for example, it does not restrict
            characters allowed in Git branch names).
    
    Returns:
        str: The parsed branch name extracted from the first line beginning with
        "On branch". If no such line is found in the provided text, the function
        returns the literal string '???' to indicate an unknown or unparseable
        branch. This return value is intended for use in human-readable logs,
        filenames, or benchmark metadata; callers should treat '???' as a sentinel
        meaning "branch could not be determined" and handle it accordingly.
    """
    from gpaw.benchmark import parse_git_status
    return parse_git_status(text)


################################################################################
# Source: gpaw.atom.configurations.core_states
# File: gpaw/atom/configurations.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_atom_configurations_core_states(symbol: str):
    """gpaw.atom.configurations.core_states returns the number of core states (Njcore) associated with a given chemical element symbol as parsed from the module-level GPAW configuration data. In the GPAW DFT/PAW context (see README: GPAW uses the PAW method and ASE), this function is used by atomic-configuration parsing routines to determine how many core electronic states are defined for an element; this number influences how core electrons and projector-augmentation channels are handled when building atomic datasets and initializing calculations.
    
    Args:
        symbol (str): The chemical element symbol (for example 'H', 'Fe') identifying the element whose core-state count is requested. The function looks up parameters[symbol] and configurations[...] in the same module to find the textual core specification; therefore the caller must ensure that the module-level dictionaries parameters and configurations contain entries for this symbol (as used elsewhere in GPAW to describe atomic configurations).
    
    Behavior and parsing details:
        The function obtains core = parameters[symbol].get('core', '') and then parses that string:
        - If the core string starts with '[' it treats the bracketed token as a reference configuration name: it splits at the first ']' into a and core, sets core_symbol = a[1:], and computes j = len(configurations[core_symbol][1]). This j is the number of core states contributed by the referenced configuration (configurations is the module-level mapping of named configurations used by GPAW).
        - After handling any bracketed reference, the remaining core string is interpreted as encoding additional core states, where each core state is represented by two characters in that encoding. The count of such additional states is computed as len(core) // 2.
        - The returned Njcore is the sum of the referenced-configuration contribution j and the number of additional encoded states (len(core) // 2).
        - If parameters[symbol] has no 'core' key, the default core string is the empty string and the function returns 0.
    
    Side effects and dependencies:
        This function has no side effects (it does not modify module-level data), but it depends on the presence and correct structure of the module-level dictionaries parameters and configurations. The second element configurations[core_symbol][1] is expected to be a sequence whose length corresponds to the number of core states in the referenced configuration.
    
    Defaults:
        The absence of the 'core' key for a symbol in parameters is treated as an empty core specification and yields a result of 0.
    
    Failure modes (exceptions raised):
        KeyError: If symbol is not a key in parameters, or if a bracketed reference core_symbol is not a key in configurations.
        ValueError: If the core string starts with '[' but does not contain a matching ']' so that the split and unpack fail.
        AttributeError: If parameters[symbol]['core'] exists but is not a string-like object (so .startswith cannot be called).
    
    Returns:
        int: Njcore, the integer number of core states parsed for the given element symbol. This integer is used by GPAW atomic-configuration and PAW setup code to determine how many core electronic states are present for the element.
    """
    from gpaw.atom.configurations import core_states
    return core_states(symbol)


################################################################################
# Source: gpaw.analyse.vdwradii.vdWradii
# File: gpaw/analyse/vdwradii.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_analyse_vdwradii_vdWradii(symbols: list, xc: str):
    """gpaw.analyse.vdwradii.vdWradii finds atomic van der Waals radii using the Tkatchenko–Scheffler scheme implemented in GPAW. It computes a cutoff electron density from a rare-gas reference atom and locates the radius at which the target atom's radial electron density equals that cutoff. The radii are returned in units of Angstrom and are suitable for use in DFT post-processing and dispersion-correction schemes within the GPAW/ASE workflow.
    
    Args:
        symbols (list): A sequence (list) of chemical element symbols (strings) for which van der Waals radii are desired, for example ['H', 'C', 'O']. The function preserves the input order and returns one radius per symbol. Each symbol is looked up in the module-level atomic_numbers mapping; if a symbol is unknown this lookup will raise a KeyError. Practical significance: use this list to request radii for atoms in a GPAW calculation, geometry, or ASE Atoms object.
        xc (str): Exchange–correlation functional identifier given as a string (for example 'PBE'). This string is used to select the PAW setups and radial densities via GPAW's XC/Setups machinery; internally, when xc is a string it is converted by calling XC(xc) to obtain the functional object used to construct Setups. Practical significance: the choice of xc determines which PAW dataset and atomic density are used to compute the vdW radii; different xc or setup choices may change the returned radii.
    
    Returns:
        list: A list of floating-point radii (Python floats) in Angstroms, one entry for each symbol in the input list, in the same order as the input. Each returned radius is computed by (1) selecting a rare-gas reference atom from a predefined list of rare gases (module-level Bondi64jpc_vdWradii and related data) belonging to the same periodic row as the target element, (2) reading the reference atom's radial electron density from the PAW setup selected for the given xc, (3) finding the reference cutoff density at the stored reference van der Waals radius (collected_vdWradii) for that rare gas (linear interpolation on the radial grid), and (4) finding the radius for the target atom where its radial density equals that cutoff density (again by linear interpolation). The returned radii are the resulting radii multiplied by the Bohr-to-Angstrom conversion factor.
    
    Behavior, side effects, and failure modes:
        The function constructs PAW Setups for single-atom calculations (Setups([Z], 'paw', {}, xc, world=world)) and therefore may read setup files from the GPAW setup database; this can incur I/O and may be relatively slow on first access. The function relies on several module-level constants and mappings (atomic_numbers, chemical_symbols, Bondi64jpc_vdWradii, collected_vdWradii, Bohr, Setups, XC, and world) provided by the gpaw.analyse.vdwradii module and the GPAW package; missing or misconfigured setup data will cause the underlying Setups constructor to raise exceptions. If the radial grid of a setup does not bracket the required radius or density, the linear interpolation steps may attempt out-of-range indexing and raise IndexError; similarly, unknown element symbols cause KeyError during atomic_numbers lookup. The function accepts xc as a string (per the signature) and converts it internally; passing non-string objects that are not valid XC representations may cause errors. No external state is modified except for possible caching or file reads performed by GPAW's setup loader.
    """
    from gpaw.analyse.vdwradii import vdWradii
    return vdWradii(symbols, xc)


################################################################################
# Source: gpaw.benchmark.gs_and_move_atoms
# File: gpaw/benchmark/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_benchmark_gs_and_move_atoms(long_name: str, calc_info: dict):
    """gpaw.benchmark.gs_and_move_atoms
    Calculates one geometry-relaxation-like step for a GPAW benchmark: evaluates energy and forces, moves atoms by a fraction of the forces (or applies a small strain if forces are negligible), records timings for the two evaluation phases, and returns the initial energy together with the forces measured after the move and timing metadata. This function is intended for automated benchmarking of GPAW/ASE geometry-step performance and reproduces the typical sequence used in a geometry relaxation: evaluate, take a small step toward the minimum, wrap positions, re-evaluate. It uses benchmark_atoms_and_calc(long_name, calc_info) to obtain an ASE Atoms object and its GPAW calculator according to the provided benchmark configuration.
    
    Args:
        long_name (str): A descriptive name for this benchmark run. In the GPAW benchmarking context this string identifies the benchmark case (for example the system and settings being tested) and is forwarded to benchmark_atoms_and_calc to select or build the Atoms and calculator configuration. Practically, long_name is used for human-readable logging and for selecting the specific benchmark input dataset; it must be a Python str.
        calc_info (dict): A dictionary of calculator-related settings and parameters used by the GPAW benchmarking harness. This dict is passed verbatim to benchmark_atoms_and_calc(long_name, calc_info) which constructs the ASE Atoms object and attaches a GPAW calculator configured according to these parameters (for example basis, xc functional, grid or k-point settings). The dict is not modified by gs_and_move_atoms itself; it must therefore contain all information required by the benchmarking helper to create a valid Atoms+calculator pair.
    
    Behavior and side effects:
        The function calls benchmark_atoms_and_calc(long_name, calc_info) to obtain (atoms, calc). It then:
        1) Enters a timed region labeled "First step" (Walltime context) and computes the initial potential energy E via atoms.get_potential_energy() and the forces F via atoms.get_forces(). The returned energy E is the potential energy computed by the attached GPAW calculator and, in the ASE/GPAW context, is expressed in ASE units (energy in eV, coordinates in Å). Forces F are the numpy array returned by ASE/GPAW (conventionally in eV/Å).
        2) If the maximum absolute force component abs(F).max() is strictly less than 0.0001 (the specific threshold used to detect vanishing forces), the function treats the system as effectively stress-dominated and instead queries the stress tensor S with atoms.get_stress(voigt=False) and applies a small cell deformation: atoms.set_cell(atoms.cell @ (I - 0.02 * S), scale_atoms=True). The scalar 0.02 is the fixed strain coefficient used by the benchmark to move the cell toward lower stress while scaling atomic positions.
        3) Otherwise (forces are not negligible), the function displaces atomic positions by adding 0.1 * F to atoms.positions; the multiplicative factor 0.1 is the fixed step-size fraction of the force used by the benchmark to mimic a modest geometry relaxation step.
        4) After the move or cell change, atoms.wrap() is called to ensure atomic positions are inside the simulation cell (ASE periodic wrapping). This mutates the Atoms object in-place.
        5) The function enters a second timed region labeled "Second step" and re-evaluates the potential energy (value discarded) and re-queries the forces F = atoms.get_forces(). The forces returned by the function are this second-set of forces (after the move).
        All described operations mutate the returned Atoms object created by benchmark_atoms_and_calc (positions and possibly cell) and may update internal calculator state as a consequence of get_potential_energy()/get_forces() calls.
    
    Defaults and numerical choices:
        The function uses fixed numeric controls internal to the benchmark: the force threshold 0.0001 (absolute), the force-displacement multiplier 0.1, and the stress-strain multiplier 0.02. These values are hard-coded and chosen to simulate a small geometry-relaxation step; they are not configurable via the signature of this function.
    
    Failure modes and exceptions:
        The function does not catch exceptions raised by benchmark_atoms_and_calc, ASE, or GPAW. Common failure modes include errors raised when constructing the Atoms/calculator pair, when the calculator fails to evaluate potential energy or forces, or when the returned arrays contain non-finite values. In such cases the exception propagates to the caller and no return value is produced. If get_forces() returns an array whose abs().max() cannot be computed (for example due to NaN or infinite values), the comparison to the threshold will either raise or behave according to NumPy semantics; callers should ensure the benchmark configuration in calc_info produces finite energies and forces.
    
    Returns:
        dict: A dictionary containing the results and timing metadata from the two evaluation steps. The dict always includes at least the following keys:
            'energy': the float potential energy E measured during the "First step" evaluation. In the GPAW/ASE context this is expressed in ASE energy units (eV).
            'forces': a Python list obtained from F.tolist() where F is the numpy array of forces measured after the movement (i.e., the forces from the "Second step"). Practically this is a nested list of floats, one 3-component force vector per atom (conventionally in eV/Å in ASE/GPAW).
        In addition, the dictionary is extended with the key/value pairs produced by the Walltime context managers step1.todict() and step2.todict() for the "First step" and "Second step" timings respectively. Those entries provide timing and profiling metadata recorded by the benchmark Walltime utility (the exact keys are those produced by Walltime.todict()).
    
    Practical significance:
        This function is intended to be used inside the GPAW benchmarking suite to simulate a single geometry-relaxation iteration and to measure the time spent in energy/force evaluation before and after a small atomic displacement or cell deformation. The returned energy and post-move forces provide a compact summary of the step's physical outcome, while the timing metadata is used for performance comparisons across calculators, grids, and hardware.
    """
    from gpaw.benchmark import gs_and_move_atoms
    return gs_and_move_atoms(long_name, calc_info)


################################################################################
# Source: gpaw.benchmark.parse_nvidia_smi
# File: gpaw/benchmark/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_benchmark_parse_nvidia_smi(dct: dict, out: str):
    """Parse output from nvidia-smi and count GPU models for gpaw.benchmark.parse_nvidia_smi.
    
    Parses the textual output produced by the NVIDIA command-line tool nvidia-smi to extract the
    advertised GPU model name and increment a counter for that model in the supplied dictionary.
    This function is used within GPAW benchmarking and environment-detection code to record how many
    GPUs of each model are present on the system where the nvidia-smi output was collected. The
    implementation expects the nvidia-smi output to contain lines with the substring "NVIDIA " and a
    tokenized layout where the GPU name tokens follow at least three initial tokens on the line;
    tokens are collected until a delimiter token ('|', 'On', or 'Off') is encountered.
    
    Args:
        dct (dict): A mapping used to accumulate counts of GPU models. Keys are GPU model name strings
            produced by joining contiguous tokens from the nvidia-smi line (see behavior below).
            Values are integers representing how many GPUs of that model have been observed.
            The function modifies this dict in-place by performing an in-place increment
            equivalent to dct[gpu_name] += 1 for each GPU it finds. Because the code uses the
            in-place addition operator on dct[gpu_name], a KeyError will be raised if the extracted
            gpu_name is not already present as a key in dct; callers must ensure the key exists
            beforehand (for example, initialize counts to 0) or handle such exceptions. Passing a
            non-dict or a dict with non-integer values for the keys will result in TypeError or
            other runtime errors when attempting to increment.
        out (str): The full text output from running the nvidia-smi command (standard output). This
            string is split into lines and searched for any line containing the substring "NVIDIA ".
            The function assumes the GPU name appears in tokens starting from the fourth whitespace
            separated token on that line (line.split()[3:]) and stops collecting tokens when it
            encounters any of the delimiter tokens '|', 'On', or 'Off'. If out contains the phrase
            "command not found", the function treats this as absence of nvidia-smi and returns
            without changing dct.
    
    Returns:
        None: The function does not return a value. Its primary effect is the side effect of
        incrementing counts in the provided dct in-place for each GPU model discovered in out.
        Failure modes and side effects:
        - No modification to dct occurs if out contains the substring "command not found".
        - A KeyError will be raised if the extracted GPU model name is not already a key in dct.
        - TypeError may be raised if dct is not a dict-like object that supports item access and
          in-place addition, or if out is not a string.
        - If the nvidia-smi output format differs from the assumed token layout, the extracted
          gpu_name may be incorrect (merged tokens, truncated name) or no name may be found,
          leading to incorrect counts or exceptions.
    """
    from gpaw.benchmark import parse_nvidia_smi
    return parse_nvidia_smi(dct, out)


################################################################################
# Source: gpaw.benchmark.parse_mem
# File: gpaw/benchmark/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_benchmark_parse_mem(memstr: str):
    """Parse a human-readable memory size string and convert it to a number of bytes using binary (base-2) multipliers.
    
    This function is used in GPAW benchmarking and configuration code to interpret short memory specifications such as those found in job configuration, command-line options, or benchmark descriptions. The input string must end with one of the exact uppercase suffixes 'G', 'M', or 'K' to indicate gibibytes, mebibytes, or kibibytes respectively. The numeric portion preceding the suffix is parsed and multiplied by the corresponding binary multiplier (G -> 1024**3, M -> 1024**2, K -> 1024**1). The result is returned as a float representing the number of bytes; this numeric byte value can be used for memory allocation decisions, resource reporting, or performance comparisons in the GPAW DFT benchmarking and runtime configuration contexts.
    
    Args:
        memstr (str): Memory string to parse. Must be a non-empty string whose last character is exactly one of 'G', 'M', or 'K' (uppercase). The characters before the final suffix must represent a decimal number (for example '2G', '512M', '64K', '1.5G'). The suffix indicates binary units (1K = 1024 bytes). This parameter is taken verbatim and not normalized by the function, so using lowercase suffixes or omitting the suffix will produce an error.
    
    Returns:
        float: The parsed memory size expressed in bytes using binary multipliers (e.g., '1G' -> 1073741824.0). The return value is a floating-point number because the input numeric part may be fractional (for example '1.5G' -> 1610612736.0).
    
    Notes on behavior and failure modes: The function has no side effects. If memstr[-1] is not one of the keys 'G', 'M', 'K', a KeyError will be raised by the internal mapping lookup. If the numeric portion memstr[:-1] cannot be converted to a float (for example it is empty or not a valid decimal), a ValueError will be raised by float(). The function does not accept lowercase suffixes or other unit strings; callers should supply exactly formatted strings when used within GPAW benchmarking, configuration parsing, or similar code paths.
    """
    from gpaw.benchmark import parse_mem
    return parse_mem(memstr)


################################################################################
# Source: gpaw.benchmark.benchmark_atoms_and_calc
# File: gpaw/benchmark/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_benchmark_benchmark_atoms_and_calc(long_name: str, calc_info: str):
    """Create an ASE Atoms object and a GPAW calculator from a combined long name and
    calculator information string for use in GPAW benchmarking and test workflows.
    
    This function is used in the gpaw.benchmark module to construct the atomic
    system and the corresponding GPAW calculator configuration from a compact
    identifier string. The function expects long_name to encode both the atomic
    system and a parameter set (joined by a single '-' character), parses these
    components with parse_system and parse_parameters, selects the GPAW interface
    implementation according to calc_info ('new' selects gpaw.new.ase_interface.GPAW,
    'old' selects gpaw.GPAW), instantiates the calculator with the parsed
    parameters, assigns it to the ASE Atoms object (atoms.calc), and returns both
    the Atoms object and the calculator instance. The GPAW calculator is created
    with a text-log file named "{long_name}-{calc_info}.log". Parameter dictionaries
    are pretty-printed on rank 0 of the global MPI communicator (world) using pp.
    
    Args:
        long_name (str): A compact identifier encoding the target atomic system and
            the calculator parameter set, joined by exactly one hyphen ('-').
            The left-hand part (system) is passed to parse_system to produce an ASE
            Atoms object representing the atomic geometry used in DFT calculations.
            The right-hand part (parameter_sets) is passed to parse_parameters to
            produce a dictionary of keyword arguments for the GPAW constructor.
            Example form: "system-parameterset". If long_name does not contain
            exactly one '-', Python will raise a ValueError when unpacking the split
            result.
        calc_info (str): A string selecting which GPAW interface implementation to
            use. Must be either 'new' or 'old'. If calc_info == 'new', the function
            imports GPAW from gpaw.new.ase_interface and instantiates that class;
            if calc_info == 'old', it imports GPAW from gpaw. If calc_info has any
            other value, the function raises Exception("Unknown calc info {calc_info}").
            This selection is important for benchmarking differences between the
            legacy and new GPAW ASE interfaces and affects available features and
            parameter names accepted by the calculator.
    
    Returns:
        tuple: (atoms, calculator) where atoms is an ASE Atoms instance created by
            parse_system(system) and calculator is the GPAW calculator instance
            assigned to atoms.calc. The calculator has been constructed by calling
            GPAW(**parameters, txt=f'{long_name}-{calc_info}.log'), so a log file with
            that name will be produced by GPAW as a side effect. The function also
            has the side effect of pretty-printing the parameters dictionary (via
            pp) when the global MPI communicator variable world has rank 0.
    
    Raises and side effects:
        - Exception: raised when calc_info is not 'new' or 'old' (explicit check in
          code).
        - ValueError: arises if long_name.split('-') does not produce exactly two
          parts (unpacking into system and parameter_sets).
        - ImportError: may be raised if the selected GPAW module cannot be imported.
        - parse_system or parse_parameters may raise exceptions for invalid system
          or parameter encodings.
        - Side effects include assignment atoms.calc, creation of a text log file
          named "{long_name}-{calc_info}.log" by the GPAW constructor, and printing
          of the parameters on rank 0 (world.rank == 0) using pp. These side effects
          are relied upon in GPAW benchmarking workflows to persist calculation
          logs and to show parsed parameters during test runs.
    """
    from gpaw.benchmark import benchmark_atoms_and_calc
    return benchmark_atoms_and_calc(long_name, calc_info)


################################################################################
# Source: gpaw.atom.radialgd.fsbt
# File: gpaw/atom/radialgd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_atom_radialgd_fsbt(
    l: int,
    f_g: numpy.ndarray,
    r_g: numpy.ndarray,
    G_k: numpy.ndarray
):
    """Fast spherical Bessel transform used in GPAW's radial-grid routines.
    
    Computes the spherical Bessel transform
        ∫_0^∞ r dr j_l(G r) f(r)
    for a radial function f(r) sampled on a discrete radial grid r_g, returning the transform sampled on the provided G_k radial-frequency points. The implementation is a fast algorithm that uses l+1 real FFTs (numpy.fft.rfft) and algebraic recurrence factors to build the transform for order l, which is useful in GPAW/PAW routines when converting atom-centered radial functions between real-space radial grids and reciprocal-space (G) representation.
    
    Args:
        l (int): Spherical Bessel order (non-negative integer) l in j_l. This selects which spherical Bessel function j_l(Gr) appears in the integral. In this implementation l must be an integer >= 0 because the algorithm performs a loop over n in range(l+1) and uses factorial ratios fac(l+n)/fac(l-n). Supplying a negative or non-integer l will produce incorrect behavior or raise an exception.
        f_g (numpy.ndarray): 1-D array of function values f(r) sampled on the radial grid r_g. This represents the radial function to be transformed (f(r) evaluated at the points r_g). f_g must have the same length as r_g and contain real-valued samples consistent with the radial grid used by GPAW atom-centered routines.
        r_g (numpy.ndarray): 1-D array of radial grid points r (same length as f_g). The first element r_g[0] is expected to be the origin (typically zero) and r_g[1] is used as the first nonzero radius / effective grid spacing in the algorithm. The code uses r_g[1] and divides by r_g[1:] in intermediate steps, so r_g[1] must be non-zero to avoid division-by-zero errors.
        G_k (numpy.ndarray): 1-D array of radial-frequency points G at which the transform is evaluated. The returned array f_k has the same shape as G_k. The algorithm assumes that G_k[1:] (all entries except possibly G_k[0]) are non-zero because the result is divided by G_k[1:]**(l+1); a zero value in G_k beyond index 0 will cause a division-by-zero runtime error.
    
    Returns:
        numpy.ndarray: 1-D array f_k with the same shape as G_k containing the sampled spherical Bessel transform values for each G in G_k, i.e., an approximation to ∫_0^∞ r dr j_l(G r) f(r) sampled at G=G_k. For G_k[0] the function handles the l==0 special case explicitly: when l == 0 the returned f_k[0] is set to numpy.dot(r_g, f_g * r_g) * r_g[1], which corresponds to the G→0 limit of the transform computed consistently with the discrete radial sampling. No other entries of the inputs are modified; all intermediate arrays are local to the function.
    
    Behavior, side effects, and failure modes:
        - The algorithm uses N = (len(G_k) - 1) * 2 and performs l+1 real FFTs (numpy.fft.rfft) on temporary arrays derived from f_g and r_g. This provides an efficient O((l+1) N log N)-type evaluation compared to direct quadrature for large grids.
        - Inputs f_g, r_g, and G_k are expected to be one-dimensional numpy.ndarray objects. f_g and r_g must have equal length. G_k can have a different length; the code uses len(G_k) to set the FFT size N.
        - r_g[1] must be non-zero because the implementation divides by r_g[1] and by r_g[1:] during intermediate steps. If r_g[1] == 0 a ZeroDivisionError will occur.
        - G_k[1:] must be non-zero because the final result divides by G_k[1:]**(l+1). If any of G_k[1:] == 0 a ZeroDivisionError will occur; G_k[0] is treated specially only for the l == 0 case.
        - If the shapes, dimensionality, or dtypes of inputs are incompatible with numpy arithmetic used in the implementation, numpy will raise the corresponding exceptions (e.g., ValueError for shape errors, TypeError for unsupported dtypes).
        - The function does not mutate the caller-provided arrays (f_g, r_g, G_k); it returns a new numpy.ndarray with the transform values.
    """
    from gpaw.atom.radialgd import fsbt
    return fsbt(l, f_g, r_g, G_k)


################################################################################
# Source: gpaw.atom.basis.make_split_valence_basis_function
# File: gpaw/atom/basis.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_atom_basis_make_split_valence_basis_function(
    r_g: numpy.ndarray,
    psi_g: numpy.ndarray,
    l: int,
    gcut: int
):
    """Make a split-valence radial basis function by smoothly joining a low-radius polynomial to a given atomic orbital on a radial grid.
    
    Args:
        r_g (numpy.ndarray): 1-D radial grid values (r) used for the atomic orbital. The function treats r_g[gcut] as the cutoff radius rcut and accesses r_g[gcut + 1], so gcut must satisfy 0 <= gcut < len(r_g) - 1. Values are expected to be real and nonzero at the indices used (division by r_g[...] occurs). In the GPAW/PAW atomic-basis context this array represents the radial grid on which orbitals and basis functions are sampled.
        psi_g (numpy.ndarray): Array of sampled atomic-orbital values multiplied by radius, i.e., psi_g[i] = psi(r_g[i]) * r_g[i]. The function reads psi_g[gcut] and psi_g[gcut + 1] to determine matching conditions and copies psi_g[gcut:] into the returned array for r >= rcut. In GPAW this represents the stored radial orbital (psi(r) * r) for an atomic basis function.
        l (int): Angular momentum quantum number (nonnegative integer) of the orbital. It appears in the low-radius polynomial as a power r^l and determines the small-r behavior enforced on the constructed basis function. In GPAW this corresponds to the orbital angular momentum channel for which a split-valence matching is being performed.
        gcut (int): Index into r_g and psi_g that selects the cutoff grid point rcut = r_g[gcut]. The function ensures the cutoff is located on a grid point by using this index; it also reads the next grid point r_g[gcut + 1] to construct a polynomial that matches value and derivative at rcut. gcut must be an integer index with an available next point (gcut + 1).
    
    Returns:
        numpy.ndarray: A new array psi_g2 of the same shape as r_g and psi_g containing values equal to psi(r) * r everywhere, with the modification that for r < rcut the returned values are given by a low-radius polynomial times r: psi_out(r) = r^(l+1) * (a - b * r^2). For r >= rcut the returned values equal the input psi_g (copied: psi_out(r) = psi_g). The polynomial coefficients a and b are determined from the two grid points r1 = r_g[gcut] and r2 = r_g[gcut + 1] by matching the orbital value and radial derivative at rcut. Concretely, the implementation computes y1 = psi_g[gcut] / r1 and y2 = psi_g[gcut + 1] / r2, then
        b = - (y2 / r2**l - y1 / r1**l) / (r2**2 - r1**2)
        a = y1 / r1**l + b * r1**2
        and sets psi_g2 = r_g**(l + 1) * (a - b * r_g**2) for indices < gcut and psi_g2[gcut:] = psi_g[gcut:] for indices >= gcut.
        The returned array is newly allocated (no in-place modification of the input arrays).
    
    Behavior, side effects, and failure modes:
        The function constructs a continuous and differentiable join at rcut by enforcing equality of the orbital value and its first radial derivative at rcut between the polynomial interior and the provided psi outside. It is intended for use in GPAW when building split-valence atomic basis functions for PAW/ASE calculations where small-r behavior must be regularized.
        No global state is modified; the function returns a new numpy.ndarray and does not alter the input psi_g or r_g arrays.
        Errors will occur if gcut is out of the valid index range (IndexError if gcut < 0 or gcut >= len(r_g) - 1), or if any required r_g element equals zero (ZeroDivisionError when dividing by r_g[gcut] or r_g[gcut + 1]). The function also assumes r_g is strictly ordered with r_g[gcut + 1] != r_g[gcut] so that the denominator (r2**2 - r1**2) is nonzero; if this is not true a ZeroDivisionError or a numerical instability may occur.
    """
    from gpaw.atom.basis import make_split_valence_basis_function
    return make_split_valence_basis_function(r_g, psi_g, l, gcut)


################################################################################
# Source: gpaw.benchmark.parse_name
# File: gpaw/benchmark/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_benchmark_parse_name(name: str):
    """Parse a benchmark name string used by the GPAW benchmarking utilities and extract a canonical (long) benchmark identifier, an optional nickname, and the calculation mode indicator.
    
    Args:
        name (str): Input benchmark name string describing a benchmark configuration and optional calculation info. The string must be a Python str and may take forms such as "C60_pw", "C60_pw#new", "C60-pw.high:kpts.density6", or "C60-pw.high:kpts.density6#new". The portion after a single '#' (if present) must be exactly "new" or "old" and indicates whether the caller requests a fresh ("new") calculation or reuse of prior results ("old"). If no '#' is present the function defaults calc_info to "new". If the name contains no '-' character it is treated as a nickname and must be present as a key in the module-level benchmarks mapping; in that case the function resolves the nickname to the full benchmark string via benchmarks[name]. If the name contains '-' it is treated as an explicit long-form benchmark identifier and is returned unchanged as the canonical form. This function depends on the module-level symbols benchmarks and benchmarks_error for nickname resolution and error reporting.
    
    Returns:
        tuple[str, str, str]: A 3-tuple (short_name, long_name, calc_info). short_name is the provided nickname when the input was a nickname (a key in benchmarks) or the literal string "N/A" when the input was already a long-form name; short_name is useful for reporting and compact identification in GPAW benchmark tooling. long_name is the resolved canonical benchmark identifier (either benchmarks[nickname] or the original long-form input) and is the value that downstream GPAW benchmark code uses to look up configuration details (e.g., DFT mode, k-point density, quality tags). calc_info is a string that is either "new" or "old" and indicates whether to perform a new calculation ("new") or to attempt to reuse previously stored results ("old"); when absent in the input the function returns "new" as the default.
    
    Raises:
        AssertionError: If the input contains a '#' but the token after the first '#' is not exactly "new" or "old", or if more than one '#' is present (the function asserts len(names) == 2), an AssertionError is raised to signal malformed calc-info suffix. Exception: If the input is treated as a nickname (no '-' in the name) but the nickname is not found in the module-level benchmarks mapping, the function raises the Exception produced by benchmarks_error(name) to indicate an unknown benchmark short name. These are the primary failure modes; the function has no other side effects.
    """
    from gpaw.benchmark import parse_name
    return parse_name(name)


################################################################################
# Source: gpaw.benchmark.parse_processor
# File: gpaw/benchmark/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_benchmark_parse_processor(text: str):
    """gpaw.benchmark.parse_processor parses the processor model string from the output of the Unix lscpu command for use in GPAW benchmarking and performance metadata.
    
    Args:
        text (str): The complete text output from the lscpu command as a single string (typically newline-separated). This function expects the standard English lscpu label "Model name:" to appear at the start of a line. In the GPAW benchmarking context this string is passed to extract a human-readable CPU model identifier to include in benchmark reports, logs, or performance comparisons.
    
    Behavior and role:
        The function splits the provided text on newline characters and examines each line in order. For the first line that begins exactly with the prefix "Model name:" (case- and position-sensitive, no leading whitespace allowed), it returns the substring after that prefix with surrounding whitespace removed. This returned string is intended to be the processor model identifier recorded in GPAW benchmark output or metadata. If multiple "Model name:" lines exist, the first matching line is used.
    
    Side effects and defaults:
        This function is pure and has no side effects (it does not modify input, write files, or perform I/O). If no line starting exactly with "Model name:" is found, the function returns the literal string 'No "Model name:" found' as a sentinel value; callers in the GPAW benchmarking pipeline should treat this as an indication that the expected lscpu label was absent or differently formatted.
    
    Failure modes and limitations:
        The function requires a str. If a non-str object is passed, an AttributeError or TypeError may be raised when attempting to call split on the input. The function performs a simple prefix match and therefore will not detect the model name if the lscpu output is localized, uses a different label, contains leading whitespace before "Model name:", or otherwise deviates from the expected format. It does not validate or normalize the extracted model string beyond stripping surrounding whitespace.
    
    Returns:
        str: The processor model string extracted from the first line that starts with "Model name:", with surrounding whitespace removed. If no such line is found, returns the exact sentinel string 'No "Model name:" found'. This return value is intended for inclusion in GPAW benchmark metadata and human-readable reports.
    """
    from gpaw.benchmark import parse_processor
    return parse_processor(text)


################################################################################
# Source: gpaw.benchmark.parse_parameters
# File: gpaw/benchmark/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_benchmark_parse_parameters(parameter_sets: str):
    """Parses a compact parameter-set descriptor string used by gpaw.benchmark into a single dictionary of configuration parameters.
    
    This function is used by GPAW benchmarking and configuration code to convert a human-readable, compact descriptor (for example "pw.high:gamma:parallel.gpu" or "lcao.dzp:kpt.density4:noscalapack") into a concrete mapping of parameters that can be passed to GPAW calculators or benchmarking routines. The descriptor language treated here is specific to gpaw.benchmark and documented by the repository examples: individual parameter sets are concatenated with ":" (colon) and refinements of a single set are given after the main set name separated by "." (dot). The function looks up predefined presets in the global gpaw_parameter_sets mapping, deep-copies the preset defaults, and merges them into a single dictionary using recursive_update so that more specific entries override earlier or more general ones. The function prints a one-line debug representation of each parsed main set and its first-level subset components to stdout (via print(firstsplit)) as a side effect.
    
    Args:
        parameter_sets (str): A colon-separated string describing one or more parameter sets and optional dot-separated subsets that refine each set. Each top-level token before ":" must be a key present in the global gpaw_parameter_sets mapping; for a token of the form "name.sub1.sub2", "name" is the main preset (used to obtain a default parameter dictionary) and subsequent dot-separated names select entries from the preset's "subsets" mapping that further modify the defaults. The order of colon-separated tokens is significant: tokens are processed left-to-right and their parameter dictionaries are merged into the returned mapping in that order. Practical examples: "pw.high:gamma" applies the "pw.high" preset then the "gamma" refinement; "lcao.dzp:kpt.density4:noscalapack" applies the "lcao.dzp" preset, then the "kpt.density4" subset, then the "noscalapack" subset. The argument must be a Python str; passing a non-str will raise a TypeError when the function attempts to call str.split.
    
    Returns:
        dict: A dictionary containing the merged configuration parameters produced by applying the requested presets and subsets. Keys and values are those defined by the gpaw_parameter_sets presets (typically nested dictionaries and primitive values used to configure GPAW calculators and benchmark runs). Later presets and subsets override earlier entries when keys overlap. The returned dictionary is a new object built by deepcopying preset dictionaries and applying recursive_update, so modifying the return value will not change the original gpaw_parameter_sets entries.
    
    Behavior, defaults, side effects, and failure modes:
        - The function uses the global gpaw_parameter_sets mapping to resolve preset names and their "subsets". Each preset entry is expected to be a (default_parameter_set, subsets) pair where default_parameter_set is a dictionary of default parameters and subsets is a mapping from subset names to dictionaries of parameters.
        - For each colon-separated token, the function deep-copies the preset's default_parameter_set and merges it into the accumulating kwargs using recursive_update; if the token contains dot-separated subset names, each named subset is deep-copied and merged in the order they appear. This merge strategy preserves nested dictionary structure while allowing later values to override earlier ones.
        - The function prints a debug tuple (set_name, parameter_subsets) for each parsed token to stdout. This is an intentional side effect present in the implementation and can be useful for debugging but may be noisy in production.
        - If a main preset name is not found in gpaw_parameter_sets, the function will raise a KeyError. If a subset name is not present in the preset's subsets mapping, the function will raise a KeyError when attempting to index subsets[subsetname]. If gpaw_parameter_sets is not defined in the module namespace, a NameError will occur. Passing a non-str for parameter_sets will raise a TypeError when split is called.
        - The function does not perform validation beyond these dictionary lookups; it does not check semantic consistency of parameter values. It returns the merged dictionary even if some presets or subsets are no-ops, provided the names resolve correctly.
    """
    from gpaw.benchmark import parse_parameters
    return parse_parameters(parameter_sets)


################################################################################
# Source: gpaw.atom.all_electron.shoot
# File: gpaw/atom/all_electron.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_atom_all_electron_shoot(
    u: numpy.ndarray,
    l: int,
    vr: numpy.ndarray,
    e: float,
    r2dvdr: numpy.ndarray,
    r: numpy.ndarray,
    dr: numpy.ndarray,
    c10: numpy.ndarray,
    c2: numpy.ndarray,
    scalarrel: bool,
    gmax: int = None
):
    """Shoot the radial Schrödinger equation for a guessed trial eigenenergy in the GPAW all-electron atomic solver.
    
    This function integrates the radial Schrödinger (or scalar-relativistic modified) differential equation for a single radial channel on a radial grid used by GPAW's projector-augmented wave (PAW) all-electron routines. It is used during eigenvalue shooting: for a trial eigenenergy e the routine integrates the wavefunction u(r) from both asymptotic boundaries (r -> 0 and r -> infinity) toward the classical turning point, counts the number of radial nodes, and computes a measure A of the derivative discontinuity at the turning point. The returned node count and discontinuity A are used by higher-level routines to adjust e until the physical eigenstate (correct node count and vanishing A) is found. The function modifies the input array u in-place to contain the integrated radial wavefunction on the provided radial mesh.
    
    Args:
        u (numpy.ndarray): One-dimensional array representing the radial wavefunction values on the radial grid. On entry u supplies storage and on exit u is overwritten with the integrated trial wavefunction corresponding to energy e. The array length determines the radial grid points used. Practical significance: u is the primary output used by the caller to evaluate normalization, overlaps, or to continue matching to outer solutions in the PAW atomic all-electron solver.
        l (int): Orbital angular momentum quantum number (ℓ) for the radial channel. This integer selects the centrifugal contribution l(l+1) in the effective potential and determines node counting rules for the radial Schrödinger problem in atomic DFT contexts.
        vr (numpy.ndarray): Radial potential multiplied by r (i.e., v(r)*r) on the same grid as u and r. This array provides the local potential entering the effective radial equation (including nuclear and Hartree/exchange-correlation parts as assembled by GPAW) and must have the same length as u and r.
        e (float): Trial eigenenergy (in the energy units used by the caller/GPAW). The shooting procedure tests this value: the aim is to find e such that the derivative discontinuity at the classical turning point vanishes and the node count matches the target state.
        r2dvdr (numpy.ndarray): Array containing r^2 * dV/dr evaluated on the radial grid. When scalarrel is True this array is used to assemble scalar-relativistic correction terms in the effective equation. Must have same length as r. Practical significance: provides the radial derivative of the potential required for scalar-relativistic modifications of the differential operator.
        r (numpy.ndarray): One-dimensional array of radial grid points (radius values) corresponding to u, vr, dr, etc. The grid ordering and spacing determine integration behavior; typically r[0] = 0 and r increases to the outermost grid point.
        dr (numpy.ndarray): Array of radial grid spacings (finite differences) used to compute numerical derivatives. dr[i] is the spacing used near grid index i and must match the grid used to construct u and r. It is used to compute finite-difference approximations to dudr and to form integration coefficients.
        c10 (numpy.ndarray): Precomputed coefficient vector c1 evaluated on the radial grid before scalar-relativistic correction. It appears in the three-point finite-difference integration formula and is required to form fm, fp, and f0 (see source). Must match the size of u and r.
        c2 (numpy.ndarray): Precomputed coefficient vector c2 on the radial grid used to assemble the second-derivative finite-difference contributions in the numeric integrator. It must have the same shape as u and r and participates in constructing fm, fp, and f0.
        scalarrel (bool): If True, scalar-relativistic corrections are included in the effective radial coefficients (the code uses a module-level constant alpha to form x = 0.5 * alpha**2 and adjusts c0 and c1 using r2dvdr). If False, the non-relativistic radial equation is integrated. Practical significance: set True when solving scalar-relativistic radial equations in GPAW; set False for non-relativistic solutions.
        gmax (int): Optional. When provided (an integer grid index), the routine treats this index as the turning-point index and performs only the forward (r -> turning point) integration and in-place updates of u up to that index, then returns None. When gmax is None (default) the routine performs the full shooting procedure including backward integration from large r, locating the classical turning point dynamically, matching the two integrations, returning node count and discontinuity. Default: None.
    
    Behavior and side effects:
        - The function integrates using a three-point finite-difference scheme assembled from c0, c1 (or corrected c1 when scalarrel is True), and c2. It constructs fm = 0.5*c1 - c2, fp = 0.5*c1 + c2, f0 = c0 - 2*c2 and uses these to step the wavefunction.
        - If scalarrel is True, additional terms proportional to r2dvdr and the module-level scalar-relativistic factor are added to c0 and c1 before integration; this implements the scalar-relativistic modification of the radial operator used in PAW atomic all-electron calculations.
        - The input array u is modified in-place to contain the integrated radial wavefunction. The routine applies a scaling so the inward and outward integrated pieces are continuous at the turning point; it does not perform a global normalization to unity — normalization is the caller's responsibility.
        - If gmax is provided, the function performs the forward integration up to gmax, stores the updated u values, and returns None (no tuple). This mode is used when the caller provides or fixes the turning point index and only needs the forward solution segment.
        - The routine attempts to prevent overflow of u by rescaling u when entries exceed ~1e100 during backward integration.
    
    Failure modes and special return conditions:
        - If gmax is None and c0 is positive for all grid points (i.e., (c0 > 0).all()), the routine raises ConvergenceError('Bad initial electron density guess!'). This indicates the effective potential combined with the trial energy e produces no classical turning point and signals a failure of the current density or trial energy guess.
        - During backward integration from large r the code expects no node to appear outside the classical turning point. If a negative value of u is encountered where a node should not occur the function prints '!!!!!!' to standard output and returns the sentinel tuple (100, None). This informs the caller that a much more negative eigenvalue is required.
        - If the located turning point is at the outermost grid point (gtp == len(u) - 1), the routine returns the tuple (100, 0.0) indicating an unsuccessful shooting attempt with a turning point at the grid boundary.
        - In the normal successful full-shooting case (gmax is None and no error conditions occur), the routine returns the number of nodes and the derivative discontinuity A (see Returns below).
    
    Returns:
        tuple:
            int: Number of radial nodes (zeros) of the integrated wavefunction u in the inner region (counted during the forward integration). This is the primary quantum-number diagnostic used by the caller to select the correct eigenstate.
            float or None: The scalar A measuring the size of the derivative discontinuity at the classical turning point: A = (dudr_plus - dudr_minus) * u_turning_point. For a correct eigenenergy e the discontinuity A should be zero. A may be None in certain failure modes (see Failure modes above).
        None: If gmax is not None the function returns None (no tuple). In this mode the intended effect is the in-place update of u up to the provided gmax; the caller inspects u directly and does not receive node/A values.
    
    Notes:
        - This routine is intended for internal use by GPAW's atomic all-electron solvers and assumes input arrays are prepared consistently (same length and compatible grid). The radial grid conventions, units, and potential assembly follow GPAW internals and the PAW method described in the repository documentation.
        - The printed messages, rescaling behavior, and special numeric thresholds (e.g., 1e100) are pragmatic safeguards in the finite-difference integration and are retained to preserve historical numerical behavior in GPAW's atomic routines.
    """
    from gpaw.atom.all_electron import shoot
    return shoot(u, l, vr, e, r2dvdr, r, dr, c10, c2, scalarrel, gmax)


################################################################################
# Source: gpaw.basis_data.parse_basis_name
# File: gpaw/basis_data.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_basis_data_parse_basis_name(name: str):
    """Parse a GPAW basis type identifier string and return the numeric zeta and
    polarization counts encoded in that identifier.
    
    This function is used by GPAW when interpreting atom-centered basis-function
    specifications (see GPAW README references to "atom-centered basis-functions").
    Basis identifiers encode how many radial basis functions ("zeta" functions)
    and how many additional polarization functions to include. Typical identifiers
    look like 'sz', 'dzp', 'qztp', or '4z3p'. The first character encodes the zeta
    count (either a decimal digit or a letter looked up in the module-level
    mapping _basis_letter2number). The second character must be the literal 'z'.
    The identifier optionally contains a polarization part: either absent (no
    polarization), a trailing 'p' (one polarization), or a third character (letter
    or digit) followed by 'p' (explicit polarization count).
    
    Args:
        name (str): Basis identifier string to parse. Accepted forms are:
            - Two characters: "<z><z>" where the second character is 'z' and the
              first character is either a decimal digit (e.g. '4') or a letter
              looked up in _basis_letter2number (e.g. 'd'). This two-character
              form denotes zero polarization functions (polcount == 0).
            - Three characters: "<z>zp" where the trailing 'p' indicates exactly
              one polarization function (polcount == 1). The first character is
              interpreted as above.
            - Four characters: "<z><p>p" where the third character encodes the
              polarization count (either a digit or a letter looked up in
              _basis_letter2number) and the fourth character is 'p'.
            The function does not modify the input string. The string must be
            non-empty and conform to the patterns above; otherwise the function
            raises an exception (see Raises). Letter-to-integer conversion uses
            the module-level mapping _basis_letter2number; if a letter is not
            present in that mapping the function will attempt to parse that
            character as a decimal digit.
    
    Returns:
        tuple of two int: (zetacount, polcount). zetacount is the integer number
        of zeta (radial) basis functions encoded by the first character of the
        identifier and is used by GPAW to determine the number of radial basis
        functions per valence orbital when constructing atom-centered basis sets.
        polcount is the integer number of polarization functions encoded by the
        identifier (0 if no polarization part is present, 1 if the trailing 'p'
        form is used, or the explicit integer from the third character in the
        four-character form). Example: '4z3p' => (4, 3).
    
    Raises:
        AssertionError: If required literal characters are missing or the overall
            string length is not one of the supported lengths (2, 3 or 4). These
            assertions validate that the second character is 'z' and that any
            trailing polarization specifier ends with 'p'.
        ValueError: If a character intended to represent a numeric count cannot be
            converted to int and is not present in _basis_letter2number.
        IndexError: If the input string is empty (accessing name[0] or name[1]
            raises IndexError).
        TypeError: If a non-string is passed (the function assumes a str and will
            fail when performing string indexing).
    """
    from gpaw.basis_data import parse_basis_name
    return parse_basis_name(name)


################################################################################
# Source: gpaw.benchmark.benchmark_from_dict
# File: gpaw/benchmark/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_benchmark_benchmark_from_dict(dct: dict):
    """gpaw.benchmark.benchmark_from_dict creates a compact, human- and machine-readable summary dictionary from the full JSON-like output of a GPAW benchmark run. This function is used by GPAW benchmarking and reporting code to extract the most important performance and system metadata (timings, hardware, MPI counts, Git revision) from the verbose benchmark output so downstream tools, plots, or tables can display and compare results without parsing the full log.
    
    Args:
        dct (dict): The complete benchmark output already loaded as a Python mapping (for example, from json.load). The top-level mapping must contain a 'Benchmark' key whose value is itself a mapping with at least the following keys: 'results' (a mapping of step names to per-step info), 'system_info' (a mapping with hardware and software metadata), 'walltime', 'shortname', 'longname', 'calcinfo', and 'max_rss'. The function extracts values from these nested mappings; if the expected keys are missing a KeyError will be raised. The function does not accept non-mapping inputs (a TypeError will occur if methods like __getitem__ are not available).
    
    Returns:
        dict: A new dictionary containing a compact summary of the benchmark suitable for reporting and comparisons. The returned mapping contains the following keys and their meanings:
            'walltime': value copied from dct['Benchmark']['walltime'], representing the overall wall-clock measurement recorded by the benchmark output.
            'shortname': value copied from dct['Benchmark']['shortname'], a short identifier for the benchmark case used by GPAW for quick labels.
            'processor': value produced by parse_processor(system_info['processor']), a normalized description of the CPU as recorded in system_info; used to identify machine CPU model/family in performance tables.
            'gpu': value produced by parse_gpu(system_info['nvidia-smi'], system_info['rocm-smi']), a normalized GPU description derived from the vendor-specific query outputs present in system_info; may be None or empty if no GPU information is available.
            'longname': value copied from dct['Benchmark']['longname'], a verbose, human-friendly name describing the benchmark case.
            'hostname': value copied from system_info['hostname'].strip(), the machine host name with surrounding whitespace removed so that comparisons and displays are consistent.
            'calcinfo': value copied from dct['Benchmark']['calcinfo'], containing calculation-specific metadata recorded by the benchmark (kept as provided in the original output).
            'mpi-ranks': value copied from system_info['mpi-ranks'], the number of MPI ranks used for the benchmark; used to correlate performance with parallelism level.
            'First step': value copied from results['First step']['walltime'], the recorded walltime of the benchmark's "First step" phase as present in the 'results' mapping; retained under the same step-name key for clarity in per-step timing comparisons.
            'Second step': value copied from results['Second step']['walltime'], the recorded walltime of the benchmark's "Second step" phase, extracted similarly to 'First step'.
            'max_rss': value copied from dct['Benchmark']['max_rss'], the maximum resident set size recorded by the benchmark output; used to monitor memory usage.
            'githash': value copied from system_info['git-hash'].strip(), the Git commit hash of the GPAW code used to run the benchmark with surrounding whitespace removed to ensure stable comparisons.
            'branch': value produced by parse_git_status(system_info['git-status']), a normalized description of the Git branch/status (for example, branch name or status string) as reported in system_info; used to tie benchmark numbers to source tree state.
    
    Behavior and side effects:
        This function is a pure extractor: it constructs and returns a new dictionary and does not modify the input mapping object in-place. It relies on helper parsing functions parse_processor, parse_gpu, and parse_git_status to normalize specific system strings; any exceptions thrown by those helpers (or by missing keys) will propagate to the caller. The returned values are taken verbatim from the benchmark output except where the code explicitly strips whitespace (hostname and githash) or passes strings to the parse_* helpers for normalization.
    
    Failure modes:
        If the input mapping does not have the expected structure (missing 'Benchmark', missing subkeys such as 'results' or 'system_info', or missing specific keys referenced in the function), a KeyError will be raised. If the provided dct is not a mapping type, operations in the function will raise a TypeError. Errors from parse_processor, parse_gpu, or parse_git_status are not caught and will propagate to the caller.
    
    Practical significance in the GPAW domain:
        The returned summary dictionary collects the minimal set of identifiers and metrics that GPAW developers and users commonly compare across machines and commits: total and per-step walltimes, CPU/GPU descriptions, MPI ranks, memory high-water mark, and the Git revision/branch. This compact form is intended for inclusion in benchmark tables, automated aggregation scripts, and performance dashboards without requiring re-parsing of the original verbose benchmark JSON.
    """
    from gpaw.benchmark import benchmark_from_dict
    return benchmark_from_dict(dct)


################################################################################
# Source: gpaw.atom.all_electron.shoot_confined
# File: gpaw/atom/all_electron.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_atom_all_electron_shoot_confined(
    u: numpy.ndarray,
    l: int,
    vr: numpy.ndarray,
    e: float,
    r2dvdr: numpy.ndarray,
    r: numpy.ndarray,
    dr: numpy.ndarray,
    c10: numpy.ndarray,
    c2: numpy.ndarray,
    scalarrel: bool,
    gmax: int = None,
    rc: float = 10.0,
    beta: float = 7.0
):
    """This function integrates a radial, confined all-electron differential equation by the shooting method and is used by the solve_confined routine in the GPAW all-electron atomic solver. It advances a provided radial wavefunction array u on a given radial grid r with spacing dr, using potential-related arrays (vr, r2dvdr) and finite-difference coefficients (c10, c2) to perform inward and outward integrations, locate the classical turning point, count nodes, and compute the derivative discontinuity A at the turning point. This information is used in the confined eigenvalue search to adjust the trial energy e until the radial wavefunction satisfies boundary conditions for bound states in GPAW's confined-atom calculations.
    
    Args:
        u (numpy.ndarray): Array for the radial part of the wavefunction to be filled and modified in place. Its length must match len(r). On successful completion (when gmax is None) the first portion u[:gtp+2] is scaled to be continuous at the turning point; intermediate and asymptotic parts are also written during integration. The array is used both as input (initial guesses at boundaries) and as output (numerical solution on the grid).
        l (int): Angular momentum quantum number (orbital quantum number) for the radial equation. The code asserts l < 3; values outside this range will trigger an AssertionError. This parameter enters the centrifugal term l*(l+1) in the effective radial equation.
        vr (numpy.ndarray): Radial potential multiplied by r (or a quantity proportional to r*V(r)) sampled on the grid r. It is used to form the effective radial operator and, together with e and r2dvdr, to compute the array c0 that determines the classical turning point and the local finite-difference coefficients.
        e (float): Trial eigenvalue (energy) for the radial equation used by the shooting method. The function evaluates the behavior of the solution for this energy; the returned node count and derivative discontinuity are used to adjust e in the outer eigenvalue solver (solve_confined).
        r2dvdr (numpy.ndarray): Array representing r^2 * dV/dr sampled on the grid r. When scalarrel is True this term contributes to the scalar-relativistic correction of the finite-difference coefficients; otherwise it is unused.
        r (numpy.ndarray): Radial grid points (distance from nucleus) matching the indexing of u, vr, r2dvdr, dr. Used to compute Mr and the effective potential terms and to locate where boundary conditions and turning points are applied.
        dr (numpy.ndarray): Grid spacing array (delta r at each grid index) corresponding to r. dr is used to compute numerical derivatives (for example dudr at the turning point) and in the finite-difference integration formulas.
        c10 (numpy.ndarray): Array of finite-difference coefficient c1 evaluated on the grid prior to scalar-relativistic correction. This array is combined with c2 to form the working finite-difference coefficients fm, fp, and f0 used by the three-term recurrence integration. If scalarrel is True, c1 is adjusted from c10 using r and r2dvdr.
        c2 (numpy.ndarray): Array of finite-difference coefficient c2 evaluated on the grid. c2 is used together with c1 (or c10) and c0 to form fm, fp, and f0 which determine the recurrence relation for numerical integration.
        scalarrel (bool): Flag indicating whether to apply the scalar-relativistic correction to the finite-difference coefficients and the effective mass term. When True, the code computes x = 0.5 * alpha**2 (the source code comment states x = 1 / (2c^2)) using a global alpha and applies corrections to Mr, c0 and c1. When False, the non-relativistic forms are used. This flag controls whether relativistic mass and potential-gradient terms (involving r2dvdr) enter the integration.
        gmax (int or None): Optional integer index that, if provided, forces the algorithm to treat gmax as the turning-point index (gtp = gmax) instead of searching for the turning point from asymptotic boundary conditions. Default is None. When gmax is None the routine performs a backward integration from a large-radius boundary to locate the turning point and imposes asymptotic boundary conditions; when gmax is not None the routine skips the asymptotic backward integration and returns early after completing the forward integration (see Returns).
        rc (float): Cutoff radius parameter used to choose an initial asymptotic boundary index when gmax is None. Default is 10.0. Internally used to compute gcut = int(rc * len(r) / (beta + rc)), which sets the starting index for imposing asymptotic boundary conditions in the backward integration.
        beta (float): Parameter used together with rc to determine the asymptotic boundary index gcut when gmax is None. Default is 7.0. Affects the index at which the code imposes u(gcut-1)=1 and u(gcut:)=0 to start the inward integration from large r.
    
    Behavior, side effects, and failure modes:
        The function asserts l < 3; supplying l >= 3 causes an AssertionError. The primary side effect is that the input array u is overwritten with the computed radial wavefunction values on the grid r; u must be writable and of appropriate length.
        When scalarrel is True the function references a global alpha and computes x = 0.5 * alpha**2 (source code comment: x = 1 / (2c^2)). This modifies Mr, c0 and c1 by terms involving e, vr and r2dvdr to include scalar-relativistic corrections.
        If gmax is None the function attempts to set asymptotic boundary conditions at large r (sets a cutoff index gcut computed from rc and beta, forces u[gcut-1]=1 and u[gcut:]=0) and integrates inward to find the classical turning point defined by the sign change of c0. If c0 is positive everywhere (i.e., no turning point found) and gmax is None, the function prints a diagnostic message about the initial electron density guess and raises SystemExit to abort execution (this mirrors behavior in GPAW when the initial guess is inadequate).
        During the backward integration from the asymptotic region the code tests for an unexpected node (sign change) occurring outside the turning point; if a node is encountered in the outward tail (u[g-1] < 0.0 at a stage where none is expected), the routine treats the trial energy e as too high, prints a short marker, and returns the pair (100, None) as an error indicator to the caller (no further scaling is performed). If values grow excessively large the routine rescales u by 1e-100 to avoid overflow.
        After setting the small-r boundary conditions (u[0] = 0.0, u[1] = 1.0) the function performs forward integration from zero up to the turning point index gtp (or up to gmax if provided), counts the number of nodes in the inner region (nodes), and computes numeric derivatives just inside and just outside the turning point. If gmax is provided the function returns early (see Returns) after the forward integration and does not scale the inner solution to match an outer solution.
        When gmax is None and all steps succeed, the function scales the inner part of u so that u is continuous at the turning point, computes the derivative discontinuity A at the turning point from the difference between outward and inward derivatives, and returns node count and A.
    
    Returns:
        tuple:
            When gmax is None and the routine completes normally, returns a 2-tuple (nodes, A) where nodes (int) is the count of sign changes (nodes) encountered in the forward-integrated inner part of the wavefunction up to the turning point, and A (float) is the scaled derivative mismatch at the turning point defined in the code as A = (dudrplus - dudrminus) * utp (utp is the wavefunction value just outside the turning point before scaling). These values are used by the outer solve_confined routine to adjust the trial energy e during eigenvalue search.
            When a node is encountered in the asymptotic backward integration (indicating an eigenvalue trial e that is too high), returns the sentinel pair (100, None) to indicate this failure mode.
            When gmax is not None the function performs only the forward integration and returns None (no explicit return value) while still modifying u in place and counting nodes internally; callers that supply gmax should not expect the (nodes, A) tuple in this case.
    
    Notes:
        The finite-difference integration uses arrays fm = 0.5*c1 - c2, fp = 0.5*c1 + c2, and f0 = c0 - 2*c2 to form a three-term recurrence relation for u on the grid (see source). The classical turning point is identified by the index where c0 becomes non-positive during backward scanning; the code stores the index gtp = g + 1 and uses centered differences in dr to estimate dudr on both sides of gtp. This routine is a low-level building block of GPAW's confined-atom solver and is intended for use only within that context (solve_confined), where the outer driver adjusts e and optionally supplies gmax to control integration ranges.
    """
    from gpaw.atom.all_electron import shoot_confined
    return shoot_confined(
        u,
        l,
        vr,
        e,
        r2dvdr,
        r,
        dr,
        c10,
        c2,
        scalarrel,
        gmax,
        rc,
        beta
    )


################################################################################
# Source: gpaw.benchmark.parse_requirement
# File: gpaw/benchmark/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_benchmark_parse_requirement(req: str):
    """Parses a benchmark resource requirement string used by gpaw.benchmark to specify the minimum and maximum compute resources required to run a benchmark or job. The function accepts a requirement string in the format "core_range:memory[:gpu_range]" (colon-separated). In the GPAW benchmarking and test-selection domain this string encodes the allowed CPU core count range (core_range), the minimum memory requirement (memory), and optionally the allowed GPU count range (gpu_range). This parser converts that textual specification into a structured dictionary that downstream benchmark selection and scheduling code can use to match available hardware to benchmark requirements.
    
    Args:
        req (str): Requirement string to parse. Must be a colon-separated string with at least two components: a core_range and a memory specification, with an optional third component gpu_range. Example forms that this function expects (exact parsing rules for each component are implemented by helper functions parse_range and parse_mem): "4-16:8GB" (cores 4 to 16, memory 8GB, no GPUs) or "8:16GB:1-2" (exactly 8 cores, 16GB memory, 1 to 2 GPUs). In the GPAW context, core_range expresses the allowed number of CPU cores for a benchmark, memory expresses the minimum memory required to run it, and gpu_range (if present) expresses the allowed number of GPUs. The function will split req on ":" and pass the first component to parse_range, the second to parse_mem, and the optional third to parse_range again.
    
    Returns:
        dict: A mapping containing the parsed resource requirements with the following keys and practical meanings used by GPAW benchmark selection code:
            'mincores': minimum number of CPU cores allowed (value returned by parse_range for the first component; used to select suitable compute nodes).
            'maxcores': maximum number of CPU cores allowed (value returned by parse_range for the first component; may be equal to mincores for a single-value specification).
            'minmem': memory requirement as returned by parse_mem for the second component (represents the minimum memory needed to run the benchmark; exact numeric units and representation follow the parse_mem implementation).
            'mingpus': minimum number of GPUs allowed (value returned by parse_range for the optional third component, or 0 when the GPU component is omitted; used to match available GPU resources).
            'maxgpus': maximum number of GPUs allowed (value returned by parse_range for the optional third component, or 0 when omitted).
        The core and GPU counts are returned as integer counts as produced by parse_range; the memory value is returned exactly as parse_mem produces it (typically a numeric value representing an amount of memory). There are no side effects; the function returns a new dictionary.
    
    Behavior, defaults, and failure modes:
        The function splits the input string on ":" and expects at least two components. If the gpu_range component is omitted, mingpus and maxgpus default to 0. Parsing of the core and GPU components is delegated to parse_range, and parsing of the memory component is delegated to parse_mem; any validation, unit interpretation, or errors from those helper functions are propagated. If req does not contain at least two colon-separated components, attempting to access the second component will raise an IndexError. If parse_range or parse_mem receive malformed component strings they will typically raise ValueError or a parsing-specific exception; those exceptions are not caught here and will propagate to the caller. The function performs no I/O and has no side effects beyond constructing and returning the dictionary.
    """
    from gpaw.benchmark import parse_requirement
    return parse_requirement(req)


################################################################################
# Source: gpaw.benchmark.parse_range
# File: gpaw/benchmark/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_benchmark_parse_range(s: str):
    """Parse a CPU or GPU range string used by gpaw.benchmark utilities and return the numeric lower and upper bounds.
    
    This function is used in GPAW benchmarking/selection code to interpret simple range expressions that specify which CPU or GPU indices should be used for a benchmark run. The input is a short string that may contain the substring "GPU" (case-sensitive) and a hyphen-separated range. Behavior follows the exact rules implemented in the source: the literal substring "GPU" is removed, a single integer denotes an exact index (both bounds equal), a missing lower bound (a leading hyphen) implies 0, and a missing upper bound (a trailing hyphen) implies an unbounded upper limit represented by numpy.inf. There are no side effects; the function only parses and returns numeric bounds. Examples and their results: "0-1" -> (0, 1), "5" -> (5, 5), "-4GPU" -> (0, 4).
    
    Args:
        s (str): Range string to parse. This should be a Python string containing an optional literal substring "GPU" (uppercase exact match) and either a single integer or two integers separated by a single hyphen. Valid example forms coming from benchmarking commands in GPAW include "0-1", "5", and "-4GPU". The function will remove all occurrences of the exact substring "GPU" before parsing. If s contains more than one hyphen (for example "0-1-2") the function will raise a ValueError due to unpacking; if the numeric parts cannot be converted to integers (for example non-numeric characters other than the removed "GPU"), int() will raise a ValueError. Passing a non-string value for s may raise a TypeError before parsing.
    
    Returns:
        tuple: A two-tuple (min, max) giving the parsed numeric bounds. The lower bound min is returned as an int. The upper bound max is returned as an int when explicitly provided, or as numpy.inf (a floating-point infinity from numpy) when the upper bound is omitted (open-ended range). For example, for the input "-4GPU" the function returns (0, 4), for "5" it returns (5, 5), and for "3-" it returns (3, numpy.inf).
    """
    from gpaw.benchmark import parse_range
    return parse_range(s)


################################################################################
# Source: gpaw.bztools.get_lattice_symmetry
# File: gpaw/bztools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_bztools_get_lattice_symmetry(cell_cv: numpy.ndarray, tolerance: float = 1e-07):
    """Return a gpaw.symmetry object that describes the lattice (space) symmetry of a unit cell used in GPAW periodic calculations.
    
    Args:
        cell_cv (numpy.ndarray): Array describing the unit cell lattice vectors for the system. This is the same unit-cell representation used throughout GPAW and ASE to define the simulation cell; the array encodes the lattice vectors in Cartesian coordinates and is passed directly to the internal gpaw.symmetry.Symmetry constructor. The function uses this array to determine which lattice symmetry operations (rotations, reflections and equivalent lattice translations) leave the periodic lattice invariant.
        tolerance (float): Numerical tolerance used when comparing coordinates and lattice vectors to decide whether a candidate symmetry operation is valid. This tolerance controls the threshold for floating-point comparisons inside the symmetry-detection algorithm; the default is 1e-07. Smaller tolerances require closer numerical agreement and may reject operations due to numerical noise, while larger tolerances may accept operations that differ by small but potentially significant numerical errors.
    
    Returns:
        gpaw.symmetry: A gpaw.symmetry object (the Symmetry instance created and populated inside this function). The returned object is constructed as Symmetry([0], cell_cv, tolerance=tolerance) and then populated by calling its find_lattice_symmetry() method. The object contains the detected lattice symmetry operations and related internal state that calling code can query to obtain rotation/translation operators for use in symmetry-aware workflows in GPAW.
    
    Behavior and side effects:
        The function instantiates a gpaw.symmetry.Symmetry object with the index list [0], the provided cell_cv and the provided tolerance, then calls find_lattice_symmetry() on that instance to populate its internal symmetry data structures. There are no other external side effects (no files are written). The tolerance default is 1e-07 and is applied directly to the symmetry-finding routine.
    
    Failure modes and cautions:
        If cell_cv is not a suitable numpy.ndarray for the gpaw.symmetry.Symmetry constructor or if its numerical content is inconsistent with a valid periodic lattice, the underlying Symmetry constructor or find_lattice_symmetry() method may raise exceptions which are propagated to the caller. Note: Symmetry.find_lattice_symmetry() uses the Symmetry instance attribute pbc_c, which defaults to periodic boundary conditions along all three Cartesian dimensions; therefore the lattice symmetry transformations produced by this routine can be incorrect for systems that are intentionally non-periodic in one or more dimensions (for example, surfaces or isolated molecules modeled with non-periodic boundaries). Calling code should verify the returned gpaw.symmetry object for consistency with the intended boundary conditions and, if necessary, use Symmetry with explicit pbc settings appropriate for the system.
    """
    from gpaw.bztools import get_lattice_symmetry
    return get_lattice_symmetry(cell_cv, tolerance)


################################################################################
# Source: gpaw.bztools.get_smallest_Gvecs
# File: gpaw/bztools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_bztools_get_smallest_Gvecs(cell_cv: numpy.ndarray, n: int = 5):
    """Find smallest reciprocal lattice vectors for a centered integer grid of Miller indices.
    
    Args:
        cell_cv (numpy.ndarray): 3x3 array representing the real-space unit cell used by GPAW and DFT calculations. The array is interpreted as containing the Cartesian real-space lattice vectors (columns of the matrix) in the same length units as used by the rest of the code (e.g. Å if the caller uses ASE/GPAW default cell units). This argument is used to form the reciprocal-lattice basis B_cv = 2π * inv(cell_cv).T; therefore cell_cv must be a square, invertible 3×3 array. The reciprocal vectors returned (G_xv) will have units of inverse length consistent with the input cell_cv units.
        n (int): Number of sampling points along each crystal axis (default 5). The function constructs a cubic grid of integer Miller indices of size n × n × n, centered on the origin by subtracting n // 2. Valid n values are positive integers; large n will produce arrays of size n**3 and may raise MemoryError for very large n.
    
    Returns:
        tuple:
            G_xv (numpy.ndarray): Array of shape (n**3, 3) containing reciprocal lattice vectors expressed in Cartesian coordinates (rows are vectors). These are computed as G_xv = N_xc @ B_cv, where B_cv = 2π * inv(cell_cv).T is the reciprocal-lattice basis. In practical DFT/GPAW usage these G vectors correspond to the plane-wave reciprocal-space sampling points (smallest integer-index combinations around the Γ point) used for operations such as constructing plane-wave components of densities or potentials. Units are the inverse of the units of cell_cv (e.g. 1/Å if cell_cv is in Å).
            N_xc (numpy.ndarray): Integer array of shape (n**3, 3) containing the corresponding Miller index triplets (h, k, l) in crystal (integer) coordinates. Each row is one triplet enumerated in the order produced by numpy.indices((n, n, n)).reshape((3, n**3)).T and then shifted by subtracting n // 2, i.e. indices run from -floor(n/2) to ceil(n/2)-1 along each axis. These integer indices are useful for mapping between plane-wave indices and reciprocal-lattice vectors in GPAW and related DFT algorithms.
    
    Behavior and side effects:
        The function performs linear-algebra operations but has no side effects (it does not modify its inputs or any global state). The default n=5 yields a small centered 5×5×5 grid of Miller indices, including the Γ point when n is odd. For even n the centered range is from -n//2 up to n-1-n//2 (see N_xc description). The ordering of returned vectors follows NumPy's array ordering produced by numpy.indices and the subsequent reshape/transpose.
    
    Failure modes and exceptions:
        A numpy.linalg.LinAlgError will be raised if cell_cv is singular (non-invertible). A ValueError or IndexError may be raised if cell_cv does not have compatible shape (it is expected to be a 3×3 array) or if n is not a positive integer. Extremely large n can raise MemoryError due to allocation of arrays of length n**3.
    """
    from gpaw.bztools import get_smallest_Gvecs
    return get_smallest_Gvecs(cell_cv, n)


################################################################################
# Source: gpaw.bztools.convex_hull_volume
# File: gpaw/bztools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_bztools_convex_hull_volume(pts: list):
    """gpaw.bztools.convex_hull_volume calculates the volume of the convex hull of a collection of 3D points.
    
    Calculates the geometric volume enclosed by the convex hull of a set of three-dimensional points. In the GPAW/ASE/DFT context this function is typically used to evaluate the spatial volume occupied by atomic coordinates, point clouds, or sets of k-points (for example to estimate cell or Brillouin-zone related volumes). The implementation builds the convex hull with scipy.spatial.ConvexHull, constructs a Delaunay triangulation of the hull vertices, computes volumes of the resulting tetrahedra with tetrahedron_volume, and returns their sum as the total hull volume. The result is expressed in the cubic units of the input coordinates (for example, if coordinates are in Å, the returned volume is in Å^3).
    
    Args:
        pts (list or ndarray): A collection of 3D points to enclose in the convex hull. Each element must represent a point in three-dimensional Cartesian coordinates (length-3 sequences or a (N, 3) array-like structure). In practical GPAW usage this is typically a Python list of atomic position triples from ASE or a NumPy ndarray of shape (N, 3). The function does not modify the input object but will pass it to SciPy routines which may implicitly convert it to a NumPy array.
    
    Returns:
        float: Volume of the convex hull computed by summing volumes of tetrahedra that tile the hull. The numeric value is in the cubic units of the input coordinates (e.g., Å^3 if input positions are in angstroms).
    
    Behavior and failure modes:
        The function requires at least four non-coplanar 3D points to form a non-zero-volume convex hull. If the input contains fewer than four non-coplanar points, if points are not three-dimensional, or if the input cannot be interpreted as an (N, 3) array of numeric values, the underlying SciPy routines (scipy.spatial.ConvexHull or scipy.spatial.Delaunay) will raise errors (for example scipy.spatial.qhull.QhullError or ValueError). Collinear or coplanar inputs produce a hull with zero or undefined volume depending on SciPy behavior. No external state is changed by this function; it returns the computed volume or propagates exceptions raised by the spatial algorithms.
    """
    from gpaw.bztools import convex_hull_volume
    return convex_hull_volume(pts)


################################################################################
# Source: gpaw.bztools.get_symmetry_operations
# File: gpaw/bztools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_bztools_get_symmetry_operations(U_scc: numpy.ndarray, time_reversal: bool):
    """gpaw.bztools.get_symmetry_operations
    Return point symmetry operations used by GPAW Brillouin-zone tools.
    
    This function prepares a set of 3x3 point-group symmetry operation matrices that are used throughout GPAW to reduce Brillouin-zone sampling, apply symmetry to k-points, and otherwise exploit spatial symmetries in density-functional-theory calculations (see GPAW README for general context). The function accepts an existing collection of Cartesian 3x3 symmetry matrices or None and optionally augments that collection with time-reversal counterparts. The implementation ensures sensible defaults and prevents adding time-reversal operations when a pure spatial inversion operation is already present.
    
    Args:
        U_scc (numpy.ndarray): Array containing point symmetry operations. In GPAW this is expected to be an array of 3x3 matrices with shape (n_ops, 3, 3) that represent spatial point-group operations in Cartesian coordinates; elements are typically integers for pure rotations/reflections but floating dtypes are accepted by the code path. If U_scc is None, the function treats it as a single identity operation and internally replaces it with numpy.array([numpy.eye(3)]). The array is not modified in-place; a new array is returned. If U_scc has an incompatible shape (not indexable as (n,3,3)), subsequent elementwise comparisons and concatenation will raise an exception (ValueError or IndexError) propagated to the caller.
        time_reversal (bool): Whether to include time-reversal variants of the supplied point operations. If True and no pure spatial inversion (-I) is present among U_scc, the function returns the concatenation of the original operations and their negatives (i.e., both U_scc and -U_scc, doubling the number of operations). If False, only the supplied operations (or the identity default) are returned. If a pure inversion operation (matrix equal to -I) is detected in U_scc, the function disables time_reversal by setting it to False internally (because spatial inversion already provides the equivalent symmetry in this context); this internal change is not reflected back to the caller except via the returned operations.
    
    Returns:
        numpy.ndarray: Array of point symmetry operations after applying the rules above. The returned array has shape (m, 3, 3) where m equals the number of input operations or twice that number if time_reversal was applied and no inversion was present. The returned matrices are the spatial symmetry operations used by GPAW for Brillouin-zone symmetry handling; the dtype follows NumPy's usual coercion rules when concatenating (e.g., integer inputs remain integer unless negation/coercion forces float). No other side effects occur.
    """
    from gpaw.bztools import get_symmetry_operations
    return get_symmetry_operations(U_scc, time_reversal)


################################################################################
# Source: gpaw.bztools.get_ibz_vertices
# File: gpaw/bztools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_bztools_get_ibz_vertices(
    cell_cv: numpy.ndarray,
    U_scc: numpy.ndarray = None,
    time_reversal: bool = None,
    origin_c: numpy.ndarray = None
):
    """gpaw.bztools.get_ibz_vertices determines the vertices of the irreducible Brillouin zone (IBZ) for a given unit cell and its crystal symmetry operations. In the GPAW DFT context this function is used to reduce k-point sampling by exploiting spatial and optional time-reversal symmetries: it generates symmetry-equivalent k-points, constructs a Voronoi cell around a representative point and returns the coordinates of the IBZ vertices used for Brillouin-zone partitioning and k-point mesh construction.
    
    Args:
        cell_cv (numpy.ndarray): Unit cell matrix for the crystal. In GPAW this is the 3x3 real-space lattice matrix (Cartesian lattice vectors) used to compute reciprocal-lattice objects; the function expects a 3x3 invertible array representing the cell vectors. The matrix is used to form the reciprocal basis B_cv = 2*pi * (cell_cv^-1).T and its inverse A_cv so that Voronoi vertices computed in reciprocal-space are transformed back to the Cartesian k-coordinate system used by GPAW.
        U_scc (numpy.ndarray): Crystal symmetry operations. An array of rotation operations in Cartesian coordinates (typically shape (n_ops, 3, 3)). If None, the function uses a single identity operation (no symmetry). These operations are passed through get_symmetry_operations together with the time_reversal flag to form the full set of point-group operations used to generate symmetry-equivalent points in the Brillouin zone.
        time_reversal (bool): Whether to include time-reversal symmetry when forming the full symmetry group. If None, the function defaults to False. When True, each spatial symmetry operation is combined with time-reversal to double the set of symmetry operations (when appropriate), which further reduces the IBZ used for k-point sampling.
        origin_c (numpy.ndarray): Origin in crystal (fractional) coordinates used to seed the IBZ construction. This is a length-3 array of fractional coordinates (values expected to satisfy |component| < 0.5). If None, the function uses the default fractional origin array [0.12, 0.22, 0.21]. The origin is rotated by the symmetry operations to produce representative points; an assertion guards that the provided origin lies within the central unit cell (absolute values less than 0.5).
    
    Returns:
        numpy.ndarray: ibzk_kc, an array of coordinates for the vertices of the irreducible Brillouin zone transformed to Cartesian k-space (the same k-coordinate convention used elsewhere in GPAW). These vertices are obtained by: mapping the seeded origin by symmetry operations, expressing those symmetry-equivalent points in reciprocal space, reflecting a set of small G-vectors to form candidate Voronoi plane mirrors, building a Voronoi diagram and extracting the vertices of the Voronoi region associated with the representative point. The returned array can be used to define the IBZ for k-point generation and integration.
    
    Behavior, defaults, side effects, and failure modes:
        - If U_scc is None the function behaves as if there is only the identity symmetry operation (no spatial symmetry reduction).
        - If time_reversal is None the function assumes time_reversal = False.
        - If origin_c is None the function uses origin_c = numpy.array([0.12, 0.22, 0.21], float). If a user-supplied origin_c violates the expectation that all absolute components are smaller than 0.5, an AssertionError is raised.
        - The function computes reciprocal-basis matrices internally as B_cv = 2*pi * (cell_cv^-1).T and A_cv = inv(B_cv).T; supplying a non-invertible cell_cv will raise a numpy.linalg.LinAlgError.
        - Voronoi construction: the function assembles a set of reflected points from a small set of G-vectors (via get_smallest_Gvecs) and attempts to build a scipy.spatial.Voronoi diagram. If the Voronoi constructor raises a QhullError (degenerate or ill-conditioned point set), the function retries by recursively calling itself with origin_c perturbed by [0.01, -0.02, -0.01] to move the seed point out of degenerate configurations. Repeated QhullError occurrences may lead to further recursion; in extreme cases this may propagate exceptions if Voronoi continues to fail.
        - No external state is modified by this function; it returns the computed IBZ vertices. Exceptions that may be raised include AssertionError for invalid origin_c, LinAlgError for singular cell_cv, QhullError (from scipy.spatial) if Voronoi fails repeatedly, or other numpy-related errors if array shapes are incorrect.
        - The function relies on helper routines in the GPAW bztools module: get_symmetry_operations, get_smallest_Gvecs, and utilities unique_rows; the caller must ensure these are available in the runtime environment (they are part of the gpaw.bztools module).
    """
    from gpaw.bztools import get_ibz_vertices
    return get_ibz_vertices(cell_cv, U_scc, time_reversal, origin_c)


################################################################################
# Source: gpaw.bztools.find_high_symmetry_monkhorst_pack
# File: gpaw/bztools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_bztools_find_high_symmetry_monkhorst_pack(calc: str, density: float):
    """Find a Monkhorst-Pack k-point grid that contains the corners of the irreducible Brillouin zone (IBZ).
    
    This function is used in the GPAW density-functional-theory (DFT) workflow to produce a high-symmetry Monkhorst–Pack (MP) k-point grid that explicitly includes the IBZ corner points. Including IBZ corners ensures that when k-point sampling is later reduced or symmetrically reduced, the full irreducible Brillouin zone remains represented and key high-symmetry points are preserved for band-structure and symmetry-sensitive calculations. The routine performs a brute-force search over MP-grid sizes starting from a minimum grid density determined by the supplied density parameter, requests gamma-centred and even grids where appropriate, consults the calculator restart file to obtain the atomic cell and wavefunction grid, and maps candidate MP grids into the first Brillouin zone using the calculator's cell information.
    
    Args:
        calc (str): The path to a GPAW calculator restart file or calculator object identifier used by restart(calc, txt=None). The function calls restart(calc, txt=None) to load the Atoms object and the calculator instance and then uses the calculator's wavefunction grid and cell (calc.wfs.gd.cell_cv) to map candidate k-points into the first Brillouin zone. Provide the same string/path that you would pass to GPAW restart; if restart() fails (file not found, incompatible format, or corrupted calculator state) the function will propagate that error.
        density (float): The required minimum density of the Monkhorst–Pack grid. This floating-point value is passed to kpts2sizeandoffsets(...) to determine the starting (minimum) MP-grid size and offsets with even=True and gamma=True semantics. The value controls the minimum k-point sampling density used for the brute-force search; it is not documented here in specific units (use the same density convention as other GPAW k-point utilities).
    
    Returns:
        ndarray: Array of shape (nk, 3) containing the k-points found for the MP grid. The returned k-points are the MP grid points (monkhorst_pack(size) + offset) mapped into the first Brillouin zone by to1bz(..., calc.wfs.gd.cell_cv). Each row is a k-point in the k-space coordinate system used by GPAW after mapping to the first Brillouin zone. The returned array has one row per k-point (nk) and three columns for the three reciprocal-space components.
    
    Behavior, side effects, defaults, and failure modes:
        - The function calls restart(calc, txt=None) to obtain atoms and a calculator; this is a required side effect and means calc must refer to a valid restart/calculator. Any exceptions raised by restart (I/O errors, invalid file, etc.) will propagate to the caller.
        - The function computes a starting MP-grid size and offset with kpts2sizeandoffsets(density=density, even=True, gamma=True, atoms=atoms). It then searches by increasing grid sizes up to maxsize = minsize + 10. For non-periodic directions (atoms.pbc False) the function forces minimum sizes to 1 and maximum sizes to 2.
        - A brute-force triple loop over candidate grid sizes (n1, n2, n3) is performed. For each candidate the routine re-computes size and offset via kpts2sizeandoffsets(size=size, gamma=True, atoms=atoms), generates MP k-points, maps them into the first BZ using to1bz(..., calc.wfs.gd.cell_cv), and checks whether all IBZ corner points returned by get_bz(calc) are present (within numerical tolerance) among the candidate k-points.
        - Progress and final messages are printed to standard output only on the MPI root rank (mpi.rank == 0). Specifically, the function prints a starting message "Brute force search for symmetry complying MP-grid... please wait.", on success prints "Done. Monkhorst-Pack grid:" followed by the discovered size and offset, and on failure prints "Did not find matching kpoints for the IBZ" and the IBZ corner coordinates rounded to 5 decimals. These prints are the primary side effects besides loading the calculator.
        - If a candidate grid fails an internal corner-presence check in a manner detected by the code, an AssertionError('Did not find ' + str(ibzk_c)) may be raised during the search. If no candidate grid in the searched range satisfies the IBZ-corner condition, the function prints the failure messages (on MPI root) and raises a RuntimeError. Callers should handle AssertionError and RuntimeError as possible failure modes.
        - Numerical checks use tolerances (1e-5 and rounding to 6 decimals) when comparing expected IBZ corners to candidate k-points; small numerical differences due to floating-point arithmetic are allowed up to these tolerances.
    
    Notes and practical significance:
        - Use this function when you need an MP grid that exactly includes IBZ corner points (for example, to preserve band degeneracies and high-symmetry sampling in DFT calculations with GPAW).
        - The function’s grid choice depends on the atomic cell loaded from the calculator restart file and the density parameter. For non-periodic directions (surfaces, clusters) the function limits grid sizes to 1 or 2 to avoid unnecessary k-point sampling in non-periodic dimensions.
        - Because the routine performs a brute-force search starting from a density-derived minimum up to minsize+10, it may be computationally trivial for small cells but could take noticeable time for more complex unit cells; the printed progress message warns the user of the brute-force nature of the search.
    """
    from gpaw.bztools import find_high_symmetry_monkhorst_pack
    return find_high_symmetry_monkhorst_pack(calc, density)


################################################################################
# Source: gpaw.bztools.unfold_points
# File: gpaw/bztools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_bztools_unfold_points(
    points: numpy.ndarray,
    U_scc: numpy.ndarray,
    tol: float = 1e-08,
    mod: int = None
):
    """Unfold k-points using a set of symmetry operators to produce the full set of symmetry-equivalent k-points for Brillouin-zone sampling and band-structure unfolding in GPAW DFT calculations.
    
    Args:
        points (numpy.ndarray): Array of input k-point vectors to be unfolded. Each row is a 3-component k-point vector in reciprocal-space coordinates (typical shape (n_points, 3)). In the GPAW context these are the k-points (wavevector coordinates) for which one wants to generate symmetry-equivalent points when exploiting crystal symmetries for Brillouin-zone sampling or band unfolding.
        U_scc (numpy.ndarray): Array of symmetry operators applied to the k-points. Each element is a linear operator (typically a 3x3 matrix) that maps k-point vectors according to a crystal symmetry operation. The function applies these operators to the rows of points, concatenates the results, and thus expands an irreducible set of k-points to the full symmetry-generated set. The array must be shape-compatible with points for the matrix multiplication performed with numpy.dot (for example, a common layout is one operator per first axis and 3x3 matrices on the last two axes).
        tol (float): Numerical tolerance used to decide when two k-points are considered identical and should be merged. Default is 1e-08. This tolerance controls the floating-point equality comparison performed by unique_rows: points whose coordinates differ by less than tol (taking into account optional periodicity when mod is set) are treated as duplicates and only one representative is kept. Very small tol may keep near-duplicate points due to numerical noise; very large tol may incorrectly merge distinct k-points.
        mod (int): Either 1 or None. When set to 1, k-points that differ by an integer reciprocal-lattice vector are considered identical (periodicity in reciprocal space is applied before comparing with tol). When None (default) periodic identification is disabled and only direct coordinate comparison within tol is used. The function forwards this argument to unique_rows; passing values other than 1 or None is not supported and may raise an error from unique_rows or produce incorrect results.
    
    Returns:
        numpy.ndarray: Array of shape (nk, 3) containing the unfolded, unique k-points after applying all symmetry operators from U_scc and removing duplicates according to tol and mod. The returned rows are 3-component k-point vectors in the same coordinate convention as the input points. No in-place modification of the input arrays is performed; the function returns a new array. Errors and failure modes include shape or broadcasting mismatches between points and U_scc that will raise numpy errors (e.g., ValueError) during the dot/concatenate operations, and invalid mod values which may propagate to unique_rows and raise exceptions.
    """
    from gpaw.bztools import unfold_points
    return unfold_points(points, U_scc, tol, mod)


################################################################################
# Source: gpaw.bztools.unique_rows
# File: gpaw/bztools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_bztools_unique_rows(
    ain: numpy.ndarray,
    tol: float = 1e-10,
    mod: int = None,
    aglomerate: bool = True
):
    """gpaw.bztools.unique_rows returns the unique rows of a 2D NumPy array, treating rows as k-point vectors in GPAW's Brillouin-zone utilities. It is used to reduce lists of k-points by identifying rows that represent the same point within a given numerical tolerance, optionally taking periodicity (full reciprocal-lattice-vector equivalence) and local clustering into account. The function preserves the original row values in the returned array but orders the unique rows according to a lexicographic sort applied after internal normalization and rounding.
    
    Args:
      ain (numpy.ndarray): 2D ndarray of shape (N, M) containing N row vectors (for example, k-point coordinates in fractional reciprocal-lattice units) to be filtered for uniqueness. The function expects a true NumPy array with two dimensions; passing an array with a different number of dimensions or a non-array object will cause an error (TypeError or IndexError) when the code attempts column-wise operations.
      tol (float): Tolerance used to decide when two rows are considered identical. The tolerance controls the number of decimal places used for rounding via rounds = -numpy.log10(tol).astype(int). Default is 1e-10. tol must be positive; nonpositive values will lead to invalid logarithms and raise an error (ValueError or RuntimeWarning).
      mod (int or None): Integer 1 or None. If set to 1, the function treats points that differ by a full reciprocal-lattice vector (i.e., integer shifts of 1 in fractional coordinates) as identical by applying a modulus operation before and after rounding. If None (the default), no periodic-identification modulo a reciprocal lattice vector is applied. This parameter is intended for the common GPAW use-case of identifying k-points modulo the periodicity of the Brillouin zone.
      aglomerate (bool): If True (default), the function calls aglomerate_points(a, tol) on the normalized coordinates before rounding; this agglomeration clusters nearby points (within tol) so that tightly spaced groups are treated consistently when rounding and modulus operations are performed. If False, clustering is skipped and rows are compared directly after rounding. Agglomeration is useful to avoid splitting clusters across modulus boundaries or rounding thresholds when identifying unique k-points.
    
    Returns:
      2D ndarray: A NumPy 2D array containing only the unique rows selected from the original ain. The returned rows are taken from the original input (not the rounded/intermediate representation) and are ordered according to a lexicographic sort applied after internal normalization, optional modulus operations, optional agglomeration, and rounding. The function does not modify the input array ain in-place; it constructs internal normalized and rounded copies for processing. Failure to satisfy input requirements (non-2D input, nonpositive tol) will raise exceptions from NumPy operations (e.g., ValueError, TypeError).
    """
    from gpaw.bztools import unique_rows
    return unique_rows(ain, tol, mod, aglomerate)


################################################################################
# Source: gpaw.coding_style.function
# File: gpaw/coding_style.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_coding_style_function(a: numpy.ndarray, b: numpy.ndarray):
    """gpaw.coding_style.function performs an elementwise addition of two NumPy arrays and returns the result. This small utility is used in the GPAW DFT codebase to combine array-valued quantities that appear in electronic-structure calculations (for example densities, potentials or components of wavefunctions) while respecting NumPy broadcasting rules and MPI-aware debug printing conventions used in GPAW scripts and modules.
    
    This function creates and returns a new numpy.ndarray that is the elementwise sum of the inputs. As implemented in the source, the function also has a side effect: when the module-level boolean flag debug is true and the MPI world communicator indicates the current process has rank 0 (mpi.world.rank == 0), the function prints the computed result scaled by the module-level constant Ha. The scaling and printing are only for human-readable diagnostic output and do not alter the returned array. Because the function relies on module-level globals (debug, mpi, Ha), its printing behavior depends on the GPAW runtime environment and MPI configuration.
    
    Args:
        a (numpy.ndarray): Left operand of the addition. In the GPAW context this typically represents an array-valued physical quantity (for example a real-space grid of densities or potentials) stored as a NumPy array. The function expects a to be a numpy.ndarray; providing another type is outside the documented contract and may raise a TypeError or lead to implicit NumPy coercion.
        b (numpy.ndarray): Right operand of the addition. As with a, b is expected to be a numpy.ndarray representing a GPAW-related array-valued quantity. The shapes of a and b must be compatible for NumPy addition (either identical shapes or shapes compatible under NumPy broadcasting); otherwise a runtime error (such as ValueError) may be raised.
    
    Returns:
        numpy.ndarray: A new NumPy array containing the elementwise sum a + b. The returned array is the result of the addition and is not modified by the function after return. Side effects: if the module-level flag debug is true and mpi.world.rank == 0, the function will print (to standard output) the value of result multiplied by the module-level constant Ha for diagnostic purposes; this print does not change the returned value.
    
    Failure modes and notes:
        The function assumes both inputs conform to the documented type numpy.ndarray and have shapes compatible for elementwise addition. If inputs do not meet these expectations, NumPy may raise TypeError or ValueError. The printing behavior depends on global state: the boolean debug and the MPI communicator object mpi.world with attribute rank, and it uses the module-level constant Ha to scale printed values. The function does not perform explicit input validation beyond relying on NumPy semantics.
    """
    from gpaw.coding_style import function
    return function(a, b)


################################################################################
# Source: gpaw.bztools.tetrahedron_volume
# File: gpaw/bztools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_bztools_tetrahedron_volume(
    a: numpy.ndarray,
    b: numpy.ndarray,
    c: numpy.ndarray,
    d: numpy.ndarray
):
    """gpaw.bztools.tetrahedron_volume — Calculate volume of a tetrahedron or volumes of many tetrahedra.
    
    Calculate the (unsigned) volume using the scalar triple product formula employed in Brillouin-zone tetrahedron methods and other tetrahedral integrations that appear in density-functional theory (DFT) workflows with GPAW and ASE. This routine computes |(a - d) · ((b - d) × (c - d))| / 6 in a vectorized manner. It is used in gpaw.bztools for geometric operations such as computing tetrahedral volumes for k-point or real-space partitioning needed in electronic-structure integration schemes and post-processing utilities that rely on tetrahedral decomposition.
    
    Args:
        a (numpy.ndarray): Coordinates of vertex a. For a single tetrahedron this is a 1-D array of length 3 containing Cartesian coordinates (typically in Angstrom when used with ASE/GPAW geometries). For batched/vectorized use this may be a 2-D array with shape (N, 3), where N is the number of tetrahedra; in that case a[i] is the a-vertex of the i-th tetrahedron. The array must be numeric and finite for meaningful results.
        b (numpy.ndarray): Coordinates of vertex b. Same conventions and requirements as parameter a. b must have the same shape and alignment as a so that corresponding rows define the same tetrahedra when performing batched computations.
        c (numpy.ndarray): Coordinates of vertex c. Same conventions and requirements as parameter a. c must have the same shape and alignment as a and b.
        d (numpy.ndarray): Coordinates of vertex d (the reference vertex used in the triple product). Same conventions and requirements as parameter a. d must have the same shape and alignment as a, b, and c.
    
    Returns:
        float or numpy.ndarray: The absolute volume(s) of the tetrahedron(s) computed as |(a - d) · ((b - d) × (c - d))| / 6. If the inputs are 1-D (length-3) arrays the function returns a scalar float (numpy.float64) giving the volume of that single tetrahedron. If the inputs are 2-D arrays with shape (N, 3) the function returns a 1-D numpy.ndarray of length N containing the volume of each corresponding tetrahedron. Volumes are in cubic units consistent with the input coordinate units (e.g., cubic Angstrom if coordinates are in Angstrom).
    
    Behavior and failure modes:
        The implementation is vectorized and uses NumPy operations (cross product and einsum) without side effects. All four input arrays must be broadcast-compatible and effectively have the same leading dimension when computing multiple volumes; typically they are provided with identical shapes. The last dimension is expected to be of length 3 (Cartesian 3D coordinates); providing arrays with a different last dimension will raise a NumPy error when attempting the cross product. Degenerate tetrahedra (coplanar or coincident vertices) produce a volume of zero. Non-finite input values produce NaN or inf results according to NumPy arithmetic rules. No in-place modification of inputs is performed.
    """
    from gpaw.bztools import tetrahedron_volume
    return tetrahedron_volume(a, b, c, d)


################################################################################
# Source: gpaw.convergence_criteria.dict2criterion
# File: gpaw/convergence_criteria.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_convergence_criteria_dict2criterion(dictionary: dict):
    """Converts a dictionary specification into a GPAW convergence criterion object.
    
    This function is used in GPAW (the DFT/PAW code) to translate a serialized or user-provided dictionary representation of a convergence criterion into a runtime criterion object that controls iterative convergence checks (for example, SCF energy or density convergence or geometry optimization tolerances). The input dictionary may be the output of a criterion's todict() method (containing a 'name' key and other keyword arguments), or a compact user shortcut mapping a criterion name to a value (for example {'energy': 0.005} or {'energy': (0.005, 3)}). dict2criterion uses get_criterion(name) to obtain the criterion factory/class and constructs an instance either by passing keyword arguments (when the dictionary contains 'name') or by passing a single positional argument (when a criterion name maps to a scalar/tuple). The function copies the input dictionary before modification so the original argument is not mutated.
    
    Args:
        dictionary (dict): A dictionary describing a convergence criterion. Accepted forms:
            - A full specification produced by todict(), i.e. a dict containing a 'name' key plus additional keys that are passed as keyword arguments to the criterion constructor. Example: {'name': 'energy', 'tol': 0.005, 'n_old': 3}.
            - A user shortcut mapping a single criterion name to a value, where the value may be a scalar, a tuple, or another dict. Example scalar: {'energy': 0.005}. Example tuple: {'energy': (0.005, 3)}.
            - A combination/nested form where the single key maps to a dict that itself contains a 'name' key; this nested dict will be handled recursively. Example: {'energy': {'name': 'energy', 'tol': 0.005, 'n_old': 3}}.
            The dictionary must therefore either contain a top-level 'name' key, or contain exactly one top-level key that names the criterion. The dictionary represents how tolerances and internal parameters for convergence checks are specified in GPAW input or serialization and is transformed into a concrete criterion object used at runtime to decide when iterations have converged.
    
    Returns:
        object: An instance of the convergence criterion class returned by get_criterion(name). If the input dict contained a 'name' key, the instance is created by calling the criterion factory with keyword arguments derived from the dictionary (ThisCriterion(**kwargs)). If the input dict used the single-key shortcut form, the instance is created by calling the criterion factory with a single positional argument corresponding to the mapped value (ThisCriterion(value)). The returned object is intended for use by GPAW convergence-management code (for example in SCF loops or optimizers) and encapsulates tolerance thresholds and any other criterion-specific parameters.
    
    Behavior and side effects:
        - The function makes a shallow copy of the provided dictionary to avoid mutating the caller's object. Any modifications (such as popping the 'name' key) are performed only on this copy.
        - If 'name' is present at the top level, remaining keys are passed as keyword arguments to the criterion constructor; this follows the serialization format produced by a criterion's todict() method.
        - If the dictionary has no top-level 'name', it must contain exactly one top-level key. The key is interpreted as the criterion name. If the associated value is itself a dict containing a 'name' key, dict2criterion is called recursively to handle that nested specification.
        - Otherwise, the single value is passed as a single positional argument to the criterion constructor. This covers compact user shortcuts such as specifying only a tolerance or a (tolerance, history length) tuple.
        - Typical practical use: converting user or serialized configuration like {'energy': 0.005} or {'name': 'energy', 'tol': 0.005, 'n_old': 3} into a concrete convergence criterion object controlling when an SCF cycle is considered converged.
    
    Failure modes and exceptions:
        - AssertionError is raised if the dictionary does not contain a top-level 'name' and does not have exactly one top-level key (the code asserts len(d) == 1).
        - Errors from get_criterion(name) will propagate (for example if the name is unrecognized, the lookup/factory may raise LookupError/KeyError or a project-specific error).
        - The criterion constructor call (ThisCriterion(**kwargs) or ThisCriterion(value)) may raise TypeError, ValueError, or other exceptions if the provided arguments or value have incorrect types or invalid values; these exceptions are propagated to the caller.
        - The function does not validate numeric ranges or semantics of tolerance values beyond relying on the criterion constructor to do so.
    
    Examples of use in GPAW context:
        - Converting a serialized criterion from persistent storage into an object used to check SCF convergence.
        - Allowing users to specify compact convergence settings in input parameters (e.g. {'energy': 0.005}) which are expanded into full criterion objects for use by the DFT driver code.
    """
    from gpaw.convergence_criteria import dict2criterion
    return dict2criterion(dictionary)


################################################################################
# Source: gpaw.core.matrix.suggest_blocking
# File: gpaw/core/matrix.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for suggest_blocking because the docstring has no description for the argument 'N'
################################################################################

def gpaw_core_matrix_suggest_blocking(N: int, ncpus: int):
    """Suggest blocking (process grid and block size) for an NxN matrix used in parallel linear-algebra routines.
    
    Args:
        N (int): Size N of the square matrix (NxN) to be distributed and operated on. In the GPAW/DFT context this is the dimension of a dense matrix (for example a Hamiltonian or overlap matrix) that will be processed by parallel ScaLAPACK-style block-cyclic algorithms. N is used to determine a block size that yields at least one whole block and at least two blocks in total when the matrix is partitioned across the process grid.
        ncpus (int): Number of CPU processes (MPI ranks) available for the parallel calculation. This function arranges these processes into a 2D process grid (rows × columns) for distributing the matrix. In typical GPAW usage ncpus corresponds to the total number of MPI ranks used for a linear-algebra task.
    
    Returns:
        tuple[int, int, int]: A tuple (nprow, npcol, blocksize) where:
            nprow (int): Number of process rows in the process grid. This value and npcol form the process grid such that nprow * npcol == ncpus. In practice nprow controls how the matrix rows are distributed among MPI ranks (larger nprow means more row partitioning).
            npcol (int): Number of process columns in the process grid. Together with nprow it defines the 2D layout used for block-cyclic distribution of the matrix across MPI ranks; the code attempts to choose npcol and nprow to be as close to each other as possible (a near-square grid) by selecting a divisor pair of ncpus.
            blocksize (int): Tile (block) size used for blocking the matrix in both row and column directions for block-cyclic algorithms (a square block dimension). The blocksize is chosen so that there will always be at least one whole block and at least two blocks in total across the largest process grid dimension; it is rounded down to the nearest power of two and then clamped to the range [1, 64]. In GPAW this block size is intended to produce reasonable whole blocks for ScaLAPACK-style parallel linear algebra.
    
    Behavior and details:
        The function first selects a factorization of ncpus into npcol × nprow by scanning divisors of ncpus and choosing a pair that makes the two dimensions as close as possible (favoring a near-square process grid). It asserts that the product npcol * nprow equals ncpus; if this invariant is violated an AssertionError is raised.
        The blocksize is computed as max((N - 2) // max(nprow, npcol), 1) to ensure at least one whole block and at least two blocks in total, then reduced to the largest power of two not exceeding that value, and finally clamped to at most 64 and at least 1. This choice reflects practical constraints observed with ScaLAPACK and block-cyclic distributions in GPAW: powers of two often give efficient memory and communication patterns, and an upper bound avoids unreasonably large tiles.
        The function has no side effects; it only returns the computed integers. It expects N and ncpus to be integers appropriate for the problem (typically positive). If ncpus does not factor into a valid npcol × nprow pair due to unexpected inputs the internal assertion will fail.
    """
    from gpaw.core.matrix import suggest_blocking
    return suggest_blocking(N, ncpus)


################################################################################
# Source: gpaw.convergence_criteria.get_criterion
# File: gpaw/convergence_criteria.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_convergence_criteria_get_criterion(name: str):
    """Retrieve a built-in GPAW convergence criterion by its registered .name attribute.
    
    This function is used within the GPAW DFT code to select one of the pre-defined convergence criteria that control when iterative algorithms stop (for example self-consistent field iterations, eigenstate/eigenvalue convergence checks, force-based stopping in geometry relaxations, or iteration limits). The function looks up a mapping constructed from the module's built-in criterion classes and returns the class/object associated with the provided name. No global state is modified by this lookup; the mapping is created from the fixed list of built-in criterion classes present in the module: Energy, Density, Eigenstates, Eigenvalues, Forces, WorkFunction, MinIter and MaxIter.
    
    Args:
        name (str): The name of the convergence criterion to retrieve. This must be a string that exactly matches the .name attribute of one of the built-in GPAW convergence criterion classes listed above. The argument determines which convergence test the caller will use when configuring or running iterative procedures in GPAW (for example selecting an energy-based, density-based, forces-based, or iteration-count-based stopping condition). There is no default value; the caller must provide a string.
    
    Returns:
        object: The built-in convergence criterion class or object from the GPAW convergence_criteria module whose .name attribute equals the supplied name. The returned value is intended to be used by GPAW code that configures convergence checks for DFT calculations (e.g., passed into SCF controllers or optimization routines). The return is a direct lookup from the internal mapping and does not produce side effects.
    
    Raises:
        InputError: If the supplied name does not match any known built-in criterion .name, an InputError is raised. The error message lists the known keys (derived from the .name attributes of the built-in classes) and advises that user-written convergence criteria cannot be imported by this function; users should consult the GPAW manual for instructions on integrating custom criteria. This function does not attempt to import or discover user-defined criteria, and providing an incorrect or misspelled name is the primary failure mode.
    """
    from gpaw.convergence_criteria import get_criterion
    return get_criterion(name)


################################################################################
# Source: gpaw.directmin.derivatives.mgs
# File: gpaw/directmin/derivatives.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_directmin_derivatives_mgs(vin: numpy.ndarray):
    """gpaw.directmin.derivatives.mgs: Modified Gram–Schmidt orthonormalization routine used in GPAW direct-minimization derivatives.
    
    Performs the modified Gram–Schmidt procedure on a set of input vectors to produce an orthonormal set. In the GPAW codebase this is used when orthonormalizing collections of vectors such as trial wavefunction coefficient arrays, search directions, or basis vectors inside direct-minimization algorithms for density-functional theory (DFT) calculations. The routine normalizes vectors and removes components along previously processed vectors so that the output vectors are orthonormal with respect to the standard Euclidean inner product.
    
    Args:
        vin (numpy.ndarray): Array containing the set of input vectors. The routine expects vin[i] to refer to the i-th vector; the array layout is preserved in the output (i.e., the returned array has the same shape and dtype as vin). vin is treated as read-only by callers: the function makes an internal deep copy before modifying data so the provided vin is not changed by the call.
    
    Returns:
        numpy.ndarray: Orthonormal set of vectors with the same shape and dtype as vin. The i-th row (or element along the first axis) of the returned array is the normalized i-th orthonormal vector produced by the modified Gram–Schmidt process. If the input vectors span a subspace of lower dimension than the number of input vectors (linear dependence), some output vectors may be (near) zero or contain NaNs/Infs due to division by very small norms; callers should check and handle such cases.
    
    Behavior and side effects:
        This implementation performs a deepcopy of vin internally, so it does not modify the caller's vin object. It uses numpy.linalg.norm to compute vector norms and numpy.dot for inner products. The algorithm iterates over vectors in the order they appear in vin and removes projections of each newly normalized vector from all remaining vectors (classical modified Gram–Schmidt ordering). Computational cost grows approximately quadratically with the number of vectors (roughly O(N^2 * M) for N vectors of length M).
    
    Defaults and failure modes:
        The function does not perform explicit regularization for zero or nearly zero norms. If any vector in vin has exact zero norm, NumPy will typically emit divide-by-zero or invalid-value warnings and the returned array will contain Inf or NaN entries. For nearly linearly dependent inputs the procedure may produce unstable results or loss of orthogonality; in numerically sensitive contexts (for example, orthonormalizing nearly dependent wavefunction coefficients in DFT) callers should consider rank-revealing alternatives or reorthogonalization and should validate the returned vectors (e.g., by checking norms and mutual inner products).
    
    Numerical notes:
        Modified Gram–Schmidt is more numerically stable than the classical Gram–Schmidt for many practical problems in electronic-structure calculations, but it is not immune to rounding error. Use with caution when high orthogonality is required.
    """
    from gpaw.directmin.derivatives import mgs
    return mgs(vin)


################################################################################
# Source: gpaw.directmin.etdm_lcao.convert_constraints
# File: gpaw/directmin/etdm_lcao.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_directmin_etdm_lcao_convert_constraints(
    constraints: list,
    n_dim: int,
    n_occ: int,
    representation: str
):
    """Parses and validates a user-supplied list of orbital constraints for one k-point used by the ETDM LCAO direct-minimization workflow in GPAW. This function accepts the raw constraints as provided by a caller (typically from input files or higher-level code that configures constrained electronic degrees of freedom), expands any single-orbital indices into all orbital pairs that include that orbital, enforces ordering rules for pair indices depending on the chosen representation, validates index ranges against the provided dimensions and occupation counts, and returns a converted list that contains only orbital pairs suitable for downstream constraint enforcement (for example, constraining density-matrix or orbital-matrix elements during constrained minimization).
    
    Args:
        constraints (list): List of constraints for one K-point as provided by the user. Each element must be either an int (single orbital index) or a list of ints of length 1 or 2. A single int entry signals that all orbital pairs involving that orbital should be added; a two-element list [i, j] denotes a constraint targeting the pair of orbitals i and j. Elements that are not int or list, or lists with length >= 3, will trigger an assertion error. Note: two-element lists may be modified in-place (their order swapped) by this function when representation != 'full' (see side effects).
        n_dim (int): Integer number of single-particle degrees of freedom (the dimension of the single-particle space) used to validate that each orbital index in a pair falls within the allowed range. This corresponds to the total number of basis states or electronic degrees of freedom for the k-point and is used by check_indices/find_all_pairs to ensure indices are valid.
        n_occ (int): Integer number of occupied orbitals used for index validation logic. In the ETDM LCAO context this typically corresponds to the number of occupied states and is used together with n_dim to determine which orbital indices are permitted for constraints.
        representation (str): String selecting the representation of electronic degrees of freedom. This controls how pairs are interpreted and ordered; valid representations include the unitary-invariant, sparse, or full representations used by the ETDM LCAO implementation. In practice, the code checks representation equality with the literal 'full': when representation != 'full' the function enforces that for any two-index constraint the first index is less than the second (it will swap indices when necessary); when representation == 'full' no automatic reordering is performed.
    
    Behavior, side effects, and failure modes:
        - Single-index entries (ints or lists of length 1) are expanded by calling find_all_pairs(index, n_dim, n_occ, representation). The expansion adds all pairs containing that index to the output list so that downstream code only receives explicit two-index constraints.
        - Two-index entries (lists of length 2) are validated by calling check_indices(i, j, n_dim, n_occ, representation). If check_indices detects invalid indices or an invalid pair according to n_dim/n_occ/representation it will raise an exception (propagated to the caller).
        - Elements of the input constraints that are lists of two integers may be modified in-place when representation != 'full' because the function may reorder the two integers so that the first becomes smaller than the second. The top-level list object referenced by the caller is shallow-copied (constraints.copy()) but the nested list objects are not deep-copied; therefore callers should not assume immutability of inner list elements.
        - The function asserts that every entry in the input list is either an int or a list and that any list has length strictly less than 3. If these assertions fail, an AssertionError with message 'Check constraints.' is raised.
        - After expansion, any residual entries that are single-index lists are removed from the returned list so that the final result contains only two-index constraints (lists of length 2).
        - The function does not introduce new accepted types or ranges beyond those already enforced by find_all_pairs and check_indices; index validity is determined by those helpers and by the provided n_dim and n_occ.
    
    Returns:
        list: A converted list of constraints for the given k-point. Every element in the returned list is a list of two integers [i, j] representing a constrained orbital pair. The returned pairs include original two-index constraints (possibly reordered when representation != 'full') and all pairs produced by expanding any single-index entries. No single-index entries are present in the returned list.
    """
    from gpaw.directmin.etdm_lcao import convert_constraints
    return convert_constraints(constraints, n_dim, n_occ, representation)


################################################################################
# Source: gpaw.directmin.sd_etdm.multiply
# File: gpaw/directmin/sd_etdm.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_directmin_sd_etdm_multiply(x: dict, const: float = 1.0):
    """gpaw.directmin.sd_etdm.multiply scales each value in a dictionary by a scalar and returns a new dictionary containing the scaled values. This utility is used in the GPAW direct minimization (sd_etdm) code path to produce a scaled copy of a state or step vector representation where state vectors or numeric containers are stored as dictionary values keyed by their identifiers. The function implements y[k] = const * x[k] for every key k present in x without mutating the input dictionary x itself.
    
    Args:
        x (dict): Input mapping representing a state, step, or collection of numeric quantities used in GPAW's direct minimization routines. Keys are identifiers (typically strings or other hashable objects) and values are objects that support multiplication by a Python float (for example Python numeric scalars or NumPy arrays, which are commonly used in GPAW as described in the project README). The function iterates over x.keys() and reads x[k] for each key; it does not modify x, so callers can rely on x remaining unchanged after the call.
        const (float): Scalar multiplier applied to every value in x. The default is 1.0, which produces a new dictionary whose values are the result of 1.0 * x[k] (effectively a scaled shallow copy). In the GPAW context this parameter is used to scale step sizes, residuals, or other numeric vectors during direct minimization algorithms.
    
    Returns:
        dict: A new dictionary y containing the same keys as x and values computed as const * x[k] for each key k. The returned dictionary is a distinct object from x (i.e., y is newly constructed inside the function) so no in-place modification of x occurs. Note that the multiplication uses the Python * operator for each value; any side effects or behaviors of that operator for the particular value types (for example, returning a new NumPy array or raising an exception) will apply. If a value in x does not support multiplication by a float, the underlying multiplication will raise the corresponding exception (for example, TypeError), which is propagated to the caller.
    """
    from gpaw.directmin.sd_etdm import multiply
    return multiply(x, const)


################################################################################
# Source: gpaw.directmin.functional.lcao.pz.constrain_grad
# File: gpaw/directmin/functional/lcao/pz.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_directmin_functional_lcao_pz_constrain_grad(
    grad: numpy.ndarray,
    constraints: list,
    ind_up: tuple
):
    """constrain_grad zeros components of a gradient vector that correspond to constrained degrees of freedom for LCAO PZ direct minimization used in GPAW DFT calculations. It enforces constraints by setting the matching gradient entries to 0.0 so that optimization steps do not change those degrees of freedom (the code would ideally avoid computing these components in the first place).
    
    This function is intended for use in the direct minimization ("directmin") workflow for localized atomic-orbital (LCAO) based functionals in GPAW. In that context, grad is the flattened 1D gradient (for example, derivative of the energy or functional with respect to a list of paired indices), constraints enumerate the specific index pairs to hold fixed during optimization, and ind_up provides the ordered mapping from index-pair tuples to positions in the grad array. The function modifies grad in-place and also returns it for convenience.
    
    Args:
        grad (numpy.ndarray): A one-dimensional NumPy array containing the gradient components for the optimization variables used in the LCAO direct-minimization routine. Each element corresponds to a specific (ind1, ind2) pair from ind_up (the mapping described below). The function will set some elements of this array to 0.0 when they match entries in constraints. The array is modified in-place; callers relying on the original values must provide a copy.
        constraints (list): A list of constrained index-pair specifications. Each element is expected to be a two-element sequence (for example, a list of two items) that can be compared for equality to the pairs produced by zipping ind_up[0] and ind_up[1]. When a constraint exactly equals [ind1, ind2] for some pair from ind_up, the corresponding gradient component is zeroed. If a constraint does not match any pair, it has no effect.
        ind_up (tuple): A tuple of two iterables (ind_up[0], ind_up[1]) that together define the ordered list of index pairs mapped to positions in grad. The function iterates over zip(ind_up[0], ind_up[1]) to produce pairs (ind1, ind2); the zero-based position of each pair in that sequence is the index into grad that may be set to zero. The length of grad should match the number of pairs produced by the zip for correct mapping; mismatches can raise IndexError or leave some constraints unapplied.
    
    Behavior and side effects:
        The function walks through the ordered pairs given by zip(ind_up[0], ind_up[1]) and compares each pair to every entry in constraints. For each exact match it sets the corresponding grad element to 0.0. This operation mutates the provided grad array in-place and also returns the mutated array. Complexity is proportional to len(constraints) * number_of_pairs.
        No new memory is allocated for a copy unless the caller makes one; returning grad is a convenience to allow chained usage.
    
    Failure modes and notes:
        If grad is not a one-dimensional NumPy array or its length does not equal the number of zipped pairs from ind_up, the function may raise IndexError or silently fail to zero intended components. If constraint elements are not comparable to the pairs produced from ind_up (different types or structure), they will not match and thus will not constrain any gradient component. The function expects constraint entries that are comparable via equality to [ind1, ind2] lists produced from ind_up.
    
    Returns:
        numpy.ndarray: The same numpy.ndarray object grad that was passed in, after setting to 0.0 all components corresponding to constrained index pairs. The returned array is mutated in-place; no separate copy is created by the function.
    """
    from gpaw.directmin.functional.lcao.pz import constrain_grad
    return constrain_grad(grad, constraints, ind_up)


################################################################################
# Source: gpaw.directmin.ls_etdm.is_descent_and_approximate_wolfe_conditions
# File: gpaw/directmin/ls_etdm.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_directmin_ls_etdm_is_descent_and_approximate_wolfe_conditions(
    der_phi_0: float,
    phi_0: float,
    der_phi_j: float,
    phi_j: float,
    eps: float = 1e-06,
    delta: float = 0.1,
    sigma: float = 0.9
):
    """Check whether a trial step simultaneously satisfies a descent test and the
    approximate Wolfe conditions used in line-search implementations for direct
    energy minimization (ETDM) in GPAW. This function implements the test
    described by William W. Hager and Hongchao Zhang (SIAM J. Optim., 16(1),
    170-192) and is intended for use inside the line-search routine of the
    direct-minimization solver (gpaw.directmin.ls_etdm). It combines a call to
    is_descent(...) for sufficient decrease in the objective (phi) with an
    inequality check on directional derivatives that enforces the approximate
    Wolfe conditions (AWC) via the parameters delta and sigma.
    
    Args:
        der_phi_0 (float): Directional derivative of the objective phi at the
            initial point (step size 0). In the ETDM/line-search context this is
            the initial slope along the search direction; it determines the sign
            and magnitude of expected decrease. The function uses der_phi_0 as the
            left-hand reference value in the AWC inequalities (both upper and
            lower bounds).
        phi_0 (float): Objective function value phi at the initial point (step
            size 0). In the DFT energy-minimization domain this typically
            represents the total energy (or an energy-like merit function) at the
            current iterate. It is passed to the internal is_descent check to
            ensure sufficient decrease of phi at the trial step.
        der_phi_j (float): Directional derivative of phi at the trial step j
            (the candidate step size). In line-search logic this is compared
            against scaled versions of der_phi_0 to enforce curvature (Wolfe-like)
            requirements: it must lie between sigma*der_phi_0 and (2*delta-1)*der_phi_0.
        phi_j (float): Objective function value phi at the trial step j. This
            value is compared to phi_0 (via is_descent) to verify that the trial
            step yields a sufficient decrease in the energy or merit function,
            subject to the tolerance eps.
        eps (float): Tolerance used by the descent test called via is_descent.
            Defaults to 1e-6. In practice, eps sets how strict the sufficient-decrease
            criterion is when comparing phi_j to phi_0 in the line-search: smaller
            eps enforces a closer decrease requirement, while larger eps relaxes it.
        delta (float): Parameter in (0,1) that controls the upper side of the
            approximate Wolfe condition. Defaults to 0.1. The AWC inequality
            implemented here uses the factor (2*delta - 1) multiplied by der_phi_0
            as the upper bound for der_phi_j; delta therefore moves that upper
            bound between -1 and 1 and tunes the allowed curvature at the trial
            point as described in Hager & Zhang.
        sigma (float): Parameter in (0,1) that controls the lower side of the
            approximate Wolfe condition. Defaults to 0.9. The AWC requires
            der_phi_j >= sigma * der_phi_0, so larger sigma makes the curvature
            requirement stricter (derivative at the trial point must be closer to
            the initial derivative).
    
    Returns:
        bool: True if and only if both (a) the descent test implemented by
        is_descent(phi_0, phi_j, eps) succeeds (indicating sufficient decrease in
        the objective at the trial step) and (b) the approximate Wolfe conditions
        hold, i.e. the directional derivatives satisfy
        (2.0 * delta - 1.0) * der_phi_0 >= der_phi_j >= sigma * der_phi_0.
        False otherwise. There are no side effects; the function performs only
        numerical comparisons. If inputs are NaN or invalid according to Python's
        floating-point semantics, comparisons may propagate NaNs and result in
        False or raise exceptions according to Python's standard behavior.
    """
    from gpaw.directmin.ls_etdm import is_descent_and_approximate_wolfe_conditions
    return is_descent_and_approximate_wolfe_conditions(
        der_phi_0,
        phi_0,
        der_phi_j,
        phi_j,
        eps,
        delta,
        sigma
    )


################################################################################
# Source: gpaw.directmin.functional.lcao.ks.constrain_grad
# File: gpaw/directmin/functional/lcao/ks.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_directmin_functional_lcao_ks_constrain_grad(
    grad: list,
    constraints: list,
    ind_up: tuple
):
    """gpaw.directmin.functional.lcao.ks.constrain_grad zeros gradient components corresponding to constrained degrees of freedom used in LCAO Kohn–Sham direct minimization in GPAW. This function is used in the direct-minimization functional code path to prevent optimization steps along specified constrained index pairs by setting those gradient components to 0.0, so optimizers (line-search, conjugate-gradient, etc.) do not change the associated degrees of freedom during a DFT/LCAO optimization step.
    
    Args:
        grad (list): A list of gradient components (typically floats) representing the derivative of the objective with respect to the ordered optimization variables used by the LCAO Kohn–Sham direct-minimization routine. The list is modified in place: elements that correspond to constrained index pairs are overwritten with 0.0. The ordering of grad must correspond to the paired indices provided by ind_up (see below). If grad contains non-numeric elements, assigning 0.0 will change their type.
        constraints (list): A list of constraints, where each constraint is expected to be a two-element list [ind1, ind2] that identifies a specific constrained degree of freedom in the same index-space used by ind_up. For each constraint in this list, any matching index pair found when zipping ind_up[0] and ind_up[1] will cause the corresponding grad entry to be set to 0.0. Equality is tested with Python's list equality, so exact ordering and element types matter.
        ind_up (tuple): A tuple of two index sequences (for example, two lists or tuples) whose elements are paired elementwise by zip(ind_up[0], ind_up[1]) to enumerate the index pairs that map to entries of grad. The n-th pair produced by this zip corresponds to grad[n] (counting from 0). The length of these sequences determines how many gradient entries are inspected; zip truncates to the shorter sequence. ind_up therefore defines the mapping from index pairs to positions in grad used by the LCAO Kohn–Sham direct-minimization implementation.
    
    Returns:
        list: The same grad list passed in (modified in place) with entries set to 0.0 for any positions whose index pair matches an element of constraints. If no constraints match, the returned list is identical to the input grad (aside from any in-place modification semantics). Side effects: grad is modified in place; callers relying on an immutable original grad must pass a copy.
    
    Behavior, side effects, defaults, and failure modes:
        The function iterates over all constraints and, for each constraint, walks the paired indices produced by zip(ind_up[0], ind_up[1]) while maintaining a running counter that maps pairs to positions in grad. When a pair equals the constraint (using Python equality), the corresponding grad entry is set to 0.0. The operation is O(len(constraints) * min(len(ind_up[0]), len(ind_up[1]))). Because grad is modified in place, the original gradient list is changed and the same object is returned. If grad is shorter than the number of pairs produced by zip(ind_up[0], ind_up[1]), assignment to grad may raise IndexError. If constraints do not use two-element lists or use types that do not compare equal to the pairs produced from ind_up, no matches will be found and grad will remain unchanged. The implementation assumes the mapping from index pairs to grad positions is given by the order of zip(ind_up[0], ind_up[1]); changing that convention requires adapting callers. Note that it can be more efficient to avoid computing constrained components of the gradient in the first place; this function provides a simple post-processing step to enforce constraints when those components are already present.
    """
    from gpaw.directmin.functional.lcao.ks import constrain_grad
    return constrain_grad(grad, constraints, ind_up)


################################################################################
# Source: gpaw.directmin.tools.array_to_dict
# File: gpaw/directmin/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_directmin_tools_array_to_dict(x: numpy.ndarray, dim: list):
    """gpaw.directmin.tools.array_to_dict: Convert a concatenated numpy.ndarray into a dictionary of component arrays indexed by integers. This function is used in GPAW's direct minimization utilities (gpaw.directmin.tools) to split a single long solution or parameter vector into separate parts (for example, per-variable coefficient blocks, atom-centered values, or grid function segments) so that routines such as component-wise updates, preconditioning, or line searches can operate on each part independently.
    
    Args:
        x (numpy.ndarray): Source array containing concatenated components. The function slices x along its first axis (x[start:stop]) to produce each component. x is not modified by this function; however, the returned component arrays are obtained by slicing x and therefore will typically be NumPy views that share memory with x (standard NumPy slicing semantics apply). The caller should therefore be aware that modifying returned arrays may modify x.
        dim (list): List of integer dimensionalities (lengths) of the parts to extract from x. Each entry dim[i] specifies the number of elements to take for key i. The practical role of dim in the GPAW direct-minimization context is to describe how a flattened optimization vector is partitioned into meaningful sub-vectors (for example, coefficients for different basis sets or distinct physical quantities). Elements of dim must be non-negative integers; non-integer or negative values will lead to TypeError or unexpected/incorrect slicing behavior because the function does no validation.
    
    Returns:
        dict: A dictionary mapping integer keys 0 .. len(dim)-1 to numpy.ndarray objects containing the corresponding slices of x. For i in range(len(dim)), the value y[i] equals x[start:stop] where start and stop are computed cumulatively from dim. If sum(dim) is less than the length of x along the first axis, the trailing elements of x beyond the summed dimensions are ignored. If sum(dim) exceeds the length of x, Python slicing semantics are used: slices that extend beyond the end of x yield shorter arrays or empty arrays (no exception is raised). No in-place modification of x is performed by this function; the only side effect to consider is that returned slices may share memory with x.
    
    Behavioral and failure notes:
        The function iterates over dim once and performs O(len(dim)) operations; it does not allocate a full copy of x for each slice (slices are views when possible). The function does not validate types or values in dim beyond relying on normal Python operations; therefore, callers must ensure dim elements are integers >= 0 and that x is a NumPy array whose first-axis length is consistent with the intended partitioning. Incorrect dim values can produce overlapping slices, empty arrays, or TypeError from invalid slice indices.
    """
    from gpaw.directmin.tools import array_to_dict
    return array_to_dict(x, dim)


################################################################################
# Source: gpaw.directmin.tools.expm_ed
# File: gpaw/directmin/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_directmin_tools_expm_ed(a_mat: numpy.ndarray, evalevec: bool = False):
    """Compute the matrix exponential of a square numpy.ndarray using an eigendecomposition
    of 1j * a_mat. This function is provided in gpaw.directmin.tools and is used in the
    GPAW DFT code (for example by direct-minimization routines) to form exponentials of
    matrices that generate unitary or orthogonal updates (typical use case: a_mat is a
    real antisymmetric generator so that 1j * a_mat is Hermitian and exp(a_mat) is a
    unitary/orthogonal update). The implementation computes eigenpairs of 1j * a_mat with
    numpy.linalg.eigh and reconstructs the matrix exponential via the eigenbasis,
    returning a contiguous numpy array and optionally the eigenvectors and eigenvalues
    used for the construction.
    
    Args:
        a_mat (numpy.ndarray): Square input matrix A to be exponentiated. In the typical
            GPAW/direct-minimization context A is a small dense matrix (N x N) whose
            multiplication generates unitary/orthogonal updates; the implementation
            assumes that 1j * a_mat is Hermitian so that numpy.linalg.eigh can be used.
            If a_mat.dtype is a float dtype the returned exponential will be converted to
            a real numpy.ndarray (product.real) to match the input real-valued type.
        evalevec (bool): If False (default) only the matrix exponential product is
            returned. If True the function additionally returns the eigenvectors and
            eigenvalues computed from numpy.linalg.eigh(1j * a_mat). Use evalevec=True
            when the caller needs the eigenbasis for subsequent reuse (avoids recomputing
            the eigendecomposition).
    
    Returns:
        numpy.ndarray: When evalevec is False, returns a contiguous numpy.ndarray with the
        same shape as a_mat containing the matrix exponential computed as V @ diag(exp)
        @ V.H, where V and diag(exp) are obtained from the eigendecomposition of
        1j * a_mat. If a_mat.dtype was a float dtype the returned array will be a real
        array (product.real). The returned array is guaranteed to be C-contiguous
        (as returned by numpy.ascontiguousarray).
        tuple(numpy.ndarray, numpy.ndarray, numpy.ndarray): When evalevec is True, returns
        a 3-tuple (product, evec, eigval) where product is the matrix exponential as
        described above (numpy.ndarray, shape (N, N)), evec is the matrix of column
        eigenvectors returned by numpy.linalg.eigh (numpy.ndarray, shape (N, N)), and
        eigval is the 1-D array of corresponding real eigenvalues (numpy.ndarray, shape
        (N,)). These eigenpairs satisfy numpy.linalg.eigh(1j * a_mat) = (eigval, evec).
    
    Behavior, side effects, defaults, and failure modes:
        The function computes eigval, evec = numpy.linalg.eigh(1j * a_mat) and then
        reconstructs the exponential as (evec * numpy.exp(-1.0j * eigval)) @ evec.T.conj().
        The result is converted to a contiguous array with numpy.ascontiguousarray before
        returning. If a_mat.dtype is a floating (real) dtype the result is reduced to its
        real part to match the real-valued input. No in-place modification of a_mat is
        performed.
        Failure modes are those of numpy.linalg.eigh and array operations: if a_mat is not
        square a subsequent operation will raise a ValueError; if 1j * a_mat is not
        Hermitian or the eigendecomposition does not converge numpy.linalg.LinAlgError may
        be raised. The function does not validate beyond relying on numpy.linalg.eigh, so
        callers should ensure inputs meet the Hermiticity requirement for 1j * a_mat when
        using this implementation for robust numerical behavior.
    """
    from gpaw.directmin.tools import expm_ed
    return expm_ed(a_mat, evalevec)


################################################################################
# Source: gpaw.directmin.etdm_lcao.find_all_pairs
# File: gpaw/directmin/etdm_lcao.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_directmin_etdm_lcao_find_all_pairs(
    ind: int,
    n_dim: int,
    n_occ: int,
    representation: str
):
    """Creates a list of orbital-index pairs that correspond to the degrees of freedom
    (orbital-rotation constraints) associated with a given orbital index in the
    electronic-structure direct energy minimization (ETDM) LCAO workflow used by
    GPAW. In the GPAW DFT context (see README), the total number of single-particle
    orbitals is n_dim and the first n_occ of these are treated as occupied;
    orbital-rotation degrees of freedom connect occupied (o) and unoccupied (v)
    subspaces and may include rotations within the occupied subspace (oo). This
    function is used by gpaw.directmin.etdm_lcao to enumerate which index pairs
    participate in constraints or parametrizations of orbital rotations for a
    single orbital index ind, given a choice of representation that controls which
    types of rotations count as degrees of freedom.
    
    Args:
        ind (int): The orbital index for which to find all associated index pairs.
            This integer identifies the single orbital (0-based indexing) in the
            basis of n_dim orbitals. In practical GPAW usage ind is expected to
            satisfy 0 <= ind < n_dim; the function does not validate this and will
            produce pairs containing ind even if it lies outside that range.
        n_dim (int): The total number of orbitals (dimension of the single-particle
            orbital space). In GPAW this corresponds to the full number of LCAO or
            basis orbitals available for rotations. Typical invariant expectation
            is n_dim >= n_occ; violating this may produce results that do not
            reflect valid orbital indices.
        n_occ (int): The number of occupied orbitals (the size of the occupied
            subspace). The function treats indices 0..n_occ-1 as occupied and
            indices n_occ..n_dim-1 as unoccupied. In the direct-minimization
            algorithm, ov pairs connect occupied and unoccupied orbitals and oo
            pairs connect two occupied orbitals.
        representation (str): A string selecting which index-pair types are
            considered degrees of freedom. Must be one of the representations used
            in the module: 'u-invar', 'sparse' or 'full'. Their meanings are:
            'u-invar' -- unitary-invariant representation: only occupied-unoccupied
                (ov) rotations are considered degrees of freedom. If ind is an
                occupied index (ind < n_occ) the function returns pairs [ind, i]
                for all unoccupied indices i in range(n_occ, n_dim); if ind is an
                unoccupied index the function returns pairs [i, ind] for all
                occupied i in range(n_occ). The order of elements in each pair is
                chosen so the smaller index appears first.
            'sparse' -- sparse representation used in the module: when ind is an
                occupied index (ind < n_occ) both occupied-occupied (oo) and
                occupied-unoccupied (ov) rotations are considered degrees of
                freedom and the function returns pairs with the smaller index
                first for every other orbital j != ind, iterating over the full
                range range(n_dim). When ind is unoccupied, 'sparse' behaves like
                the ov-only case and returns [i, ind] for i in range(n_occ).
            'full' -- full representation: the orbital-rotation matrix is not
                assumed antihermitian, so both orderings of each index pair must
                be treated as independent constraints. For any ind the function
                enumerates pairs for all j != ind from range(n_dim), appending
                both [min(j,ind), max(j,ind)] and the reversed ordering, i.e. both
                orderings appear as separate entries for each partner orbital j.
            Note: if representation is not one of these documented strings, the
            function falls through to the final fallback branch (equivalent to
            the ov-only behavior for an unoccupied index) and may produce results
            that include self-pairs for occupied indices; unsupported strings are
            not validated and are therefore a potential source of errors.
    
    Returns:
        list[list[int]]: A list of two-element integer lists [a, b], each
        representing an ordered pair of orbital indices that together define a
        degree of freedom (a constraint or an independent rotation parameter) for
        the orbital ind in the ETDM LCAO direct-minimization context. Elements
        are integers that index the single-particle orbitals in the range assumed
        by the caller. The behavior by representation is as described above:
        'u-invar' returns only ov pairs, 'sparse' returns oo+ov when ind is
        occupied and ov only when ind is unoccupied, and 'full' returns both
        orderings for every partner orbital j != ind. No other side effects occur
        (the function is pure and returns the computed list), but the function
        does not perform bounds checking on ind, n_dim, or n_occ; passing values
        outside the expected relations (for example n_occ > n_dim or ind < 0 or
        ind >= n_dim) can produce incorrect or invalid index pairs. The routine
        runs in O(n_dim) time and may produce up to roughly 2*(n_dim-1) entries in
        the 'full' representation.
    """
    from gpaw.directmin.etdm_lcao import find_all_pairs
    return find_all_pairs(ind, n_dim, n_occ, representation)


################################################################################
# Source: gpaw.directmin.tools.dict_to_array
# File: gpaw/directmin/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_directmin_tools_dict_to_array(x: dict):
    """Converts a dictionary whose keys are integers into a single one-dimensional NumPy array by appending the values for use in linear-algebra operations in GPAW direct-minimization utilities.
    
    This function is intended for assembling separate components (for example, per-atom or per-grid blocks of degrees of freedom used in density-functional theory (DFT) computations implemented in GPAW) into a single contiguous vector suitable for minimization, matrix-vector products, and other numerical linear-algebra routines. It does not modify the input dictionary; it constructs new Python objects and returns a NumPy array whose data buffer is created from the concatenated values.
    
    Args:
        x (dict): Dictionary with integer keys mapping to sequence-like objects (iterables) such as lists or arrays. Each value x[k] is expected to support iteration and len(x[k]) so that its elements can be appended. The integer keys determine the iteration order used for concatenation: values are appended in the order produced by x.keys(). In GPAW this pattern is used to convert per-component data structures into a single vector for algorithms that require flat arrays.
    
    Returns:
        tuple: A 3-tuple (array, dim, dimtot) with the following entries:
            numpy.ndarray: One-dimensional NumPy array produced by concatenating all elements from the dictionary values in the key-iteration order. The dtype is inferred by numpy.asarray and no explicit casting is performed. This array is suitable for input to linear-algebra routines used in GPAW direct-minimization and related modules.
            list: A list of integers giving the length len(x[k]) of each original dictionary value, in the same order as concatenation. This list is useful for reconstructing the original segmented structure from the flat array.
            int: The total length (sum of the individual lengths) of the concatenated array, equal to sum(dim). Useful for dimension checks and bookkeeping.
    
    Behavior, defaults, and failure modes:
        - The function requires that every key in x is an int; if any key is not an int an AssertionError is raised with the message 'Cannot convert dict to array if keys are not integer.'.
        - Each value x[k] must be iterable and support len(x[k]). If a value does not support iteration or len, a TypeError or AttributeError raised by Python/numpy may occur.
        - The concatenation order follows the iteration order of x.keys(); in Python 3.7+ this is the insertion order of the dictionary. Users who rely on a specific ordering must ensure the dictionary is constructed in that order.
        - No in-place modifications are performed on the input dictionary or its values; new objects are created.
        - The returned NumPy array is created with numpy.asarray on the concatenated Python list; large inputs may therefore have memory implications when constructing the intermediate Python list before array creation.
    """
    from gpaw.directmin.tools import dict_to_array
    return dict_to_array(x)


################################################################################
# Source: gpaw.directmin.tools.gramschmidt_lcao
# File: gpaw/directmin/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_directmin_tools_gramschmidt_lcao(C_nM: numpy.ndarray, S_MM: numpy.ndarray):
    """Gram-Schmidt orthonormalization for linear-combination-of-atomic-orbitals (LCAO)
    using a Cholesky decomposition of the projected overlap matrix.
    
    This function is used in GPAW's LCAO/direct-minimization context to convert a
    set of LCAO expansion coefficients into an orthonormal set with respect to
    the atomic-basis overlap. Concretely, it forms the projected overlap matrix
    S_nn = C_nM @ S_MM.conj() @ C_nM.T.conj(), performs a lower-triangular
    Cholesky factorization S_nn = L_nn L_nn^H, and returns X = L_nn^{-1} C_nM.
    The returned coefficient matrix X satisfies X @ S_MM.conj() @ X.T.conj() =
    Identity_n within numerical precision, which is required before diagonaliza-
    tion or other operations that assume an orthonormal set of states.
    
    Args:
        C_nM (numpy.ndarray): LCAO coefficients provided as a two-dimensional
            NumPy array with the first index enumerating states (n) and the
            second index enumerating basis functions (M). In the GPAW LCAO
            workflow these coefficients express wavefunctions (or trial vectors)
            in the non-orthogonal atomic basis. The function expects C_nM to be
            compatible with matrix multiplication by S_MM on its right (i.e.,
            its second dimension must match the shape of S_MM).
        S_MM (numpy.ndarray): Overlap matrix between basis functions as a
            two-dimensional NumPy array with shape (M, M). This matrix encodes
            the non-orthogonality of the atomic basis used by GPAW. The function
            treats S_MM as the Hermitian overlap matrix S; it is conjugated where
            needed in the computation. S_MM must be finite-valued (no NaNs or
            Infs) and compatible with C_nM for the multiplications performed.
    
    Returns:
        numpy.ndarray: A two-dimensional NumPy array of the same shape as the
        input C_nM containing orthonormalized LCAO coefficients X. The returned
        array satisfies X @ S_MM.conj() @ X.T.conj() = Identity_n within
        numerical precision, so that the new overlap between the returned
        coefficient rows is the Kronecker delta. The dtype and memory layout are
        those produced by NumPy's linear algebra routines; the shape equals that
        of C_nM.
    
    Raises:
        numpy.linalg.LinAlgError: If the projected overlap matrix S_nn is not
            positive-definite (for example, due to exact linear dependence or
            near-singularity of the supplied coefficients and overlap), the
            Cholesky decomposition will fail and this exception is raised.
        ValueError: If the input arrays have incompatible shapes for the required
            matrix multiplications, a ValueError will be raised by NumPy.
    
    Notes and side effects:
        - The implementation computes S_nn = C_nM @ S_MM.conj() @ C_nM.T.conj()
          and calls linalg.cholesky(..., lower=True, overwrite_a=True,
          check_finite=False). The overwrite_a=True flag allows the routine to
          reuse the temporary S_nn buffer, reducing memory overhead; it does not
          modify the caller's C_nM or S_MM arrays because S_nn is a locally
          created array in the function.
        - check_finite=False is used for performance; therefore inputs must be
          free of NaNs and Infs. Supplying non-finite values can lead to silent
          numerical failures or to an exception from the underlying LAPACK call.
        - The orthonormalization enforces orthonormality in the subspace spanned
          by the rows of C_nM. Numerical round-off means the identity condition is
          satisfied up to machine precision; for nearly linearly dependent inputs
          the result may be ill-conditioned and Cholesky may fail.
        - Typical usage in GPAW: apply this function to a set of trial or
          intermediate LCAO coefficient vectors before eigensolving or
          subspace-projection steps to ensure stability and correctness of
          subsequent linear-algebra operations.
    """
    from gpaw.directmin.tools import gramschmidt_lcao
    return gramschmidt_lcao(C_nM, S_MM)


################################################################################
# Source: gpaw.directmin.tools.d_matrix
# File: gpaw/directmin/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_directmin_tools_d_matrix(omega: numpy.ndarray):
    """gpaw.directmin.tools.d_matrix: Compute the complex "d-matrix" used in direct-minimization gradient formulas for skew-Hermitian generators.
    
    This helper constructs the m-by-m complex matrix u_m whose (i, j) element is
    1j*(exp(-1j*(omega_i - omega_j)) - 1)/(omega_i - omega_j), with the
    diagonal (and any zero-difference) entries set to the analytic limit value 1.
    The function implements Eq. 40 from A. V. Ivanov et al., Comput. Phys.
    Commun., 267, 108047 (2021) (arXiv:2101.12597), and is used in GPAW's
    direct-minimization machinery to assemble factors that appear when computing
    the gradient of an energy functional with respect to a skew-Hermitian
    generator (i.e., an anti-Hermitian matrix that parameterizes unitary
    rotations of electronic states). In practice, omega contains the set of
    state-dependent scalar parameters (for example phase angles or eigenvalue-like
    quantities) whose pairwise differences enter these gradient expressions.
    
    Args:
        omega (numpy.ndarray): One-dimensional NumPy array of length m (shape[0] == m)
            containing the scalar parameters (typically real-valued phases or
            eigenvalue-like quantities) for the m states. The function reads
            omega.shape[0] to determine m and computes pairwise differences
            omega_i - omega_j for all i,j in [0, m-1]. The input array is not
            modified. If omega contains non-finite values (NaN or ±Inf), the
            arithmetic may produce NaN/Inf values that are subsequently replaced
            by the analytic limit value 1 in the output; supplying non-finite
            entries is therefore not recommended and may mask upstream errors.
            The function requires at least a one-dimensional array (a 0-d scalar
            will not provide a valid shape[0]).
    
    Returns:
        numpy.ndarray: Complex NumPy array of shape (m, m). The returned matrix
        u_m contains the values
        u_m[i, j] = 1j*(exp(-1j*(omega[i] - omega[j])) - 1) / (omega[i] - omega[j])
        for i != j, and u_m[i, i] = 1. The implementation handles the
        omega_i == omega_j (zero denominator) case by using NumPy error-state
        suppression and replacing resulting NaN/Inf entries with 1, yielding the
        correct analytic limit. The output dtype will be a complex type (typically
        complex128) due to the use of complex arithmetic. This function is
        purely functional (no side effects) and has O(m^2) time and memory cost;
        it will raise an IndexError if omega has no first dimension (i.e., is a
        0-d array) or propagate other exceptions thrown by NumPy operations.
    """
    from gpaw.directmin.tools import d_matrix
    return d_matrix(omega)


################################################################################
# Source: gpaw.directmin.tools.expm_ed_unit_inv
# File: gpaw/directmin/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_directmin_tools_expm_ed_unit_inv(
    a_upp_r: numpy.ndarray,
    oo_vo_blockonly: bool = False
):
    """gpaw.directmin.tools.expm_ed_unit_inv computes a unitary matrix by evaluating the matrix exponential formula given in Eq. (6) of J. Hutter, M. Parrinello, and S. Vogel, J. Chem. Phys., 101, 3862 (1994). This routine is used in GPAW's direct-minimization tools to construct occupied/virtual rotation operators (unitary updates) from the block X (called a_upp_r here) that couples occupied and virtual subspaces during wavefunction optimization in density-functional theory (DFT) calculations.
    
    Args:
        a_upp_r (numpy.ndarray): The block X from the paper, given as a two-dimensional NumPy array with shape (n_o, n_v) where n_o is the number of occupied states (rows) and n_v is the number of virtual/unoccupied states (columns). The function uses a_upp_r to form p_nn = a_upp_r @ a_upp_r.T.conj() and therefore expects a numeric array (real or complex) that supports .T.conj() and matrix multiplication. In the GPAW DFT context, a_upp_r encodes infinitesimal rotations or update amplitudes between occupied and virtual subspaces; this routine converts that information into a full unitary rotation operator. If a_upp_r is exactly zero (all elements equal to zero within floating-point tolerance), the function returns the identity (or the corresponding block form) without performing eigendecomposition.
        oo_vo_blockonly (bool): If False (default), return the full unitary matrix U of shape (n_o + n_v, n_o + n_v) constructed from the four blocks U_oo, U_ov, U_vo, and U_vv as in the cited equation; this is the typical form needed when a complete unitary update of the combined occupied+virtual basis is required. If True, return only the stacked column-blocks that contain the U_oo and U_vo blocks as a contiguous array of shape (n_o + n_v, n_o). This option exists for algorithms in GPAW that only need the occupied-column part of the unitary (oo and vo blocks) to update occupied orbitals and avoid constructing the full (larger) matrix, yielding memory and computational savings.
    
    Returns:
        numpy.ndarray: A contiguous NumPy array containing the computed unitary matrix or its oo/vo stacked blocks. If oo_vo_blockonly is False, the returned array has shape (n_o + n_v, n_o + n_v) and dtype matching a_upp_r.dtype, representing the full unitary rotation operator that acts on the combined occupied+virtual subspace. If oo_vo_blockonly is True, the returned array has shape (n_o + n_v, n_o) and contains the stacked [U_oo; U_vo] blocks (first the n_o-by-n_o U_oo block, then the n_v-by-n_o U_vo block). The output is guaranteed to be returned as a contiguous array (numpy.ascontiguousarray) for efficient subsequent linear-algebra operations.
    
    Behavior, defaults, and failure modes:
        This function implements the matrix functions via eigendecomposition of p_nn = a_upp_r @ a_upp_r.T.conj(). Eigenvalues that are numerically negative or extremely small (real part < 1.0e-13) are clipped to 1.0e-13 before taking square roots to avoid division by zero and to improve numerical stability; this is necessary because p_nn should be positive semidefinite in exact arithmetic but may acquire tiny negative components due to floating-point roundoff. The function calls helper routines (matrix_function) to evaluate cosine, sinc-like, and related scalar functions on the eigenvalues and reconstructs the corresponding matrix functions using the eigenvectors. If a_upp_r is all zeros (within numpy.allclose), the function returns either the identity matrix of size n_o+n_v (oo_vo_blockonly=False) or the stacked [I_n_o; 0_n_vxn_o] block (oo_vo_blockonly=True) without performing eigendecomposition. If the input array has incompatible dimensions for matrix multiplication or is not a NumPy ndarray, NumPy operations (such as numpy.linalg.eigh) will raise the usual exceptions (for example, ValueError or LinAlgError); these exceptions are not intercepted by this routine. The default behavior is oo_vo_blockonly=False. The function has no other side effects beyond allocating and returning the computed array.
    """
    from gpaw.directmin.tools import expm_ed_unit_inv
    return expm_ed_unit_inv(a_upp_r, oo_vo_blockonly)


################################################################################
# Source: gpaw.directmin.lcao.etdm_helper_lcao.rotate_subspace
# File: gpaw/directmin/lcao/etdm_helper_lcao.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_directmin_lcao_etdm_helper_lcao_rotate_subspace(
    h_mm: numpy.ndarray,
    c_nm: numpy.ndarray
):
    """rotate_subspace selects canonical orbitals for an LCAO subspace by forming the projected (n-by-n) Hamiltonian in the subspace, diagonalizing it, and rotating the input coefficient matrix into the basis of its eigenvectors. This routine is used in the gpaw.directmin.lcao.etdm_helper_lcao workflow to obtain energy-diagonal (canonical) orbitals and their eigenvalues when performing direct minimization or subspace rotations in the LCAO (linear combination of atomic orbitals) representation within GPAW's DFT calculations.
    
    Args:
        h_mm (numpy.ndarray): The subspace Hamiltonian matrix with shape (m, m). This is the Hamiltonian represented in the m-dimensional subspace (indices m,m) used by the etdm LCAO helper; it must be a square numpy.ndarray (Hermitian in exact arithmetic). Practically, h_mm provides the Hamiltonian matrix elements for the subspace whose orbitals are to be canonicalized. The function uses h_mm to form the projected Hamiltonian l_nn = c_nm @ h_mm @ c_nm.conj().T; if h_mm is not square or not compatible with c_nm, a ValueError will be raised by NumPy during the matrix multiplications.
        c_nm (numpy.ndarray): The coefficient matrix with shape (n, m). Rows are indexed by n (basis-function or grid degrees of freedom used by GPAW) and columns by the m subspace vectors. In the LCAO/direct-minimization context, c_nm contains the current subspace vectors expressed in the underlying n-dimensional basis. This matrix may be real or complex; the routine forms the projected Hamiltonian in the n-dimensional subspace via c_nm @ h_mm @ c_nm.conj().T and then diagonalizes that projected Hamiltonian.
    
    Returns:
        tuple: A two-item tuple (rotated_c_nm, eps).
            rotated_c_nm (numpy.ndarray): A numpy.ndarray with the same shape as c_nm (n, m). It is equal to w.T.conj() @ c_nm where w contains the eigenvectors of the projected Hamiltonian l_nn. rotated_c_nm are the input subspace coefficients rotated into the canonical (energy-diagonal) basis. In GPAW's LCAO/direct-minimization workflow this represents the canonical orbitals expressed in the same underlying basis as c_nm and is ready for use where energy-ordered orbitals or canonical representations are required.
            eps (numpy.ndarray): A one-dimensional numpy.ndarray of length n containing the real eigenvalues of the projected Hamiltonian l_nn (orbital energies in the projected subspace). These eigenvalues are returned in ascending order as produced by numpy.linalg.eigh and correspond to the columns/rows of w used to construct rotated_c_nm.
    
    Behavior and side effects:
        The function computes l_nn = c_nm @ h_mm @ c_nm.conj().T, diagonalizes l_nn with numpy.linalg.eigh to obtain eigenvalues (eps) and eigenvectors (w), and returns the rotated coefficient matrix w.T.conj() @ c_nm together with eps. There are no side effects (no in-place modification of inputs). The routine always performs the diagonalization; it does not attempt to detect or short-circuit when l_nn is already diagonal (the code contains a comment noting such a possible optimization but it is not implemented). The eigenvalues eps are real when l_nn is Hermitian (as expected physically); small numerical non-Hermiticity due to floating-point errors may still be handled by eigh but can affect results at the level of numerical precision.
    
    Failure modes and exceptions:
        If input arrays have incompatible shapes for the required matrix multiplications, NumPy will raise ValueError. If the diagonalization fails, numpy.linalg.LinAlgError may be raised. Inputs must be two-dimensional numpy.ndarray objects; passing other types may lead to TypeError or other NumPy exceptions. The routine does not validate Hermiticity of l_nn before calling eigh, so non-Hermitian inputs may produce spurious results.
    
    Domain significance:
        In GPAW's LCAO-based direct-minimization and subspace-rotation procedures, canonical orbitals (energy-diagonal orbitals) are often required for occupation assignments, stability analysis, or as a basis for further minimization. This function implements that canonicalization step by projecting the subspace Hamiltonian into the n-dimensional representation, diagonalizing it, and rotating the coefficient matrix accordingly, providing both the rotated orbitals and their orbital energies for downstream DFT operations.
    """
    from gpaw.directmin.lcao.etdm_helper_lcao import rotate_subspace
    return rotate_subspace(h_mm, c_nm)


################################################################################
# Source: gpaw.directmin.etdm_lcao.check_indices
# File: gpaw/directmin/etdm_lcao.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_directmin_etdm_lcao_check_indices(
    ind1: int,
    ind2: int,
    n_dim: int,
    n_occ: int,
    representation: str
):
    """gpaw.directmin.etdm_lcao.check_indices validates a pair of user-supplied integer indices that specify a constraint between electronic states used by the ETDM (energy-targeted direct minimization) LCAO (linear combination of atomic orbitals) routines in GPAW. The function ensures the indices are distinct and lie in the ranges required by the chosen representation so that downstream direct-minimization code does not attempt illegal array or orbital accesses.
    
    Args:
        ind1 (int): First index of the constraint pair. In practice this is typically the index of an occupied state or the first state participating in a constraint/rotation. This argument must be an integer index and is checked for range depending on the chosen representation. If ind1 equals ind2 an AssertionError is raised to prevent degenerate constraints.
        ind2 (int): Second index of the constraint pair. In practice this is typically the index of the second state participating in a constraint/rotation and may refer to an occupied or unoccupied state depending on representation. This argument must be an integer index and is checked for range depending on the chosen representation.
        n_dim (int): Total dimension of the single-particle state space (the number of states, basis functions, or columns in the coefficient matrix used by the LCAO direct-minimization routines). Used as the upper exclusive bound for valid indices in the 'full' and 'sparse' representations and as the upper exclusive bound for ind2 in the 'u-invar' representation.
        n_occ (int): Number of occupied states (occupied orbitals) in the current electronic configuration. Used to partition the index range into occupied (0 .. n_occ-1) and unoccupied (n_occ .. n_dim-1) subspaces for representations that require that distinction.
        representation (str): Representation mode that determines which range checks are applied. The function contains explicit branches for the values 'full', 'sparse', and 'u-invar':
            - 'full': both ind1 and ind2 are required to satisfy 0 <= index < n_dim.
            - 'sparse': ind1 is required to satisfy 0 <= ind1 < n_occ (occupied), and ind2 is required to satisfy 0 <= ind2 < n_dim.
            - 'u-invar': ind1 is required to satisfy 0 <= ind1 < n_occ (occupied) and ind2 is required to satisfy n_occ <= ind2 < n_dim (strictly unoccupied).
          If a different string is supplied, no additional range checks beyond the uniqueness check (ind1 != ind2) are performed by this function.
    
    Returns:
        None: This function does not return a value. It performs validation by asserting conditions; on success it has no side effects and simply returns None. On failure it raises AssertionError with the message 'Check constraints.' to indicate that the supplied indices do not satisfy the constraints required by the chosen representation. This guard prevents downstream index-out-of-range errors or ill-defined occupied/unoccupied constraints in the ETDM LCAO direct-minimization code.
    """
    from gpaw.directmin.etdm_lcao import check_indices
    return check_indices(ind1, ind2, n_dim, n_occ, representation)


################################################################################
# Source: gpaw.directmin.tools.loewdin_lcao
# File: gpaw/directmin/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_directmin_tools_loewdin_lcao(C_nM: numpy.ndarray, S_MM: numpy.ndarray):
    """Loewdin-based orthonormalization of LCAO coefficients used in GPAW direct-minimization tools.
    
    This function implements the symmetric (Loewdin) orthonormalization for linear-combination-of-atomic-orbitals
    (LCAO) coefficient matrices that appear in GPAW's direct minimization and LCAO modes. Given a set of
    LCAO coefficients C_nM and the basis-function overlap matrix S_MM, it constructs a unitary-like transformation
    that maps the input coefficients to a new set of coefficients that are orthonormal with respect to S_MM.
    In practical DFT/LCAO workflows this is used to ensure that the resulting orbitals satisfy
    C_new.conj() @ S_MM @ C_new.T = I (the Kronecker delta), which is required by many numerical algorithms
    inside GPAW for stable and correct eigenvalue/energy computations.
    
    The routine follows these steps (as implemented in the source):
    1. Form the Hermitian matrix C^† S C = C_nM.conj() @ S_MM @ C_nM.T with shape (n, n), where n is the number
       of rows in C_nM (typically number of states/orbitals).
    2. Diagonalize this Hermitian matrix to obtain eigenvalues ev and eigenvectors U (called S_overlapp in code).
    3. Build the inverse square-root in the eigenbasis: U (1/sqrt(ev)) U^†.
    4. Apply the resulting transformation to the input coefficients: C_new = (U (1/sqrt(ev)) U^†).T @ C_nM,
       returning an array with the same shape as C_nM and with orthonormality C_new.conj() @ S_MM @ C_new.T = I.
    
    Args:
        C_nM (numpy.ndarray): LCAO coefficient matrix with shape (n, M). Rows (index n) typically label states
            or molecular orbitals and columns (index M) label basis functions in the atomic-orbital basis used by GPAW.
            These are the coefficients to be orthonormalized so that the transformed coefficients represent the same
            subspace but become orthonormal with respect to S_MM.
        S_MM (numpy.ndarray): Overlap matrix between basis functions with shape (M, M). This is the standard
            overlap matrix S used in LCAO representations in GPAW and must correspond to the basis in which C_nM is expressed.
            S_MM is expected to be Hermitian (S_MM.conj().T == S_MM) as typical overlap matrices in quantum-chemical/DFT
            calculations are Hermitian.
    
    Returns:
        numpy.ndarray: Orthonormalized coefficient matrix with the same shape as C_nM (n, M). The returned array is a new
        NumPy array (no in-place modification of the input C_nM occurs) and satisfies the orthonormality condition
        C_new.conj() @ S_MM @ C_new.T = I_n (the n-by-n identity), up to numerical precision.
    
    Behavior, side effects and failure modes:
        - The function is pure (no side effects): it does not modify C_nM or S_MM in place; it returns a new array.
        - Numerical requirement: the intermediate eigenvalues ev obtained from the diagonalization of C_nM.conj() @ S_MM @ C_nM.T
          must be positive and non-zero for the inverse square-root 1/sqrt(ev) to be finite and well-defined. If any eigenvalue
          is zero or negative, computing 1/sqrt(ev) will produce infinities, NaNs, or complex infinities, and the returned result
          will be numerically invalid for orthonormalization.
        - If the overlap matrix S_MM is not Hermitian or if the eigen-decomposition does not converge, numpy.linalg.eigh may raise
          a numpy.linalg.LinAlgError. Users should ensure S_MM is the correct Hermitian overlap matrix for the basis and that
          C_nM spans a non-singular subspace with respect to S_MM.
        - For numerically small positive eigenvalues, it may be necessary (outside this function) to apply regularization or
          thresholding to avoid amplification of numerical noise; the implementation here does not perform such regularization.
        - The function preserves data types consistent with NumPy arithmetic; complex-conjugation and Hermitian transposes are used
          as appropriate for complex-valued LCAO coefficients and overlap matrices.
    
    Practical significance in GPAW:
        - Use this function when you need to convert a set of LCAO coefficients to an orthonormal representation before
          performing subspace diagonalization, energy minimization, or other linear-algebra operations in GPAW's LCAO/direct-min
          routines. Ensuring orthonormality with respect to the overlap matrix S_MM is essential for correct DFT results
          when working in a non-orthogonal atomic-orbital basis.
    """
    from gpaw.directmin.tools import loewdin_lcao
    return loewdin_lcao(C_nM, S_MM)


################################################################################
# Source: gpaw.directmin.tools.minimum_cubic_interpol
# File: gpaw/directmin/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_directmin_tools_minimum_cubic_interpol(
    x_0: float,
    x_1: float,
    f_0: float,
    f_1: float,
    df_0: float,
    df_1: float
):
    """gpaw.directmin.tools.minimum_cubic_interpol computes the position of the minimum of a cubic polynomial
    that interpolates function values and derivatives at the two endpoints of an interval [x_0, x_1].
    
    This function is used in GPAW's direct minimization and line-search utilities to suggest a scalar step length along a
    search direction by fitting a cubic to the objective (for example, DFT total energy) and its directional derivatives
    at the interval boundaries. The inputs x_0 and x_1 define the interval in the independent variable (e.g., a
    line-search parameter or displacement along a geometry-optimization direction). The values f_0 and f_1 are the
    function values at those endpoints (for example, energies in ASE/GPAW units) and df_0 and df_1 are the corresponding
    first derivatives with respect to x (for example, directional derivatives of the energy). All inputs are floats and
    the function returns a float x_min that is the location of the cubic interpolant's minimum constrained to the closed
    interval [min(x_0, x_1), max(x_0, x_1)].
    
    The routine swaps endpoints internally if x_0 > x_1 so the order of the inputs does not matter. It constructs the
    unique cubic f(x) = a x^3 + b x^2 + c x + d in the local coordinate measured from x_0 using the standard formulae
    derived from the two function values and two derivatives. It then inspects the cubic's stationary points by forming
    the discriminant D = b^2 - 3 a c. If D < 0 there are no real stationary points for the derivative inside the real
    line and the function returns the endpoint (x_0 or x_1) with the smaller provided function value. If D >= 0 the
    routine computes one candidate stationary point r0 = (-b + sqrt(D)) / (3 a) + x_0 (the code uses the + root) and
    accepts r0 as the minimum if r0 lies strictly inside the open interval (x_0, x_1) and the interpolated cubic value at
    r0 is smaller than both endpoint values; otherwise it returns the endpoint with smaller f. The cubic is evaluated
    with a helper that expects the local coordinate (r0 - x_0). The function never modifies external state.
    
    Args:
        x_0 (float): Left endpoint of the interval in the independent variable. This defines one boundary of the interval
            used to build the cubic interpolant. If x_0 > x_1 the function will swap the two endpoints internally so the
            computation proceeds on [min(x_0, x_1), max(x_0, x_1)].
        x_1 (float): Right endpoint of the interval in the independent variable. Together with x_0, it sets the interval
            over which the cubic is constructed and searched for a minimum. Units and meaning should match those of x_0
            (for example, a line-search displacement or step length).
        f_0 (float): Function value at x_0 (for example, total energy at the left endpoint when performing a line search).
            This value is used, together with f_1 and the derivatives, to determine the cubic coefficients and to compare
            endpoint vs interior values when selecting the minimizing point.
        f_1 (float): Function value at x_1 (for example, total energy at the right endpoint). Used symmetrically with
            f_0 in the cubic construction and endpoint comparisons.
        df_0 (float): First derivative of the function with respect to x evaluated at x_0 (for example, directional
            derivative or slope at the left endpoint). This derivative is used to determine the cubic coefficients and the
            location of stationary points.
        df_1 (float): First derivative of the function with respect to x evaluated at x_1 (for example, directional
            derivative or slope at the right endpoint). This derivative is used together with df_0 to determine the cubic
            coefficients and the discriminant that controls whether an interior stationary point exists.
    
    Returns:
        float: x_min, the location of the minimum of the cubic interpolant constrained to the closed interval
        [min(x_0, x_1), max(x_0, x_1)]. If the cubic has a valid interior minimum that also yields a lower interpolated
        function value than both endpoints, that interior point is returned. Otherwise, the endpoint with the smaller
        provided function value (f_0 or f_1) is returned. The returned value has the same units and meaning as the inputs
        x_0 and x_1 and is suitable for use as a proposed step length in GPAW/ASE line searches or direct minimization.
    
    Failure modes and numerical notes:
        The implementation performs a division by 3.0 * a when computing a candidate stationary point; if the computed
        cubic coefficient a is zero (within floating-point rounding) this leads to a division-by-zero error. The code does
        not explicitly guard against a == 0, so callers should ensure inputs are non-pathological or catch ZeroDivisionError.
        For discriminant values D very close to zero, floating-point rounding may influence whether an interior point is
        found; in that borderline case the routine falls back to endpoint selection behavior described above. Inputs that
        are NaN or infinite will propagate and may produce NaN or raise exceptions from numpy.sqrt. The function has no
        side effects and does not modify any external objects.
    """
    from gpaw.directmin.tools import minimum_cubic_interpol
    return minimum_cubic_interpol(x_0, x_1, f_0, f_1, df_0, df_1)


################################################################################
# Source: gpaw.doctools.aamath.block
# File: gpaw/doctools/aamath.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for block because the docstring has no description for the argument 'lines'
################################################################################

def gpaw_doctools_aamath_block(lines: list[str]):
    """Find superscript/subscript blocks in a columnar ASCII-art math fragment used by gpaw.doctools.aamath.
    
    This function scans a multi-line ASCII representation of a math expression (provided as a list of equally long strings) column by column to detect vertically stacked regions that represent superscripts or subscripts. It is used by the doctools.aamath subsystem of GPAW to locate and extract these stacked blocks so they can be converted (via cut() and parse()) into TeX-like math strings for inclusion in generated documentation or math rendering. The function does not modify the input list; it only reads characters to determine block boundaries and then calls the local cut() and parse() helpers to produce the returned fragments.
    
    Args:
        lines (list[str]): A list of strings, each string representing one horizontal line of an ASCII-art math fragment. All strings are expected to have the same length; the function iterates over indices 0..len(lines[0]) - 1 and indexes each line at those positions. Columns consisting entirely of the literal space character ' ' are treated as separators; any other character is treated as part of a block. If lines is empty the function returns an empty dict. Passing strings of differing lengths will raise IndexError when the function attempts to index beyond the end of a shorter string. Tabs or other whitespace characters are not treated as equivalent to the space character and may cause blocks to be misdetected if present.
    
    Returns:
        dict[int, str]: A mapping from integer baseline column indices to parsed block strings. Each key is the zero-based column index immediately to the left of a detected superscript/subscript block (computed internally as the start-column minus one). Each value is the result of parse(cut(lines, ...)) for that block (for example '\\mathbf{k}' or '2' in the module's ASCII-to-TeX conversion), suitable for insertion into a TeX-like math expression. If no blocks are found the function returns an empty dict.
    
    Behavior and failure modes:
        The function scans only up to the length of the first string in lines. If a detected block reaches the end of the line, the function calls cut(lines, i1) without an explicit end column to extract the trailing block. There are no external side effects other than calling cut() and parse(); the input list is not mutated. Typical failure modes include IndexError when input strings are not of equal length and TypeError when lines is not a list of strings. The detection logic treats only the literal space character as empty; other whitespace characters or control characters may lead to incorrect detection.
    """
    from gpaw.doctools.aamath import block
    return block(lines)


################################################################################
# Source: gpaw.directmin.tools.update_constraints_kpt
# File: gpaw/directmin/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_directmin_tools_update_constraints_kpt(constraints: list, ind: list):
    """gpaw.directmin.tools.update_constraints_kpt updates constraint indices for a single k-point to match a new indexation (for example, after sorting orbitals or reordering wavefunctions). This function is used in the GPAW direct minimization workflow to ensure that constraint references (which select orbitals or states at a given k-point) remain valid after the underlying index order has changed; failing to update these indices would cause constraints to refer to the wrong orbitals and lead to incorrect constrained minimization behavior.
    
    Args:
        constraints (list): The list of constraints for one K-point. In practice this is a sequence (typically a list of lists) containing integer indices that reference orbitals or states before reindexing. The function treats each element constraints[i][k] as an index that must be mapped into the new ordering given by ind. The original constraints object is not modified; a deep copy is created and returned.
        ind (list): List containing the new indexation information: a sequence whose elements enumerate the old indices in the new order. Each entry of ind is expected to be equal to some element present in constraints; the function finds the new position of each old index by calling ind.index(old_index). This list defines how old indices map to new indices and is typically produced when orbitals or states are sorted or redistributed for a specific k-point in GPAW.
    
    Behavior and side effects:
        The function creates a deep copy of constraints and then replaces every constraint index constraints[i][k] with its new index position in ind, i.e., new[i][k] = ind.index(constraints[i][k]). The original constraints object passed as the constraints argument is left unchanged.
        The mapping uses list.index, which performs a linear search for each mapping; for large constraint sets or index lists this can become costly. If an element referenced in constraints is not present in ind, list.index raises a ValueError; this is not caught inside the function and will propagate to the caller. Passing non-list objects for constraints or ind may raise TypeError or produce undefined behavior.
        This function operates for a single K-point's constraint set; it does not modify constraints for other k-points or perform any parallel communication. It is intended to be used as part of GPAW's internal direct-minimization tooling when per-k-point orbital indexations change.
    
    Returns:
        list: A deep-copied list with the same nested structure as constraints but with each original index replaced by its new index position according to ind. The returned structure can be used directly by GPAW routines that apply constraints to the reindexed orbitals for the given k-point.
    """
    from gpaw.directmin.tools import update_constraints_kpt
    return update_constraints_kpt(constraints, ind)


################################################################################
# Source: gpaw.doctools.aamath.autodoc_process_docstring
# File: gpaw/doctools/aamath.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_doctools_aamath_autodoc_process_docstring(lines: list):
    """gpaw.doctools.aamath.autodoc_process_docstring processes a list of documentation/source lines in-place to detect custom aamath code blocks annotated with a trailing ':::' marker and replace those blocks with Sphinx-compatible math directives. This hook-function is intended for use when building GPAW project documentation with Sphinx: it finds aamath blocks, converts their contents to LaTeX using the local parse(...) function, and inserts the resulting ".. math:: <latex>" directive into the provided lines so that Sphinx will render the math in the generated documentation.
    
    Args:
        lines (list): A mutable sequence of strings representing the lines of a docstring or Sphinx source file. Each element should be a single line (without a terminating newline character). The function expects that one or more lines may end with the literal sequence ':::' to mark the start of an aamath block. The list is modified in-place: detected block ranges are removed and replaced by one or more lines containing the Sphinx math directive and, when applicable, the preserved portion of the original start line. If elements of this list are not strings, methods like str.endswith will raise exceptions; callers should provide a list of strings.
    
    Behavior and practical significance:
        The function implements the following exact algorithm, used by GPAW's documentation generation to convert aamath annotations into LaTeX for Sphinx:
        - It scans the supplied lines from start to end to find lines where line.endswith(':::') is true. Each such line is treated as the start of a potential aamath block.
        - For each start index i1 found, it searches forward beginning at index i1 + 2 for the first empty line (a line that evaluates to False). The empty line (if found) marks the exclusive end index i2 of the block. If no empty line is found, the block is assumed to extend to the end of the provided lines; the code adjusts i2 accordingly so the exclusive end index covers the remainder of the list.
        - It collects all (start, end) index pairs for the detected blocks and then processes these blocks in reversed order (from the end of the list toward the start) to avoid invalidating earlier indices when replacing slices.
        - For each block with indices (i1, i2), it calls parse(lines[i1 + 1:i2]). The parse(...) function (expected to be available in the same module) converts the block content lines into a LaTeX string. The function then creates a single replacement line of the form '.. math:: {latex}' where {latex} is the string returned by parse.
        - Replacement semantics:
            - If the original start line, after removing surrounding whitespace, is exactly ':::', the function replaces the entire slice lines[i1:i2] with a single line containing the math directive '.. math:: {latex}'.
            - Otherwise, the function replaces the slice lines[i1:i2] with three items: the original start line with its last two characters removed (that is, lines[i1][:-2]), then an empty string (a blank line), and then the math directive '.. math:: {latex}'. Note: the code intentionally removes the final two characters of the original start line rather than all three trailing colons; callers should therefore expect the preserved start line to retain one trailing ':' character in this branch.
        - Using reversed processing ensures that replacements do not shift indices for blocks that occur earlier in the list.
    
    Side effects:
        This function modifies the provided lines list in-place. It does not create and return a new list. The typical use in GPAW documentation building is to pass the docstring lines obtained from Sphinx/autodoc into this function so that aamath blocks are converted before Sphinx renders the documentation.
    
    Failure modes and errors:
        - If the parse(...) function raises an exception while converting the block lines to LaTeX, that exception propagates to the caller.
        - If the provided lines argument is not a list of strings, attribute lookups such as line.endswith(':::') may raise AttributeError or TypeError; callers must supply the expected type.
        - The function does not validate the semantics of the LaTeX string returned by parse(...); malformed LaTeX will be passed through to the '.. math::' directive and may cause Sphinx to fail or render incorrectly.
        - Because the function operates in-place and has no internal synchronization, concurrent modifications to the same list from multiple threads or processes will result in undefined behavior.
    
    Returns:
        None: The function returns None and relies on in-place modification of the supplied lines list as its effect. After the call, lines will have aamath blocks replaced by appropriate '.. math::' directives ready for Sphinx to process.
    """
    from gpaw.doctools.aamath import autodoc_process_docstring
    return autodoc_process_docstring(lines)


################################################################################
# Source: gpaw.dos.gaussian_dos
# File: gpaw/dos.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_dos_gaussian_dos(
    eig_kn: numpy.ndarray,
    weight_kn: numpy.ndarray,
    weight_k: numpy.ndarray,
    energies: numpy.ndarray,
    width: float
):
    """gpaw.dos.gaussian_dos computes a one-dimensional density of states (DOS) on a supplied energy grid by broadening discrete Kohn–Sham eigenvalues with normalized Gaussian functions and summing their weighted contributions across k-points and bands. This function is used in the GPAW DFT workflow to transform discrete eigenvalue spectra (per k-point and band) into a smooth DOS suitable for plotting, integration, and analysis (for example to locate peaks or integrate states around the Fermi level).
    
    Args:
        eig_kn (numpy.ndarray): Per-k-point eigenvalues. This is an array-like container indexed by k-point that yields, for each k-point, a one-dimensional sequence of eigenvalues (energies) for the bands at that k-point. In GPAW usage, these energies are typically given in the same energy units as the rest of the calculation (commonly electronvolts, eV). The function iterates over eig_kn to obtain each k-point's band eigenvalues and centers the Gaussians at these values.
        weight_kn (numpy.ndarray): Per-band weights for each k-point or None. When provided, weight_kn must align with eig_kn such that for each k-point the corresponding entry gives a one-dimensional sequence of per-band multiplicative weights (for example, band occupations or projection weights). These per-band weights are multiplied with the k-point weight and the Gaussian for each eigenvalue to scale that eigenvalue's contribution to the DOS. If weight_kn is None, the implementation treats all bands at each k-point as having unit band-weight (i.e., only the k-point weight is used).
        weight_k (numpy.ndarray): Per-k-point weights. A one-dimensional array whose length matches the number of k-points represented in eig_kn. Each k-point weight scales the total contribution from that k-point's bands. In GPAW workflows, these are typically the k-point sampling weights used to approximate integrals over the Brillouin zone. The function multiplies these weights with per-band weights (if provided) and with the normalized Gaussian contributions.
        energies (numpy.ndarray): Energy grid at which to evaluate the DOS. This one-dimensional numpy.ndarray defines the target energy points (for example a uniform array spanning an energy window) where the DOS is computed. The returned DOS array has the same shape as energies and gives the summed, broadened density at each energy grid point.
        width (float): Gaussian broadening parameter. The function uses the Gaussian form exp(-((energies - e)/width)**2) for each eigenvalue center e and divides the accumulated sum by (sqrt(pi) * width) to normalize the integrated area of a single broadened state to unity (before multiplication by the provided weights). width must be provided in the same energy units as energies (for GPAW/ASE typical units are eV). Smaller values of width produce narrower, more discrete-looking peaks; larger values produce smoother, more blurred DOS. A non-positive width will produce mathematically invalid results; the implementation does not explicitly check for width <= 0, so the caller should ensure width > 0.
    
    Behavior and side effects:
        The function constructs a DOS array initialized to zeros with the same shape as energies and accumulates contributions from each eigenvalue by adding weight_k * weight_kn * normalized Gaussian(energies - e) (or weight_k * normalized Gaussian if weight_kn is None). The Gaussian normalization factor of 1/(sqrt(pi) * width) ensures that the integral over energy of a single Gaussian equals 1 (so that the integrated contribution of a state equals the product of its weights). The function does not modify its input arrays; it returns a newly allocated one-dimensional array. The algorithm loops in Python over k-points and bands (O(n_kpoints * n_bands * n_energies) operations), so for very large systems or very fine energy grids this may be computationally expensive and a caller may prefer a vectorized or parallelized alternative.
    
    Failure modes and caller responsibilities:
        The implementation uses Python zip to iterate over eig_kn, weight_k, and weight_kn (if provided). If the lengths of these arrays/iterables do not match, zip will truncate to the shortest iterable and some k-point contributions will be silently ignored; therefore the caller must ensure consistent shapes and lengths. Similarly, if entries inside eig_kn and weight_kn have mismatched lengths per k-point, zip over bands will truncate, again leading to missing contributions. The function does not explicitly validate array dimensions or types and will raise standard NumPy errors if operations on the provided numpy.ndarray objects are incompatible. For robust use, ensure energies is one-dimensional, weight_k length equals the number of k-points in eig_kn, and, if provided, weight_kn mirrors the per-k-point band structure of eig_kn. Extremely small width values can produce very large exponent arguments or result in numerical underflow/overflow in exp; choose width appropriate to the energy resolution and floating-point range.
    
    Returns:
        : One-dimensional numpy.ndarray with the same shape as energies giving the computed DOS on that energy grid. The values represent the sum of normalized Gaussian-broadened contributions from all eigenvalues, scaled by k-point and (optional) band weights; when energies are expressed in eV (GPAW/ASE convention), the DOS values have units of states per eV (so that integrating the returned DOS over energy yields the total number of weighted states contributed, consistent with the provided weights).
    """
    from gpaw.dos import gaussian_dos
    return gaussian_dos(eig_kn, weight_kn, weight_k, energies, width)


################################################################################
# Source: gpaw.eigensolvers.eigensolver.reshape
# File: gpaw/eigensolvers/eigensolver.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_eigensolvers_eigensolver_reshape(a_x: numpy.ndarray, shape: tuple):
    """gpaw.eigensolvers.eigensolver.reshape: Construct and return a numpy.ndarray of the requested shape by taking elements from a flattened buffer array.
    
    Args:
        a_x (numpy.ndarray): 1-D or N-D buffer array containing numeric data used in GPAW eigensolver routines (for example flattened wavefunction coefficients, densities, or intermediate vectors). The function first flattens this buffer using numpy.ravel() and then uses the first numpy.prod(shape) elements to form the output. This parameter provides the source data from which a shaped view or copy is produced; it is not modified by the function itself, but the returned array may share memory with a_x so modifying the return value can affect a_x if a view is returned.
        shape (tuple): A tuple of integers specifying the desired output shape (for example (n, m) for a 2-D array). The product of the entries in this tuple, computed with numpy.prod(shape), determines how many elements are taken from the flattened a_x buffer to populate the returned array.
    
    Returns:
        numpy.ndarray: An ndarray with shape equal to the supplied shape tuple containing the first numpy.prod(shape) elements of a_x.ravel(). The returned array contains the requested data arranged with the standard C-like row-major ordering implied by numpy.reshape on the sliced flattened buffer. Where possible numpy will return a view into the original buffer; otherwise a copy will be returned.
    
    Behavior, side effects, defaults, and failure modes:
        The function flattens a_x with numpy.ravel(), slices the flattened array to the first numpy.prod(shape) elements, and reshapes that slice to the requested shape. If the flattened buffer contains more elements than required, the extra elements are discarded (truncated). If the flattened buffer contains fewer elements than required (i.e., a_x.ravel().size < numpy.prod(shape)), numpy.reshape will raise a ValueError indicating that the array cannot be reshaped to the requested shape. No in-place modification of a_x is performed by this function itself; however, because the return value may be a view that shares memory with a_x, modifying the returned array may modify a_x. The function does not validate element types beyond relying on numpy.ravel() and numpy.reshape; callers should ensure a_x is a numpy.ndarray and shape is a tuple of integers appropriate for the GPAW eigensolver context.
    """
    from gpaw.eigensolvers.eigensolver import reshape
    return reshape(a_x, shape)


################################################################################
# Source: gpaw.ffbt.rescaled_bessel_limit
# File: gpaw/ffbt.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_ffbt_rescaled_bessel_limit(l: int):
    """gpaw.ffbt.rescaled_bessel_limit
    Get the x -> 0 limit of a rescaled spherical Bessel function j_l(x)/x^l used in radial function handling.
    
    Calculates the closed-form value of the limit
        lim_{x->0} j_l(x) / x^l = 2^l * l! / (2*l + 1)!
    for a given angular momentum quantum number l. In the GPAW DFT codebase this quantity is useful when working with spherical Bessel functions that appear in radial integrals, projector-augmented wave (PAW) components, and plane-wave / atom-centered basis treatments described in the project README: it provides the finite small-argument normalization constant that prevents singular behavior and aids numerical stability when evaluating radial basis functions or expansions near the origin.
    
    Args:
        l (int): Non-negative integer angular momentum quantum number l that indexes the spherical Bessel function j_l(x). In GPAW this corresponds to the usual orbital/partial-wave index used in PAW and spherical-harmonic decompositions. The function expects l to be an integer; supplying negative values or non-integers will result in an exception propagated from the underlying factorial routine (for example, a ValueError raised by math.factorial or an equivalent implementation).
    
    Returns:
        float: The floating-point value of 2**l * fac(l) / fac(2*l + 1), i.e. the exact small-x limit of j_l(x)/x^l. This value is returned as a Python float because the computation uses floating point division. For large l the factorials grow rapidly and the result may underflow to 0.0 or lose precision due to floating-point range/rounding; no internal arbitrary-precision arithmetic is performed by this function.
    
    Behavior and side effects:
        This function is pure (no side effects) and deterministic: it computes a closed-form constant from the integer input l and returns it. It does not modify global state or write files. Errors raised originate from invalid inputs to the underlying factorial routine (e.g. negative l or non-integer types), or from standard Python exceptions if incompatible types are provided. The function is intended to be used where the analytic small-argument limit of spherical Bessel functions is required for stable evaluation of radial components in GPAW calculations.
    """
    from gpaw.ffbt import rescaled_bessel_limit
    return rescaled_bessel_limit(l)


################################################################################
# Source: gpaw.ffbt.generate_bessel_coefficients
# File: gpaw/ffbt.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_ffbt_generate_bessel_coefficients(lmax: int):
    """Generate spherical Bessel function expansion coefficients up to angular momentum lmax.
    
    This function computes the complex expansion coefficients c_lm used to express spherical Bessel functions in a polynomial-like expansion. The implementation follows the recurrence relation for spherical Bessel functions (see Marco Vanin, 2008) and uses the closed-form solution implied by that recurrence. In the context of GPAW (a DFT code using the PAW method and real-space / plane-wave representations), these coefficients are used by the gpaw.ffbt module to build Bessel-based expansions required in radial integrals, projector functions, and fast Fourier–Bessel transforms. The returned data structure is organized for direct indexing by angular momentum l and magnetic quantum number m.
    
    Args:
        lmax (int): Maximum angular momentum l to include in the expansion. The function computes coefficients for all integer l in the inclusive range 0..lmax, and for each l for all integer m in the inclusive range 0..l. The argument must be provided as a Python int. If lmax is negative the function returns an empty list (no coefficients). Supplying a non-integer value will raise a TypeError when used by the internal range() call.
    
    Returns:
        list[list[complex]]: A two-dimensional Python list c_lm where c_lm[l][m] is the complex coefficient c_{l m} for angular momentum l and order m. The outer list is indexed by l = 0..lmax, and each inner list contains m = 0..l entries in ascending m. Coefficients are computed using the closed-form expression
        c_{l m} = i^{1+m} * fac(2*l - m) / (2^{(l-m)} * fac(l-m) * fac(m)),
        which is equivalent to applying the spherical Bessel recurrence relations with the initial conditions c_00 = i, c_10 = i, c_11 = -1 described in the implementation. No external side effects occur; the function only constructs and returns the coefficient lists.
    
    Behavior and failure modes:
        The function performs O(lmax^2) arithmetic operations due to the nested loops over l and m. It relies on a factorial function (fac) for integer factorials; extremely large lmax may produce very large intermediate factorial values and lead to floating-point overflow or loss of numerical precision, depending on the factorial implementation and floating-point range. The function does not validate that fac arguments are non-negative integers beyond the natural use of range-based indices; passing a non-integer lmax will raise a TypeError when constructing the ranges. There are no modifications to global state.
    """
    from gpaw.ffbt import generate_bessel_coefficients
    return generate_bessel_coefficients(lmax)


################################################################################
# Source: gpaw.external.create_external_potential
# File: gpaw/external.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_external_create_external_potential(name: str, **kwargs):
    """Construct an external potential instance identified by name and configured
    with the provided keyword parameters.
    
    This function is part of GPAW's external potential framework and is used to
    create external potentials (for example potentials that will be added to the
    Kohn–Sham Hamiltonian or represented on real-space grids) from a registry of
    known potential factories. The registry is the module-level mapping known_potentials;
    if the registry is empty, this function calls the internal _register_known_potentials()
    to populate it before construction. The function looks up a factory or
    constructor by the string key name in known_potentials and calls it with the
    supplied keyword arguments, returning whatever object that factory produces.
    Typical usage in GPAW is to call this function when an external potential is
    described in input data (often parsed into dictionaries) and must be turned
    into a runtime object used by the calculator.
    
    Args:
        name (str): Key identifying which registered potential factory to use.
            This string must match one of the keys in the module-level known_potentials
            registry. The key selects the constructor or factory function that will
            be invoked to produce the external potential object. If the registry is
            empty when this function is called, the internal _register_known_potentials()
            function is invoked to populate known_potentials before lookup.
        kwargs (dict): Keyword arguments forwarded verbatim to the selected factory.
            These are the configuration parameters for the potential (for example,
            parameters parsed from an input dictionary such as amplitudes, positions,
            widths, or other potential-specific settings). The exact names, types and
            required/optional status of these keywords are defined by the selected
            factory. This function does not validate or transform these values beyond
            forwarding them as keyword arguments.
    
    Returns:
        object: The object returned by the factory function retrieved from known_potentials[name].
        This object represents the constructed external potential usable by GPAW. The
        concrete type and API of the returned object depend on the registered factory
        associated with name (for example, a callable potential, a grid object, or a
        potential descriptor used by the GPAW calculator).
    
    Behavior, side effects, and failure modes:
        - If the module-level registry known_potentials is empty, the function invokes
          _register_known_potentials() as a side effect to populate the registry.
        - The function performs a dictionary lookup known_potentials[name]; if name
          is not present, a KeyError is raised.
        - The selected factory is called as known_potentials[name](**kwargs). Any
          exceptions raised by the factory (for example TypeError for unexpected
          keyword arguments, ValueError for invalid parameter values, or other
          runtime errors) propagate to the caller.
        - No attempt is made here to coerce types or to supply defaults beyond what
          the factory itself implements; callers must provide the keyword parameters
          expected by the chosen factory.
        - This function does not persist the created object; it simply returns it to
          the caller who is responsible for attaching it to GPAW calculators or
          managing its lifecycle.
    """
    from gpaw.external import create_external_potential
    return create_external_potential(name, **kwargs)


################################################################################
# Source: gpaw.elph.gpts.obtain_gpts_suggestion
# File: gpaw/elph/gpts.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_elph_gpts_obtain_gpts_suggestion(
    cell_cv: numpy.ndarray,
    ecut: float,
    h: float,
    print_suggestions: bool = False
):
    """Compare plane-wave (PW) and localized-basis (LCAO) grid-point suggestions and return a conservative (tighter) grid-point setting suitable for use when two separate GPAW calculators must share the same real-space grid (for example in electron–phonon coupling workflows where PW and LCAO modes run separately but need identical gpts=(...) settings).
    
    This function is used in GPAW DFT workflows to compute and reconcile the number of real-space grid points ("gpts") required by a PW calculation with cutoff ecut and an LCAO calculation with target maximal grid spacing h, for a simulation cell described by cell_cv. It calls gpaw.elph.gpts.get_number_of_grid_points with PW(ecut) and LCAO() modes to obtain the per-axis integer grid-point counts required by the two modes, and then constructs a recommended grid Nopt_c that is (a) at least as large as the LCAO requirement and (b) the PW requirement rounded to the nearest multiple of 4 (implemented as (Npw_c/4 + 0.5).astype(int) * 4), ensuring compatibility with GPAW internals that prefer multiples of 4 for plane-wave related grids. The result is intended to be used as the gpts=... argument supplied to calculators so that separate PW and LCAO runs use identical real-space grids.
    
    Args:
        cell_cv (numpy.ndarray): Real-space cell vectors for the simulation cell used by GPAW. This should be the same array that would be passed to GPAW/ASE atoms objects (typically shape (3, 3) for a periodic cell). The array is used to compute the axiswise number of grid points for each mode; invalid shapes or non-numeric contents will cause the underlying get_number_of_grid_points call to raise an exception which is propagated to the caller.
        ecut (int or float): Plane-wave kinetic-energy cutoff (in the same energy units expected by GPAW) used when constructing the PW-mode suggestion. This value is passed to PW(ecut) and therefore may be an integer or a float as accepted by GPAW PW mode; non-positive or otherwise invalid values will cause get_number_of_grid_points or PW(...) to raise an exception that is propagated.
        h (float): Intended maximal real-space grid spacing (in the length units used by GPAW, e.g., Å) for LCAO mode. This target spacing is passed to get_number_of_grid_points with mode=LCAO() to compute the LCAO-required integer grid points per axis. Non-positive or invalid h will cause the underlying computation to raise an error.
        print_suggestions (bool): If True, the function prints human-readable guidance to standard output describing the computed PW and LCAO gpts and the recommended gpts for use in electron–phonon (elph) workflows. The printed text mirrors the messages produced in GPAW usage, including explicit formatted arrays for PW(ecut) -> gpts=..., LCAO, h=... -> gpts=..., and Recommended for elph: gpts=.... Default is False, in which case no printing occurs and the function is side-effect free except for returning the recommendation.
    
    Returns:
        numpy.ndarray: An integer numpy array of per-axis grid-point counts (the recommended gpts) to use for both PW and LCAO calculators. The returned array is computed as the elementwise maximum of the LCAO-required grid points and the PW-required grid points rounded to the nearest multiple of 4 (i.e., Nopt_c = max(Nlcao_c, rounded_to_multiple_of_4(Npw_c))). This recommendation ensures that (1) the LCAO grid spacing requirement h is satisfied and (2) the PW grid derived from ecut is represented on a real-space grid with sizes compatible with GPAW plane-wave-related conventions. If the function cannot compute the suggestion because the underlying helper functions (get_number_of_grid_points, PW, LCAO) raise errors (for example due to invalid cell_cv shape, invalid ecut or h, or missing GPAW mode constructors), those exceptions are propagated to the caller; the function performs no additional exception handling.
    """
    from gpaw.elph.gpts import obtain_gpts_suggestion
    return obtain_gpts_suggestion(cell_cv, ecut, h, print_suggestions)


################################################################################
# Source: gpaw.ffbt.ffbt
# File: gpaw/ffbt.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_ffbt_ffbt(l: int, f_g: numpy.ndarray, r_g: numpy.ndarray, k_q: numpy.ndarray):
    """gpaw.ffbt.ffbt: Fast Fourier–Bessel transform of a radial real-space function f(r) used in GPAW density-functional calculations. This routine computes the radial transform g(k) = k^{l+1} ∫_0^{rc} r dr j_l(kr) r f(r) by expanding the spherical Bessel function j_l(x) into a finite polynomial series and evaluating the resulting radial integrals using discrete Fast Fourier Transforms (FFTs). It is intended for transforming radial parts of quantities (for example radial components of wavefunctions, densities, or potentials in spherical coordinates) from a uniform real-space radial grid r_g to a uniform radial reciprocal-space grid k_q; the implementation performs l+1 FFTs on a 2Q-length grid and returns only the Q positive-frequency values corresponding to k_q.
    
    Args:
        l (int): The spherical harmonic order l >= 0 that determines which spherical Bessel function j_l(kr) appears in the integral. In GPAW/PAW context, l selects the angular momentum channel for which the radial transform is computed. The algorithm sums contributions for m = 0..l using precomputed expansion coefficients c_lm; if c_lm does not contain the requested l or m an IndexError may be raised.
        f_g (numpy.ndarray): One-dimensional array of sampled values f(r) on the real-space radial grid r_g. The array length N must match len(r_g). The code assumes f(r)=0 for r >= rc (i.e., for grid indices g >= N the integrand is zero); numpy.fft.fft zero-padding is relied upon for g >= N when the FFT length 2*Q exceeds N.
        r_g (numpy.ndarray): One-dimensional array of radial grid point positions r_g[g] for g = 0..N-1. The function assumes a uniform real-space grid starting at r_g[0] == 0.0 and with constant spacing dr = r_g[1] - r_g[0]. When the module-level debug flag is True, the function asserts r_g[0] == 0.0 and that all spacings r_g[i+1] - r_g[i] equal dr, raising AssertionError if violated. The transform interprets r_g as r = g * dr for integer g.
        k_q (numpy.ndarray): One-dimensional array of target radial reciprocal-space points k(q) for q = 0..Q-1. The function expects k_q[0] == 0.0 and a uniform spacing dk = π / (Q * dr) when debug is enabled; it also assumes Q = len(k_q) >= len(r_g) so that the reciprocal-space grid length Q is at least the number of real-space samples. The function returns transform values at exactly these k_q points (the Q positive-frequency points). If the debug flag is True and the k_q grid does not satisfy the asserted spacing or ordering, an AssertionError will be raised.
    
    Returns:
        numpy.ndarray: A one-dimensional numpy array g_q of length Q containing the computed real-valued radial transform g(k) evaluated at the supplied k_q points. Each element g_q[q] is computed as the real part of the corresponding positive-frequency components of a length-2Q FFT applied to the integrand terms, summed over m = 0..l with factors c_lm[l][m] * r^{m+1} * f(r) and multiplied by k_q**m and the radial spacing dr. No inplace modification of the input arrays is performed; the function allocates intermediate arrays for the FFTs. Side effects are limited to memory allocation and use of numpy.fft.fft. If the module-level debug flag is True and the input grids are non-uniform or inconsistent (for example Q < len(r_g) or k_q spacing inconsistent with dk), the function will raise AssertionError. An IndexError can occur if the global coefficient table c_lm does not contain entries for the requested l and m. The computational cost scales as O((l+1) * 2*Q * log(2*Q)) due to performing l+1 FFTs of length 2Q.
    """
    from gpaw.ffbt import ffbt
    return ffbt(l, f_g, r_g, k_q)


################################################################################
# Source: gpaw.gaunt.gaunt
# File: gpaw/gaunt.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for gaunt because the docstring has no description for the argument 'lmax'
################################################################################

def gpaw_gaunt_gaunt(lmax: int = 2):
    """Gaunt coefficients for products of three spherical harmonics used in GPAW's
    angular integrals and PAW projector coupling.
    
    Args:
        lmax (int): Highest single-particle angular momentum quantum number l
            considered when constructing Gaunt coefficients. lmax defines the
            sizes of the returned 3D array by Lmax = (lmax + 1)**2 and
            L2max = (2 * lmax + 1)**2, which correspond to the number of
            combined (l,m) basis functions for the single- and double-range
            spherical-harmonic indices used in GPAW. Typical use in GPAW: lmax
            = 2 (d-like functions) which is the default. The value must be an
            integer (the function is annotated with int) and is intended to be
            non-negative; negative or non-integer values are not supported and
            will lead to incorrect sizes or runtime errors (for example a
            TypeError from range() or an incorrect array shape). Increasing lmax
            increases both CPU time and memory usage significantly because the
            function constructs a dense 3D array with dimensions determined by
            lmax.
    
    Returns:
        Array3D: A NumPy array G_LLL with dtype float and shape
            (Lmax, L2max, L2max) where Lmax = (lmax + 1)**2 and
            L2max = (2 * lmax + 1)**2. Entry G_LLL[L1, L2, L] is the Gaunt
            coefficient corresponding to the integral over the unit sphere of
            the product of three spherical harmonics Y_{L1}(r) * Y_{L2}(r) *
            Y_{L}(r) (as constructed from gpaw.spherical_harmonics.YL and the
            gam(...) function). In GPAW these coefficients are used to evaluate
            angular coupling terms (for example in PAW projector overlaps and
            angular momentum coupling integrals) when expressing products of
            spherical harmonics in a Cartesian-monomial representation. The array
            is computed deterministically by summing contributions from the
            sparse YL representation and the gam(...) integrals; zeros are common
            due to angular-momentum selection rules. The function caches the
            computed array in a module-level cache (_gaunt) keyed by lmax: a
            subsequent call with the same lmax returns the cached array object
            (same reference) rather than recomputing it. Large lmax can consume
            large amounts of memory (size scales as Lmax * L2max**2) and may
            raise MemoryError or significantly increase runtime.
    
    Behavior and side effects:
        The function checks a module-level cache (_gaunt) and returns a cached
        result if available. If not cached, it imports YL and gam from
        gpaw.spherical_harmonics and constructs G_LLL via explicit nested loops
        over the sparse YL coefficients and the gam(...) integrals. The default
        value is lmax = 2. No external files are read or written. The function
        may be CPU- and memory-intensive for large lmax; callers should choose
        lmax to match the angular resolution required by the GPAW calculation.
        If memory allocation fails, a MemoryError or other NumPy allocation
        exception may be raised.
    """
    from gpaw.gaunt import gaunt
    return gaunt(lmax)


################################################################################
# Source: gpaw.gaunt.nabla
# File: gpaw/gaunt.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for nabla because the docstring has no description for the argument 'lmax'
################################################################################

def gpaw_gaunt_nabla(lmax: int = 2):
    """Create the array of derivative integrals used by GPAW's Gaunt/spherical-harmonics machinery.
    
    This function constructs a 3D array of derivative integrals Y_LLv[L1, L2, v] that are used in GPAW (a DFT code based on the PAW method and ASE) when coupling spherical-harmonic channels and evaluating gradients/derivative coupling terms. The implementation expands the precomputed spherical-harmonic coefficient lists YL (from gpaw.spherical_harmonics) and accumulates contributions of the form n2[v] * c1 * c2 * gam(n0, n1, n2) where n = n1 + n2 with a decrement of the v-th Cartesian exponent in n2. The result is stored in a module-level cache (_nabla) to avoid recomputation for the same lmax. The default lmax is 2 (suitable for low angular-momentum expansions commonly used in PAW projector constructs).
    
    Args:
        lmax (int): Maximum angular momentum (l) to include in the expansion. The function interprets lmax as the highest spherical-harmonic degree; the number of spherical-harmonic labels L is Lmax = (lmax + 1)**2 and the returned Array3D therefore has shape (Lmax, Lmax, 3). Caller should pass a non-negative integer; passing negative or non-integer values will produce undefined or meaningless results because the routine relies on integer looping and on gpaw.spherical_harmonics data structures keyed by integer L values. The default is 2, which covers s, p, and d components in typical GPAW usages.
    
    Behavior and side effects:
        - If a value for this lmax is already present in the module-level cache _nabla, the cached Array3D is returned immediately to save CPU time and memory allocations.
        - When not cached, the function imports gpaw.spherical_harmonics.YL and gpaw.spherical_harmonics.gam and builds a NumPy array Y_LLv of shape (Lmax, Lmax, 3) (Lmax = (lmax + 1)**2) filled by triple loops over L1, L2, and Cartesian direction v.
        - For each pair of spherical-harmonic expansions YL[L1] and YL[L2], each term (c1, n1) in YL[L1] and (c2, n2) in YL[L2] contributes only when n2[v] > 0; in that case the exponent vector n is formed as n1 + n2 and the v-th component is decremented by one before calling gam(n0, n1, n2). The sum of n2[v] * c1 * c2 * gam(...) over all terms is placed into Y_LLv[L1, L2, v].
        - The completed array is stored in the module cache _nabla under the key lmax and returned. Subsequent calls with the same lmax will return the cached object (note: the returned array is the cached array object; modifying it in place will change the cached value for future callers).
    
    Performance and failure modes:
        - Computational cost grows rapidly with lmax because Lmax = (lmax + 1)**2 and the routine loops over all L1, L2 pairs and all coefficient pairs from YL[L1] and YL[L2]. For large lmax this can be memory- and CPU-intensive.
        - The function assumes gpaw.spherical_harmonics.YL and gpaw.spherical_harmonics.gam exist and are consistent with integer exponent tuples; if those data structures are missing or malformed an exception (ImportError, KeyError, TypeError, or IndexError) may be raised by the implementation.
        - The function does not validate types beyond relying on Python's runtime behavior; callers must supply an int lmax and should avoid mutating the returned array unless they intend to change the cached result.
    
    Returns:
        Array3D: A three-dimensional array of derivative integrals with shape (Lmax, Lmax, 3), where Lmax = (lmax + 1)**2. The array elements are floating-point integral values computed as described above and used by GPAW for coupling spherical-harmonic channels and computing derivative (gradient-like) matrix elements. The returned object is cached in the module-level dictionary _nabla for reuse on subsequent calls with the same lmax.
    """
    from gpaw.gaunt import nabla
    return nabla(lmax)


################################################################################
# Source: gpaw.fftw.check_fft_size
# File: gpaw/fftw.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_fftw_check_fft_size(n: int, factors: list = [2, 3, 5, 7]):
    """Check if an integer grid length n is an efficient FFT size for FFT-based operations.
    
    This function is used in GPAW to decide whether a grid dimension length n is suitable for efficient fast Fourier transform (FFT) algorithms (for example the FFTW library) that perform best when the transform length factors into small primes. In the GPAW domain this influences choices of plane-wave / real-space grid dimensions and multigrid operations: a return value of True indicates that n can be reduced to 1 by successive division by the allowed small prime factors (default [2, 3, 5, 7]), and therefore n is likely to give efficient FFT performance.
    
    Args:
        n (int): The integer transform length (grid size along one dimension) to test. This function expects n to be a positive integer (n >= 1). n == 1 is treated as efficient and returns True immediately. If n == 0 the function will repeatedly divide 0 by any factor that divides 0 and will never reach 1, leading to infinite recursion and ultimately a RecursionError; therefore do not pass n == 0. Negative integers are not meaningful for FFT sizes and are not in the intended domain of this function.
        factors (list): A list of integer factors (default [2, 3, 5, 7]) that are considered "small primes" for the factorization test. Each element is expected to be an integer greater than 1 (typically prime values). The function tests whether n can be factored entirely into elements from this list by repeatedly dividing n by any factor in factors that evenly divides n. Modifying this list changes which prime factors are allowed; including 1 or 0 in this list will cause non-terminating recursion and is therefore invalid.
    
    Returns:
        bool: True if n can be reduced to 1 by repeatedly dividing by elements of factors (i.e., n's prime factors are a subset of the provided factors), and False otherwise. A True return means the transform length is considered efficient for FFT algorithms that prefer small-prime factorizations (useful when choosing grid sizes in GPAW). A False return means n contains prime factors outside the provided list and may give suboptimal FFT performance. The function has no other side effects; it is a pure, deterministic check.
    """
    from gpaw.fftw import check_fft_size
    return check_fft_size(n, factors)


################################################################################
# Source: gpaw.ffbt.spherical_bessel
# File: gpaw/ffbt.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_ffbt_spherical_bessel(l: int, x_g: numpy.ndarray):
    """gpaw.ffbt.spherical_bessel computes the spherical Bessel function j_l(x) for a given integer order l and a NumPy array of non-negative radial arguments x_g. This implementation is used in the gpaw.ffbt module for radial/plane-wave integrals and expansions that appear in GPAW density-functional-theory calculations (for example, in radial parts of PAW/projector expansions and Fourier–Bessel transforms). The routine evaluates j_l(x) using the finite expansion
    j_l(x) = x^{-(l+1)} sum_{m=0}^l Re{ c_lm[l][m] * x^m * exp(-i x) }
    based on the coefficients c_lm (see Marco Vanin, 2008). The function returns a real-valued NumPy array with the same shape as x_g containing elementwise values of j_l(x).
    
    Args:
        l (int): The spherical order l of the Bessel function j_l. This must be a non-negative integer corresponding to the angular-momentum quantum number used in radial expansions in GPAW. Negative values are not supported and will typically produce incorrect results or runtime errors (for example, an empty coefficient sum or IndexError). The value of l determines the number of terms (m = 0..l) used in the finite expansion and the behaviour at x = 0 (j_0(0) = 1, j_l(0) = 0 for l > 0).
        x_g (numpy.ndarray): A NumPy array of non-negative floating-point radial arguments x where j_l(x) is to be evaluated. The array's dtype must be float (the code asserts x_g.dtype == float) and all elements must satisfy x >= 0 (the code asserts numpy.all(x_g >= 0)). The function preserves the shape of x_g and returns an array of the same shape. Values with x < 1e-10 are treated as x = 0 for numerical stability: j_0(0) is set to 1.0 and j_l(0) is set to 0.0 for l > 0.
    
    Returns:
        numpy.ndarray: A NumPy array jl_g with the same shape and floating dtype as x_g containing the real-valued spherical Bessel function j_l(x) evaluated elementwise. For x values below the internal zero threshold (x < 1e-10) the function uses the exact small-x limits (j_0(0) = 1, j_l(0) = 0 for l > 0). For x > 0 the value is computed from the expansion described above and the real part of the complex exponential; the result is normalized by x^(l+1).
    
    Behavior, side effects, and failure modes:
        - The function has no side effects on global state beyond reading module-level coefficient tables (c_lm). It does not modify the input array x_g.
        - The function asserts that x_g.dtype == float and that all x_g >= 0. If either assertion fails, an AssertionError is raised.
        - The implementation relies on the presence and sufficient size of the coefficient table c_lm indexed as c_lm[l][m]. If c_lm is undefined or does not contain entries for the requested l and m indices, a NameError, KeyError, or IndexError may be raised at runtime.
        - The code uses a numerical threshold 1e-10 to treat values as zero; users should be aware that values smaller than this threshold are treated as exactly zero and the small-x analytic limits are used.
        - The returned array contains real numbers; the computation temporarily uses complex exponentials but only the real part is returned.
        - The routine is intended for non-negative real-valued x_g only; inputs with negative values are not supported and will trigger the assertion.
    """
    from gpaw.ffbt import spherical_bessel
    return spherical_bessel(l, x_g)


################################################################################
# Source: gpaw.gaunt.super_gaunt
# File: gpaw/gaunt.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for super_gaunt because the docstring has no description for the argument 'lmax'
################################################################################

def gpaw_gaunt_super_gaunt(lmax: int = 2):
    """super_gaunt computes the contracted (product) Gaunt coefficients needed to express the product of three spherical harmonics as a single spherical-harmonic expansion. In the GPAW/PAW context (density-functional theory, projector-augmented wave method), these coefficients are used when combining angular parts of atomic-like functions (spherical harmonics) that appear in integrals and projections; the function returns the 4-dimensional tensor G_L_L1_L2_L3 defined by the contraction over an intermediate angular-momentum index L' of two Gaunt tensors.
    
    Args:
        lmax (int): Maximum single-particle angular momentum l used to build the Gaunt coefficients. This is the same lmax used elsewhere in GPAW when expanding atomic orbitals or angular parts of basis functions; the default value is 2 (i.e., l = 0..2). The function will compute gaunt(lmax) and gaunt(2*lmax) internally, so the computational cost and memory footprint grow with lmax. If an invalid lmax (for example a negative value) is provided, the underlying gaunt(...) call or NumPy operations will raise an exception propagated to the caller.
    
    Returns:
        Array4D: A four-dimensional NumPy array G with indices ordered as G[L, L1, L2, L3] such that
        G[L, L1, L2, L3] = sum_{L'} G1[L, L1, L'] * G2[L', L2, L3],
        where G1 = gaunt(lmax) and G2 = gaunt(2*lmax). In physical terms, this tensor gives the coefficient multiplying the spherical harmonic Y_L in the expansion of the product Y_{L1} Y_{L2} Y_{L3} after contracting over the intermediate angular momentum L'. The function returns a NumPy ndarray (rank 4) containing these contracted Gaunt coefficients. As a side effect, the computed array is cached in the module-level cache _super_gaunt keyed by the provided lmax; subsequent calls with the same lmax return the cached array without recomputation. Possible failure modes include exceptions from gaunt(...) for invalid lmax, NumPy errors for incompatible array shapes, or MemoryError for large lmax due to the rapid growth of tensor size.
    """
    from gpaw.gaunt import super_gaunt
    return super_gaunt(lmax)


################################################################################
# Source: gpaw.fftw.get_efficient_fft_size
# File: gpaw/fftw.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_fftw_get_efficient_fft_size(N: int, n: int = 1, factors: list = [2, 3, 5, 7]):
    """Return the smallest efficient FFT size that is greater than or equal to N and divisible by n.
    
    This function is used in GPAW to select array/grid sizes for FFT-based operations (for example FFTW transforms used in plane-wave or real-space DFT calculations). An "efficient" size is one that passes the check_fft_size test: its prime-factorization is restricted to the small primes listed in factors (by default [2, 3, 5, 7]), which typically yields good performance in FFT libraries such as FFTW. The returned size is therefore suitable for high-performance FFTs and for distribution constraints that require sizes to be multiples of n (for example MPI domain decomposition or block-alignment requirements in GPAW).
    
    Args:
        N (int): The minimum requested FFT size. The function returns a size greater than or equal to this value. This parameter represents a desired grid length or array dimension in GPAW FFTs and must be an integer.
        n (int, optional): The required divisor of the returned size. The returned integer will be divisible by n. Default is 1. This parameter is commonly used to enforce processor- or block-alignment constraints (for example ensuring the FFT length is a multiple of the number of MPI ranks or a local block size).
        factors (list, optional): A list of integer prime factors accepted for efficient FFT sizes. Default is [2, 3, 5, 7]. The function relies on check_fft_size(N, factors) to determine whether a candidate size is efficient by verifying that its prime-factorization only contains elements from this list. Choosing small primes in factors yields sizes that FFT libraries typically handle efficiently.
    
    Behavior and implementation details:
        The implementation first rounds N up to the smallest multiple of n (using integer arithmetic). It then tests that candidate with check_fft_size; if the test fails, the function increases the candidate by n and repeats until check_fft_size returns True. The function does not modify global state and is deterministic given the same inputs.
        Default factors [2, 3, 5, 7] are chosen because numbers composed only of these primes are typically fast for FFTW and similar libraries, which is important for GPAW performance in DFT calculations.
    
    Failure modes and edge cases:
        If n is zero or a non-positive integer, the initial computation that rounds N up to a multiple of n will raise a ZeroDivisionError or produce incorrect behavior; callers must pass a positive integer n.
        If factors is an empty list or contains values that prevent any multiple of n from passing check_fft_size, the function will loop indefinitely. In typical use (for example the default factors list), there exist infinitely many integers composed of those primes, so the loop will find a match.
        Inputs should be standard Python integers; passing non-integer types will cause a TypeError in arithmetic operations.
    
    Returns:
        int: An integer >= N, divisible by n, and acceptable to check_fft_size given the provided factors. This returned value is intended to be used as an FFT grid length or array dimension in GPAW to ensure efficient FFT performance and satisfy divisibility constraints.
    """
    from gpaw.fftw import get_efficient_fft_size
    return get_efficient_fft_size(N, n, factors)


################################################################################
# Source: gpaw.hybrids.parse_name
# File: gpaw/hybrids/__init__.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for parse_name because the docstring has no description for the argument 'name'
################################################################################

def gpaw_hybrids_parse_name(name: str):
    """Parse known hybrid functional names and return the libxc semi-local functional name
    and numerical parameters that GPAW uses to configure hybrid-exchange calculations.
    
    This function is used in GPAW (a density-functional theory Python package) to map a small set
    of canonical hybrid functional identifiers to the concrete parameters required by GPAW's
    hybrid/exact-exchange implementation. The returned values are used when setting up the
    exchange-correlation treatment in calculations that mix exact (Hartree–Fock) exchange with
    a semi-local functional, for example when constructing PBE0, HSE03, HSE06, B3LYP or
    Yukawa-screened PBE0 hybrids.
    
    Args:
        name (str): Hybrid functional identifier string. Must be one of the exact, case-sensitive
            names recognized by this function: 'EXX', 'PBE0', 'HSE03', 'HSE06', 'B3LYP', or
            'YS-PBE0'. The identifier selects a known mapping implemented in gpaw.hybrids.parse_name;
            the function does not perform fuzzy matching or case normalization, so the caller must
            supply the identifier exactly as listed.
    
    Returns:
        tuple[str, float, float, bool]: A 4-tuple with the following entries in order:
            The first element is the libxc-name (str) of the semi-local exchange or
            exchange–correlation functional that GPAW will combine with exact exchange.
            This string is passed to GPAW's libxc interface (for example 'HYB_GGA_XC_PBEH'
            for PBE0 or 'GGA_X_SFAT_PBE' for the short-range-functional part used with
            Yukawa-screened PBE0).
            The second element is the exact-exchange fraction (float): the fraction of
            Hartree–Fock-like exchange to include (for example 0.25 for the common hybrids).
            The third element is the damping coefficient (float): a dimensionless numerical
            parameter used by GPAW's hybrid/range-separation implementation to control the
            short-range damping or screening of the exact-exchange contribution (for example
            ~0.11 for HSE-type hybrids; for YS-PBE0 the value returned is 1.5 * 0.11 = 0.165
            as used in GPAW's implementation).
            The fourth element is the Yukawa screening flag (bool): True when the hybrid
            should use Yukawa-type (exponential) screening for the short-range exact exchange
            (as in 'YS-PBE0'), False when the standard (non-Yukawa) form used by the named
            hybrid is to be used (for example False for HSE03/HSE06/PBE0/B3LYP/EXX).
    
    Behavior and failure modes:
        This function performs a deterministic, side-effect-free mapping for the small set
        of hard-coded hybrid identifiers implemented in gpaw.hybrids.parse_name. If the input
        name does not match one of the recognized, case-sensitive strings listed above, the
        function raises a ValueError with the message "Unknown hybrid functional: {name}".
        The function does not validate or normalize other input types; callers must pass a
        Python str. The mapping implemented is exactly the one used in the source code:
        EXX -> ('null', 1.0, 0.0, False)
        PBE0 -> ('HYB_GGA_XC_PBEH', 0.25, 0.0, False)
        HSE03 -> ('HYB_GGA_XC_HSE03', 0.25, 0.106, False)
        HSE06 -> ('HYB_GGA_XC_HSE06', 0.25, 0.11, False)
        B3LYP -> ('HYB_GGA_XC_B3LYP', 0.2, 0.0, False)
        YS-PBE0 -> ('GGA_X_SFAT_PBE', 0.25, 1.5 * 0.11, True)
    
    Examples of practical significance:
        The returned libxc-name and numerical parameters are intended to be consumed by GPAW
        when constructing the hybrid exchange-correlation operator for a DFT calculation.
        For example, PBE0 uses 25% exact exchange (0.25) combined with the PBE semi-local
        functional, whereas EXX indicates pure exact exchange (fraction 1.0) with no damping.
    
    Side effects:
        None. The function is pure and only returns the mapping tuple.
    """
    from gpaw.hybrids import parse_name
    return parse_name(name)


################################################################################
# Source: gpaw.hyperfine.delta
# File: gpaw/hyperfine.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for delta because the docstring has no description for the argument 'r'
################################################################################

def gpaw_hyperfine_delta(r: numpy.ndarray, rT: float):
    """Extended delta function used in hyperfine-related real-space operations in GPAW.
    
    This function evaluates an analytic, smoothly decaying "extended delta" function
    defined by the expression 2 / rT / (1 + 2 * r / rT)**2. In the GPAW DFT/hyperfine
    context this function is used to model a localized contact-like distribution
    (centered at r = 0) with a finite range controlled by the parameter rT; it is
    suitable for use on real-space radial grids (numpy arrays) when constructing or
    analyzing hyperfine coupling terms and other localized operators. The amplitude
    at r = 0 is 2/rT and the large-r asymptotic decay is proportional to 1/r^2,
    so rT controls both the spatial extent (range) and the peak magnitude of the
    distribution. In practical GPAW/ASE workflows the radial distances r are
    typically expressed in the same length units used elsewhere in the calculation
    (e.g., Å when interacting with ASE structures and outputs).
    
    Args:
        r (numpy.ndarray): One-dimensional numpy.ndarray of radial coordinates
            () at which to evaluate the extended delta function. Each entry
            represents a distance from the origin on a real-space radial grid and
            should be non-negative for a physical radial distance; negative values
            are mathematically accepted by the formula but have no physical
            significance in standard radial-grid usage. The output is computed
            elementwise and the returned array preserves the shape of r. In GPAW
            workflows these values are typically in the same units as atomic
            positions (for example, Å when using ASE conventions).
        rT (float): Positive floating-point parameter that sets the effective
            range/width of the extended delta distribution and scales its
            amplitude. Physically, rT acts like a smoothing/cutoff radius: smaller
            rT yields a narrower, higher peak (value at r = 0 equals 2/rT), while
            larger rT produces a broader, lower-amplitude distribution. The
            function performs arithmetic division by rT, so rT must be non-zero.
    
    Returns:
        numpy.ndarray: A numpy.ndarray with the same shape as the input r containing
        the elementwise values of the extended delta function 2 / rT / (1 + 2 * r / rT)**2.
        This array is suitable for direct use in GPAW real-space integrations,
        convolution with radial basis functions, or assembling localized hyperfine
        contributions. No in-place modifications are made to the input r.
    
    Raises:
        ZeroDivisionError: If rT == 0. The implementation performs division by rT
            and will raise a ZeroDivisionError rather than silently returning
            infinities.
        TypeError: If r is not a numpy.ndarray or rT is not a float-like scalar,
            elementwise arithmetic may raise a TypeError; callers should pass the
            types shown in the signature to avoid such errors.
    
    Notes:
        - The implementation is fully vectorized over r and does not alter global
          state. Non-finite values (NaN, inf) in r will propagate to the output.
        - The formula and usage are consistent with GPAW's real-space/PAW methods
          where localized, smooth approximations to delta-like distributions are
          required for numerical stability and physical modeling of contact
          interactions.
    """
    from gpaw.hyperfine import delta
    return delta(r, rT)


################################################################################
# Source: gpaw.fulldiag.fulldiag
# File: gpaw/fulldiag.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_fulldiag_fulldiag(filename: str, bands: int = None, scalapack: int = 1):
    """Set up full Hamiltonian (H) and overlap (S) matrices from a saved GPAW calculation file and compute all or a subset of eigenvalues and eigenvectors using ScaLAPACK.
    
    This function is intended for post-processing/analysis in the GPAW density-functional theory (DFT) codebase. It reads a saved calculation contained in a .gpw file, constructs the full H and S matrices from the wavefunction data, calls GPAW's full diagonalization routine to obtain eigenpairs for the requested number of bands, writes a new gpw file containing the computed eigenvectors, and prints an estimate of the maximum dense matrix size and memory footprint for the diagonalization. The function uses the GPAW API and the GPAW parallelization keyword 'band' to request a ScaLAPACK parallel layout for the diagonalization.
    
    Args:
        filename (str): Path to an existing GPAW checkpoint file saved in the .gpw format. The function requires that filename end with the literal extension ".gpw"; otherwise an AssertionError is raised. This file is read with GPAW(filename, ...). The file provides the saved calculator state (density, wave functions, projector data) from which the full H and S matrices are assembled for diagonalization.
        bands (int): Number of Kohn–Sham bands (eigenpairs) to compute. Defaults to None, which signals the routine to compute all available bands stored in the input .gpw file. In practical use, providing a smaller integer than the total number of bands reduces computation time and memory, while None requests the full-spectrum diagonalization for complete eigenvector information (e.g., for post-processing, spectral analysis, or producing a new gpw with all states).
        scalapack (int): Number of cores (MPI band-parallel processes) to request for ScaLAPACK diagonalization. The value is passed to GPAW via parallel={'band': scalapack}. Default is 1, which runs without band-level ScaLAPACK parallelization. Setting this to a value >1 requires a parallel MPI environment with ScaLAPACK/BLACS configured; otherwise the call may fail or fallback behavior depends on the local GPAW/parallel configuration.
    
    Behavior, side effects, defaults, and failure modes:
        - The function asserts that the provided filename has extension ".gpw" and will raise AssertionError if this is not the case.
        - It constructs a GPAW calculator object by calling GPAW(filename, parallel={'band': scalapack}, txt=name + '-all.txt'), where name is filename without the extension. This creates a text log file named "<name>-all.txt" that records the diagonalization run and any messages from GPAW.
        - The function calls calc.diagonalize_full_hamiltonian(bands) to perform the dense diagonalization using GPAW's implementation. This is the computationally intensive step that builds full H and S matrices and finds eigenvalues/eigenvectors.
        - After diagonalization, the function writes a new checkpoint file named "<name>-all.gpw" using calc.write(name + '-all.gpw', 'all'). The 'all' mode causes GPAW to store all computed eigenvectors and related state in the output gpw file for later loading or analysis.
        - The function computes an estimate of the maximum matrix linear dimension ng from calc.wfs.pd.ngmax and prints an estimate of the matrix size in megabytes using mem = ng**2 * 16 / 1024**2. The factor 16 corresponds to the assumed bytes per matrix element in the dense matrix representation used here; this printed estimate helps users judge required memory and whether the calculation is feasible on their hardware.
        - Typical failure modes include: insufficient memory for forming/storing dense H and S matrices (which may raise MemoryError or cause the process to be killed by the OS), missing or improperly configured ScaLAPACK/BLACS when scalapack>1 (which may cause GPAW to raise an informative error), and IO errors when reading the input .gpw or writing the "<name>-all.gpw" output. Any exceptions from the GPAW API (GPAW(...), diagonalize_full_hamiltonian, write, etc.) are propagated to the caller.
        - The function performs no explicit input validation beyond the filename extension assertion; it relies on GPAW to validate that the input .gpw contains the required wavefunction and projector data for full diagonalization.
    
    Returns:
        None: The function does not return a value. Instead, it has the following observable side effects: it reads the specified .gpw file to reconstruct the electronic-structure state, performs full dense diagonalization (possibly using ScaLAPACK), writes a human-readable log file "<name>-all.txt" and a new checkpoint "<name>-all.gpw" containing the computed eigenvectors (mode 'all'), and prints an estimate of the maximum dense matrix size and memory footprint to standard output.
    """
    from gpaw.fulldiag import fulldiag
    return fulldiag(filename, bands, scalapack)


################################################################################
# Source: gpaw.hubbard.aoom
# File: gpaw/hubbard.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for aoom because the docstring has no description for the argument 'D_ii'
################################################################################

def gpaw_hubbard_aoom(
    D_ii: numpy.ndarray,
    l: int,
    l_j: List[int],
    n_j: List[int],
    N0_q: numpy.ndarray,
    scale: bool = True
):
    """gpaw.hubbard.aoom returns the atomic orbital occupation matrix (aoom) for a specified angular momentum quantum number l and a companion scaling matrix used in GPAW's DFT+U Hubbard correction. The function selects the block(s) of the full partial-wave density matrix D_ii that correspond to the specified l, combines these block(s) according to radial inner products of bounded and unbounded partial waves, and returns the resulting orbital occupation submatrix N_mm together with a dHU_ii matrix that contains the scaling factors placed in the corresponding sub-block positions of the full matrix. In GPAW and DFT+U calculations this aoom (N_mm) is used to compute orbital occupations for the Hubbard energy and to build the Hubbard potential, while dHU_ii encodes the same radial scaling factors in the full partial-wave index space for later use when assembling the DFT+U correction.
    
    Args:
        D_ii (numpy.ndarray): Full partial-wave density matrix for an atom, provided as a 2D square NumPy array. This matrix contains the density matrix blocks for all partial waves (all j indices) in the ordering defined by l_j; the function slices D_ii to extract one or two sub-blocks corresponding to the requested angular momentum l. The caller must ensure that D_ii has a block structure consistent with l_j (i.e., its dimension equals the sum over j of 2*l_j + 1). The function does not modify D_ii in place.
        l (int): Target angular momentum quantum number (e.g., 0 for s, 1 for p, 2 for d). The function uses l to find which partial-wave j indices in l_j correspond to this angular momentum and to determine the size nm = 2*l + 1 of the returned atomic-orbital occupation matrix N_mm (for l=2, nm=5).
        l_j (List[int]): List of integer angular momentum quantum numbers for each partial wave j in the atom (one entry per partial wave). This list defines the block partitioning of D_ii: each entry contributes a block size of 2*l_j[j] + 1. The function locates indices nl = where(l_j == l) to identify one or two blocks with the requested l; the implementation supports exactly one or two matching partial-wave blocks (len(nl) == 1 or 2).
        n_j (List[int]): List of radial (principal) quantum numbers or markers for each partial wave j. In GPAW's partial-wave setup, a value of -1 is used to mark an unbound (scattering-like) partial wave. The function uses n_j to decide whether a given matching partial wave is unbound (n_j == -1) and thereby selects the appropriate normalization/scaling formula for the radial inner products used in forming the occupation matrix.
        N0_q (numpy.ndarray): 1D NumPy array containing precomputed radial inner products between pairs of partial waves (q-indexed radial overlaps). Specific q indices computed inside the function correspond to: q1 = bounded-bounded inner product, q2 = unbounded-unbounded inner product, and q12 = bounded-unbounded inner product. These values are used to scale contributions from each sub-block of D_ii; when scale is True they are combined into relative normalization factors, otherwise they are used directly. The caller must ensure N0_q contains the required q entries for the partial-wave pairs present in l_j; insufficient length or incorrect ordering will raise IndexError.
        scale (bool, optional): If True (default), scale the radial inner products so that the bounded partial-wave inner product is treated as unity (N1 = 1) and the other inner products are normalized relative to it. This reflects the convention in GPAW's Hubbard implementation that bounded partial waves are taken as the normalization reference when constructing the DFT+U occupation. If False, the raw inner products from N0_q are used directly as scaling factors. Choosing scale=True is the standard behavior for assembling the occupation matrix for Hubbard corrections; scale=False can be used to apply raw overlap values instead.
    
    Returns:
        Tuple[numpy.ndarray, numpy.ndarray]: A tuple (N_mm, dHU_ii) where:
            N_mm (numpy.ndarray): The atomic-orbital occupation matrix for angular momentum l. N_mm is an nm x nm NumPy array with nm = 2*l + 1 (derived from the first matching partial wave). If two partial-wave blocks with the same l are present (typical in PAW setups with a bounded and an unbounded radial function), N_mm is built by summing/scaling the two corresponding sub-blocks of D_ii as
                N_mm = D_ii[i1,i1]*N1 + D_ii[i2,i2]*N2 + (D_ii[i1,i2] + D_ii[i2,i1])*N12,
            where i1 and i2 are index slices for the two sub-blocks and N1, N2, N12 are the normalization/scaling factors computed from N0_q and n_j. If only a single partial-wave block for l exists, N_mm = D_ii[i1,i1]*N1.
            dHU_ii (numpy.ndarray): Full-matrix (same shape as D_ii) NumPy array containing the normalization/scaling factors placed in the sub-block positions that correspond to the partial waves with angular momentum l. The returned dHU_ii has zeros outside those sub-blocks and contains N1, N2, N12 in the same block layout used to form N_mm. This matrix is suitable for later use when assembling the Hubbard potential in the full partial-wave index space.
    
    Behavior, defaults, and failure modes:
        - The function supports exactly one or two partial-wave blocks for the requested l found in l_j. If the number of matches len(nl) is not 1 or 2, the function raises NotImplementedError with a message indicating the unexpected count and the required behavior for DFT+U corrections.
        - If scale is True, the bounded partial-wave inner product (N0_q[q1]) is used as the normalization reference and set to unity; other inner products are divided by N0_q[q1] (or divided by the geometric mean of the two bounded values when both are bound) according to the code path. If scale is False, the raw values from N0_q are used directly.
        - The function assumes D_ii, l_j, n_j, and N0_q are consistent in length and ordering with the PAW partial-wave indexing used by GPAW. Mismatched sizes, missing q entries in N0_q, or inconsistent l_j ordering will lead to IndexError or incorrect slicing results.
        - The function may raise ZeroDivisionError or produce NaNs if the relevant N0_q entries used as divisors are zero when scale is True. Callers should ensure that N0_q contains physically meaningful, nonzero radial overlaps where required.
        - The function does not modify the input D_ii array in place; it constructs and returns a new dHU_ii array using numpy.zeros_like(D_ii).
        - Typical use in GPAW: call aoom to obtain N_mm for a given l to evaluate orbital occupations for the Hubbard U energy and to obtain dHU_ii for use when building the full Hubbard potential in the partial-wave basis.
    """
    from gpaw.hubbard import aoom
    return aoom(D_ii, l, l_j, n_j, N0_q, scale)


################################################################################
# Source: gpaw.dos.linear_tetrahedron_dos
# File: gpaw/dos.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_dos_linear_tetrahedron_dos(
    eig_kn: numpy.ndarray,
    weight_kn: numpy.ndarray,
    energies: numpy.ndarray,
    cell: numpy.ndarray,
    size: tuple,
    bz2ibz_map: numpy.ndarray = None
):
    """Linear-tetrahedron density-of-states (DOS) evaluator used in GPAW DFT post-processing.
    
    This function computes the electronic density of states (DOS) on a supplied energy grid using the linear tetrahedron integration (LTI) method over a k-point grid defined by `size` and `cell`. It is intended for use with eigenvalue data produced by GPAW or compatible DFT calculations: `eig_kn` contains eigenvalues for k-points and bands, `weight_kn` contains optional k-point weights, and `energies` is the energy grid where the DOS is evaluated. The implementation reshapes flattened eigenvalue/weight arrays to match the k-point grid dimensions, optionally remaps data from a full Brillouin-zone ordering to an irreducible-zone ordering using `bz2ibz_map`, and then calls the underlying LTI routine `lti(cell, eig_kn, energies, weight_kn)` to produce the DOS. This function performs no I/O and returns the DOS array for further analysis (for example, plotting or integrating to obtain number of states).
    
    Args:
        eig_kn (numpy.ndarray): Flattened or already-shaped eigenvalues for all k-points and bands. In GPAW workflows this typically contains eigenvalues produced by a band-structure calculation. If `eig_kn` is a 1D array whose length equals the product of the `size` tuple multiplied by the number of bands, the function will reshape it to shape `size + (-1,)` where the trailing axis indexes bands. If `len(eig_kn) != numpy.prod(size)` the function expects a mapping array `bz2ibz_map` to remap eigenvalues from a full Brillouin-zone ordering to the ordering used by `size`; failing to provide a correct `bz2ibz_map` when required will raise an indexing error or TypeError. The function does not modify the input array in-place beyond local reshaping/viewing.
        weight_kn (numpy.ndarray): Flattened or already-shaped k-point weights corresponding to `eig_kn`. These weights are used by the linear tetrahedron integration to account for k-point sampling of the Brillouin zone. If provided, `weight_kn` is reshaped in the same manner as `eig_kn` (to `size + (-1,)`) and is remapped with `bz2ibz_map` when remapping `eig_kn` is performed. `weight_kn` may be None (the code checks for `is not None`); in that case the LTI routine will be called with `weight_kn=None` and will use its internal handling of weights. If `weight_kn` is provided but its length is inconsistent with `eig_kn` and `size`, a ValueError or reshape/indexing error will occur.
        energies (numpy.ndarray): 1D array of energy values at which the DOS will be evaluated. The returned DOS array has the same logical correspondence to this energy grid (typically the same length as `energies`). The energy units should match those of `eig_kn` (for GPAW calculations this is normally electron-volt units when ASE/GPAW default units are used).
        cell (numpy.ndarray): Real-space unit cell vectors or cell information used by the tetrahedron integration routine to construct tetrahedra in reciprocal space. In the GPAW context `cell` determines the k-point sampling geometry for the LTI method and must be consistent with the `size` k-point grid and the ordering of `eig_kn`.
        size (tuple): Tuple of integers describing the k-point grid dimensions (for example a grid produced by Monkhorst-Pack). This tuple is used to reshape `eig_kn` and `weight_kn` into an array with shape `size + (-1,)` where the last axis indexes bands. The product of the integers in `size` must equal the number of k-point entries present in `eig_kn` (or in the full Brillouin-zone ordering when used with `bz2ibz_map`).
        bz2ibz_map (numpy.ndarray = None): Optional 1D integer index array mapping a full-Brillouin-zone ordering of k-points/eigenvalues to the ordering used in the irreducible Brillouin zone (IBZ) that matches `size`. If `len(eig_kn) != numpy.prod(size)` the function will attempt to remap `eig_kn` (and `weight_kn` if not None) via `eig_kn = eig_kn[bz2ibz_map]`. If a remapping is required but `bz2ibz_map` is None or has an incompatible length/type, an exception (TypeError, IndexError or ValueError) will be raised. When provided, `bz2ibz_map` must correctly reflect how the input eigenvalues/weights were ordered relative to the k-point grid implied by `size`.
    
    Returns:
        : One-dimensional array containing the computed density of states evaluated at the input `energies`. The returned array is produced by the linear tetrahedron integration routine `lti(cell, eig_kn, energies, weight_kn)` and thus represents the DOS obtained by integrating band contributions over the Brillouin zone using tetrahedral interpolation. The length and ordering of this array correspond to the `energies` input. No files are written by this function; the result is returned for downstream analysis. Failure modes include reshape/indexing errors when input array sizes or `bz2ibz_map` are inconsistent, and type errors if inputs are not NumPy arrays as expected.
    """
    from gpaw.dos import linear_tetrahedron_dos
    return linear_tetrahedron_dos(eig_kn, weight_kn, energies, cell, size, bz2ibz_map)


################################################################################
# Source: gpaw.hybrids.eigenvalues.idle
# File: gpaw/hybrids/eigenvalues.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for idle because the docstring has no description for the argument 'n'
################################################################################

def gpaw_hybrids_eigenvalues_idle(n: int, s: int):
    """Idle fraction for packing eigenvalues into fixed-size blocks used by gpaw.hybrids.eigenvalues.layout().
    
    Computes the fraction of unused ("idle") slots when n discrete items (for example, eigenvalues or bands in a GPAW DFT calculation) are arranged into b contiguous blocks of size s. The function is a small, pure helper used by the layout() function in the hybrids.eigenvalues module to quantify packing inefficiency when distributing eigenvalue-related data structures into blocks of length s for parallelization or memory layout purposes in GPAW (a DFT code). Internally, b is computed as the integer ceiling of n / s using b = (n + s - 1) // s, and the idle fraction is returned as 1 - n / (b * s).
    
    Args:
        n (int): The number of items to place into blocks, e.g., the number of eigenvalues or bands that must be assigned. In the GPAW context this corresponds to a count of electronic states or similar discrete objects that the layout() function will partition. Must be a positive integer (n > 0) for the computation to be well-defined; n == 0 will make b zero and lead to a division-by-zero at runtime.
        s (int): The block size (number of slots per block) used when partitioning items, e.g., the number of eigenvalues per block in the layout. This controls how many items fit into a single block and therefore affects packing efficiency. Must be a positive integer (s > 0); s == 0 will raise a ZeroDivisionError.
    
    Returns:
        float: The fraction of allocated slots that remain unused (idle) after packing n items into b blocks of size s. For valid inputs (n > 0 and s > 0) the return value is in the interval [0.0, 1.0): 0.0 indicates perfect packing with no idle slots (n is an exact multiple of s), values greater than 0.0 indicate the proportion of wasted slots due to incomplete final block. No side effects; the function is deterministic and pure. Exceptions: a ZeroDivisionError will occur if s <= 0 or if n == 0 (which makes the computed number of blocks b equal to zero), so callers must ensure positive n and s.
    """
    from gpaw.hybrids.eigenvalues import idle
    return idle(n, s)


################################################################################
# Source: gpaw.hyperfine.expand
# File: gpaw/hyperfine.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for expand because the docstring has no description for the argument 'D_ii'
################################################################################

def gpaw_hyperfine_expand(D_ii: numpy.ndarray, l_j: List[int], l: int):
    """Get expansion coefficients of a block-structured matrix in a spherical-harmonic
    multipole basis used for hyperfine/atomic-projector couplings in GPAW.
    
    This function is used inside the gpaw.hyperfine code path to transform a
    two-dimensional, block-partitioned matrix D_ii (for example a matrix of
    projector overlaps or density-matrix blocks arranged by angular-momentum
    channels) into multipole components labelled by the target angular momentum l.
    The operation contracts each (2*l1+1) x (2*l2+1) block of D_ii corresponding to
    pairs of angular-momentum channels l1, l2 (given in l_j) with the corresponding
    Gaunt coupling coefficients to produce coefficients D_mjj for the 2*l+1
    magnetic components m of the multipole l. In GPAW this expansion is relevant
    for evaluating hyperfine interactions and other quantities that couple pairs of
    spherical harmonics to a definite multipole order.
    
    Args:
        D_ii (numpy.ndarray): A two-dimensional NumPy array containing the block-
            partitioned matrix to be expanded. The array is interpreted as a
            concatenation of square blocks for each angular momentum channel in
            l_j; the expected size along each axis is sum(2*l_j[k] + 1 for k in
            range(len(l_j))). Each block corresponding to channel j has dimension
            (2*l_j[j] + 1) x (2*l_j[j] + 1). This function does not modify D_ii.
        l_j (List[int]): A list of integers specifying the angular-momentum
            quantum numbers l1, l2, ... for the block partitioning of D_ii. The
            ordering and values in l_j determine how D_ii is split into the
            (2*l1+1)-by-(2*l2+1) blocks that are contracted with Gaunt coefficients.
            The length of l_j is the number of blocks along each axis; the result
            D_mjj has dimensions indexed by these block indices.
        l (int): The target multipole angular-momentum quantum number used for the
            expansion. The function returns coefficients for the 2*l+1 magnetic
            components of this multipole. The integer l must be provided as an
            int (matching the function signature) and is used to select the
            corresponding slice of Gaunt coefficients used in the contraction.
    
    Returns:
        numpy.ndarray: A three-dimensional NumPy array D_mjj of shape
        (2*l + 1, len(l_j), len(l_j)). The first axis corresponds to the 2*l+1
        magnetic components m of the multipole l (in the ordering produced by
        the gaunt(...) routine used internally). The second and third axes index
        the block channels j1 and j2 from l_j. Each element D_mjj[m_index, j1, j2]
        is the contracted coefficient obtained by summing over the (a,b) indices
        of the block D_ii corresponding to channels j1 and j2 together with the
        corresponding Gaunt coupling for multipole l. No in-place modification of
        inputs occurs; the returned array is newly allocated.
    
    Behavior and side effects:
        The implementation constructs Gaunt coupling coefficients via
        gaunt(lmax=2) and selects the columns corresponding to multipole l,
        then iterates over block indices j1, j2 determined by l_j. For each block
        it slices the appropriate (2*l1+1) x (2*l2+1) submatrix from D_ii and
        contracts it with the corresponding sub-block of Gaunt coefficients using
        numpy.einsum to produce the 2*l+1 component vector for that pair (j1,j2).
        There are no side effects: input arrays are not mutated and results are
        returned as a new numpy.ndarray.
    
    Failure modes and errors:
        If D_ii does not contain the expected block structure (for example its
        shape along an axis is not equal to sum(2*l_j[k] + 1 for k in range(len(l_j)))),
        the slicing performed by the function will raise IndexError and the
        contraction cannot proceed. If l is incompatible with the Gaunt coefficients
        provided by gaunt(...) (for example requesting an l that exceeds the range
        covered by the returned Gaunt array), an IndexError or ValueError may be
        raised when selecting the Gaunt slice. TypeErrors will arise if inputs are
        not NumPy arrays or if l_j is not a list of ints. The function does not
        perform explicit shape validation or raise custom exceptions; callers should
        ensure consistency of D_ii and l_j before calling.
    
    Usage note:
        This routine is intended for use within GPAW's hyperfine and projector
        machinery where matrices are naturally organized by atomic angular-momentum
        channels. The returned D_mjj is suitable for further assembly of multipole
        contributions to hyperfine tensors or other spherical-harmonic multipole
        quantities.
    """
    from gpaw.hyperfine import expand
    return expand(D_ii, l_j, l)


################################################################################
# Source: gpaw.hybrids.paw.python_pawexxvv
# File: gpaw/hybrids/paw.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_hybrids_paw_python_pawexxvv(M_pp: numpy.ndarray, D_ii: numpy.ndarray):
    """gpaw.hybrids.paw.python_pawexxvv: Compute the PAW (projector-augmented wave) correction matrix for valence-valence exact-exchange (EXX) energy used in GPAW hybrid functional routines. This function builds a valence-space potential-like matrix V_ii by contracting a packed-pair interaction matrix M_pp with a valence density matrix D_ii using the packed_index(i, j, ni) mapping that is used elsewhere in the gpaw.hybrids.paw implementation.
    
    Args:
        M_pp (numpy.ndarray): Two-dimensional numpy.ndarray containing PAW pairwise interaction elements arranged using the packed-index ordering produced by packed_index(i, j, ni). In the GPAW PAW hybrid context, M_pp encodes corrections between pairs of projector indices (packed pairs) required to form the PAW correction to the EXX operator. This array is accessed with indices p13 = packed_index(i1, i3, ni) and p24 = packed_index(i2, i4, ni) inside the routine; therefore its first and second dimensions must be at least as large as the maximum packed_index value for the given ni = len(D_ii). Supplying an array with incompatible dimensions will typically raise an IndexError at runtime. The function does not modify M_pp.
    
        D_ii (numpy.ndarray): Square two-dimensional numpy.ndarray of shape (ni, ni) representing the valence-valence density matrix (or a related occupied-state tensor) in the atomic/projector index basis used by GPAW. The integer ni is inferred as len(D_ii), and the routine assumes D_ii is square. D_ii provides the coefficients D_ii[i3, i4] that are contracted with M_pp to produce the PAW correction V_ii. Passing a non-square or improperly shaped D_ii will raise a ValueError or lead to IndexError during execution.
    
    Returns:
        numpy.ndarray: A two-dimensional numpy.ndarray V_ii of shape (ni, ni) (where ni = len(D_ii)) containing the computed PAW correction matrix in the valence index space. Each element is computed as V_ii[i1, i2] = sum_{i3,i4} M_pp[packed_index(i1,i3,ni), packed_index(i2,i4,ni)] * D_ii[i3,i4]. This returned matrix is the quantity used in subsequent EXX energy and operator assembly within GPAW hybrid-PAW workflows. The function has no other side effects.
    
    Behavior and failure modes:
        The implementation uses four nested Python loops and the packed_index mapping to access M_pp; its computational cost scales as O(ni^4) in the number of valence indices ni and can be slow for large ni. For production calculations in GPAW, this Python implementation is intended for correctness and clarity; optimized or compiled implementations may be used for performance-critical code paths. The function will raise TypeError if inputs are not array-like in ways that NumPy cannot handle, ValueError if D_ii is not two-dimensional and square, and IndexError if M_pp does not have sufficient dimensions to accommodate the packed_index lookups for the inferred ni. No in-place modification of inputs occurs.
    """
    from gpaw.hybrids.paw import python_pawexxvv
    return python_pawexxvv(M_pp, D_ii)


################################################################################
# Source: gpaw.gpu.as_xp
# File: gpaw/gpu/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_gpu_as_xp(array: numpy.ndarray, xp: numpy.ndarray):
    """Transfer an array between CPU (NumPy) and GPU (CuPy) backends for use in GPAW's numerical kernels.
    
    This function is used in the GPAW DFT code to ensure that numerical data structures (for example real-space grid arrays that represent wavefunctions, electron density, potentials, or basis coefficients used by plane-wave, atom-centered or real-space multigrid methods) reside on the requested device before being passed to device-specific computational kernels. The routine will either return the array unchanged (if already on the requested backend) or perform an explicit device/host transfer using CuPy conversion helpers. Transfers allocate memory on the destination device and copy data between host and device, which may be expensive; CuPy must be available for GPU transfers.
    
    Args:
        array (numpy.ndarray or cupy.ndarray): Input array holding numerical data used by GPAW (examples: wavefunction grids, densities, potentials). This argument may be a NumPy ndarray (resident on the CPU) or a CuPy ndarray (resident on the GPU). The function inspects this object to decide whether a transfer is necessary. If it must move data to NumPy it uses cupy.asnumpy(array); if it must move data to CuPy it uses cupy.asarray(array). The returned array is a view or new allocation depending on the conversion routine used.
        xp (module (numpy or cupy)): The target array API/module indicating the desired device/backend. Pass the numpy module (typically imported as np) to request a CPU-side NumPy ndarray, or pass the cupy module to request a GPU-side CuPy ndarray. The function compares xp by identity with numpy (xp is np) to decide the target backend.
    
    Returns:
        numpy.ndarray or cupy.ndarray: The same data as the input array, but guaranteed to be an array object belonging to the requested backend: a NumPy ndarray when xp is the numpy module, or a CuPy ndarray when xp is the cupy module. If the array is already on the requested backend it is returned (in some branches) without additional copying; otherwise a new array may be allocated and data copied.
    
    Behavior, side effects and failure modes:
        - When xp is the numpy module (xp is np) and array is already a NumPy ndarray, the function returns array unchanged (no allocation or copy).
        - When xp is the numpy module and array is a CuPy array, the function converts it to host memory using cupy.asnumpy(array), which allocates host memory and copies data from device to host.
        - When xp is the cupy module and array is a NumPy ndarray, the function converts it to a CuPy array using cupy.asarray(array), which allocates device memory and copies data from host to device.
        - Due to an explicit "1 / 0" in the current implementation, if xp is not the numpy module and array is not an instance of numpy.ndarray (the common case when xp is cupy and array is already a CuPy array), the function raises a ZeroDivisionError instead of returning the input array. Similarly, if xp is neither numpy nor cupy the function will also raise ZeroDivisionError. This is an implementation bug: callers should be prepared for a ZeroDivisionError in these cases until the implementation is fixed.
        - GPU transfers require the CuPy library to be importable; if CuPy is not available, attempting to perform a GPU transfer will raise the usual ImportError/NameError from the environment or module-level imports.
        - Transfers allocate memory on the destination device and copy data across the host-device boundary; these operations can be expensive in time and memory and may fail with memory allocation errors if insufficient memory is available.
    """
    from gpaw.gpu import as_xp
    return as_xp(array, xp)


################################################################################
# Source: gpaw.ibz2bz.get_phase_shifted_overlap_coefficients
# File: gpaw/ibz2bz.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_ibz2bz_get_phase_shifted_overlap_coefficients(
    dO_aii: dict,
    spos_ac: numpy.ndarray,
    K_c: numpy.ndarray
):
    """gpaw.ibz2bz.get_phase_shifted_overlap_coefficients applies a Bloch-phase shift to per-atom overlap coefficients.
    
    This function is used in GPAW (a DFT/PAW code) when transforming or assembling overlap coefficients that are defined per atom for a single k-point in the irreducible Brillouin zone into their phase-shifted form appropriate for a given scaled wave vector K_c (for example when expanding quantities from the IBZ to the full Brillouin zone). For each atomic index a present in dO_aii, the function multiplies the stored overlap coefficients by the complex Bloch phase factor exp(2j * pi * (K_c · R_a)), where R_a is the scaled atomic position spos_ac[a] and K_c is the input scaled wave vector. The operation preserves the keys of the input dictionary and does not modify dO_aii in-place; a new dictionary is returned.
    
    Args:
        dO_aii (dict): Mapping from atomic index (keys) to overlap coefficients (values). In GPAW this dictionary holds per-atom overlap-coefficient arrays or scalars used in PAW/plane-wave expansions; each value must be a numeric or array-like object that supports elementwise multiplication by a complex scalar (the computed phase factor). The function iterates dO_aii.items() and applies the same-phase factor to the corresponding value for each atom.
        spos_ac (numpy.ndarray): Array of scaled atomic positions. Indexed by atomic index a such that spos_ac[a] yields the coordinate vector R_a for atom a. These coordinates are in the same scaled/Cartesian convention expected by the calling code and are used in the dot product K_c @ spos_ac[a] to compute the phase argument 2π (K_c · R_a).
        K_c (numpy.ndarray): Scaled wave vector (k-point) represented as a numpy.ndarray. This vector is used to compute the Bloch phase via the inner product K_c @ spos_ac[a]. The vector must be compatible in shape with the coordinate vectors returned by spos_ac[a].
    
    Returns:
        dict: A new dictionary mapping the same atomic indices as dO_aii to their phase-shifted overlap coefficients. Each returned value is the original dO_aii[a] multiplied by the complex phase factor numpy.exp(2j * numpy.pi * (K_c @ spos_ac[a])). The input dO_aii is not modified; this function has no other side effects.
    
    Behavior, defaults, and failure modes:
        - Phase convention: the Bloch phase applied is exp(2j * pi * K_c · R_a), matching the 2π convention used in GPAW for scaled k-vectors and positions.
        - No in-place modification: the function constructs and returns a new dictionary new_dO_aii; callers should use the returned dictionary to obtain the shifted coefficients.
        - Key correspondence: the function assumes every key a in dO_aii has a corresponding entry spos_ac[a]. If a key is missing in spos_ac, a KeyError will be raised by indexing spos_ac[a].
        - Type and shape compatibility: values in dO_aii must support multiplication by a complex scalar. If K_c and spos_ac[a] have incompatible shapes for the dot product, numpy will raise a ValueError (or propagate a shape-related exception). If dO_aii contains non-numeric objects that cannot be multiplied by a complex scalar, a TypeError will be raised.
        - Numerical precision: the result is a complex-valued multiplication; if inputs are real-valued arrays they will be promoted to complex as needed by numpy.
    """
    from gpaw.ibz2bz import get_phase_shifted_overlap_coefficients
    return get_phase_shifted_overlap_coefficients(dO_aii, spos_ac, K_c)


################################################################################
# Source: gpaw.inducedfield.inducedfield_base.zero_pad
# File: gpaw/inducedfield/inducedfield_base.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_inducedfield_inducedfield_base_zero_pad(a: numpy.ndarray):
    """Add a one-cell zero padding on both sides of the last three axes of a numpy.ndarray. This function is intended for use in GPAW induced-field and real-space grid code paths (for example when preparing arrays for finite-difference stencils, multigrid operations, or FFTs in induced-field calculations) where a one-cell layer of zeros ("ghost" or padding cells) is required on each side of the three spatial axes. The function returns a newly allocated array; the input is not modified. Not parallel safe: it performs a full local allocation/copy and does not coordinate padding across distributed (MPI) decompositions.
    
    Args:
        a (numpy.ndarray): Input array containing data defined on a real-space grid or similar multi-dimensional field used by GPAW. The array's dtype is preserved in the returned array. The implementation assumes that the array has at least three axes corresponding to the three spatial dimensions used in induced-field computations; if a.ndim < 3 the indexing used inside the function will very likely raise an IndexError.
    
    Returns:
        numpy.ndarray: A newly allocated array with the same dtype as the input whose shape equals numpy.array(a.shape) + z_shape where z_shape contains 2 added to each of the last three axes (i.e., each of those axes is increased by 2, corresponding to one zero element added at the beginning and one at the end). Leading axes (if any) are left unchanged in size. The input array a is not modified. Note that this allocation copies the input data into the central region of the output (b[..., 1:-1, 1:-1, 1:-1] = a), so peak memory use is higher while the function runs; this can be significant for large real-space grids.
    """
    from gpaw.inducedfield.inducedfield_base import zero_pad
    return zero_pad(a)


################################################################################
# Source: gpaw.gauss.I
# File: gpaw/gauss.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_gauss_I(R: list, a: tuple, b: tuple, alpha: float, beta: float):
    """Calculate the 3D integral of a product of two Gaussian functions multiplied by Cartesian monomials, and return that integral together with its Cartesian derivatives with respect to the displacement vector R.
    
    This function is used in GPAW's Gaussian integral utilities (gpaw.gauss) to evaluate integrals that appear when forming overlap, moment, and projector matrix elements in the PAW/DFT context. Concretely, it computes the integral
    
    value = ∫ x^(a0+b0) y^(a1+b1) z^(a2+b2) exp(-alpha * r^2) exp(-beta * |r - R|^2) dr
    
    over all space (r ∈ ℝ^3), and returns the integral value together with the partial derivatives of that integral with respect to the Cartesian components of the vector R (∂/∂Rx, ∂/∂Ry, ∂/∂Rz). The implementation evaluates the integral by calling the internal helper I1 and uses standard recurrence relations (raising and lowering of Cartesian polynomial exponents) to form the derivatives efficiently.
    
    Args:
        R (list): Cartesian displacement vector R = [Rx, Ry, Rz] (three entries). R locates the center of the second Gaussian relative to the first. In GPAW this vector represents the relative position used when computing overlap-type integrals between Gaussian-like functions. The function converts R to a NumPy array internally; providing a list of three numeric values is the documented and supported input form. Supplying an object with length different from 3 will cause downstream indexing or helper-function errors.
        a (tuple): Triple of non-negative integer exponents (a0, a1, a2) for the Cartesian monomial multiplying the first Gaussian: x^a0 y^a1 z^a2. These determine the polynomial prefactor associated with the first Gaussian center. The function treats a as a length-3 tuple and uses integer increment/decrement recurrence relations; non-integer or incorrectly sized tuples will lead to errors in the internal recurrence.
        b (tuple): Triple of non-negative integer exponents (b0, b1, b2) for the Cartesian monomial multiplying the second Gaussian: x^b0 y^b1 z^b2 (in the coordinate system of the first Gaussian). Together, a and b determine the total polynomial power in each Cartesian direction as a_i + b_i. The function expects a length-3 tuple of integers; incorrect shapes or types will produce exceptions.
        alpha (float): Positive (or non-negative) Gaussian exponent for the first Gaussian factor exp(-alpha * r^2). In the GPAW/DFT context this parameter controls the spatial width of the first Gaussian. Passing non-float types that cannot be used in NumPy arithmetic will raise a TypeError; alpha ≤ 0 may produce mathematically divergent or ill-conditioned integrals and is not recommended.
        beta (float): Positive (or non-negative) Gaussian exponent for the second Gaussian factor exp(-beta * |r - R|^2). This controls the width of the second Gaussian centered at R. Same type and sign considerations as for alpha apply.
    
    Behavior and implementation notes:
        - The integrand is the product of a Cartesian polynomial x^(a0+b0) y^(a1+b1) z^(a2+b2) and two isotropic Gaussian factors exp(-alpha r^2) and exp(-beta |r - R|^2). The function integrates this product over ℝ^3.
        - The returned derivative components are partial derivatives of the integral with respect to the Cartesian components of R: [∂/∂Rx, ∂/∂Ry, ∂/∂Rz]. These derivatives are computed using recurrence relations that call the helper function I1 with incremented or decremented polynomial exponents; see gpaw.gauss.I1 for the low-level integral evaluation.
        - No external state is mutated; the function has no side effects other than allocating and returning a NumPy array.
        - The function internally converts R and a to NumPy arrays for arithmetic and indexing and calls I1; therefore, malformed inputs (wrong length, non-numeric entries, non-integer exponents where integers are expected) will typically raise exceptions from NumPy operations or from I1.
        - Numerical accuracy depends on the magnitudes of alpha, beta, and the exponents a and b; very large exponents or extreme ratios of alpha and beta may lead to underflow/overflow or loss of precision typical for floating-point Gaussian integrals.
    
    Returns:
        numpy.ndarray: 1D array of length 4 containing the integral and its Cartesian derivatives in the order [value, d/dRx, d/dRy, d/dRz]. The first element is the scalar integral value described above. The remaining three elements are the corresponding partial derivatives with respect to the Cartesian components of R. This NumPy array is ready for direct use in further GPAW matrix-element assembly or gradient calculations; if an alternative container (e.g., a Python tuple) is required by a caller, convert explicitly.
    """
    from gpaw.gauss import I
    return I(R, a, b, alpha, beta)


################################################################################
# Source: gpaw.hgh.parse_local_part
# File: gpaw/hgh.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_hgh_parse_local_part(string: str):
    """Parse a whitespace-separated description of the local part of an HGH
    (Hartwigsen–Goedecker–Hutter) pseudopotential and return the parsed
    components needed to initialize an HGHParameterSet in GPAW.
    
    This function is used in the GPAW DFT codebase when reading or constructing
    HGH pseudopotential parameter sets. It tokenizes the input string with
    str.split(), interprets the first token as a symbol (optionally containing
    a suffix after a '.' which is ignored for chemical identity), looks up the
    atomic number from the module-level atomic_numbers mapping, and parses the
    subsequent tokens as the number of valence electrons, the local radius
    parameter, and any remaining floating-point coefficients for the local
    potential. The returned values are suitable for creating or initializing the
    local part of an HGHParameterSet object elsewhere in the codebase.
    
    Args:
        string (str): Whitespace-separated input describing the local part.
            Expected token order is: symbol Nv rloc [c_1 c_2 ...]. The symbol
            may include a suffix separated by a '.' (for example "Si.suffix"); the
            substring before the first '.' is treated as the chemical symbol used
            to look up the atomic number. Nv is parsed with int() and represents
            the number of valence electrons in the pseudopotential. rloc is
            parsed with float() and represents the local radius/lengthscale
            parameter for the local part of the pseudopotential. Any remaining
            tokens are parsed with float() to form the list of local-part
            coefficients. The function uses string.split() so arbitrary amounts of
            whitespace separate tokens; an empty or too-short string will raise
            StopIteration when required tokens are missing.
    
    Returns:
        tuple: A 5-tuple (symbol, Z, Nv, rloc, c_n) where:
            symbol (str): The original first token (may include a '.' suffix)
                identifying the pseudopotential entry; useful for preserving
                file-format identifiers or labels when constructing an
                HGHParameterSet.
            Z (int): The atomic number looked up from the module-level
                atomic_numbers mapping using the chemical symbol (the portion of
                symbol before any '.'). This is the nuclear charge used in DFT
                pseudopotential setup.
            Nv (int): The number of valence electrons parsed from the second
                token; used to configure valence occupancy in the HGHParameterSet.
            rloc (float): The local radius parameter parsed from the third token;
                used as the lengthscale/radius for the local part of the
                pseudopotential in GPAW.
            c_n (list[float]): A list of zero or more floating-point coefficients
                parsed from any remaining tokens; these coefficients parameterize
                the local potential and are stored for initializing the local
                part of an HGHParameterSet.
    
    Raises:
        StopIteration: If the input string does not contain enough tokens to
            extract symbol, Nv, and rloc.
        KeyError: If the chemical symbol (portion before any '.') is not found in
            the module-level atomic_numbers mapping.
        ValueError: If Nv cannot be converted to int or if rloc or any coefficient
            token cannot be converted to float.
    
    Side effects:
        Reads the module-level atomic_numbers mapping to determine Z. The
        function does not modify global state or the input string; it only
        returns parsed values for use by callers (for example, to build an
        HGHParameterSet).
    """
    from gpaw.hgh import parse_local_part
    return parse_local_part(string)


################################################################################
# Source: gpaw.kpt_descriptor.to1bz
# File: gpaw/kpt_descriptor.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_kpt_descriptor_to1bz(bzk_kc: numpy.ndarray, cell_cv: numpy.ndarray):
    """Wrap k-points to the first Brillouin zone (1. BZ) used by GPAW.
    
    This function is used in GPAW to map a set of k-points given in units of the reciprocal-lattice basis vectors to their nearest images inside the first Brillouin zone. It is intended for k-point handling in density-functional-theory workflows where k-points are represented as coordinates relative to the reciprocal lattice vectors derived from the real-space unit cell (cell_cv). The routine computes the Cartesian reciprocal vectors from cell_cv, evaluates the distances to the 27 nearest reciprocal-lattice images (integer shifts in {-1,0,1} along each reciprocal axis), and subtracts the integer shift that places each input k-point closest to the origin image. To avoid nondeterministic choice when distances are nearly equal, differences between the shortest distances are rounded to 6 decimal places and the lowest-index image is chosen.
    
    Args:
        bzk_kc (numpy.ndarray): (n,3) array of k-points. Each row is a k-point expressed in units of the reciprocal lattice basis vectors (i.e., fractional coordinates with respect to the reciprocal-lattice vectors). This array must have shape (n,3); n is the number of k-points. The function does not modify this array in-place but reads its values to compute the wrapped positions.
        cell_cv (numpy.ndarray): (3,3) unit cell matrix in real-space cartesian coordinates. Rows (or columns, depending on convention) define the three lattice vectors of the real-space unit cell. The function uses cell_cv to form the reciprocal-lattice matrix via B_cv = 2*pi * inv(cell_cv).T; therefore cell_cv must be invertible and have shape (3,3).
    
    Returns:
        numpy.ndarray: (n,3) array of k-points in the same units as the input bzk_kc (units of the reciprocal lattice vectors). Each returned row is the input k-point shifted by an integer combination of reciprocal-lattice basis vectors chosen from shifts in {-1,0,1} per axis so that the k-point is mapped to the nearest image corresponding to the first Brillouin zone. The returned array is a copy; the original bzk_kc is not modified.
    
    Behavior and side effects:
        The function computes the reciprocal-lattice matrix B_cv = 2*pi * inv(cell_cv).T, converts input fractional k-points to Cartesian K vectors, constructs the 27 candidate reciprocal-lattice vectors obtained from integer shifts N_xc in {-1,0,1} along each axis, and selects for each k-point the integer shift whose corresponding reciprocal-lattice vector is closest in Euclidean distance. To break ties deterministically, distances are compared after subtracting the minimum and rounding to 6 decimal places, and the tie is resolved by selecting the candidate with the lowest index. The selected integer shift is then subtracted from the input fractional coordinates to yield the wrapped k-point.
    
    Failure modes and exceptions:
        If cell_cv is singular (non-invertible), numpy.linalg.LinAlgError will be raised when computing its inverse. If the input arrays do not have compatible shapes for the linear algebra operations (for example, bzk_kc not having shape (n,3) or cell_cv not having shape (3,3)), NumPy operations such as dot or indexing will raise ValueError or IndexError. The function assumes numeric (floating) array data; passing arrays with incompatible dtypes may lead to unexpected behavior or errors from NumPy.
    """
    from gpaw.kpt_descriptor import to1bz
    return to1bz(bzk_kc, cell_cv)


################################################################################
# Source: gpaw.lcao.local_orbitals.get_plane_dirs
# File: gpaw/lcao/local_orbitals.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_lcao_local_orbitals_get_plane_dirs(plane: str):
    """Get normal and in-plane directions for a plane identifier used in GPAW's local-orbital and plane-related utilities.
    
    Args:
        plane (str): Pair of characters identifying the plane in Cartesian axes using letters 'x', 'y', 'z' (for example, 'xy' identifies the plane spanned by the x and y axes). In the GPAW DFT context (see README), this string is used by routines that need a compact user-facing way to specify a geometric plane for operations such as slicing densities, orienting local orbitals, or defining slab/plane orientations for analysis and visualization. The function sorts the characters and maps 'x'->0, 'y'->1, 'z'->2 to integer axis indices; valid characters are only 'x', 'y', and 'z'. The argument is interpreted literally; duplicates (e.g. 'xx') or strings of unexpected length are not validated beyond what the implementation performs and therefore produce results consistent with the mapping and subsequent set-difference logic described below.
    
    Returns:
        norm_dir (int): Integer axis index (0, 1, or 2) corresponding to the axis normal to the requested plane. This is the index not present among the mapped in-plane indices and is commonly used in GPAW code to select the axis along which to take a normal (perpendicular) direction for plane cuts or local-orbital projections.
        plane_dirs (list): List of integer axis indices (each 0, 1, or 2) corresponding to the in-plane directions derived from the input string, returned in ascending order because the implementation sorts the characters before mapping. These indices indicate which two Cartesian axes span the requested plane and are used by GPAW routines that iterate over or index components in those directions.
    
    Behavior and failure modes:
        The function converts the input characters to indices by calling 'xyz'.index(character) for each character in sorted(plane). If any character is not one of 'x', 'y', 'z', a ValueError is raised by str.index and propagates to the caller. If the input contains all three distinct characters (for example 'xyz'), the computed list of in-plane indices will include all axes and the subsequent attempt to select the normal axis (norm_dir[0]) will raise an IndexError because there is no remaining axis; this reflects that a three-axis input does not identify a single plane. If the input contains duplicate characters (for example 'xx'), plane_dirs will contain duplicate indices and the normal axis is computed as the first axis not present in that list. An empty string results in plane_dirs being an empty list and norm_dir being 0 (the first axis) according to the implementation. No other side effects occur; the function is pure and returns a tuple of the normal axis index and the list of in-plane axis indices for use by higher-level GPAW local-orbital and plane-processing code.
    """
    from gpaw.lcao.local_orbitals import get_plane_dirs
    return get_plane_dirs(plane)


################################################################################
# Source: gpaw.lcao.generate_ngto_augmented.read_gaussian_basis_file
# File: gpaw/lcao/generate_ngto_augmented.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_lcao_generate_ngto_augmented_read_gaussian_basis_file(fname: str):
    """gpaw.lcao.generate_ngto_augmented.read_gaussian_basis_file reads a Gaussian basis set file and returns the first element/atom entry found in the file together with a textual description and a list of contracted Gaussian-type orbital (CGTO) dictionaries suitable for use in GPAW's LCAO/NGTO augmentation workflow. This function is used in the gpaw.lcao.generate_ngto_augmented pipeline to import atom-centered Gaussian basis definitions (common in quantum chemistry basis set libraries) and convert them into the internal CGTO representation consumed by GPAW for density-functional theory (DFT) calculations that use atom-centered basis functions.
    
    Args:
        fname (str): Path to a text file containing Gaussian basis set definitions in a standard plain-text format where element blocks are separated by lines beginning with '*' and comment/description lines begin with '!'. The function opens this file for reading using Python's default text encoding. The caller must provide a valid filesystem path; passing a non-existent path will raise the underlying I/O exception (e.g., FileNotFoundError). The fname argument is the only input and controls which basis set file is parsed and imported into GPAW.
    
    Behavior and parsing rules:
        The function reads the file line-by-line and implements the following parsing semantics that are important for correct use in GPAW:
        - Lines beginning with '*' mark separators between element/atom sections. Only the first element/atom section encountered (the first block before the next '*' separator) is parsed and returned; any subsequent atoms in the file are ignored. This enforces that the function imports exactly one atom's basis definition per call.
        - Lines beginning with '!' are treated as comment/description lines. The leading '!' is stripped and the remainder of each such line is concatenated (with newline separators) into the returned description string. This preserves human-readable metadata or provenance notes commonly present in Gaussian basis files.
        - Blank lines and lines beginning with '*' are ignored until the first non-empty, non-'*' line is found; that first non-ignored line supplies the atom identifier (the first whitespace-separated token on that line) and is returned as the atom label.
        - After the atom label, the function reads shell specification lines until the next '*' separator. Each shell line is expected to start with an angular-momentum character (one of s, p, d, f, g, h, i; case-insensitive) followed by an integer giving the number of primitive Gaussian functions (Nj) in that shell.
        - For each primitive in a shell the function expects a subsequent line with two numeric fields: exponent (alpha) and contraction coefficient. Numeric fields may use the Fortran-style 'D' exponent marker; the parser converts 'D' to 'E' before float conversion to support common Gaussian basis set notations.
        - For each shell the function accumulates alpha and coefficient lists and calls create_CGTO_dictionary(l, alpha_j, coeff_j) with l being the angular-momentum index computed from 'spdfghi'. The returned object from create_CGTO_dictionary is appended to the gtos list. The practical significance is that each returned CGTO dictionary encodes one contracted shell in a format appropriate for GPAW's LCAO basis construction.
    
    Returns:
        tuple: A 3-tuple (atom, description, gtos) describing the first element/atom found in the Gaussian basis file.
            atom (str): The element or atom identifier parsed from the first non-empty, non-separator line of the file. In practice this string maps the returned basis to a species in GPAW's atom-centered basis-function framework and is used to select which atomic basis to attach to an ASE Atoms object.
            description (str): A concatenated string of comment lines from the file (lines that began with '!'), with leading '!' removed and original comment line ordering preserved. This provides human-readable metadata and provenance for the imported basis and is useful for logging, reproducibility, and diagnostics in GPAW workflows.
            gtos (list): A list of CGTO dictionaries (the objects returned by create_CGTO_dictionary) each encoding a contracted Gaussian shell: angular-momentum index, lists of primitive exponents, and contraction coefficients. These CGTO dictionaries are the practical representation consumed by GPAW when building atom-centered basis functions for LCAO or NGTO augmentation.
    
    Side effects and defaults:
        - The only side effect is reading the specified file from disk. No global state is modified by this function.
        - The function only parses and returns the first element/atom block in the file; users who need multiple atoms must call the parser repeatedly on appropriately segmented input or use a different utility.
        - Numeric fields accept Fortran-style 'D' exponents by automatic conversion to 'E' before float parsing.
    
    Failure modes and exceptions:
        - File I/O errors (e.g., FileNotFoundError, PermissionError) are raised by the open() call if the fname path is invalid or inaccessible.
        - Malformed files may raise IndexError or ValueError when the parser expects tokens or numeric fields that are missing or not parseable as floats; these exceptions originate from list indexing or float(...) conversions. In addition, NameError may occur if create_CGTO_dictionary is not available in the current module scope.
        - The function does not attempt to validate that the parsed basis is physically complete or compatible with a particular element beyond the textual format checks described above; such validation must be performed by the caller or downstream GPAW code.
    """
    from gpaw.lcao.generate_ngto_augmented import read_gaussian_basis_file
    return read_gaussian_basis_file(fname)


################################################################################
# Source: gpaw.kpt_refine.get_reduced_monkhorst
# File: gpaw/kpt_refine.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_kpt_refine_get_reduced_monkhorst(size: tuple, N_c: int):
    """Find a Monkhorst-Pack k-point grid for a refined reciprocal-space grid and shrink it to the reciprocal-space volume of a single original k-point cell.
    
    This function is used in k-point refinement and folding workflows within GPAW (a DFT code using plane-waves/real-space grids) to generate the Monkhorst-Pack sampling for a refined grid specified by size and then scale (shrink) those k-point coordinates so they lie inside the volume corresponding to one original coarse k-point. It calls monkhorst_pack(size) to produce the refined-grid k-point coordinates and returns those coordinates divided by N_c so that the refined mesh is represented within a single original k-point cell. This is useful when mapping refined k-point sampling onto the Brillouin-zone volume of a coarse k-point for tasks such as supercell unfolding, k-point folding, or constructing reduced k-point sets for symmetry/reduction.
    
    Args:
        size (tuple): The integer tuple specifying the dimensions of the refined Monkhorst-Pack grid. Each element gives the number of subdivisions along a reciprocal-lattice direction for the refined grid; the tuple is passed directly to monkhorst_pack(size) to generate the refined k-point coordinates. In practical GPAW/DFT usage, size determines the density and anisotropy of the refined k-point sampling in reciprocal space.
        N_c (int): An integer scaling factor equal to the number of refined-grid cells that correspond to one original (coarse) k-point cell. This function divides the refined-grid coordinates by N_c to map them into the volume of a single original k-point. In practice N_c is used to perform the folding/shrinking operation when transforming a finer k-point mesh to the reference domain of a coarser mesh.
    
    Returns:
        The value returned by monkhorst_pack(size) scaled by 1/N_c: the refined-grid Monkhorst-Pack k-point coordinates mapped into the reciprocal-space volume of one original k-point. The exact returned object has the same structure and type as produced by monkhorst_pack(size) (for example, an array-like collection of k-point coordinate vectors) but with every coordinate divided by N_c so that the set fits into one original k-point cell.
    
    Behavior, side effects, defaults, and failure modes:
        This function performs no I/O and has no side effects; it is a pure computation that calls monkhorst_pack(size) and returns the scaled result. If size is not a valid argument for monkhorst_pack, monkhorst_pack(size) will raise whatever exception it normally raises (for example, a TypeError or ValueError), and this function will propagate that exception. If N_c is zero, the division by N_c will result in a division-by-zero situation: depending on the numeric type returned by monkhorst_pack(size) this may raise an exception or produce infinities/NaNs with a runtime warning; callers should ensure N_c is a positive integer appropriate for the intended folding. No validation of input ranges or shapes is performed beyond what monkhorst_pack enforces.
    """
    from gpaw.kpt_refine import get_reduced_monkhorst
    return get_reduced_monkhorst(size, N_c)


################################################################################
# Source: gpaw.kpt_refine.get_fine_bzkpts
# File: gpaw/kpt_refine.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_kpt_refine_get_fine_bzkpts(
    center_ic: numpy.ndarray,
    size: numpy.ndarray,
    bzk_coarse_kc: numpy.ndarray,
    kwargs: dict
):
    """Return list of reducible refined k-points and the indexes of the selected
    coarse-grid points that serve as refinement centers, for use in k-point
    refinement in GPAW (DFT/PAW code). This function implements the practical
    procedure used in GPAW to refine a Monkhorst–Pack coarse k-point grid by
    replacing, for a number of neighbour "shells" around specified coarse-grid
    centers, each coarse point by a small reduced Monkhorst–Pack patch. The
    output is suitable for subsequent integrations or symmetry-reduced k-point
    sums in plane-wave or real-space calculations performed by GPAW.
    
    Args:
        center_ic (numpy.ndarray): One-dimensional array of integer indices referring
            to points on the coarse k-point grid. Each entry is interpreted as an
            index into bzk_coarse_kc and identifies a coarse-grid k-point that will
            serve as a center for refinement. In GPAW's k-point refinement workflow,
            these centers typically come from symmetry-unique k-points selected on
            the coarse grid; they determine the spatial locations (in the same
            coordinate basis as bzk_coarse_kc) around which finer subgrids are
            constructed.
        size (numpy.ndarray): One-dimensional array-like container whose length
            sets the number of neighbour "shells" to be refined (nshells = size.shape[0]).
            Each element size[shell] is passed unchanged to get_reduced_monkhorst to
            produce the scaled Monkhorst–Pack mesh for that shell. Practically,
            each element encodes the integer refinement factors (for example a
            tuple or array of integers in typical usage) that define how many
            subdivisions along each reciprocal direction are used to replace a
            coarse-grid point in that shell. The function uses size to decide both
            the geometry of each refined patch and the weights assigned to refined
            k-points.
        bzk_coarse_kc (numpy.ndarray): Array of k-point coordinate vectors for the
            coarse grid (same coordinate convention used elsewhere in GPAW, e.g.,
            fractional coordinates with respect to reciprocal lattice vectors or
            whatever "kc" denotes in the calling code). This array is indexed by
            integers in center_ic; the selected rows act as the translation
            centers for the refined Monkhorst–Pack meshes. The function does not
            alter bzk_coarse_kc; it only reads rows by integer indices derived from
            center_ic and symmetry-equivalence operations.
        kwargs (dict): Keyword arguments forwarded to create_kpoint_descriptor when
            constructing the initial coarse-grid descriptor (kd_coarse). This
            dictionary typically contains parameters that define how the coarse
            grid is interpreted (such as symmetry, lattice vectors, or grid
            conventions required by GPAW). Any missing, misspelled, or incompatible
            entries in kwargs will be passed to create_kpoint_descriptor and can
            therefore raise TypeError or ValueError originating from that call.
    
    Behavior and side effects:
        The function first constructs a k-point descriptor for the coarse grid by
        calling create_kpoint_descriptor(bzk_coarse_kc, **kwargs). It then
        computes neighbour coordinates by shells around zero and, for each shell,
        translates those neighbour offsets to every declared center (center_ic).
        For each translated neighbour, the function uses find_equivalent_kpoints to
        discover symmetry-equivalent coarse-grid indices and keeps only unique
        indices (removing duplicates arising from symmetry and overlaps between
        neighbor shells). The unique center indices are used to extract center
        k-point coordinates from bzk_coarse_kc. For every retained center and for
        every shell, a reduced (smaller) Monkhorst–Pack mesh is generated via
        get_reduced_monkhorst(size[shell], kd_coarse.N_c) and translated to the
        center coordinate; these translated points are collected into the refined
        k-point list. The function computes a weight for each refined k-point as
        1 / prod(size[shell]) (equal weight within a refined patch) and concatenates
        weights from all shells. No global state is modified by this function beyond
        the calls to the helper routines; its effects are limited to returning the
        computed arrays.
    
    Defaults and conventions:
        The number of shells to process is determined by size.shape[0]. The term
        "kc" in variable names denotes the same k-coordinate convention used by the
        caller and in GPAW routines; the function preserves that convention in its
        outputs. kwargs defaults are those of create_kpoint_descriptor; this
        function does not supply default kwargs itself.
    
    Failure modes and exceptions:
        The function may raise IndexError if any entry of center_ic is not a valid
        index for bzk_coarse_kc. It may raise TypeError or ValueError if size or
        entries of size are of inappropriate types or shapes for get_reduced_monkhorst,
        or if kwargs are inappropriate for create_kpoint_descriptor. Two internal
        consistency checks at the end of the function use assert and will raise
        AssertionError if the total weight does not match the number of retained
        centers within numerical tolerance or if the number of weights does not
        match the number of returned refined k-points; such an assertion indicates
        an unexpected logic error or numerical inconsistency in inputs or helper
        routines.
    
    Returns:
        centers_i (numpy.ndarray): One-dimensional integer array of unique indices
            into bzk_coarse_kc. Each entry identifies a coarse-grid k-point that
            was selected (after symmetry filtering and de-duplication) to serve as
            the center of a refined Monkhorst–Pack patch. These indices are the
            practical connection between coarse-grid bookkeeping in GPAW and the
            refined k-point set.
        bzk_fine_kc (numpy.ndarray): Two-dimensional array of k-point coordinate
            vectors for the refined grid. The coordinates are expressed in the
            same "kc" convention as the input bzk_coarse_kc and are ordered to
            match the corresponding entries of weight_k. This array contains the
            concatenated refined patches obtained by translating reduced
            Monkhorst–Pack meshes to each retained center.
        weight_k (numpy.ndarray): One-dimensional floating-point array of weights
            for each refined k-point in bzk_fine_kc. Weights are computed as
            1 / prod(size[shell]) for all points coming from a given shell, and
            concatenated in the same order as bzk_fine_kc. The function asserts
            that sum(weight_k) approximately equals len(centers_i) to ensure
            consistency with the intended normalization used in GPAW k-point
            integrations.
    """
    from gpaw.kpt_refine import get_fine_bzkpts
    return get_fine_bzkpts(center_ic, size, bzk_coarse_kc, kwargs)


################################################################################
# Source: gpaw.kpt_refine.construct_neighbours_by_shells
# File: gpaw/kpt_refine.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_kpt_refine_construct_neighbours_by_shells(nshells: int, N_c: numpy.ndarray):
    """gpaw.kpt_refine.construct_neighbours_by_shells constructs a grouped list of neighbour translation vectors arranged in concentric "shells" around the center point. This function is used in GPAW's k-point refinement utilities to generate the fractional translations (relative to a discrete grid N_c) for points at increasing shell indices; each shell contains the grid points whose maximum absolute component equals the shell index, so shells form cube-like layers around the center in grid-index space.
    
    Args:
        nshells (int): Number of shells to construct, including the innermost shell (the center). This argument controls how many concentric layers are produced. If nshells >= 1 the function returns exactly nshells groups (the first group is always the center). If nshells <= 0 the function still returns the center group only. nshells must be an integer; passing a non-integer will raise a TypeError from Python's range() usage. Practical significance: choose nshells to cover the required neighbourhood radius for k-point refinement; larger nshells produce more distant translation vectors.
        N_c (numpy.ndarray): One-dimensional NumPy array with three entries (N_c[0], N_c[1], N_c[2]) giving the grid counts along the three Cartesian dimensions used to normalize integer displacements into fractional translations. Elements of N_c are used as divisors (the code divides integer coordinate offsets by N_c) and must therefore be non-zero; a zero element will raise a ZeroDivisionError. If a component N_c[i] equals 1, the function treats that dimension as having no displacement (it uses only 0 for that coordinate), which is important when one dimension is not sampled or is collapsed in the k-point grid. If N_c does not have length 3, an IndexError will be raised. In the domain of GPAW k-point refinement, N_c typically represents the number of k-point subdivisions or cells along each Cartesian axis and therefore determines the spacing of neighbour translations.
    
    Returns:
        numpy.ndarray: A one-dimensional NumPy array (object dtype) of length max(1, nshells) containing, for each shell index starting from 0, a two-dimensional NumPy array of dtype float and shape (M, 3) with the fractional translation vectors for that shell. The element at index 0 is the innermost shell (the center) and equals [[0.0, 0.0, 0.0]] (shape (1, 3)). For shell s (1 <= s < nshells when nshells >= 1), the corresponding array contains all integer triplets [cx, cy, cz] with -s <= cx,cy,cz <= s and with at least one component having absolute value exactly s; these integer triplets are divided elementwise by N_c to produce fractional translations. Practical significance: the returned structure groups neighbours by radial shell for use in algorithms that require progressively larger neighbourhoods (for example, when refining k-point sampling). The function has no side effects (it does not modify its inputs) and only constructs and returns these arrays. Potential failure modes include TypeError if nshells is not an integer, IndexError if N_c does not have three elements, and ZeroDivisionError if any element of N_c is zero.
    """
    from gpaw.kpt_refine import construct_neighbours_by_shells
    return construct_neighbours_by_shells(nshells, N_c)



################################################################################
# Source: gpaw.lcao.tools.collect_orbitals
# File: gpaw/lcao/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_lcao_tools_collect_orbitals(a_xo: numpy.ndarray, coords: list, root: int = 0):
    """Collect array data distributed over the orbital axis (last axis) from all MPI ranks to a single root CPU.
    
    This function is used in GPAW's LCAO tooling to gather orbital-related arrays that are distributed across MPI processes. In typical GPAW DFT workflows the orbital coefficients or orbital-dependent data are split so that the last axis of a per-rank array corresponds to a subset of orbitals owned by that rank. collect_orbitals gathers those per-rank pieces and assembles a full array on the designated root CPU for purposes such as writing orbitals to disk, performing serial postprocessing, or diagnostics. The function preserves the input dtype and produces an array whose leading dimensions match the input except that the final axis equals the total number of orbitals given by sum(coords). The function relies on a global MPI-like communicator object named world that provides size, rank, ssend and receive; it uses synchronous sends (tag 112) and explicit receives on the root.
    
    Args:
        a_xo (numpy.ndarray): Local array on the calling rank with orbital data distributed along the last axis. The array shape is ( ..., norb_local ) where the trailing dimension corresponds to the number of orbitals owned by this rank. The function first calls numpy.ascontiguousarray on this argument to ensure a contiguous memory layout, and the dtype of a_xo is preserved in the returned array on root. In GPAW LCAO usage this array typically contains per-orbital coefficients or orbital-projected quantities.
        coords (list): Python list of integers giving the number of orbital entries (lengths of the last axis) owned by each MPI rank. The intended practical use is that coords[rank] equals the trailing-axis length of the array held by that rank. In normal operation len(coords) should equal world.size; sum(coords) equals the total number of orbitals to assemble on root. If coords does not match the actual communicator size or per-rank data lengths, the function may raise an assignment/error or hang.
        root (int = 0): Integer rank index of the root CPU that will receive and assemble all pieces into a single full array. In GPAW workflows this is typically 0. Non-root ranks send their local a_xo to this rank and return None; the root rank performs receives and returns the collected array. If world.size == 1 the function returns the (possibly converted to contiguous) a_xo immediately.
    
    Returns:
        numpy.ndarray or None: On the root rank (root == world.rank), returns a new numpy.ndarray a_xO whose shape equals a_xo.shape[:-1] + (sum(coords),) and whose dtype equals the input a_xo.dtype; this array contains the concatenated orbital data from all ranks in the rank order implied by coords. On non-root ranks the function returns None and has the side effect of sending the local a_xo to the root using a synchronous send (world.ssend) with tag 112. If world.size == 1 the function returns the input array (converted to contiguous) on that single rank.
    
    Behavioral notes, side effects, and failure modes:
        - The function makes a contiguous copy of a_xo via numpy.ascontiguousarray; this can allocate memory even on non-root ranks before sending.
        - On non-root ranks the function performs a blocking synchronous send (world.ssend) to the specified root and then returns None; the send may block until the root posts a matching receive.
        - On the root rank the function allocates an output array large enough to hold sum(coords) orbital entries along the last axis; this allocation can be large and may raise MemoryError if insufficient memory is available.
        - The function expects that all ranks invoke it with consistent coords and that coords provides counts for all ranks (normally len(coords) == world.size). Mismatches between coords and the actual local trailing-axis sizes or communicator behavior can lead to array assignment errors, hangs, or raise exceptions from the communicator.
        - The communicator tag 112 is used for all sends/receives; mixing calls with other communications using the same tag may interfere.
        - The function depends on a global communicator object world (as used elsewhere in GPAW). If such an object is not present or does not implement the required methods/attributes (size, rank, ssend, receive), a NameError or AttributeError will be raised.
    """
    from gpaw.lcao.tools import collect_orbitals
    return collect_orbitals(a_xo, coords, root)


################################################################################
# Source: gpaw.lcao.tools.basis_subset2
# File: gpaw/lcao/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_lcao_tools_basis_subset2(
    symbols: list,
    largebasis: str = "dzp",
    smallbasis: str = "sz"
):
    """gpaw.lcao.tools.basis_subset2 returns a boolean mask selecting basis functions when reducing
    an LCAO (linear combination of atomic orbitals) basis set for an entire list of atoms.
    This function is used in GPAW DFT workflows to generate a per-basis-function selection mask
    that maps a larger, more complete atomic basis (for example, 'dzp' double-zeta-polarized)
    to a smaller basis (for example, 'sz' single-zeta) for all atoms in a calculation. The
    mask can be applied to packed LCAO coefficient vectors or basis-function arrays to
    truncate or test reduced-basis representations for performance or analysis.
    
    Args:
        symbols (list): Ordered list of atomic symbols (e.g., ['H', 'O', 'C']) specifying the
            atoms for which the basis subset mask is constructed. The order determines the
            ordering of basis functions in the returned mask: for each symbol in sequence,
            basis functions for that atom are considered in the same local ordering used by
            the helper function basis_subset. symbols must be a Python list; if it contains
            invalid element types or unknown chemical symbols, helper functions
            types2atomtypes or basis_subset will raise exceptions which propagate out of this
            function.
        largebasis (str): Label for the larger (reference) per-atom basis set from which
            functions may be retained or removed. Typical GPAW labels are strings such as
            'dzp' (double-zeta polarized). This argument is passed to types2atomtypes to
            produce a per-atom basis specification aligned with the symbols list. The default
            value is 'dzp', meaning that, when not specified, the function assumes the larger
            basis is 'dzp'.
        smallbasis (str): Label for the smaller per-atom basis set that defines which
            functions should be kept (True) vs. discarded (False) when compared to largebasis.
            Typical GPAW labels are strings such as 'sz' (single-zeta). This argument is
            passed to types2atomtypes to produce a per-atom basis specification aligned with
            the symbols list. The default value is 'sz', meaning that, when not specified, the
            function assumes the smaller basis is 'sz'.
    
    Returns:
        numpy.ndarray: 1-D NumPy array of booleans (dtype bool) representing the mask over all
        basis functions for the provided symbols list. True entries indicate basis functions
        that are kept in the smallbasis relative to largebasis; False entries indicate basis
        functions that are removed. The length of the returned array equals the total number
        of basis functions obtained by concatenating the per-atom basis-function lists in the
        order of symbols. The ordering and grouping of True/False values follow the per-atom
        ordering returned by the helper function basis_subset for each atom.
    
    Behavior and side effects:
        This function is pure (no side effects on the input lists) and constructs the mask by:
        (1) mapping the scalar basis labels largebasis and smallbasis to per-atom specifications
        using types2atomtypes(symbols, largebasis/smallbasis, default=...), (2) iterating over
        the symbols and their corresponding per-atom large and small basis specifications, and
        (3) extending a Python list with the boolean selections produced by basis_subset(symbol,
        large_per_atom, small_per_atom) for each atom, finally converting the list to a NumPy
        boolean array. The function relies on the helper functions types2atomtypes and
        basis_subset from gpaw.lcao.tools; any exceptions they raise (for example, due to
        invalid basis labels or unknown atom symbols) are propagated to the caller.
    
    Failure modes and errors:
        If symbols is not a list, or contains unsupported symbol entries, types2atomtypes or
        basis_subset may raise TypeError or ValueError. If largebasis or smallbasis are not
        valid GPAW basis labels understood by types2atomtypes/basis_subset, an error will be
        raised. The function does not perform additional validation beyond calling the helper
        routines and will propagate their exceptions.
    """
    from gpaw.lcao.tools import basis_subset2
    return basis_subset2(symbols, largebasis, smallbasis)


################################################################################
# Source: gpaw.lcao.tools.basis_subset
# File: gpaw/lcao/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_lcao_tools_basis_subset(symbol: str, largebasis: str, smallbasis: str):
    """gpaw.lcao.tools.basis_subset: Determine which basis-function indices in a larger atom-centered LCAO basis are present in a smaller basis for the same atomic symbol. This helper is used in the GPAW LCAO tooling to create a boolean mask that selects orbitals belonging to the smaller basis out of the larger basis representation so matrices (overlap, Hamiltonian, density) defined on the large basis can be restricted or sliced to the smaller basis.
    
    This function looks up basis descriptions with Basis.find(symbol, basisname) and extracts counts of radial (zeta) and polarization (pol) functions using zeta_pol(basis). The code and ordering convention used here (as in the LCAO implementation in GPAW) assume that the Basis object arranges atomic orbitals such that the first zeta entries are the radial (single-particle) functions followed immediately by polarization functions. The returned boolean mask has length equal to the number of atomic orbitals in the large basis (blarge.nao) and is True exactly for those indices that correspond to orbitals present in smallbasis.
    
    Args:
      symbol (str): Atomic symbol for which the bases are defined (for example 'H', 'C', 'O'). This is passed verbatim to Basis.find to locate the per-atom basis descriptions used by GPAW's LCAO machinery. It identifies the chemical element whose basis sets are being compared.
      largebasis (str): Name or identifier of the larger (superset) basis for the given symbol. This string is passed to Basis.find(symbol, largebasis) to obtain the Basis object blarge. The function assumes largebasis defines blarge.nao and that zeta_pol(blarge) returns (zeta_large, pol_large).
      smallbasis (str): Name or identifier of the smaller (subset) basis for the same symbol. This string is passed to Basis.find(symbol, smallbasis) to obtain the Basis object bsmall. The function assumes zeta_pol(bsmall) returns (zeta_small, pol_small).
    
    Returns:
      numpy.ndarray: A 1-D boolean numpy array of length blarge.nao. Each element corresponds to an orbital index in the large basis: True means the orbital at that index is present in smallbasis, False means it is not. The mask is constructed by including the first zeta_small radial functions and the first pol_small polarization functions (placed after zeta_large in the large-basis ordering). This array can be used directly to index or mask GPAW LCAO matrices.
    
    Behavior, side effects and failure modes:
      - The function performs no I/O and has no side effects beyond calling Basis.find and zeta_pol.
      - It relies on the ordering convention where radial (zeta) functions occupy the first zeta_large indices and polarization functions occupy the next pol_large indices in the large basis; the code sets insmall[:zeta_small] = True and insmall[zeta_large:zeta_large + pol_small] = True accordingly.
      - If zeta_small > zeta_large or pol_small > pol_large the function triggers an AssertionError due to explicit assertions in the implementation. This enforces that smallbasis must indeed be a subset (not contain more zeta or pol functions) of largebasis for the same symbol.
      - Errors raised by Basis.find or zeta_pol (for example if a basis name is unknown or the symbol/basis combination is invalid) are propagated to the caller; the function does not catch these exceptions.
      - The returned numpy.ndarray dtype is bool and its length equals blarge.nao as obtained from the Basis object for largebasis.
    """
    from gpaw.lcao.tools import basis_subset
    return basis_subset(symbol, largebasis, smallbasis)


################################################################################
# Source: gpaw.lcaotddft.magneticmomentwriter.parse_header
# File: gpaw/lcaotddft/magneticmomentwriter.py
# Category: valid
################################################################################

def gpaw_lcaotddft_magneticmomentwriter_parse_header(line: str):
    """gpaw.lcaotddft.magneticmomentwriter.parse_header parses a single header line that encodes the name, numeric version, and JSON keyword arguments for a writer used in the gpaw.lcaotddft.magnetic-moment writer subsystem. The function extracts these three pieces of information and returns them as a tuple (name, version, kwargs) for downstream use when reconstructing or selecting the appropriate writer implementation in GPAW's real-space/time-dependent DFT workflows.
    
    The expected header format is exactly:
        NameOfWriter[version=1](**{"arg1": "abc", ...})
    where NameOfWriter is an identifier matching Python word characters, version is a non-negative integer, and the argument map is a JSON object literal (the literal appears after the literal characters '(**' and before the final ')'). This format is used by the gpaw.lcaotddft.magneticmomentwriter module to serialize writer selection and configuration in text output or checkpoint files.
    
    Args:
        line (str): A single header line string to parse. This line must follow the exact format shown above: a writer name composed of ASCII word characters (matches the regular expression \w+), followed immediately by "[version=" plus a decimal integer and "]", followed immediately by "(**" plus a JSON object literal representing keyword arguments and a closing ")". The function does not perform trimming of surrounding whitespace; the regular expression used requires the pattern to match the entire string from start to end. Practical significance: callers should pass the header line produced by the corresponding writer serialization routines in GPAW to recover writer identity, numerical version, and configuration.
    
    Returns:
        name (str): The writer name extracted from the header (the NameOfWriter identifier). This identifies which magnetic-moment writer implementation to instantiate or compare against when reading serialized writer metadata in GPAW workflows.
        version (int): The integer version parsed from the header. This numeric version is intended to allow code that reads older or newer serialized writer headers to detect format or behavior differences and handle compatibility in GPAW output processing.
        kwargs (dict): A Python dictionary obtained by JSON-decoding the argument object in the header. These keyword arguments represent the configuration parameters that were serialized for the writer (for example, argument names and values that control writer behavior). The dict is produced via json.loads and will be a standard Python mapping suitable for passing as keyword arguments (via **) to writer constructors or factory functions.
    
    Raises:
        ValueError: If the input line does not match the required header pattern, the function raises ValueError with the message 'unable parse header'. This indicates the line is not in the exact expected serialized format (for example, invalid name characters, missing version, missing surrounding tokens, or extra characters).
        ValueError: If the header pattern matches but the JSON argument substring cannot be decoded by json.loads, the function raises ValueError with the message 'unable parse keyword arguments'. This indicates the argument payload is not valid JSON (for example, malformed string quoting, trailing commas, or other JSON syntax errors) and therefore cannot be converted to a Python dict.
    
    Side effects and behavior notes:
        This function is pure parsing code and has no external side effects (it does not modify files or global state). It relies on a strict regular expression to validate the overall structure; callers must supply the header exactly as produced by the corresponding writer serialization in GPAW. No normalization (such as stripping or case-folding) is performed. The JSON decoding uses the standard json library, so JSON types map to native Python types according to the standard json.loads semantics.
    """
    from gpaw.lcaotddft.magneticmomentwriter import parse_header
    return parse_header(line)


################################################################################
# Source: gpaw.lcaotddft.qed.forward_finite_difference
# File: gpaw/lcaotddft/qed.py
# Category: valid
################################################################################

def gpaw_lcaotddft_qed_forward_finite_difference(
    coefficients: list[int],
    data_tx: numpy.ndarray
):
    """gpaw.lcaotddft.qed.forward_finite_difference computes a forward finite-difference linear combination along the first axis (time axis) of a time-dependent data array using an explicit integer coefficient stencil.
    
    Args:
        coefficients (list[int]): Ordered list of integer finite-difference coefficients that define the forward-difference stencil. Each entry in this list is multiplied with a shifted slice of the input data along the time axis and summed to produce the output at every time index. The coefficients are typically obtained from finite-difference coefficient tables (for example, see finite-difference coefficient references such as https://en.wikipedia.org/wiki/Finite_difference_coefficient). This list must be non-empty and its length determines the forward stencil width; providing an empty list or an invalid width will result in an error when constructing the padded array.
        data_tx (numpy.ndarray): Time-dependent data array whose first axis is the time axis (length N). The remaining axes may represent spatial coordinates, channels, or other degrees of freedom used in LCAO-TDDFT/QED calculations in GPAW. The function treats data_tx as read-only and does not modify it in place. The array's dtype is preserved in the returned array. The function requires that data_tx has at least one time sample (N >= 1); passing an empty array along the first axis will raise an error during padding.
    
    Returns:
        numpy.ndarray: Array of the same shape and dtype as data_tx containing the linear combination (finite-difference result) computed at each time index. For each time index t in 0..N-1, the result is the sum over i of coefficients[i] * data_tx_padded[t + i], where data_tx_padded is a padded version of data_tx constructed to preserve the original shape: the initial time sample data_tx[0] is repeated len(coefficients) times at the start and the remaining entries are filled with data_tx[1:]. This padding choice ensures the returned array has the same temporal length N as the input.
    
    Behavior and side effects:
        The function constructs an internal zero-initialized padded array of shape (N + len(coefficients) - 1, ...) and an output array initialized with zeros. It accumulates the weighted sum by sliding windows of length N over the padded array, multiplied by the provided coefficients. The input array data_tx is not modified; the function returns a newly allocated numpy array. Computational cost scales approximately as O(N * len(coefficients) * product_of_other_dimensions). The function preserves the dtype of data_tx.
    
    Failure modes:
        Passing an empty coefficients list or an input array with zero length along the first axis will lead to invalid padding dimensions and raise an exception (for example, a NumPy error or IndexError) when constructing or indexing the padded array. Coefficients should be supplied as integers (list[int]) as per the signature; supplying other types may still work if NumPy can cast them, but is not guaranteed by the implementation. The function does not validate that the coefficients represent a normalized derivative stencil; it simply applies the provided linear combination.
    """
    from gpaw.lcaotddft.qed import forward_finite_difference
    return forward_finite_difference(coefficients, data_tx)


################################################################################
# Source: gpaw.lcaotddft.qed.calculate_third_derivative
# File: gpaw/lcaotddft/qed.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_lcaotddft_qed_calculate_third_derivative(timestep: float, data_tx: numpy.ndarray):
    """gpaw.lcaotddft.qed.calculate_third_derivative calculates the third time derivative of time-dependent data using a forward finite-difference stencil and returns an array with the same shape as the input data_tx. This function is used in the GPAW LCAO TDDFT QED context to obtain the third temporal derivative of time-series quantities (axis 0 is time), where timestep is the uniform time increment used during time propagation.
    
    Args:
        timestep (float or None): Time step used to scale the finite-difference result (Δt). In normal use this must be a non-zero float equal to the sampling interval of the time axis of data_tx. The implementation also accepts None only for the special-case when data_tx contains a single time sample (len(data_tx) == 1); in that case the function returns an array of zeros with the same shape as data_tx without performing a division. If timestep is zero (and not the single-sample None special-case) a division by zero will occur and a ZeroDivisionError or FloatingPointError may be raised by the underlying arithmetic.
        data_tx (numpy.ndarray): Array of time-dependent data where the first axis (index 0) is the time axis and remaining axes are spatial, orbital, or other degrees of freedom used by GPAW LCAO TDDFT QED. The array may have any shape provided the time axis length is at least 1. To preserve the output shape, the algorithm repeats the data corresponding to the last time step as needed when applying the forward finite-difference stencil.
    
    Returns:
        numpy.ndarray: The numerical third derivative with respect to time of data_tx, computed pointwise and returned with the same shape and dtype as data_tx. The derivative is computed by applying a forward finite-difference operator with coefficients [-1, 3, -3, 1] (ordered from oldest times to newest times) and dividing the finite-difference result by timestep**3. For a single-sample input (len(data_tx) == 1) and timestep is None the function returns an array of zeros with the same shape as data_tx. No in-place modification of data_tx is performed; the function is pure with respect to its inputs.
    """
    from gpaw.lcaotddft.qed import calculate_third_derivative
    return calculate_third_derivative(timestep, data_tx)


################################################################################
# Source: gpaw.lcaotddft.qed.calculate_first_derivative
# File: gpaw/lcaotddft/qed.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_lcaotddft_qed_calculate_first_derivative(timestep: float, data_tx: numpy.ndarray):
    """Calculate the first time derivative of time-dependent data using a first-order forward finite difference.
    
    This function is used in the LCAO-TDDFT QED parts of GPAW to obtain time derivatives of time-dependent quantities (for example dipole moments, densities, or density-matrix elements) during real-time propagation or analysis of time-series output. It computes the forward first-order finite-difference approximation (coefficients [-1, 1]) so that the discrete derivative at time t is approximated by (f(t+dt) - f(t)) / dt. To preserve the original array shape along the time axis, the implementation repeats the last-time sample as required by the underlying forward_finite_difference routine; this ensures the returned array has the same shape as data_tx and can be used directly in subsequent GPAW time-stepping or post-processing code.
    
    Args:
        timestep (float): Time step dt used for the finite-difference quotient. This value is the spacing between successive samples along the time axis (first axis) of data_tx and is used as the denominator in the finite-difference formula. If timestep is zero, the division will produce infinities or NaNs (or raise, depending on NumPy error handling). If timestep is None, this function only accepts the special case documented below: when data_tx contains exactly one time point (len(data_tx) == 1), the function returns a zero array without performing division. If timestep is None and data_tx contains more than one time point, a TypeError or other failure will occur when attempting the division.
        data_tx (numpy.ndarray): Array of time-dependent data with the time axis as the first axis (axis 0). The remaining axes represent spatial, orbital, or other internal degrees of freedom used by GPAW LCAO-TDDFT/QED routines. The function treats consecutive entries along axis 0 as values at successive times separated by timestep. The input is not modified in place; a new array of the same shape is produced.
    
    Returns:
        numpy.ndarray: Array of the same shape as data_tx containing the first derivative evaluated at each time sample using a first-order forward difference scheme. The time axis (axis 0) of the returned array corresponds to the derivative at the same time-grid points as the input. In the special case where len(data_tx) == 1 and timestep is None, a zeros_like(data_tx) array is returned. No other side effects occur. Potential failure modes include division by zero when timestep == 0 (leading to infinities/NaNs or runtime warnings) and TypeError when timestep is None for multi-sample inputs. The implementation relies on the internal forward_finite_difference routine and the coefficient stencil [-1, 1] to produce a result compatible with downstream GPAW TDDFT/QED code.
    """
    from gpaw.lcaotddft.qed import calculate_first_derivative
    return calculate_first_derivative(timestep, data_tx)


################################################################################
# Source: gpaw.lrtddft.apmb.sqrt_matrix
# File: gpaw/lrtddft/apmb.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_lrtddft_apmb_sqrt_matrix(a: numpy.ndarray, preserve: bool = False):
    """Get the symmetric matrix square root of a (diagonalization is used).
    This function is intended for use in GPAW's linear-response / TDDFT
    code paths (gpaw.lrtddft.apmb) where square roots of symmetric matrices
    (e.g. overlap, density, or response matrices that arise in DFT/PAW
    calculations) are required. The operation performed is sqrt(a) =
    Z * sqrt(D) * Z^T where a = Z * D * Z^T is the eigen-decomposition
    computed with a Hermitian eigensolver. If preserve is False the
    result overwrites the input array a in-place for memory efficiency;
    if preserve is True the input is copied and left unchanged.
    
    Args:
        a (numpy.ndarray): Square symmetric matrix to be square-rooted.
            The function expects a to be a two-dimensional NumPy array of
            shape (n, n) containing real floating-point numbers (the code
            asserts a.dtype == float and a.shape == (n, n) when the
            module-level debug flag is enabled). In the GPAW application
            domain this matrix typically represents a real symmetric
            operator (overlap, density, response, etc.) coming from DFT
            calculations. The function diagonalizes a with a standard
            symmetric eigensolver and uses the eigenvectors and eigenvalues
            to construct the matrix square root.
        preserve (bool): If True, do not modify the input array a; a copy
            is made and the copy is returned. If False (default), the
            computation is performed in-place by reusing the input array
            storage and the returned array is the same object as the input.
            Use preserve=True when the original matrix must be retained
            for subsequent operations; use preserve=False to avoid the
            allocation cost of copying for large matrices in memory-sensitive
            DFT calculations.
    
    Returns:
        numpy.ndarray: The matrix square root of a, with the same shape
        (n, n) as the input. If preserve is False the returned array is
        the same object as the input argument a (in-place modification).
        If preserve is True the returned array is a separate copy and the
        original a is left unchanged.
    
    Notes and failure modes:
        The algorithm diagonalizes the matrix to obtain eigenpairs (D, Z)
        and computes sqrt(a) = Z * sqrt(D) * Z^T. If a is not symmetric
        (within numerical precision) or contains negative eigenvalues,
        the computed sqrt will be invalid for real arithmetic: negative
        eigenvalues produce NaNs when taking the real square root. The
        implementation relies on LAPACK/BLAS routines (eigh and a BLAS
        matrix multiply) for performance; non-contiguous inputs may be
        copied internally (the code checks contiguity only when the
        module-level debug flag is enabled). Numerical round-off errors are
        possible for nearly-degenerate eigenvalues, which is typical for
        matrices arising in DFT and should be handled at the application
        level if strict positive-definiteness is required.
    """
    from gpaw.lrtddft.apmb import sqrt_matrix
    return sqrt_matrix(a, preserve)


################################################################################
# Source: gpaw.lrtddft.dielectric.get_dielectric
# File: gpaw/lrtddft/dielectric.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_lrtddft_dielectric_get_dielectric(
    exlist: list,
    volume: float,
    emin: float = 0,
    emax: float = None,
    de: float = None,
    energyunit: str = "eV",
    width: float = 0.08,
    comment: str = None,
    form: str = "v"
):
    """Evaluate the macroscopic dielectric function from a list of electronic excitations produced by GPAW's linear-response routines.
    
    Args:
        exlist (list): List of excitation objects (an ExcitationList or equivalent) produced by gpaw.lrtddft. Each element is expected to provide two methods used by this function: get_energy(), which returns the excitation energy in atomic units (Hartree), and get_oscillator_strength(form), which returns the oscillator strength for that excitation in the requested representation. In the GPAW/TDDFT workflow, exlist typically comes from a linear-response calculation and encodes transition energies and strengths that determine the optical response.
        volume (float): Unit cell volume in Angstrom**3. This scalar is used in the physical prefactor pre = 4*pi/volume * Bohr**3 * Hartree**2 to convert the summed oscillator strengths into the macroscopic dielectric response for a periodic system. Passing an incorrect unit (not Angstrom**3) or zero will produce incorrect results or a division-by-zero error.
        emin (float): Minimum energy for the output spectrum in the units specified by energyunit. Default 0. If None-like behavior is desired, the code treats the absence of an explicit lower bound as starting from zero energy. emin selects the lower bound of the energy grid used when folding discrete excitations into a continuous spectrum.
        emax (float): Maximum energy for the output spectrum in the units specified by energyunit. Default None. If None, the routine selects an upper bound that covers all supplied excitations (i.e., it will extend to include the highest excitation energies present in exlist after unit conversion). emax controls the upper limit of the energy grid for the folded dielectric function.
        de (float): Desired energy spacing (grid step) for the output spectrum in the units specified by energyunit. Default None. If None, the folding routine (Folder.fold) chooses an appropriate spacing. Providing de sets the resolution of the returned arrays and therefore the spectral resolution of eps1/eps2, refractive index and reflectivity.
        energyunit (str): Energy unit for emin, emax, de and width. The function currently supports only 'eV' and will raise RuntimeError if another value is supplied. Internally, excitation energies returned by ex.get_energy() are multiplied by the Hartree constant to convert from Hartree (atomic units) to eV before further processing; the output energies are therefore in eV.
        width (float): Broadening width for folding discrete excitations into a continuous spectrum, expressed in the same units as energyunit (default 0.08 eV). The routine uses Lorentzian folding (RealLorentzPole and ImaginaryLorentzPole) with this width to produce eps1 and eps2 from discrete oscillator strengths. A larger width increases spectral broadening; a nonpositive width can lead to unphysical results or errors from the folding routine.
        comment (str): Optional free-form comment or metadata string. Default None. This parameter is accepted for compatibility/metadata purposes but is not used by this function to modify the calculation or results (it has no side effects in this implementation).
        form (str): String passed to each excitation object's get_oscillator_strength(form) to select the oscillator-strength representation (for example the representation required by the excitation objects). Default 'v'. The value is forwarded directly to the excitation objects; invalid or unsupported values will cause those objects to raise an error.
    
    Behavior and side effects:
        The function reads energies and oscillator strengths from exlist, converts energies from Hartree to electronvolts, and folds the discrete spectrum into continuous real and imaginary dielectric parts using Lorentzian broadening. The physical prefactor includes the provided unit cell volume in Angstrom**3 and atomic-to-SI conversion factors (Bohr and Hartree) as implemented in the GPAW constants used in the source. There are no external side effects: the function does not modify exlist or write files. Possible runtime failures include RuntimeError when energyunit is not 'eV', AttributeError if an element of exlist does not provide the required methods get_energy() and get_oscillator_strength(), ZeroDivisionError if volume is zero, or errors propagated from the internal Folder.fold routine if invalid folding parameters are supplied.
    
    Returns:
        tuple: A 6-tuple of numpy.ndarray objects (energies, eps1, eps2, N, K, R) describing the optical response on a 1-D energy grid.
            energies (numpy.ndarray): 1-D array of energy values in electronvolts (eV) corresponding to the spectral grid produced by the folding routine. Length equals the number of sampled energy points determined by emin, emax and de (or by the folding routine if de is None).
            eps1 (numpy.ndarray): Real part of the macroscopic dielectric function epsilon1(omega) evaluated at each energy in energies. Dimensionless. Computed as 1 + pre * folded_real_part where pre = 4*pi/volume * Bohr**3 * Hartree**2 and folded_real_part is obtained from Lorentzian folding of oscillator strengths.
            eps2 (numpy.ndarray): Imaginary part of the macroscopic dielectric function epsilon2(omega) evaluated at each energy in energies. Dimensionless. Computed from the folded imaginary pole contributions scaled by the same physical prefactor.
            N (numpy.ndarray): Real part of the complex refractive index (commonly called the refractive index n) evaluated at each energy in energies. Dimensionless. Calculated from eps1 and eps2 via N = sqrt(0.5*(sqrt(eps1**2 + eps2**2) + eps1)).
            K (numpy.ndarray): Imaginary part of the complex refractive index (the extinction coefficient k) evaluated at each energy in energies. Dimensionless. Calculated via K = sqrt(0.5*(sqrt(eps1**2 + eps2**2) - eps1)).
            R (numpy.ndarray): Normal-incidence reflectance (reflection coefficient) computed from N and K at each energy: R = ((N - 1)**2 + K**2) / ((N + 1)**2 + K**2). Dimensionless, ranges between 0 and 1 for physically valid N and K.
    
    Notes:
        This function is intended for use in GPAW's linear-response TDDFT workflows to obtain optical spectra (dielectric function, refractive index, extinction coefficient, reflectivity) from a list of calculated excitations. The routine assumes SI-consistent internal conversion constants (Hartree and Bohr) as used throughout GPAW; ensure the provided volume and requested energyunit are consistent with these expectations.
    """
    from gpaw.lrtddft.dielectric import get_dielectric
    return get_dielectric(
        exlist,
        volume,
        emin,
        emax,
        de,
        energyunit,
        width,
        comment,
        form
    )


################################################################################
# Source: gpaw.lrtddft.spectrum.rotatory_spectrum
# File: gpaw/lrtddft/spectrum.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_lrtddft_spectrum_rotatory_spectrum(
    exlist: list = None,
    filename: str = None,
    emin: float = None,
    emax: float = None,
    de: float = None,
    energyunit: str = "eV",
    folding: str = "Gauss",
    width: float = 0.08,
    comment: str = None
):
    """gpaw.lrtddft.spectrum.rotatory_spectrum writes a folded rotatory spectrum produced by linear-response time-dependent density-functional theory (TD-DFT) calculations performed with GPAW. The function takes a list of excitation objects (produced by GPAW linear-response routines), extracts excitation energies and rotatory strengths, optionally converts energy units to wavelength (nm), applies a spectral folding/broadening kernel (Gaussian or Lorentzian) to produce a continuous spectrum on an energy (or wavelength) grid, and writes a two-column text output (energy or wavelength and rotatory strength) either to a file or to standard output. The output includes a header identifying the spectrum type, the GPAW version, the folding and width used (if any), and the column units ("om [energyunit]" and "R [cgs]").
    
    The function is used in the GPAW DFT/TD-DFT workflow to produce rotatory (optical activity) spectra from discrete excitation results: exlist should contain excitation objects that implement get_energy() and get_rotatory_strength(), where get_energy() returns excitation energy in atomic units (Hartree) as produced by GPAW linear-response solvers, and get_rotatory_strength() returns rotatory strength in cgs units consistent with the output header. Energies are converted to electronvolts (eV) by multiplying by the module-level Hartree conversion factor, and if energyunit is 'nm' energies are converted to wavelength (nanometers) using fundamental constants. If folding is provided (default 'Gauss'), the function constructs a Folder(width, folding) and calls its fold(x, y, de, emin, emax) method to obtain a sampled spectrum; if folding is None, the function writes the raw discrete energies and rotatory strengths.
    
    Behavior and side effects:
    - If filename is provided, the function opens that file for writing and writes the header and spectrum lines; if filename is None the function writes the same output to sys.stdout. If comment is provided it is written as an initial commented line.
    - The function prints a header that includes the folding method and width (with the energyunit) and the GPAW version string obtained from the module-level variable version.
    - The numeric output format is two whitespace-separated columns per line: energy (formatted with 10.5f) and rotatory strength (formatted with 12.7e).
    - The function does not return a value; its primary effect is to write the spectrum to the chosen output stream or file.
    
    Failure modes and error conditions:
    - energyunit must be exactly 'eV' (default) or 'nm'. Any other value causes a RuntimeError('currently only eV and nm are supported').
    - exlist must be an iterable list of excitation objects. If exlist is None or not iterable, a TypeError or similar iteration error will occur. If any excitation object does not implement get_energy() or get_rotatory_strength(), an AttributeError will be raised.
    - I/O errors can occur when opening or writing to the given filename (e.g., permission or filesystem errors).
    - Errors raised by the Folder(width, folding).fold(...) call (for example due to invalid folding string, incompatible width, or missing/invalid de/emin/emax) will propagate from that routine.
    - The function assumes get_energy() returns energies in Hartree atomic units (so multiplication by the module-level Hartree constant yields energies in eV) and that get_rotatory_strength() returns rotatory strengths in cgs units consistent with the header.
    
    Args:
        exlist (list): Iterable list of excitation objects produced by GPAW linear-response TD-DFT. Each excitation object is expected to provide get_energy() returning the excitation energy in Hartree (atomic units) and get_rotatory_strength() returning the rotatory strength in cgs units. The function iterates over exlist to build the discrete energy and rotatory-strength arrays; if exlist is None or not iterable an error will occur.
        filename (str): Path to an output file. If provided, the function writes the header and spectrum to this file (opened with mode 'w'); if None (default) the function writes to sys.stdout. I/O errors from opening or writing the file will propagate.
        emin (float): Minimum energy (or wavelength when energyunit == 'nm') for the folded spectrum grid passed to the Folder.fold method. If None, folding may use a default range defined by the Folder implementation; the exact behavior is delegated to Folder.fold.
        emax (float): Maximum energy (or wavelength when energyunit == 'nm') for the folded spectrum grid passed to the Folder.fold method. If None, folding may use a default range defined by the Folder implementation; the exact behavior is delegated to Folder.fold.
        de (float): Energy (or wavelength when energyunit == 'nm') grid spacing passed to Folder.fold. This defines the sampling step for the folded spectrum. If None, Folder.fold may decide a default spacing; the exact behavior depends on the Folder implementation.
        energyunit (str): Unit for the output energy axis. Supported values are 'eV' (default) or 'nm'. When 'eV' the function outputs excitation energies in electronvolts after converting from Hartree. When 'nm' the function converts excitation energies to wavelength in nanometers using fundamental constants (2*pi*_hbar*_c/_e and a factor 1e9) and outputs wavelengths in nm. Any other value raises RuntimeError('currently only eV and nm are supported').
        folding (str): Folding (broadening) kernel to apply to the discrete spectrum. Defaults to 'Gauss' for Gaussian broadening; the code comment indicates 'Gauss' or 'Lorentz' are valid kernel names accepted by Folder. If folding is None, no folding is applied and the raw discrete energies and rotatory strengths are written. If folding is provided, a Folder(width, folding) is constructed and its fold(x, y, de, emin, emax) method is used to produce the sampled spectrum; errors from Folder are propagated.
        width (float): Width parameter for the folding kernel (interpreted in the units given by energyunit). Default is 0.08. When folding is not None the width is passed to Folder(width, folding) and its meaning is determined by the chosen kernel (e.g., Gaussian sigma or Lorentzian half-width). The value is printed in the output header together with the energyunit.
        comment (str): Optional free-text comment string. If provided, the function writes a commented line ('#', comment) at the top of the output before the standard header. Useful to annotate the output file with calculation-specific notes.
    
    Returns:
        None: The function does not return a Python value. Its effect is to write a two-column text spectrum to the given filename or to standard output. The first column contains energies (or wavelengths when energyunit == 'nm') and the second column contains rotatory strengths (R) in cgs units. The header documents the folding, width, units, and GPAW version.
    """
    from gpaw.lrtddft.spectrum import rotatory_spectrum
    return rotatory_spectrum(
        exlist,
        filename,
        emin,
        emax,
        de,
        energyunit,
        folding,
        width,
        comment
    )


################################################################################
# Source: gpaw.matrix.suggest_blocking
# File: gpaw/matrix.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_matrix_suggest_blocking(N: int, ncpus: int):
    """Suggest blocking of an NxN matrix for distributed linear algebra in GPAW.
    
    This function is used inside GPAW (a DFT code that supports parallel calculations via MPI and ScaLAPACK) to choose a processor grid and a block size for distributing an NxN dense matrix across ncpus MPI ranks. The returned values (nprow, npcol, blocksize) are intended for use with ScaLAPACK-style block-cyclic distribution: nprow and npcol define the 2D process grid (rows and columns of MPI processes) and blocksize is the linear block dimension used to partition the matrix. The heuristic aims to make the processor grid as square as possible (minimizing imbalance between nprow and npcol), to guarantee at least one whole block per process dimension and at least two blocks in total, and to choose a power-of-two block size (for performance and compatibility), capped at 64.
    
    Args:
        N (int): The matrix dimension (number of rows and columns of the square matrix). In the GPAW/DFT context this is the global size of a distributed NxN matrix (for example a Hamiltonian or overlap matrix) that will be distributed across processes. The value is used to determine a block size that yields whole blocks and multiple blocks per distributed dimension.
        ncpus (int): The total number of MPI processes available for the distributed calculation. The function attempts to factor ncpus into a 2D grid (nprow, npcol) with npcol chosen as a divisor of ncpus so that nprow * npcol == ncpus; ncpus therefore determines how the global matrix will be partitioned across processes.
    
    Behavior and algorithmic details:
        The routine initializes a 1-by-ncpus grid (npcol = 1, nprow = ncpus) and then searches for the largest npcol_try < nprow that divides ncpus. When such a divisor is found, npcol is set to that divisor and nprow to ncpus // npcol, producing a processor grid where nrow >= npcol and the two dimensions are as close as possible given integer divisors. An assertion verifies that nprow * npcol equals ncpus.
        The block size is computed to ensure at least one whole block and at least two blocks in total along the largest processor grid dimension: initial_block = max((N - 2) // max(nprow, npcol), 1). To favor cache-friendly and commonly optimized sizes, the function then reduces this initial block size to the largest power of two not exceeding it, and finally clamps the block size to the range [1, 64] (inclusive). The resulting blocksize is therefore a power of two, at most 64, and at least 1.
    
    Side effects and defaults:
        This function has no side effects: it does not modify global state, files, or MPI communicators. There are no implicit defaults beyond the algorithm described above; all behavior is determined by the explicit N and ncpus input arguments.
    
    Failure modes and errors:
        An AssertionError is raised if the internal computation fails to produce nprow * npcol == ncpus (the code asserts this invariant). Other exceptions are not raised by the code as written for typical integer inputs, but callers should pass integer values consistent with their MPI configuration and problem size.
    
    Returns:
        tuple: A 3-tuple (nprow, npcol, blocksize) where nprow (int) is the number of process rows, npcol (int) is the number of process columns in the 2D process grid, and blocksize (int) is the chosen linear block dimension (power of two, between 1 and 64). These return values are intended to be used to set up ScaLAPACK-style block-cyclic distribution of an NxN matrix in GPAW parallel calculations.
    """
    from gpaw.matrix import suggest_blocking
    return suggest_blocking(N, ncpus)


################################################################################
# Source: gpaw.lrtddft2.tools.isocubes
# File: gpaw/lrtddft2/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_lrtddft2_tools_isocubes(filename: str, isoval: float, scale: float):
    """gpaw.lrtddft2.tools.isocubes converts a plain-text volumetric grid file produced by GPAW-related workflows into three 2D projection PNG images (XY, XZ, YZ) that visualize positive and negative isosurface contributions on orthogonal planes. This function is intended for use in the lrtddft2 tools of the GPAW package to create simple visual summaries of scalar fields (for example, charge density differences or response densities computed on a real-space grid) by projecting values that exceed a threshold magnitude and mapping them to RGB pixels using a small built-in color scheme.
    
    The function expects a specific plain-text grid layout produced by some GPAW tools: the first two lines are ignored, the third line begins with an integer number of atoms, the next three lines begin with the integer grid dimensions nx, ny, nz (each line may contain extra values that are ignored by this routine), followed by natom lines (which are skipped), and then nx*ny*nz lines each containing a single floating-point scalar value. The value ordering read in the nested loops is x outermost, y middle, z innermost: z varies fastest in the file. For each grid point the routine compares the floating value against the threshold isoval and accumulates projected contributions onto the XY, XZ and YZ planes. The accumulated projections are scaled, clamped, converted to 8-bit RGB triples and written to three PNG files named filename + '_iso_xy.png', filename + '_iso_xz.png' and filename + '_iso_yz.png'. The function requires the Python Imaging Library (PIL / Pillow) Image module to be importable as Image.
    
    Args:
        filename (str): Path to an input plain-text volumetric grid file. The file must be readable by the current process. The expected content format (used by GPAW-related output) is: two header lines (ignored), a line whose first token is an integer natom, three lines whose first tokens are the integer grid sizes nx, ny, nz respectively, then natom lines (skipped), followed by nx*ny*nz lines each containing a single float scalar value. The function opens the file in text mode with an internal buffer size of 256*1024 bytes and reads values in x-y-z nested order (z fastest). The function will create three PNG files in the same directory as filename by appending suffixes '_iso_xy.png', '_iso_xz.png' and '_iso_yz.png'.
        isoval (float): Absolute threshold used to determine which voxel values contribute to the projections. If a read scalar val satisfies val > isoval it is treated as a positive contribution; if -val > isoval it is treated as a negative contribution. Values with absolute magnitude less than or equal to isoval are ignored (they do not contribute). In the domain of GPAW DFT output this parameter controls which regions of a computed scalar field (for example, regions with sufficiently large density or density difference) are visualized.
        scale (float): Multiplicative scaling factor applied to each contributing voxel value before projection accumulation and color mapping. Each qualifying value is multiplied by scale and added to two internal accumulators per projected pixel; scale therefore controls the visual intensity of features in the generated PNGs. The accumulation is later multiplied by 100 and clamped to the 0–255 range when converted to 8-bit RGB.
    
    Behavior and side effects:
        The routine reads the input file described above and constructs three 2D projection arrays by summing scaled contributions from all voxels whose absolute value exceeds isoval. For positive contributions (val > isoval) the code adds val*scale to both accumulator entries for the projected pixel; for negative contributions (val < -isoval) the code adds -val*scale to the total accumulator and subtracts -val*scale from the signed accumulator. After processing all voxels each accumulator pair [total, signed] is converted into pixel color components by computing n = int(total*100 + 0.5) and d = int(signed*100). If n exceeds 255 it is clamped to 255 and d is rescaled proportionally (d = 255 * d / original_n) to preserve relative signed intensity. The RGB mapping applied is: if d > 0 the pixel is (n, n-d, n-d) (reddish for positive sign), if d < 0 the pixel is (n+d, n+d, n) (bluish for negative sign), otherwise the pixel is (0, 0, 0). Images are created with PIL.Image.new in 'RGB' mode and sizes (nx, ny), (nx, nz) and (ny, nz) for XY, XZ and YZ respectively; pixel (i, j) corresponds to grid coordinate i along the first dimension and j along the second dimension used for that projection. The function writes three PNG files with suffixes '_iso_xy.png', '_iso_xz.png' and '_iso_yz.png' appended to the provided filename.
    
    Failure modes and exceptions:
        If PIL (Pillow) is not installed or Image cannot be imported as Image, an ImportError or ModuleNotFoundError will be raised. If filename does not exist or cannot be opened, an OSError (e.g., FileNotFoundError, PermissionError) will be raised. If the input file does not conform to the expected textual format (missing lines, non-numeric tokens where integers or floats are expected, or fewer than nx*ny*nz data lines), a ValueError or EOFError/StopIteration (or other IO-related exception) may be raised during parsing or conversion. If the parsed grid sizes are nonsensical (zero or negative) or lead to excessively large memory usage, downstream errors or MemoryError may occur. Writing the PNG files may raise OSError on I/O failures (disk full, permission denied, etc.). The function does not perform additional validation beyond the parsing described above.
    
    Returns:
        None: The function has no return value. Its primary effect is to write three PNG image files derived from the input volumetric data to disk with names filename + '_iso_xy.png', filename + '_iso_xz.png' and filename + '_iso_yz.png'.
    """
    from gpaw.lrtddft2.tools import isocubes
    return isocubes(filename, isoval, scale)


################################################################################
# Source: gpaw.lrtddft.spectrum.spectrum
# File: gpaw/lrtddft/spectrum.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_lrtddft_spectrum_spectrum(
    exlist: list = None,
    filename: str = None,
    emin: float = None,
    emax: float = None,
    de: float = None,
    energyunit: str = "eV",
    folding: str = "Gauss",
    width: float = 0.08,
    comment: str = None,
    form: str = "r"
):
    """Write out a folded photoabsorption spectrum computed by linear-response time-dependent DFT (TD-DFT) and save it to a file or STDOUT. This function is used in the GPAW code base to produce a 1D spectrum from an excitation list produced by a TD-DFT calculation (ExcitationList), fold the discrete transitions with a chosen broadening function (Gaussian or Lorentzian) into a continuous spectrum, and write a human- and machine-readable text file containing a header and five columns: energy (in the chosen energy unit), total oscillator strength density and the three Cartesian components. The output can be used for analysis, plotting, or comparison with experiment; the function itself does not perform the TD-DFT calculation but relies on the provided excitation data and the helper get_folded_spectrum to compute the folded spectrum.
    
    Args:
        exlist (list): List-like object containing excitations (conceptually an ExcitationList produced by GPAW linear-response TD-DFT). Each item encodes transition energies and oscillator strengths used to construct the folded spectrum. This parameter is required for meaningful output; if None or malformed, the underlying spectrum construction routine (get_folded_spectrum) will raise an error.
        filename (str): Path to the output file where the spectrum will be written. If None, the function writes to standard output (STDOUT). When a filename is provided the function opens the file for writing, writes the header and spectrum lines, and closes the file before returning. IO errors while opening or writing the file propagate to the caller.
        emin (float): Minimum energy (lower bound) of the output energy grid expressed in the units given by energyunit. If None, the function (via get_folded_spectrum) will choose a lower bound that covers all excitation energies in exlist so that no transitions are omitted from the printed spectrum.
        emax (float): Maximum energy (upper bound) of the output energy grid expressed in the units given by energyunit. If None, the function (via get_folded_spectrum) will choose an upper bound that covers all excitation energies in exlist so that no transitions are omitted from the printed spectrum.
        de (float): Energy spacing (step) between consecutive points on the output energy grid, in the units given by energyunit. If None, the underlying spectrum routine determines a reasonable spacing (typically based on the excitation density or internal defaults). Small de increases resolution but increases output size and computation time.
        energyunit (str): Energy unit for both the printed energy column and the interpretation of width; accepted values are 'eV' or 'nm'. The default is 'eV'. The chosen unit affects the numerical values written and the meaning of the folding width parameter.
        folding (str): Folding (broadening) function applied to discrete transitions to produce a continuous spectrum. Accepted values are 'Gauss' for Gaussian broadening and 'Lorentz' for Lorentzian broadening. If folding is None, no folding summary line is printed in the header; the underlying spectrum routine controls whether folding is applied.
        width (float): Broadening width (full width parameter appropriate for the chosen folding) expressed in the chosen energyunit. Default is 0.08 (in energyunit). This controls the spectral linewidth: larger values produce broader, smoother features; smaller values approach the discrete transitions.
        comment (str): Optional free-form comment string that, if provided, is written to the top of the output file as a commented line (prefixed by '#'). Use this to annotate provenance, calculation parameters, or notes for later users.
        form (str): Choice of oscillator strength representation printed in the header and used to select how oscillator strengths are interpreted for output. Accepted values are 'r' for the length form and 'v' for the velocity form; default is 'r'. If any other value is passed, the function raises an AssertionError.
    
    Returns:
        None: The function does not return a Python value. Instead it produces side effects: it writes a text file (or writes to STDOUT) containing a header with provenance information (a comment line if comment is given, a line stating "Photoabsorption spectrum from linear response TD-DFT", the GPAW version, a folding description if folding is not None, and a line indicating length or velocity form), followed by a column header and one line per energy grid point. Each data line contains the energy (in the chosen unit), the total oscillator strength density and the three Cartesian components formatted to fixed precision. The output file is closed before the function returns.
    
    Behavior, side effects, defaults, and failure modes:
        This routine delegates the numerical generation of the folded spectrum to get_folded_spectrum(exlist, emin, emax, de, energyunit, folding, width, form) and then writes the returned energies and values to the chosen destination. If filename is provided, the file is opened for writing and closed deterministically; any IO-related exceptions (e.g., permission denied, disk full) propagate to the caller. If emin or emax are None they will be chosen to cover the excitations in exlist so no transitions are omitted. If de is None the underlying routine selects an appropriate spacing. The function prints a human-readable header including GPAW version; altering this header would require changing this code. The function asserts that form is either 'r' or 'v'; otherwise an AssertionError is raised. The function may propagate exceptions raised by get_folded_spectrum when exlist is missing, empty, or contains invalid entries, or when numerical issues occur during folding. The formatting of numeric output uses fixed-width columns and scientific notation for oscillator strengths; downstream parsers should expect this layout.
    """
    from gpaw.lrtddft.spectrum import spectrum
    return spectrum(
        exlist,
        filename,
        emin,
        emax,
        de,
        energyunit,
        folding,
        width,
        comment,
        form
    )


################################################################################
# Source: gpaw.lcao.tools.lead_kspace2realspace
# File: gpaw/lcao/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_lcao_tools_lead_kspace2realspace(
    h_skmm: numpy.ndarray,
    s_kmm: numpy.ndarray,
    bzk_kc: numpy.ndarray,
    weight_k: numpy.ndarray,
    direction: str = "x",
    symmetry: dict = {'point_group': False}
):
    """Convert a k-dependent lead Hamiltonian and overlap matrices (provided in reciprocal
    space) into a real-space tight-binding representation suitable for transport
    calculations. This function is part of GPAW's LCAO (linear combination of
    atomic orbitals) tools and is used when building lead Hamiltonians for
    density-functional-theory based quantum transport: for each transverse k-point
    it produces a real-space tight-binding Hamiltonian of doubled size that
    represents two principal layers plus the coupling between them, preserving the
    original complex dtype and k-point weighting used in GPAW calculations.
    
    Args:
        h_skmm (numpy.ndarray): k-dependent Hamiltonian for the lead in reciprocal
            space. In GPAW LCAO context this array encodes the Hamiltonian matrix
            elements as a function of spin and k-point (transverse directions)
            and basis-function indices. The function expects a NumPy array whose
            leading axes correspond to (spin, k-point, basis_index, basis_index)
            or otherwise are compatible with the internal helper get_realspace_hs.
            The array's dtype (possibly complex) is preserved in the returned
            real-space Hamiltonian. This parameter is the input Hamiltonian that
            will be converted to an onsite + coupling tight-binding block form.
        s_kmm (numpy.ndarray): k-dependent overlap matrix for the lead in
            reciprocal space. Analogous to h_skmm, this NumPy array encodes the
            overlap (S) matrix elements as function of k and basis indices. It is
            used together with h_skmm to construct the doubled-site overlap matrix
            in real-space tight-binding form. The dtype and axes must be
            compatible with get_realspace_hs.
        bzk_kc (numpy.ndarray): k-point coordinates or related k-space sampling
            information used to perform the Fourier transform (or equivalent
            reconstruction) from k-space to real-space along the transport
            direction. In GPAW this array participates in selecting transverse
            k-points and weights when calling the internal helper get_realspace_hs.
            Must be a NumPy array in the form expected by the calling code and
            helpers (typically k-point cartesian or crystal coordinates per k).
        weight_k (numpy.ndarray): k-point weights associated with bzk_kc. These
            numerical weights determine the contribution of each transverse
            k-point when converting to a real-space tight-binding description and
            are preserved/transformed to weight_t_k for the returned transverse
            k-point set. Must be a NumPy array with one weight per k-point in
            bzk_kc.
        direction (str): Transport direction along which the k-dependent
            Hamiltonian is converted to real-space tight-binding couplings.
            Accepted values are 'x', 'y' or 'z' (default 'x'). The function maps
            the string to an index via 'xyz'.index(direction) and then constructs
            onsite (R_c = 0) and nearest-neighbor (R_c with unit in this index)
            real-space couplings. If a value other than 'x', 'y' or 'z' is passed a
            ValueError will be raised by the index lookup. This argument selects
            which Cartesian direction is treated as the transport direction and is
            therefore critical for constructing the two-principal-layer tight-
            binding block structure appropriate for transport calculations.
        symmetry (dict): Symmetry control dictionary for the transformation. The
            default is {'point_group': False}. If symmetry['point_group'] is True
            the function currently raises NotImplementedError because point-group
            symmetry handling is not implemented for this transformation.
            Other keys are ignored by this function but may be used elsewhere in
            GPAW. This parameter documents whether additional symmetry-based
            reductions are requested; by default no point-group reduction is used.
    
    Returns:
        tuple: A 4-tuple (ibz_t_kc, weight_t_k, h_skmm, s_kmm) where
        ibz_t_kc (numpy.ndarray): The transverse k-point coordinates (or indices)
            for the transformed/possibly reduced transverse Brillouin zone used in
            the returned tight-binding representation. These are the k-points that
            correspond to the returned weight_t_k and the returned block matrices.
        weight_t_k (numpy.ndarray): NumPy array of weights corresponding to
            ibz_t_kc. These are the transformed or selected transverse k-point
            weights that should be used when summing/integrating quantities over
            transverse k in subsequent transport or electronic-structure
            computations.
        h_skmm (numpy.ndarray): Real-space tight-binding Hamiltonian for the lead
            after conversion. Its dtype is the same as the input h_skmm/h_skii and
            its block structure encodes two principal layers plus coupling:
            h_skmm has shape (nspins, nk_transverse, 2*nbf, 2*nbf) where nspins and
            nk_transverse are determined by the input arrays and helper routines,
            and nbf is the number of basis functions per principal layer. The
            returned matrix is arranged as 2x2 blocks: diagonal blocks are the
            onsite Hamiltonian for each principal layer (identical), the upper
            right block is the coupling from layer 1 to layer 2, and the lower
            left block is the Hermitian conjugate of that coupling.
        s_kmm (numpy.ndarray): Real-space tight-binding overlap matrix with the
            same block structure and layout as h_skmm. Typical shape is
            (nk_transverse, 2*nbf, 2*nbf) (note overlap does not have an explicit
            spin axis in the current code path) and the dtype matches the input
            overlap dtype. Diagonal blocks are onsite overlaps, off-diagonal
            blocks describe overlap between the two principal layers and are
            related by Hermitian conjugation.
    
    Behavior, defaults, side effects, and failure modes:
        - The function processes each transverse k-point independently and builds
          a doubled-size block Hamiltonian representing two principal layers and
          the coupling between them; this representation is commonly used in
          quantum transport (lead) calculations where the transport direction is
          singled out and transverse momenta are conserved.
        - The default transport direction is 'x'. Valid values are 'x', 'y', 'z';
          otherwise 'xyz'.index(direction) will raise ValueError.
        - If symmetry['point_group'] is True the function raises NotImplementedError
          because point-group symmetry handling is not implemented in this
          conversion routine.
        - The input array dtypes (including complex type) and numeric precision are
          preserved in the returned h_skmm and s_kmm arrays.
        - The function does not modify external/global state; it returns newly
          constructed arrays. It does not perform file I/O.
        - The function relies on the internal helper get_realspace_hs to extract
          onsite and nearest-neighbor real-space blocks; if the inputs are not in
          the expected shape or format for that helper, NumPy indexing or shape
          errors will be raised.
        - This routine is intended for use within GPAW's LCAO transport workflows;
          misuse with incompatible array shapes or non-standard k-point arrays may
          produce exceptions (IndexError, ValueError, TypeError) propagated from
          NumPy or the helper functions.
    """
    from gpaw.lcao.tools import lead_kspace2realspace
    return lead_kspace2realspace(h_skmm, s_kmm, bzk_kc, weight_k, direction, symmetry)


################################################################################
# Source: gpaw.lrtddft.spectrum.get_folded_spectrum
# File: gpaw/lrtddft/spectrum.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_lrtddft_spectrum_get_folded_spectrum(
    exlist: list = None,
    emin: float = None,
    emax: float = None,
    de: float = None,
    energyunit: str = "eV",
    folding: str = "Gauss",
    width: float = 0.08,
    form: str = "r"
):
    """Return a folded (convoluted) spectrum computed from a list of linear-response excitations.
    
    This function is used in the GPAW linear-response TDDFT (lrtddft) context to convert a list of excitation objects (each providing an excitation energy and an oscillator strength) into a spectrum suitable for comparison with experiment or plotting. It extracts excitation energies from each excitation object using ex.get_energy(), converts those energies to the requested unit (default 'eV'), extracts oscillator strengths using ex.get_oscillator_strength(form), and either returns the raw (energy, intensity) pairs or convolves them with a spectral kernel (folding) using Folder(width, folding).fold(...). The convolution (folding) produces a continuous spectrum on a specified energy/wavelength grid and is commonly used to simulate finite experimental broadening (e.g., Gaussian or Lorentzian line shapes).
    
    Args:
        exlist (list): List of excitation-like objects produced by GPAW lrtddft routines. Each element must implement get_energy() and get_oscillator_strength(form). get_energy() is expected to return the excitation energy in atomic units (Hartree); the function multiplies that value by the module-level Hartree constant to convert to electronvolts (eV) before any further unit conversion. get_oscillator_strength(form) must return a numeric oscillator strength (intensity) for the requested form; form is forwarded unchanged to that method. Practical significance: exlist provides the discrete transitions (energies and intensities) from which the spectrum is built.
        emin (float): Minimum energy (or wavelength if energyunit == 'nm') for the output spectrum grid. This value is passed directly to Folder.fold(...) and therefore must be expressed in the same physical units as the returned energy axis (determined by energyunit). If None, the Folder.fold implementation will determine behavior (e.g., use data bounds) — Folder.fold may raise an error if explicit bounds are required.
        emax (float): Maximum energy (or wavelength if energyunit == 'nm') for the output spectrum grid. This value is passed directly to Folder.fold(...) and must be in the same units as emin and the returned energy axis. If None, Folder.fold will determine behavior or may raise an error if explicit bounds are required.
        de (float): Energy (or wavelength) grid spacing (step size) for the folded spectrum passed to Folder.fold(...). de is expressed in the same units as energyunit and controls the resolution of the output spectrum. If None, Folder.fold may choose a default step or raise an error depending on its implementation.
        energyunit (str): Unit for the returned energy axis and for emin/emax/de. Supported values are exactly 'eV' (default) and 'nm'. Behavior: when 'eV', excitation energies are returned in electronvolts after conversion from atomic units; when 'nm', excitation energies are converted to experimental wavelength in nanometers using the module constants (hbar, c, e) and returned as wavelengths. Any other value causes a RuntimeError because only 'eV' and 'nm' are supported by the current implementation. Practical significance: choose 'eV' for theoretical comparisons and plotting on an energy axis, or 'nm' to compare directly with many experimental optical spectra.
        folding (str): Folding kernel name or None. If None, no convolution is performed and the function returns the raw energy and oscillator-strength lists (after unit conversion). If a string is provided (for example 'Gauss' or 'Lorentz', which are commonly used and supported in the GPAW Folder implementation), the function constructs Folder(width, folding) and calls its fold(x, y, de, emin, emax) method to produce a continuous, broadened spectrum. Practical significance: set to None to inspect discrete transitions, or choose a kernel to simulate experimental broadening.
        width (float): Width parameter for the folding kernel (Gaussian or Lorentzian). The width is interpreted in the same physical units as the energy axis determined by energyunit: when energyunit == 'eV' the default width=0.08 is in eV; when energyunit == 'nm' the width must be given in nm. This value is passed directly to Folder(width, folding) and controls the half-width (or standard deviation) of the line shape depending on the kernel implementation. Choose this parameter to model instrumental or intrinsic broadening.
        form (str): String forwarded to each excitation's get_oscillator_strength(form) method to select which oscillator strength component to use (for example, different polarization or averaged forms). The exact meanings of allowed form strings are defined by the excitation object implementation in lrtddft. Practical significance: use form to pick the component of oscillator strength relevant to the desired spectrum (e.g., dipole-averaged).
    
    Returns:
        tuple: A pair (energy_axis, spectrum) where energy_axis is a 1-D sequence of floats giving energies (in 'eV') or wavelengths (in 'nm') depending on energyunit, and spectrum is a 1-D sequence of floats giving either the raw oscillator strengths (if folding is None) or the folded (convoluted) spectral intensity produced by Folder.fold(...). Both sequences are aligned and have the same length. Failure modes and side effects: the function raises RuntimeError if energyunit is not 'eV' or 'nm'. If exlist is None or contains objects without the required get_energy/get_oscillator_strength methods, AttributeError or TypeError will be raised during execution. When folding is requested, errors raised by Folder(width, folding).fold(...) (for example due to missing de/emin/emax or invalid kernel name) propagate to the caller. There are no other side effects; the function does not modify the input excitation objects.
    """
    from gpaw.lrtddft.spectrum import get_folded_spectrum
    return get_folded_spectrum(exlist, emin, emax, de, energyunit, folding, width, form)


################################################################################
# Source: gpaw.mpi.run
# File: gpaw/mpi.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_mpi_run(iterators: list):
    """Run through list of iterators one step at a time.
    
    This function is a small synchronization helper used in GPAW (a DFT code that supports MPI parallelism) to advance multiple iterator-like objects in lockstep. In GPAW workflows it can be used to drive multiple per-process or per-task generators (for example, work queues, streaming results, or synchronized producers) so that each call to next() on every iterator corresponds to the same logical step across the collection. The function consumes (advances) the supplied iterator objects and returns the last complete set of values produced by all iterators when the iteration stops.
    
    Args:
        iterators (list): A list of iterator objects to advance in lockstep. Each element must support the iterator protocol (i.e., next(element) is valid). The order of elements in the list determines the order of values in the returned results list. Although the annotated type is list, the implementation also accepts a single iterator object (not wrapped in a list): in that case the function will fully exhaust the single iterator by iterating over it (for i in iterators: pass) and then return None. If a non-list, non-iterator value is passed, a TypeError may be raised by the for-loop or by next().
    
    Returns:
        list or None: If a non-list iterator was passed, or an empty list was passed, the function returns None after consuming the iterator(s) as a side effect. If a non-empty list of iterators is passed, the function repeatedly calls next() on every iterator, collecting the returned values into a list in the same order as the input list on each cycle. When any iterator raises StopIteration, the function stops and returns the last successfully collected list of values (the results from the most recent full cycle). The returned list therefore contains one element per input iterator and represents the final successful synchronized step.
    
    Behavior, side effects, and failure modes:
    - The function advances (consumes) the provided iterator objects. After return, iterators may be partially or fully exhausted depending on when StopIteration occurred.
    - If iterators is not a list, the function treats it as a single iterator and exhausts it; this is a deliberate implementation behavior to support both single-generator and list-of-generators usage patterns in GPAW code paths.
    - If the provided list is empty, the function returns immediately with None and does not perform any next() calls.
    - If any element of the list is not an iterator (i.e., does not support next()), next() will raise a TypeError.
    - If a StopIteration occurs during the first attempt to advance all iterators (i.e., before any complete cycle finishes), the implementation does not set the results variable and will raise an UnboundLocalError (NameError) when attempting to return results. This is an implementation detail that callers should be aware of: ensure iterators are initially capable of producing at least one value per element if you expect a results list to be returned.
    - The function can block if any of the iterators block on next(); in MPI-based or I/O-bound generators this means the caller may wait until all iterators produce values or until one raises StopIteration.
    """
    from gpaw.mpi import run
    return run(iterators)


################################################################################
# Source: gpaw.new.gpw.as_single_precision
# File: gpaw/new/gpw.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_new_gpw_as_single_precision(array: numpy.ndarray):
    """gpaw.new.gpw.as_single_precision converts a NumPy array holding 64-bit real or complex floating-point numbers into a newly allocated NumPy array using 32-bit single-precision storage. This function is used in the GPAW DFT codebase to reduce memory footprint and communication volume (e.g., in MPI-parallel calculations) by casting double-precision arrays (numpy.float64 or numpy.complex128) to the corresponding single-precision types (numpy.float32 or numpy.complex64) while preserving array shape and numeric values to the extent representable in single precision.
    
    Args:
        array (numpy.ndarray): Input array containing floating-point data. The function requires that array.dtype is exactly numpy.float64 for real-valued data or numpy.complex128 for complex-valued data; these are the 64-bit types produced by many GPAW and NumPy operations in DFT workflows. The role of this argument is to supply the numeric data to be converted to single precision. Passing an array with a different dtype will cause the function to fail (see Raises). The function treats the input array as read-only and does not modify it in place.
    
    Returns:
        numpy.ndarray: A new NumPy array containing the same values and shape as the input but stored in single precision: numpy.float32 if the input was numpy.float64, or numpy.complex64 if the input was numpy.complex128. This return value is an independent copy (not a view) so subsequent in-place changes to the returned array do not affect the original array. The conversion preserves values within the precision limits of 32-bit floats; users should be aware that numeric precision is reduced and some small differences may occur compared to the original 64-bit data.
    
    Raises:
        AssertionError: If array.dtype is not one of the supported 64-bit types (numpy.float64 or numpy.complex128), the internal assertion fails and an AssertionError is raised. This explicit check prevents accidental conversion of integer or other unsupported types.
    
    Notes:
        - Side effects: None on the input array; the function allocates and returns a new array.
        - Practical significance: Use this function when memory, storage, or communication bandwidth is a limiting factor in GPAW simulations and single-precision accuracy is acceptable. Do not use it when full double-precision accuracy is required for numeric stability or final results.
    """
    from gpaw.new.gpw import as_single_precision
    return as_single_precision(array)


################################################################################
# Source: gpaw.new.gpw.as_double_precision
# File: gpaw/new/gpw.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_new_gpw_as_double_precision(array: numpy.ndarray):
    """Convert an array of 32-bit floating-point numbers to 64-bit (double) precision for use in GPAW numerical routines.
    
    This utility is used in the GPAW DFT codebase to promote single-precision numeric arrays—such as wavefunction coefficients, densities, potentials, or other real/complex arrays used in Hamiltonian and multigrid operations—to double precision before performing calculations that require higher numerical accuracy and stability. The function preserves the numeric values while returning a new NumPy array with the promoted dtype. If a None value is passed (commonly used to denote the absence of data in calling code), None is returned unchanged.
    
    Args:
        array (numpy.ndarray): A NumPy array containing numeric data to be promoted to double precision. In the GPAW codebase this typically represents arrays used in electronic-structure calculations (for example, real-valued densities or complex-valued wavefunction coefficients). The function accepts arrays whose dtype is exactly numpy.float32 (single-precision real) or numpy.complex64 (single-precision complex). Passing None is also accepted and returns None. The parameter must be a NumPy ndarray; other types are not accepted by this implementation.
    
    Returns:
        numpy.ndarray or None: If array is None, returns None (no side effects). Otherwise returns a new NumPy ndarray that is a copy of the input with its dtype converted as follows: if the input dtype is numpy.float32 the returned array has dtype numpy.float64; if the input dtype is numpy.complex64 the returned array has dtype complex (the NumPy complex type, typically a double-precision complex type). The original input array is not modified; the returned array is a separate object suitable for use in downstream GPAW routines that require double precision.
    
    Raises / Failure modes:
        AssertionError: Raised when array is not None and array.dtype is not one of [numpy.float32, numpy.complex64]. This enforces that only the two single-precision dtypes handled by GPAW are promoted by this function.
        TypeError / AttributeError: May be raised by NumPy if the provided object is not a numpy.ndarray or does not have a dtype attribute; callers in GPAW should pass valid numpy.ndarray objects or None.
    
    Notes:
        - This function is a small, explicit utility used to standardize numeric precision across GPAW components (plane-wave, real-space grids, multigrid solvers) where double precision is required for accuracy and reproducibility of DFT results.
        - The conversion creates a new array (no in-place modification) to avoid side effects on caller-owned data structures.
    """
    from gpaw.new.gpw import as_double_precision
    return as_double_precision(array)


################################################################################
# Source: gpaw.lrtddft.spectrum.polarizability
# File: gpaw/lrtddft/spectrum.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_lrtddft_spectrum_polarizability(
    exlist: list,
    omega: numpy.ndarray,
    form: str = "v",
    tensor: bool = False,
    index: int = 0
):
    """Evaluate the frequency-dependent polarizability tensor or its projected components using a sum-over-states representation produced by a linear-response TDDFT ExcitationList from GPAW.
    
    This function is used in the gpaw.lrtddft.spectrum module to convert an ExcitationList (collection of excited-state transition objects computed by GPAW linear-response TDDFT) into a complex polarizability as a function of photon energy omega. The result can be used to build optical spectra (absorption, dielectric response) or to extract static and frequency-dependent polarizabilities. The implementation performs the sum-over-states alpha(omega) = sum_ex F_ex / ((E_ex * Hartree)^2 - omega^2) and multiplies by Bohr**2 * Hartree to yield the units reported below. Use this function when you have an ExcitationList where each excitation object exposes an energy attribute (exc.energy, in atomic units of Hartree) and methods get_oscillator_strength(form) and get_dipole_tensor(form) that return oscillator strengths and dipole tensors in the expected form.
    
    Args:
        exlist (list): Sequence of excitation objects (ExcitationList-like). Each element is expected to have an energy attribute (exc.energy, numeric, in Hartree) and to implement get_oscillator_strength(form) and get_dipole_tensor(form). get_oscillator_strength(form) must return an indexable sequence where index 0 is the orientationally averaged oscillator strength and indices 1,2,3 correspond to the xx, yy, zz components used when tensor is False. get_dipole_tensor(form) must return a 3x3 complex array for tensor=True. This argument is the source of transition energies and transition strengths used in the sum-over-states polarizability.
        omega (numpy.ndarray): Photon energy (eV). Array of one or more photon energies at which to evaluate the polarizability. The shape of omega determines the shape of the returned alpha: if tensor is False the return has the same shape as omega; if tensor is True the return has shape omega.shape + (3, 3). Values should be provided in electronvolts because internal calculations compare (exc.energy * Hartree)**2 with omega**2, where Hartree is the conversion factor used in GPAW constants.
        form (str): {'v', 'r'}. Specifies the form of the dipole matrix element used to compute oscillator strengths or dipole tensors. 'v' typically denotes the velocity form and 'r' the length (position) form as provided by the ExcitationList methods. Default is 'v'. The caller is responsible for choosing the form consistent with how the excitation data were produced.
        tensor (bool): If True, compute and return the full complex polarizability tensor alpha_ij(omega) with indices i,j = x,y,z by summing excitation dipole tensors from ex.get_dipole_tensor(form=form). When True, the index argument is ignored. If False (default), compute scalar projections or averaged polarizability components from ex.get_oscillator_strength(form=form) indexed by index.
        index (int): {0, 1, 2, 3}. Selects which component of the oscillator strength to use when tensor is False. 0 returns the orientationally averaged polarizability; 1, 2, 3 return the xx, yy, zz diagonal components respectively. Default is 0. If an out-of-range index is provided, the underlying call to get_oscillator_strength(form) will raise an IndexError.
    
    Returns:
        numpy.ndarray: Complex-valued polarizability alpha(omega) with units e^2 Angstrom^2 / eV. If tensor is False the returned array has the same shape as the input omega array and contains the scalar polarizability (complex) evaluated at each photon energy. If tensor is True the returned array has shape omega.shape + (3, 3) and contains the full 3x3 polarizability tensor at each photon energy. The numerical result is computed as a sum over excitations and multiplied by Bohr**2 * Hartree to convert from internal atomic units to the stated units. Raises IndexError if index is outside {0,1,2,3}; TypeError or AttributeError if excitation objects do not provide the required attributes/methods; numerical warnings may occur near resonant denominators when omega is close to |exc.energy * Hartree| causing large (possibly singular) contributions.
    """
    from gpaw.lrtddft.spectrum import polarizability
    return polarizability(exlist, omega, form, tensor, index)


################################################################################
# Source: gpaw.matrix.matrix_matrix_multiply
# File: gpaw/matrix.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_matrix_matrix_matrix_multiply(
    alpha: float,
    a: numpy.ndarray,
    opa: str,
    b: numpy.ndarray,
    opb: str,
    beta: float = 0.0,
    c: numpy.ndarray = None,
    symmetric: bool = False
):
    """matrix-matrix multiplication wrapper that follows BLAS conventions and is used throughout GPAW for dense linear algebra operations (for example, forming products of Hamiltonian, overlap, and density matrices during DFT/PAW calculations). This function dispatches to the appropriate BLAS routine (dgemm, zgemm, dsyrk, zherk, dsyr2k, zher2k) or PBLAS equivalents for distributed matrices to provide high-performance, possibly parallel, implementations of the operation.
    
    This routine multiplies matrices a and b with optional transposition or conjugate-transposition controlled by opa and opb, scales the product by the real scalar alpha, adds beta times c, and returns the resulting matrix. alpha and beta are real scalars (type float) even when the matrix elements are complex; a, b and c must all have the same element type (all real or all complex) and compatible shapes for the requested operations. Use symmetric=True when the mathematical result is known to be symmetric/hermitian so that only the lower triangle of c is computed and written (this can reduce work and communicate less data for distributed matrices).
    
    Args:
        alpha (float): Real scalar multiplier for the matrix product. In GPAW dense linear algebra contexts this scales the computed product alpha * (A op B). Even for complex-valued matrices, alpha must be a Python float (real) and is broadcast to the complex field when needed.
        a (numpy.ndarray): Left-hand matrix operand. This is the array whose (possibly transposed or conjugate-transposed) values participate in the product. The array's dtype (real or complex) must match b and c. Shapes must be compatible with opa and the shape of b for matrix multiplication; otherwise a ValueError is raised.
        opa (str): Operation to apply to a before multiplication. Must be exactly one of 'N', 'T', or 'C' (case-sensitive). 'N' means use a as-is, 'T' means use the (non-conjugated) transpose a.T, and 'C' means use the conjugate transpose a.T.conj() (for real-valued arrays 'C' is equivalent to 'T'). Invalid values raise an error.
        b (numpy.ndarray): Right-hand matrix operand. This array must have the same dtype as a and c and shapes compatible with opb and a (after applying opa) for matrix multiplication. In GPAW this often represents matrices such as wavefunction coefficients, Hamiltonian blocks, or overlap blocks.
        opb (str): Operation to apply to b before multiplication. Must be exactly one of 'N', 'T', or 'C' (case-sensitive). Semantics are identical to opa: 'N' no-op, 'T' transpose, 'C' conjugate transpose. Mismatched or invalid values result in an exception.
        beta (float): Real scalar multiplier applied to the existing contents of c before adding the scaled product. Defaults to 0.0. As with alpha, beta is a Python float (real) even for complex matrices and will be applied accordingly. Use beta != 0.0 to accumulate results into an existing c.
        c (numpy.ndarray): Output/accumulator matrix. If provided, its dtype must match a and b and its shape must be suitable to receive the result; it will be overwritten in-place (after scaling by beta and adding alpha * product). If c is None, a new numpy.ndarray is allocated to hold the result and is returned. When used with GPAW in parallel/distributed contexts, c may correspond to a distributed matrix object wrapped by internal helpers; in all cases the array returned represents the matrix holding the result.
        symmetric (bool): If True, the routine assumes the mathematical result is symmetric (for real dtypes) or Hermitian (for complex dtypes) and computes/stores only the lower triangle of c (the routine uses dsyrk/zherk/dsyr2k/zher2k where appropriate). Defaults to False. When symmetric=True, only the lower half of c is guaranteed to be evaluated and written; the upper triangle may remain unchanged or undefined.
    
    Returns:
        numpy.ndarray: The resulting matrix c containing the value alpha * (op(a) dot op(b)) + beta * c. If a c array was provided, that same array is overwritten (in-place) and returned. If c was None, a newly allocated numpy.ndarray with the appropriate shape and the same dtype as a and b is returned. If symmetric=True, only the lower triangle of the returned array is guaranteed to contain the computed values; the upper triangle may be left unchanged.
    
    Behavior, side effects, and failure modes:
    - The function dispatches to highly optimized BLAS/PBLAS routines (dgemm/zgemm/dsyrk/zherk/dsyr2k/zher2k) where available to maximize performance in GPAW DFT calculations; for distributed matrices PBLAS equivalents are used and communication patterns follow those libraries.
    - alpha and beta must be Python floats (real scalars). a, b, and c must all have the same numeric dtype (all real or all complex); passing mixed dtypes will raise an exception.
    - opa and opb must be one of 'N', 'T', or 'C' (case-sensitive); other values raise a ValueError.
    - Shapes of a and b (after applying opa/opb) must satisfy standard matrix multiplication rules (inner dimensions must match). The shape of c must match the resulting outer dimensions; otherwise a ValueError is raised.
    - If c is provided it is modified in-place: its previous contents are scaled by beta and then the scaled product is added. If c is None a new array is allocated and returned.
    - When symmetric=True, c must be square and the function will compute and write only the lower triangular part of c. Supplying a non-square c with symmetric=True will result in an error.
    - For complex input arrays, 'C' requests the conjugate transpose; for real arrays 'C' behaves the same as 'T'.
    - Exceptions raised by underlying BLAS/PBLAS providers (e.g., due to out-of-memory or MPI communication errors in distributed runs) propagate up to the caller.
    """
    from gpaw.matrix import matrix_matrix_multiply
    return matrix_matrix_multiply(alpha, a, opa, b, opb, beta, c, symmetric)


################################################################################
# Source: gpaw.new.brillouin.ranks
# File: gpaw/new/brillouin.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_new_brillouin_ranks(N: int, K: int):
    """gpaw.new.brillouin.ranks computes a deterministic mapping from k-point indices to MPI rank indices for parallel k-point distribution used in GPAW's Brillouin-zone (k-point) parallelization logic. This function is used by the gpaw.new.brillouin module to assign each of K k-points to one of N MPI ranks so that the k-point workload is distributed as evenly as possible across ranks in density-functional theory (DFT) calculations.
    
    Args:
        N (int): Number of MPI ranks (processes) available for distributing k-points. In the context of GPAW and parallel k-point sampling, N corresponds to the size of the MPI communicator used for k-point parallelization. Must be a positive integer; if N is zero a ZeroDivisionError will result from the underlying integer division.
        K (int): Total number of k-points to distribute. K is the length of the k-point list or sampling grid for which the mapping is required. Must be a non-negative integer. In typical DFT runs K >= 0; negative values are not meaningful for k-point counts and the function's behavior is undefined for negative K.
    
    Returns:
        : A one-dimensional NumPy integer array of length K (shape (K,)) where the element at index k (0 <= k < K) is the MPI rank index (an integer in the range 0..N-1) responsible for processing k-point k. The distribution aims to balance the number of k-points per rank: some ranks receive floor(K/N) k-points and the remaining ranks receive ceil(K/N) k-points so that the difference between any two ranks' assigned counts is at most one. The returned array is suitable for indexing, grouping, or scattering k-point work among MPI ranks in GPAW's Brillouin-zone handling code.
    
    Behavior and algorithmic details:
        The function performs integer division and remainder computations (n, x = divmod(K, N)) to compute the base number n = floor(K/N) and remainder x = K % N. It then constructs an array of length K in which the first (N - x) ranks are assigned n k-points each and the remaining x ranks are assigned n+1 k-points each. Specifically, ranks 0 through N-x-1 receive n k-points and ranks N-x through N-1 receive n+1 k-points. The mapping is produced in O(K) time and uses O(K) memory for the returned array. The function is deterministic: for the same N and K it always returns the same mapping.
    
    Side effects:
        None. The function does not modify external state, files, or MPI communicators; it only returns the computed mapping array.
    
    Failure modes and errors:
        A ZeroDivisionError will be raised if N == 0 because division by zero is attempted. The function assumes N > 0 and K >= 0; supplying negative K is invalid for k-point counts and may lead to unexpected results. Invalid non-integer types for N or K will lead to TypeError or ValueError raised by Python arithmetic operations.
    
    Example:
        For N = 4 MPI ranks and K = 6 k-points, the function returns an array mapping k-point indices to ranks: array([0, 1, 2, 2, 3, 3]) so that ranks 0..3 are assigned 1,1,2,2 k-points respectively.
    """
    from gpaw.new.brillouin import ranks
    return ranks(N, K)


################################################################################
# Source: gpaw.new.zips
# File: gpaw/new/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_new_zips(*iterables, strict: bool = True):
    """gpaw.new.zips returns a generator that yields tuples of items taken in lockstep from each of the provided input iterables, following the behavior specified in PEP 618. It is intended for use in GPAW workflows (DFT calculations, geometry and property loops, parallel processing helpers) where multiple sequences (for example atom positions and corresponding forces, arrays of k-points and weights, or parallel chunk descriptors) must be advanced together and strict length agreement between those sequences is required by default.
    
    Args:
        iterables (iterable): One or more iterable objects to be zipped together. Each item yielded by the returned generator is a tuple whose jth element is the next value from the jth iterable. The function calls iter() on each argument to obtain an iterator; therefore non-iterable arguments will raise TypeError when zips() is called. If no iterables are supplied (no positional arguments), the function returns immediately (None) rather than returning an empty generator.
        strict (bool): If True (the default), zips enforces that all input iterables have exactly the same length and raises ValueError when a length mismatch is detected. If False, zips behaves like the usual zip: it stops when the shortest iterable is exhausted and does not raise an error. The strict flag controls post-iteration validation only; it does not change the element-by-element yielding order or the fact that iterators are advanced by calling next().
    
    Behavior and side effects:
        The function is a generator: calling gpaw.new.zips(...) returns an iterator that yields tuples. For each yielded tuple, the generator advances each underlying iterator exactly once by calling next() on it. If any iterator raises StopIteration while building a tuple, iteration stops. After the first StopIteration, if strict is True the function performs additional checks to detect which argument was shorter or longer and raises ValueError with a message constructed exactly as in the implementation (examples: "zips() argument 2 is shorter than argument 1" or "zips() argument 4 is longer than arguments 1-3"). If strict is False, no length-checking exceptions are raised and iteration simply ends at the shortest iterable. Because iterators are advanced, passing iterators with side-effecting next() implementations will trigger those side effects as iteration proceeds. If called with no iterables, the function returns None immediately and produces no generator or yields.
    
    Failure modes:
        Passing a non-iterable as one of iterables raises TypeError when iter() is called on that argument.
        If strict is True and the input iterables have differing lengths, a ValueError is raised after iteration completes. The ValueError message identifies which argument is shorter or longer using the same index-based wording produced by the implementation.
        If an iterator raises an exception other than StopIteration during next(), that exception propagates to the caller.
    
    Returns:
        iterator of tuple: A generator/iterator that yields tuples where each tuple contains one element from each provided iterable in the same order as the arguments. If no iterables are passed, the function returns None instead of an iterator and has no yields (side effect: immediate return).
    """
    from gpaw.new import zips
    return zips(*iterables, strict)


################################################################################
# Source: gpaw.new.lcao.forces.add_den_mat_paw_term
# File: gpaw/new/lcao/forces.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_new_lcao_forces_add_den_mat_paw_term(
    b: int,
    dO_ii: numpy.ndarray,
    P_Mi: numpy.ndarray,
    dPdR_vMi: numpy.ndarray,
    erhoT_MM: numpy.ndarray,
    indices: list,
    F_av: numpy.ndarray,
    my_row_range: tuple
):
    """gpaw.new.lcao.forces.add_den_mat_paw_term: Calculate and add the PAW density-matrix contribution to atomic forces.
    
    This function implements the PAW (projector-augmented wave) correction to the forces that arises from the density-matrix term in GPAW's LCAO code path. In density-functional theory calculations using the PAW method (as described in the repository README), the total atomic forces include a contribution from the PAW augmentation that depends on derivatives of the projector functions and the density matrix. add_den_mat_paw_term computes that contribution for a block of projector rows (my_row_range), accumulates per-projector quantities using a BLAS-like routine (mmm), contracts them with a precomputed erhoT_MM tensor, and then distributes the resulting force increments to the atomic force accumulator F_av for the involved atoms. The implementation loops over the three Cartesian directions (v = 0,1,2) and updates F_av in-place.
    
    Args:
        b (int): Index of the "other" atom or projector block that participates in the two-body PAW density-matrix term. In the code comment this is the atom index labeled b in the summation; the computed contribution is added to F_av[b, v]. This integer is used to identify which atom (or projector group) receives the positive counterpart of the force increment.
        dO_ii (numpy.ndarray): On-site derivative of the overlap/occupancy-related matrix for the local projectors (dtype array). This array contains quantities labelled i,i in the code and is used as input to the BLAS-like multiplication (mmm) to form intermediate arrays. Its length (first dimension) must match the expected projector-index range used together with P_Mi; mismatched shapes will raise errors or produce incorrect results.
        P_Mi (numpy.ndarray): Projector coefficient matrix P with indices (M, i) as used in the PAW formalism. The code uses len(P_Mi) to determine the number of projectors M in the local block. P_Mi provides the projector amplitudes that enter the construction of Z_MM via matrix products with dO_ii and dPdR_vMi. The dtype of P_Mi is used to choose numeric accumulation precision.
        dPdR_vMi (numpy.ndarray): Derivative of the projector functions with respect to atomic Cartesian coordinates. This is indexed as [v, M_local_range, i] where v is the Cartesian direction (0..2). The function slices this array with my_row_range to obtain the local rows of the derivative for the current process/block. The array must provide valid derivatives for the same projector indexing as P_Mi and dO_ii; shape mismatches or invalid slicing (out of range indices) are failure modes.
        erhoT_MM (numpy.ndarray): Precomputed contracted energy-density-like tensor with indices (M_local_range, M_projector) and the same shape as the temporary Z_MM produced in the function. It is contracted with Z_MM via a real part of an elementwise product and summed over the second index to produce ZE_M. The shapes of erhoT_MM and the produced Z_MM must match exactly for the einsum 'MN, MN -> M' operation to succeed.
        indices (list): A list of index-triplets used to map projector-row ranges to atoms. Each element must be a tuple (a, M1, M2) where a is an atom index (integer) and M1, M2 are integer global row-range bounds for projectors associated with atom a (inclusive/exclusive as used in the caller). The function uses these to decide which atoms receive the negative contribution and which atom b receives the positive counterpart. If indices contain values inconsistent with my_row_range or F_av shape, the caller may get indexing errors.
        F_av (numpy.ndarray): Force accumulator array that stores forces per atom and Cartesian direction. This array is modified in-place: F_av[a, v] is decremented and F_av[b, v] is incremented by computed amounts dE for each relevant (a, M1, M2) index and Cartesian direction v. Typical shape is (n_atoms, 3) but only the requirement that the array can be indexed by atom indices a and b and by v=0..2 is enforced by the code. The caller must provide a writable numpy.ndarray of an appropriate floating dtype.
        my_row_range (tuple): Two-integer tuple (m1, m2) that selects the local slice of projector rows to be processed by this call. The function allocates temporary arrays Z_MM of shape (m2 - m1, len(P_Mi)) and loops only over the rows in this half-open range; the caller must ensure that this range corresponds to the portion of global projector rows owned by the current process or worker.
    
    Returns:
        None: This function does not return a value. Side effects: F_av is updated in-place with the PAW density-matrix correction to the forces for the atoms referenced by indices and by b. The function also allocates and uses temporary arrays (Z_MM, dOP_iM) internally and relies on the external BLAS-like routine mmm for dense multiplications and accumulations.
    
    Behavior, side effects, and failure modes:
        - The function computes intermediate arrays using numpy and a BLAS-like mmm routine. The numeric dtype of P_Mi determines the dtype used for temporary arrays.
        - For each Cartesian direction v in (0,1,2) the function forms Z_MM = dPdR_vMi[v, m1:m2] * (dO_ii @ P_Mi) (implemented via mmm calls), contracts Z_MM with erhoT_MM to form a per-projector scalar array ZE_M, and then uses indices to accumulate scalar contributions dE to the atomic force accumulator F_av.
        - All array shapes must be compatible: in particular, Z_MM and erhoT_MM must have identical shapes for the einsum contraction; len(P_Mi) and the second dimension of Z_MM must match; slicing dPdR_vMi[v, m1:m2] must be valid for the provided my_row_range.
        - The function updates F_av in-place: F_av entries for atoms a and for atom b are modified. Callers should ensure F_av is initialized and appropriately shared/locked in parallel contexts.
        - Possible failure modes include IndexError from invalid my_row_range or indices entries, ValueError from incompatible array shapes during mmm or einsum calls, and TypeError if provided objects are not numpy.ndarray or do not support required indexing/operations. These errors are raised by NumPy/BLAS routines; the function does not catch them internally.
        - Numerical precision and performance depend on the dtype of inputs and the implementation of the mmm routine; callers concerned with parallel distribution or precision should follow the GPAW conventions for array ownership and dtype selection.
    """
    from gpaw.new.lcao.forces import add_den_mat_paw_term
    return add_den_mat_paw_term(
        b,
        dO_ii,
        P_Mi,
        dPdR_vMi,
        erhoT_MM,
        indices,
        F_av,
        my_row_range
    )


################################################################################
# Source: gpaw.new.gpw.convert_to_new_packing_convention
# File: gpaw/new/gpw.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_new_gpw_convert_to_new_packing_convention(a_asp: dict, density: bool = False):
    """Convert arrays from the old packing convention to the new packing convention used in GPAW.
    
    This function is used in the GPAW codebase (a DFT code based on the PAW method and NumPy arrays) to change how matrix-like, packed data are stored inside a dictionary of arrays. For each value array in the input dictionary a_asp, the function reconstructs a full 2D (or higher-dimensional) representation using either unpack_hermitian (for Hermitian-packed data) or unpack_density (for density-specific packing) and then replaces the original packed storage in-place with the elements taken from the lower-triangular indices of the reconstructed array. This implements the following illustrative re-ordering of a 3x3 example from the old convention (left) to the new convention (right):
    
        1 2 3      1 2 4
        . 4 5  ->  . 3 5
        . . 6      . . 6
    
    Args:
        a_asp (dict): A dictionary whose values are array-like containers holding packed matrix data in the old packing convention. Each value is assumed to be compatible with NumPy indexing and slice assignment (as used in GPAW). The typical use in GPAW is that these arrays represent packed Hermitian matrices, density-related packed objects, or similar two-index quantities stored in a compact form; the function will iterate over a_asp.values(), reconstruct full arrays, and overwrite each array value in-place with the new packing ordering.
        density (bool): If False (default), each value array is interpreted as a Hermitian-packed object and is reconstructed by calling unpack_hermitian(a_sp). If True, each value array is interpreted as a density-packed object and is reconstructed by calling unpack_density(a_sp). The choice affects how the full array is reconstructed before extracting the lower-triangle elements to form the new packing.
    
    Returns:
        None: The function does not return a value. Instead, it has the side effect of modifying the arrays stored as values in the input dictionary a_asp in-place. After the call, each previously-packed array in a_asp will contain elements ordered according to the new packing convention derived from the lower-triangle of the reconstructed full arrays.
    
    Behavior, side effects, defaults, and failure modes:
        The conversion is performed in-place: the original array objects referenced by a_asp are mutated via slice assignment (a_sp[:]). The default behavior (density=False) uses unpack_hermitian to reconstruct full symmetric/Hermitian arrays; setting density=True uses unpack_density which may handle density-specific reconstruction details. The function uses NumPy's tril index selection (numpy.tril_indices) on the second axis size of the reconstructed array (a_sii.shape[1]) and assigns a_sii[(...,) + L] into the original packed storage.
        Errors will propagate from the called unpack_hermitian/unpack_density functions or from NumPy indexing operations if the values in a_asp are not compatible with those operations or if array shapes are inconsistent with expectations (for example, mismatched dimensionality, sizes that make tril indexing invalid, or non-array-like values). These errors are not caught inside the function and will surface to the caller as standard Python/NumPy exceptions (e.g., ValueError, IndexError, TypeError) depending on the underlying failure.
        This function is intended for use within GPAW data migration or internal routines that need to standardize packed storage; it is not intended to create new arrays or to validate input beyond relying on the behavior of unpack_hermitian/unpack_density and NumPy indexing.
    """
    from gpaw.new.gpw import convert_to_new_packing_convention
    return convert_to_new_packing_convention(a_asp, density)


################################################################################
# Source: gpaw.new.magma.eigh_magma_cpu
# File: gpaw/new/magma.py
# Category: valid
################################################################################

def gpaw_new_magma_eigh_magma_cpu(matrix: numpy.ndarray, UPLO: str):
    """Wrapper for MAGMA symmetric/Hermitian eigensolvers (CPU version) that diagonalizes a real symmetric or complex Hermitian matrix and returns its eigenvalues and orthonormal eigenvectors. In the GPAW DFT codebase this function is used to obtain eigenvalues (for example Kohn–Sham energies) and eigenvectors (orbitals represented in the computational basis) from Hermitian matrices such as Hamiltonians or overlap matrices; it delegates the heavy lifting to MAGMA via the cgpaw interface and adapts MAGMA's output to NumPy conventions.
    
    Args:
        matrix (numpy.ndarray): Square input matrix of shape (N, N) to diagonalize. Must be symmetric (dtype numpy.float64) or Hermitian (dtype numpy.complex128). The matrix is passed to the MAGMA wrapper provided by cgpaw; callers should not assume the input buffer is preserved (underlying MAGMA routines may copy or overwrite the array). The routine selects the MAGMA routine based on the matrix dtype: complex128 selects the Hermitian routine, float64 selects the real symmetric routine. If the array has any other dtype a TypeError is raised.
        UPLO (str): Indicates which triangle of the matrix is stored and therefore used by the MAGMA routine. Must be either 'U' for upper triangle or 'L' for lower triangle. This matches the standard LAPACK/MAGMA convention; providing any other value may cause the underlying MAGMA wrapper to raise an error.
    
    Returns:
        tuple[numpy.ndarray, numpy.ndarray]: A pair (w, v) where:
            w (numpy.ndarray): One-dimensional array of shape (N,) containing eigenvalues in ascending order. These correspond to physical quantities such as orbital energies when the input matrix is a Hamiltonian; ordering is ascending for predictable selection of lowest/highest states.
            v (numpy.ndarray): Two-dimensional array of shape (N, N) whose columns are orthonormal eigenvectors in NumPy convention. The eigenvector corresponding to w[i] is v[:, i]. Internally MAGMA produces eigenvectors in rows; this function conjugates and transposes MAGMA's output so that eigenvectors appear in columns with the correct complex conjugation for Hermitian problems.
    
    Failure modes and side effects:
        This function asserts that MAGMA support is available in the cgpaw build: if MAGMA was not compiled into cgpaw, an AssertionError with the message "Must compile with MAGMA support" is raised. If matrix.dtype is not numpy.complex128 or numpy.float64 a TypeError("Unsupported matrix dtype") is raised. If the input matrix is not actually symmetric/Hermitian the numerical results are undefined and the underlying MAGMA routine may fail or return garbage. The UPLO argument must be 'U' or 'L' or the MAGMA wrapper may raise an error. The function may copy or overwrite the input matrix buffer depending on the MAGMA wrapper implementation; do not rely on the input remaining unchanged after the call.
    """
    from gpaw.new.magma import eigh_magma_cpu
    return eigh_magma_cpu(matrix, UPLO)


################################################################################
# Source: gpaw.new.orbmag.calculate_orbmag_from_density
# File: gpaw/new/orbmag.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_new_orbmag_calculate_orbmag_from_density(D_asii: dict, n_aj: list, l_aj: list):
    """Calculate orbital magnetic moment vectors for each atom from atomic density matrices.
    
    This function is used within the GPAW DFT codebase (projector-augmented wave method) to extract the atomic orbital contribution to the magnetic moment from per-atom PAW/partial-wave density matrices. It assumes D_asii is present on every MPI rank (the function is not parallelised) and computes, for each atom a, the 3 Cartesian components of the orbital magnetic moment by evaluating traces of the atomic electron-density block with precomputed angular-momentum operator matrices for each radial partial wave.
    
    Args:
        D_asii (AtomArrays or dictionary): Atomic density matrix for each atom a. Expected to be a mapping from atom index a (integer) to an array-like D_sii where the first axis s enumerates spin/charge blocks with length 4 (s = 0 corresponds to the electron density, s = 1,2,3 correspond to spin components x,y,z). For each atom a, D_sii[0] must be a square numpy.ndarray giving the electron density matrix in the basis of partial waves (i index runs over all partial-wave functions for that atom). This argument is read-only; the function does not modify D_asii. The function assumes D_asii is available on every MPI rank and will raise AssertionError if, for any atom, D_sii does not have length 4 along the s-axis.
        n_aj (List of lists of integers): For each atom a, a list of principal quantum numbers n_j for each radial partial wave j. The outer list is indexed by atom a in the same ordering/association as D_asii keys; the inner list gives one integer per radial function j for that atom. A negative n_j denotes an unbounded radial function (these partials are skipped and contribute zero). The principal quantum numbers determine which radial blocks are summed; only partial waves that share the same radial index j (i.e., belong to the same radial function) may give nonzero contributions.
        l_aj (List of lists of integers): For each atom a, a list of angular momentum quantum numbers l_j for each radial partial wave j. The outer list is indexed by atom a matching D_asii and n_aj. Each l_j is used to select the corresponding precomputed orbital angular-momentum operator block L_vlmm[v][l_j] (v = 0,1,2 for x,y,z) whose shape is (2*l_j+1, 2*l_j+1). The function assumes the ordering and block sizes implied by l_aj match the block partitioning of the per-atom partial-wave basis encoded in D_asii[0].
    
    Returns:
        numpy.ndarray: A two-dimensional numpy array of shape (N_atoms, 3) where N_atoms == len(n_aj). Each row orbmag_av[a] contains the three Cartesian components (x, y, z) of the orbital magnetic moment vector computed for atom a by summing, for each radial function j with n_j >= 0, the real part of the trace of the electron-density sub-block D_ii corresponding to that radial function with the corresponding angular-momentum operator matrix L_vlmm[v][l_j]. The returned array contains floating-point values; no units are added or converted by this function (consumers should interpret units consistent with the caller/context within GPAW).
    
    Behavior and important details:
        - The function iterates atoms by zipping D_asii.items(), n_aj and l_aj. The atom index keys in D_asii are bound to the variable a and should match the logical ordering/association of the lists in n_aj and l_aj; mismatched ordering or incompatible lengths may produce incorrect results or IndexError.
        - For each atom, the function asserts that D_sii.shape[0] == 4. If this assertion fails, an AssertionError is raised indicating the provided density array does not have the expected spin/charge blocks.
        - Only D_sii[0] (the electron density block) is used for the orbital-moment calculation; spin blocks D_sii[1:4] are ignored by this function.
        - The partial-wave index i enumerates all partial waves for the atom; the radial index j enumerates distinct radial functions. The code accumulates contributions only over diagonal blocks of size (2*l_j+1) corresponding to each radial function j. The running index Ni is used to slice out the appropriate i-range for that radial function.
        - Partials with n_j < 0 are skipped (treated as unbounded radial functions that do not contribute); Ni is advanced appropriately to keep indexing consistent.
        - For each Cartesian component v (0=x,1=y,2=z), the contribution is computed as the real part of the sum over i,i' of D_ii[Ni:Ni+Nm, Ni:Ni+Nm] * L_vlmm[v][l_j][i,i'] (implemented via numpy.einsum in the code). This requires that corresponding L_vlmm structures (indexed by v and l) are available in the module environment where the function is executed.
        - The function performs no I/O and has no side effects other than returning the computed numpy array. It does not perform MPI communication; callers must ensure D_asii is replicated on every rank if used in a parallel workflow.
        - Failure modes include AssertionError when D_sii has unexpected shape, IndexError or ValueError if the block partitioning implied by n_aj/l_aj does not match the size of D_sii[0], and KeyError or mismatches if D_asii keys do not correspond to the ordering of n_aj and l_aj.
    """
    from gpaw.new.orbmag import calculate_orbmag_from_density
    return calculate_orbmag_from_density(D_asii, n_aj, l_aj)


################################################################################
# Source: gpaw.new.symmetry.mat
# File: gpaw/new/symmetry.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_new_symmetry_mat(rot_cc: list):
    """gpaw.new.symmetry.mat converts a 3x3 matrix (typically a rotation matrix used in GPAW's symmetry utilities) into a compact, human-readable string representation. This function is intended for producing deterministic textual forms of small integer or numeric matrices for logging, comparison, or inclusion in text output generated by GPAW symmetry code paths.
    
    Args:
        rot_cc (list): A list-like object of row iterables that represents a 3x3 matrix (for example, a rotation matrix). Each element of rot_cc is expected to be an iterable of three numeric values (ints or floats) corresponding to one row of the matrix. The function does not perform strict shape validation: it iterates over rot_cc and each contained iterable, formatting each element with the format specifier f'{r:2}'. Practically, callers should pass a list of three lists (or tuples) each of length three; passing other shapes will produce a string reflecting the provided shape but may not be meaningful in the symmetry context. Elements must be formatable with the format specification '2'; otherwise Python's formatting will raise a TypeError.
    
    Returns:
        str: A string containing the matrix formatted as nested Python-style lists with two-character field alignment for each element, e.g. '[[-1,  0,  0], [ 0,  1,  0], [ 0,  0,  1]]'. The returned string has no side effects and is suitable for human-readable logging or deterministic textual comparisons of rotation matrices used by GPAW.
    """
    from gpaw.new.symmetry import mat
    return mat(rot_cc)


################################################################################
# Source: gpaw.new.lcao.forces.add_den_mat_term
# File: gpaw/new/lcao/forces.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_new_lcao_forces_add_den_mat_term(
    erhoT_MM: numpy.ndarray,
    dThetadR_vMM: numpy.ndarray,
    F_av: numpy.ndarray,
    indices: list,
    mya: list,
    my_row_range: tuple
):
    """gpaw.new.lcao.forces.add_den_mat_term computes and adds the density-matrix (erho) contribution arising from basis-function overlap (the dTheta/dR term) to the atomic force accumulator used in the LCAO (linear combination of atomic orbitals) implementation in GPAW. This function implements the loop over matrix block indices and performs in-place updates to the per-atom force array F_av by contracting the derivative-of-overlap tensor with the transposed density-matrix block using a NumPy einsum and taking the real part with the -2 prefactor that appears in the LCAO expression for the overlap contribution to forces. It is intended to be called during force evaluation (for geometry optimization, molecular dynamics, or force reporting) and is compatible with GPAW's MPI/domain-decomposed data layout when mya and my_row_range restrict the work to the local process.
    
    Args:
        erhoT_MM (numpy.ndarray): The transposed density-matrix block (erho^T) provided as a NumPy array. In the LCAO forces context this array contains density-matrix elements for a global matrix index range; slices of this array indexed by the integer offsets computed from indices and my_row_range are contracted with dThetadR_vMM. The array must be indexable with the integer ranges produced in the function and compatible with the einsum contraction used inside the function.
        dThetadR_vMM (numpy.ndarray): The derivative of the overlap (Theta) with respect to atomic coordinates, given as a NumPy array whose leading axis indexes force components (for example the three Cartesian components) and whose remaining axis/axes index matrix element positions consistent with erhoT_MM. Slices of dThetadR_vMM produced by the local row-range offsets are contracted with corresponding slices of erhoT_MM using the einsum signature used in the function. The array must be indexable with the integer ranges produced in the function and dimensionally compatible with erhoT_MM for the contraction.
        F_av (numpy.ndarray): The per-atom force accumulator to be updated in place. F_av[a, :] is updated for each atom index a processed by this function. The array must support in-place subtraction of the computed vector contribution; its first axis must be addressable by the atom indices a supplied in indices and mya. This array is modified directly (no copy is returned), which is the primary side effect of the function.
        indices (list): A list of index tuples (a, M1, M2) describing blocks of the global matrix associated with atom a. Each tuple supplies an integer atom index a and integer matrix-range bounds M1 and M2 analogous to a block [M1:M2) or a contiguous block of matrix rows/columns. The function iterates over this list and processes only those tuples whose atom a is owned by the local process (membership in mya) and whose matrix block overlaps the local row range my_row_range.
        mya (list): A list of atom indices that are owned or processed by the current MPI rank / local worker. This list is used to skip index tuples for atoms not local to the process; only tuples with a in mya will cause updates to F_av on this process.
        my_row_range (tuple): A two-integer tuple specifying the global row-range assigned to this process (used to compute local slice offsets into erhoT_MM and dThetadR_vMM). The function uses my_row_range to determine overlap between the provided matrix block bounds (M1, M2) and the local rows, to compute local offsets m1 and m2, and to slice the input arrays accordingly. my_row_range must be consistent with the indexing used in indices and the shapes of erhoT_MM and dThetadR_vMM.
    
    Behavior and side effects:
        The function loops over each tuple (a, M1, M2) in indices. For each tuple it first checks that the atom a belongs to mya and that the matrix block [M1, M2) overlaps the local row range my_row_range; only when both conditions are satisfied will that tuple contribute to the local force update. Local slice offsets m1 and m2 are computed from the overlap of [M1, M2) with my_row_range and used to slice erhoT_MM and dThetadR_vMM. The contraction performed is equivalent to subtracting 2 * Re(einsum('vmM, mM -> v', dThetadR_slice, erhoT_slice)) from F_av[a, :], i.e., the function performs F_av[a, :] -= 2 * real(contraction). All updates are performed in place on F_av; no new force array is returned. The factor of -2 and the real-part extraction follow the LCAO expression for the overlap contribution to forces used in GPAW.
    
    Failure modes and requirements:
        If the shapes or indexing conventions of erhoT_MM or dThetadR_vMM are incompatible with the index ranges computed from indices and my_row_range, NumPy indexing errors (IndexError) or shape-mismatch errors (ValueError) will be raised by the slicing or the einsum call. If indices does not contain tuples of three integers (a, M1, M2) the iteration will raise TypeError or unpacking errors. my_row_range must be a two-integer tuple consistent with the global matrix indexing used elsewhere in the driver; incorrect semantics here will lead to incorrect local offsets and either runtime errors or incorrect force updates. The function assumes F_av is writable and that atom indices a address valid rows in F_av.
    
    Returns:
        None: This function does not return a value. Instead, it updates F_av in place by subtracting the computed density-matrix overlap contributions for the atoms and matrix blocks that are local to the current process.
    
    Raises:
        IndexError: If computed slice indices fall outside the bounds of erhoT_MM, dThetadR_vMM, or F_av.
        ValueError: If the arrays cannot be contracted due to incompatible shapes during the einsum operation.
        TypeError: If indices elements are not 3-tuples of integers or if argument types are not numpy.ndarray / list / tuple as required.
    """
    from gpaw.new.lcao.forces import add_den_mat_term
    return add_den_mat_term(erhoT_MM, dThetadR_vMM, F_av, indices, mya, my_row_range)


################################################################################
# Source: gpaw.new.symmetry.safe_id
# File: gpaw/new/symmetry.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_new_symmetry_safe_id(magmom_av: list, tolerance: float = 0.001):
    """Convert a sequence of per-atom magnetic moments into stable integer identifiers used for grouping atoms by magnetic moment in symmetry-related processing within GPAW.
    
    This function is used in gpaw.new.symmetry to mitigate small rounding differences in magnetic moments produced by density-functional theory (DFT) calculations. It assigns an integer identifier to each magnetic moment in magmom_av such that the first occurrence of a distinct magnetic moment value defines a new identifier and any later magnetic moments within the symmetric tolerance range of that first occurrence are assigned the same identifier. The comparison uses the Euclidean norm of the difference between two moment values (so for scalar moments this is the absolute difference). This produces reproducible, compact integer ids that can be used to group atoms in symmetry detection and other analyses where per-atom magnetic moments should be considered equivalent up to a small numerical tolerance. Example: safe_id([1.01, 0.99, 0.5], tolerance=0.025) -> [0, 0, 2].
    
    Args:
        magmom_av (list): A list of per-atom magnetic moments in the order of atoms. Each entry is expected to be a numeric magnetic-moment value (typically a float as produced by GPAW/DFT calculations). The length of this list determines the number of identifiers returned. The function does not modify this list.
        tolerance (float): Numerical tolerance used to decide when two magnetic moments are considered identical. Two moments x and y are treated as the same if numpy.linalg.norm(x - y) < tolerance. Default is 0.001 (1e-3), chosen to tolerate small rounding errors common in DFT magnetic-moment outputs; increasing this value will merge more distinct moment values into the same identifier, while decreasing it will treat near-equal values as distinct.
    
    Returns:
        list: A list of integer identifiers with the same length as magmom_av. Each identifier is the index of the first occurrence of a magnetic-moment value that the element is considered equivalent to (under the specified tolerance). Identifiers start from 0 and increase when a new distinct magnetic-moment value (not within tolerance of any earlier value) is encountered.
    
    Behavior and failure modes:
        The function is pure (no side effects) and deterministically produces ids based solely on the input list and tolerance. If tolerance is negative, no two distinct values will match (because no positive norm will be less than a negative tolerance), effectively giving each element a unique identifier equal to its index. If elements of magmom_av are not numeric or cannot be subtracted / passed to numpy.linalg.norm, a TypeError or ValueError from NumPy will be raised. Care should be taken to choose tolerance consistent with the desired physical equivalence of magnetic moments in symmetry or grouping analyses.
    """
    from gpaw.new.symmetry import safe_id
    return safe_id(magmom_av, tolerance)


################################################################################
# Source: gpaw.nlopt.shg.shg_length_gauge
# File: gpaw/nlopt/shg.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_nlopt_shg_shg_length_gauge(
    w_l: numpy.ndarray,
    f_n: numpy.ndarray,
    E_n: numpy.ndarray,
    r_vnn: numpy.ndarray,
    rd_vvnn: numpy.ndarray,
    D_vnn: numpy.ndarray,
    pol_v: list,
    band_n: list = None,
    ftol: float = 0.0001,
    Etol: float = 1e-06,
    eshift: float = 0
):
    """Compute length-gauge two- and three-band contributions for second-harmonic generation (SHG) by looping over electronic bands.
    
    This function is used in GPAW's nonlinear optics (nlopt) SHG module to assemble the frequency-dependent two-band and three-band terms in the length gauge. It loops over pairs and triplets of electronic bands, applies time-reversal symmetry to reduce the summation, and accumulates complex-valued contributions as functions of the input complex frequency array w_l. The routine expects inputs from a DFT/PAW calculation: band energies, Fermi occupations, interband matrix elements and generalized derivatives. The optional eshift allows a uniform band-gap correction (in eV) commonly used in post-processing GW or scissor-corrected results.
    
    Args:
        w_l (numpy.ndarray): 1D complex array of frequencies at which the SHG response is evaluated. The function returns arrays of the same length, so w_l.size defines the output frequency grid. Denominators in the expressions use w_l and combinations with energy differences, so values of w_l that make denominators very small or zero can lead to large or divergent results.
        f_n (numpy.ndarray): 1D real array of Fermi occupations for each band (length nb). Differences of these values (f_n[n]-f_n[m]) determine whether a band pair/triplet contributes and are compared against ftol to treat near-degeneracies or partial occupations.
        E_n (numpy.ndarray): 1D real array of band energies for each band (length nb). Energy differences E_m - E_n, possibly shifted by eshift multiplied by occupation differences, appear in denominators and resonance conditions; Etol is used to detect and skip near-degenerate energy denominators.
        r_vnn (numpy.ndarray): Complex array of interband dipole/momentum matrix elements with indexing compatible with r_vnn[pol, n, m], where pol selects a polarization component and n,m are band indices. This tensor provides the basic transition elements used in both two-band and three-band terms.
        rd_vvnn (numpy.ndarray): Complex array of generalized derivatives of the position operator, indexable as rd_vvnn[pol1, pol2, m, n]. These appear in the two-band length-gauge expressions and encode gradient-like corrections to the dipole matrix elements used in SHG calculations.
        D_vnn (numpy.ndarray): Complex array of velocity differences or related matrix elements, indexable as D_vnn[pol, m, n]. D_vnn is combined with r_vnn in some two-band terms to form higher-order contributions; its dimensionality must match the band indices used.
        pol_v (list): List (typically of three integers) selecting the polarization components used in the tensor contractions. The code accesses pol_v[0], pol_v[1], and pol_v[2] to pick the relevant components from r_vnn, rd_vvnn, and D_vnn, thereby specifying which tensor element of the SHG response is computed.
        band_n (list or None): Optional list of integer band indices to include in the summation. If None (default), all bands (0..nb-1) are used. Supplying a subset restricts the loop to those bands and is useful to limit computation to valence/conduction subspaces or to test convergence.
        ftol (float): Tolerance for significance of occupation differences (default 0.0001). Occupation differences |f_n[n]-f_n[m]| smaller than ftol are treated as zero, which omits corresponding two-band contributions and prevents spurious contributions from nearly identical occupations.
        Etol (float): Energy tolerance (default 1e-6) used to detect and skip near-degenerate energy denominators in three-band terms. If |Eln - Eml| < Etol the triplet contribution is excluded to avoid division by a nearly zero denominator and reduce numerical instability.
        eshift (float): Uniform band-gap correction in electron volts (eV) applied to some energy differences (default 0). The code adds eshift multiplied by certain occupation differences to modify energy denominators (e.g., Emn = E_m - E_n + (f_n[n]-f_n[m]) * eshift), which is commonly used when applying a scissor correction or approximate quasiparticle shift.
    
    Returns:
        tuple: A pair (sum2_l, sum3_l) of numpy.ndarray objects, each a 1D complex array with length equal to w_l.size.
            sum2_l (numpy.ndarray): Frequency-dependent two-band contribution accumulated over all included band pairs. This term arises from pairwise (n,m) transitions in the length gauge and includes combinations of r_vnn, rd_vvnn, and D_vnn contracted with the polarization indices pol_v. The result is accumulated as complex values and returned for all frequencies in w_l.
            sum3_l (numpy.ndarray): Frequency-dependent three-band contribution accumulated over all included band triplets. This term originates from sequences of transitions (n,m,l) and uses products of three r_vnn elements divided by inter-band energy differences; Etol controls skipping near-degenerate denominators.
        None: There are no additional side effects; the function does not modify inputs in-place. All accumulated results are returned; the caller must handle units and any further post-processing.
    
    Behavior, side effects, defaults, and failure modes:
        - The function assumes time-reversal symmetry and only sums band pairs with m > n (the code skips m <= n) to avoid double counting; this reduces computational cost but requires that the provided matrix elements are consistent with this symmetry.
        - If band_n is None, the function sets band_n = list(range(nb)) where nb = len(f_n). Mismatched lengths among f_n, E_n, and the band-indexed axes of r_vnn/rd_vvnn/D_vnn will lead to IndexError or incorrect results; inputs must be consistent in band dimension.
        - Denominators involving Emn, (w_l - Emn), and (2*w_l - Emn) are computed explicitly. Even though the code avoids some pathological cases (skipping small occupation differences or near-degenerate triplet denominators within Etol), it does not guard against resonant frequencies where denominators become zero (for example w_l equal to Emn or Emn/2). Such resonances produce large values, infinities, or NaNs; the caller should regularize frequencies or filter results if resonant singularities are expected.
        - Numerical stability depends on the choices of ftol and Etol. Larger tolerances exclude more near-degenerate contributions and reduce instabilities at the cost of possibly omitting physically relevant near-degenerate transitions.
        - eshift is applied as a simple uniform correction multiplied by occupation differences (in eV) as used in many post-processing scissor corrections; it does not perform any band-by-band quasiparticle correction and therefore should be used only when such an approximation is appropriate.
        - The function is pure in the sense that it returns new numpy arrays and does not alter the input arrays in-place.
        - Typical use is within GPAW post-processing for SHG spectrum calculation: supply DFT-computed E_n, f_n, and matrix element tensors to obtain the length-gauge two- and three-band contributions as functions of complex frequency w_l.
    """
    from gpaw.nlopt.shg import shg_length_gauge
    return shg_length_gauge(
        w_l,
        f_n,
        E_n,
        r_vnn,
        rd_vvnn,
        D_vnn,
        pol_v,
        band_n,
        ftol,
        Etol,
        eshift
    )


################################################################################
# Source: gpaw.nlopt.shg.make_output
# File: gpaw/nlopt/shg.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_nlopt_shg_make_output(gauge: str, sum2_l: numpy.ndarray, sum3_l: numpy.ndarray):
    """make_output(gauge, sum2_l, sum3_l)
    Concise summary:
        Compute and return the second-order nonlinear susceptibility chi (chi_l) in SI units [m / V]
        for second-harmonic-generation (SHG) calculations in GPAW by multiplying the precomputed
        2-band and 3-band band-sum contributions with the appropriate physical prefactor and combining
        them according to the chosen gauge. This function is used in the gpaw.nlopt.shg module, which
        assembles microscopic band-sum contributions (sum2_l and sum3_l) produced by electronic-structure
        evaluations into a macroscopic second-order response suitable for analysis or comparison with
        experiment.
    
    Args:
        gauge (str): Chosen gauge for combining the band-sum contributions. In the context of SHG and
            optical-response calculations within GPAW, typical values are 'lg' for the length gauge and
            'vg' for the velocity gauge. The gauge controls the algebraic combination of the 2-band
            and 3-band contributions and therefore affects the computed phase and prefactors of chi_l.
            Only 'lg' and 'vg' are implemented. If a different string is provided, the function prints
            a message via parprint and raises NotImplementedError.
        sum2_l (numpy.ndarray): The precomputed "2-bands" term: a NumPy array of the same shape as
            sum3_l containing the contribution from two-band intermediate states to the second-order
            susceptibility. These arrays are expected to contain the band-sum values produced earlier
            in the SHG pipeline and are in atomic units. They may be complex-valued; the function
            multiplies them elementwise with prefactors and imaginary unit factors as required by the
            chosen gauge.
        sum3_l (numpy.ndarray): The precomputed "3-bands" term: a NumPy array of the same shape as
            sum2_l containing the contribution from three-band intermediate states to the second-order
            susceptibility. Like sum2_l, these values are provided in atomic units and are combined
            elementwise with sum2_l and the computed prefactor.
    
    Behavior, side effects, defaults, and failure modes:
        The function constructs a multiplicative prefactor and applies it to an elementwise combination
        of sum2_l and sum3_l to produce chi_l in SI units [m / V]. The prefactor is assembled as
        follows (matching the implementation):
        prefactor = 4.0 * pi            # 4*pi originates from vacuum permittivity expressed in atomic units
        prefactor /= (2.0 * pi)**3      # normalization factor associated with Brillouin-zone volume factors
        prefactor *= (Bohr * 1e-10 * _e) / (Ha / J)
        where Bohr, _e, Ha, and J are the module's physical constants used to convert from atomic units
        (Bohr * elementary charge / Hartree) to SI units (meters per volt). This conversion is required
        because the upstream band-sum arrays sum2_l and sum3_l are produced in atomic units by the GPAW
        electronic-structure routines, while the returned chi_l is expected in SI units for reporting
        or comparison with experiment.
    
        Gauge-dependent combination rules implemented:
        - If gauge == 'lg' (length gauge): chi_l = prefactor * (1j * sum2_l + sum3_l)
          This applies an imaginary prefactor to the 2-band term and adds the 3-band term, consistent
          with the length-gauge form used in this SHG implementation.
        - If gauge == 'vg' (velocity gauge): chi_l = prefactor * 1j / 2 * (sum2_l + sum3_l)
          This applies a common imaginary prefactor with an additional factor of 1/2 and combines the
          two contributions symmetrically, matching the velocity-gauge convention used here.
    
        Side effects:
        - If an unsupported gauge string is provided, the function calls parprint('Gauge ' + gauge + ' not implemented.')
          (a module-specific printing routine used by GPAW) and then raises NotImplementedError.
        - No other global state is modified; the function performs pure array arithmetic and returns
          a new NumPy array.
    
        Failure modes:
        - If sum2_l and sum3_l have incompatible shapes for elementwise operations, NumPy will raise a
          ValueError (or broadcast-related error). The function does not perform explicit shape checks,
          so callers must ensure inputs are broadcast-compatible.
        - If a gauge other than 'lg' or 'vg' is supplied, NotImplementedError is raised after a parprint.
        - If the inputs are not NumPy arrays (despite the annotated type), operations may raise TypeError or
          produce unexpected results; callers should pass numpy.ndarray instances as documented.
    
    Returns:
        numpy.ndarray: The computed second-order susceptibility chi_l in SI units [m / V]. This array is
        produced by elementwise arithmetic and has the same shape as the input arrays sum2_l and sum3_l
        (subject to NumPy broadcasting rules). The returned array contains the macroscopic second-order
        response used in SHG analyses and can be further processed, saved, or compared to experimental
        SI-valued data.
    """
    from gpaw.nlopt.shg import make_output
    return make_output(gauge, sum2_l, sum3_l)


################################################################################
# Source: gpaw.occupations.fermi_dirac
# File: gpaw/occupations.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for fermi_dirac because the docstring has no description for the argument 'eig'
################################################################################

def gpaw_occupations_fermi_dirac(eig: numpy.ndarray, fermi_level: float, width: float):
    """Compute Fermi–Dirac occupations, their energy derivatives, and per-state electronic entropy contributions used for electronic smearing in GPAW.
    
    This routine implements the Fermi–Dirac distribution used in GPAW for converting single-particle eigenvalues (energies) into occupation numbers for finite electronic temperature (smearing). It is typically used in self-consistent-field DFT calculations to obtain fractional occupations for metallic or thermally-broadened systems, and to evaluate the entropic contribution to the electronic free energy. The implementation is numerically stabilized by clipping the reduced energy argument to the range [-100, 100] to avoid overflow in the exponential. The function is pure (no side effects) and returns three numpy arrays corresponding to the occupation, its derivative with respect to eigenvalue, and a per-state entropy-related energy term.
    
    Args:
        eig (numpy.ndarray): Array of single-particle eigenvalues (energies) for which occupations are required. In GPAW this is the set of Kohn–Sham eigenvalues from which electronic occupations are computed. The values must be expressed in the same energy units as fermi_level and width; the function performs vectorized arithmetic on this array and returns arrays of the same shape.
        fermi_level (float): The Fermi level (chemical potential) in the same energy units as eig and width. This parameter shifts the center of the Fermi–Dirac distribution and determines which states are occupied at the given smearing width; in GPAW it typically comes from the current estimate of the electronic chemical potential.
        width (float): Smearing width (thermal broadening) in the same energy units as eig and fermi_level. Practically this acts like kB*T (electronic temperature) and controls the smoothness of the occupation around the Fermi level. Width must not be zero (division by zero will occur). Physically meaningful values are non-negative; very small positive widths approach a step-function occupation, while larger widths produce broader fractional occupations. The implementation clips the reduced argument to [-100, 100] to maintain numerical stability for extreme values.
    
    Behavior and numerical details:
        The function computes the reduced argument x = (eig - fermi_level) / width and clips x to [-100, 100] to prevent overflow in the exponential. It then computes the occupation f = 1 / (1 + exp(x)), the derivative dfde = (f - f**2) / width (the derivative of the occupation with respect to eigenvalue), and an entropy-related per-state energy term e_entropy computed internally as width * (x*exp(x)/(1+exp(x)) - log(1+exp(x))) (the implementation performs algebraically equivalent operations to avoid catastrophic cancellation). If eig contains NaN or infinite values, results will propagate those values. If width == 0 a ZeroDivisionError or invalid values will result; negative width values are mathematically allowed by the formula but are physically nonstandard and will invert the occupation step.
    
    Returns:
        Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]: A tuple of three numpy arrays, each having the same shape as eig:
            f: numpy.ndarray: The Fermi–Dirac occupation numbers for each eigenvalue, in the range (0, 1), giving the fractional occupancy used in GPAW electronic-structure calculations.
            dfde: numpy.ndarray: The derivative of the occupation with respect to the eigenvalue, ∂f/∂ε. This quantity is used in response calculations and in constructing smeared density matrices; it scales as 1/width.
            e_entropy: numpy.ndarray: Per-state electronic entropy-related energy contribution (in the same energy units as eig and width) used when evaluating the entropic term in the electronic free energy. This value is computed consistently with the occupations and width returned above.
    """
    from gpaw.occupations import fermi_dirac
    return fermi_dirac(eig, fermi_level, width)


################################################################################
# Source: gpaw.nlopt.matrixel.get_rml
# File: gpaw/nlopt/matrixel.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_nlopt_matrixel_get_rml(
    E_n: numpy.ndarray,
    p_vnn: numpy.ndarray,
    pol_v: list,
    Etol: float = 1e-06
):
    """get_rml computes position and velocity-difference matrix elements used in GPAW DFT calculations.
    
    Args:
        E_n (numpy.ndarray): One-dimensional array of band energies (length nb). In the GPAW/DFT context these are the eigenvalues for electronic bands; they are used to form energy differences E_n - E_m that enter denominators for position matrix elements and to identify near-degenerate states.
        p_vnn (numpy.ndarray): Momentum matrix elements. Expected to be indexable over Cartesian components and bands (code assumes a first axis of length 3 and two band axes of length nb, i.e. shape (3, nb, nb)). Each entry p_vnn[v, n, m] corresponds to the momentum matrix element between bands n and m for Cartesian component v, and these are used to compute position operator matrix elements via the relation r = p / (i * ΔE).
        pol_v (list): Iterable of integer component indices (e.g. 0, 1, 2) selecting which Cartesian components to compute. The function iterates over set(pol_v) and uses each value as an index into the first axis of p_vnn. In GPAW this controls which Cartesian polarization/velocity components are processed when constructing matrix elements for response or optical calculations.
        Etol (float): Energy tolerance (default 1e-6). Energy differences |E_n - E_m| smaller than Etol are treated as degenerate to avoid numerical division by zero; such differences are temporarily set to a nonzero value for the division and the corresponding position matrix elements are explicitely zeroed afterwards. The default value matches the function's built-in safeguard.
    
    Returns:
        r_vnn (numpy.ndarray): Complex array of position matrix elements with shape (3, nb, nb). For each Cartesian component v selected via pol_v, r_vnn[v, n, m] is computed as p_vnn[v, n, m] / (1j * (E_n[n] - E_n[m])) with entries for near-degenerate pairs (|E_n - E_m| < Etol) set to zero. Physically, these r_vnn values approximate <n|r|m> from momentum matrix elements and band energy differences and are commonly used in optical response and transition-matrix computations within GPAW.
        D_vnn (numpy.ndarray): Complex array with shape (3, nb, nb) giving velocity-difference (diagonal momentum difference) matrix elements. For each selected component v, D_vnn[v, n, m] = p_n[n] - p_n[m], where p_n is the diagonal of p_vnn[v]. These differences appear in intraband/interband separation and related response expressions.
    
    Detailed behavior, side effects, and failure modes:
        The function allocates and returns new numpy arrays (r_vnn and D_vnn) and has no external side effects. Internally it constructs the matrix of pairwise energy differences E_nn = E_n[:, None] - E_n[None, :], identifies entries with absolute value below Etol as degenerate (zeroind), sets those E_nn entries to 1 for the purpose of safe division, computes r_vnn for each component in set(pol_v) as p_vnn[v] / (1j * E_nn), then resets the entries r_vnn[v, zeroind] to 0 to reflect degeneracy handling. D_vnn is constructed from the diagonal elements of p_vnn[v] using broadcasting to form pairwise differences. If input shapes are inconsistent (for example E_n is not one-dimensional of length nb, or p_vnn does not have compatible band axes), or if pol_v contains indices outside the valid range for p_vnn's first axis, the code may raise IndexError or broadcasting-related exceptions; the function does not perform explicit shape validation beyond relying on numpy broadcasting and indexing. The default Etol value is used when the parameter is omitted.
    """
    from gpaw.nlopt.matrixel import get_rml
    return get_rml(E_n, p_vnn, pol_v, Etol)


################################################################################
# Source: gpaw.nlopt.matrixel.get_derivative
# File: gpaw/nlopt/matrixel.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_nlopt_matrixel_get_derivative(
    E_n: numpy.ndarray,
    r_vnn: numpy.ndarray,
    D_vnn: numpy.ndarray,
    pol_v: list,
    Etol: float = 1e-06
):
    """Compute the generalised derivative of position matrix elements used in response calculations (optical and transport properties) within the GPAW density-functional theory framework. This function combines band energies, momentum matrix elements and velocity-difference matrix elements to produce the complex generalized derivative tensor rd_vvnn that is used when evaluating derivatives of position-dependent operators and related response tensors in band-structure based calculations.
    
    Args:
        E_n (numpy.ndarray): 1D array of band energies (eigenvalues) indexed by band index. The function uses these energies to form energy differences E_nn = E_n[:, None] - E_n[None, :], which determine denominators in the derivative formula and are critical for identifying degenerate or nearly-degenerate band pairs in DFT/PAW calculations.
        r_vnn (numpy.ndarray): Array of momentum (position) matrix elements. The first index selects a tensor/polarization component (typically Cartesian components used in optical response, e.g. 0..2), and the remaining indices run over band indices. In practice this is the set of r^{v}_{n n'} matrices for each v; the function accesses r_vnn[v] for v in pol_v and forms products and dot-products with D_vnn and E_nn to compute the derivative.
        D_vnn (numpy.ndarray): Array of velocity-difference matrix elements with the same convention as r_vnn: the first index selects the tensor/polarization component and the remaining indices run over bands. D_vnn provides the velocity-difference contributions that enter linearly in the numerator of the generalized derivative formula used for response and transport property evaluation.
        pol_v (list): Iterable (list) of integer tensor/polarization indices to include in the computation. Only the unique values in pol_v are processed (the function iterates over set(pol_v)), so duplicate entries are ignored. Typical use is to pass the Cartesian component indices [0, 1, 2] when computing full 3×3 tensors for optical or conductivity response.
        Etol (float = 1e-06): Energy tolerance used to identify degenerate or nearly-degenerate band pairs. Any energy difference |E_n - E_m| < Etol is treated specially to avoid division by zero: the intermediate denominator is set to 1 to avoid a runtime error, and the corresponding output derivative entries are set to zero. The default value 1e-06 matches the original implementation; choosing a smaller tolerance may risk numerical instability for nearly-degenerate states, while a larger tolerance will classify more pairs as degenerate and zero out more derivative entries.
    
    Behavior and side effects:
        The function computes rd_vvnn[v1, v2, n, n'] according to the expression implemented in the source: for each unique pair of tensor indices v1, v2 in pol_v it evaluates
        (r_vnn[v1] * D_vnn[v2].T + r_vnn[v2] * D_vnn[v1].T + 1j * dot(r_vnn[v1], r_vnn[v2] * E_nn) - 1j * dot(r_vnn[v2] * E_nn, r_vnn[v1])) / E_nn,
        where E_nn is the matrix of energy differences. For entries where |E_nn| < Etol the denominator is temporarily set to 1 to avoid division-by-zero and the final rd_vvnn entries for those pairs are explicitly set to zero. The function constructs and returns a complex-valued NumPy array rd_vvnn with shape (3, 3, nb, nb) where nb = len(E_n) according to the implementation; the leading two indices correspond to tensor/polarization components and the last two indices correspond to band indices. There are no other side effects (no global state is modified).
    
    Failure modes and errors:
        If the shapes or indexing conventions of r_vnn, D_vnn and E_n are inconsistent (for example, band-dimension mismatches or pol_v containing indices outside the valid range for the first dimension of r_vnn/D_vnn), NumPy indexing or broadcasting operations will raise exceptions (IndexError or ValueError). The function does not perform explicit shape validation beyond relying on NumPy operations; callers must ensure that r_vnn and D_vnn provide component-indexed matrices compatible with len(E_n).
    
    Returns:
        numpy.ndarray: Complex-valued array rd_vvnn containing the generalised derivative of position matrix elements with shape (3, 3, nb, nb) as constructed by the implementation. The first two indices index tensor/polarization components (Cartesian components used in GPAW response calculations) and the last two indices index the bands (n, n'). The returned tensor is ready for use in subsequent response or optical property calculations in GPAW; entries corresponding to nearly-degenerate band pairs (|E_n - E_m| < Etol) are set to zero as described above.
    """
    from gpaw.nlopt.matrixel import get_derivative
    return get_derivative(E_n, r_vnn, D_vnn, pol_v, Etol)


################################################################################
# Source: gpaw.nlopt.shg.shg_velocity_gauge
# File: gpaw/nlopt/shg.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_nlopt_shg_shg_velocity_gauge(
    w_l: numpy.ndarray,
    f_n: numpy.ndarray,
    E_n: numpy.ndarray,
    p_vnn: numpy.ndarray,
    pol_v: list,
    band_n: list = None,
    ftol: float = 0.0001,
    Etol: float = 1e-06,
    eshift: float = 0
):
    """Loop over bands to compute velocity-gauge second-harmonic generation (SHG)
    terms used in GPAW's nonlinear optical response routines.
    
    This function computes the frequency-dependent two-band (sum2_l) and
    three-band (sum3_l) contributions to the SHG response in the velocity
    gauge. It is intended for use inside GPAW (a DFT/PAW code) postprocessing
    or response modules that evaluate second-order susceptibilities from
    single-particle band energies, occupations and momentum matrix elements.
    The implementation follows the band-sum formulas: it loops over specified
    bands, applies time-reversal symmetry to halve the work (skip m <= n),
    uses occupation differences and energy denominators with optional
    scissors-like bandgap correction (eshift), and discards contributions
    that are numerically singular or degenerate according to the provided
    tolerances (ftol and Etol). The outputs are complex frequency-dependent
    arrays suitable for constructing SHG spectra or further combination with
    prefactors to yield macroscopic susceptibilities.
    
    Args:
        w_l (numpy.ndarray): Complex frequency array at which the SHG response
            is evaluated. This 1-D array provides frequency points (omega or
            omega + i*eta) and determines the length of the returned arrays.
            The function initializes outputs with length w_l.size and computes
            frequency-dependent denominators such as 1/(w_l - Emn) and
            1/(2*w_l - Emn). Practical significance: choose w_l to cover the
            spectral range of interest for SHG (e.g., real frequencies with a
            small imaginary broadening).
        f_n (numpy.ndarray): Fermi occupations (occupation factors) for each
            band index n. This 1-D array of floats determines which band
            transitions contribute via differences fnm = f_n[n] - f_n[m].
            In GPAW DFT domain, f_n typically contains 0/1 for zero
            temperature or fractional occupations for finite-temperature or
            smeared calculations. The ftol parameter below controls when two
            occupations are considered effectively equal (degenerate).
        E_n (numpy.ndarray): Band energies for each band index n. This 1-D
            array of floats (energies in the same units used by the caller)
            is used to form differences Emn = E_m - E_n and other energy
            denominators. The energies combined with eshift implement a
            possible bandgap correction: Emn is shifted by (f_n[n]-f_n[m]) *
            eshift to apply a scissors-like correction only to transitions
            involving occupied <-> unoccupied differences.
        p_vnn (numpy.ndarray): Momentum matrix elements (velocity/momentum
            operator) array used to form tensor contractions. Indexed as
            p_vnn[pol, n, m] in the source code. In practice this is a
            multidimensional numpy array where the first axis indexes
            polarization/Cartesian components or velocity operator components
            and the remaining axes index bands. The function multiplies and
            contracts elements like p_vnn[pol_v[0], n, m] * p_vnn[pol_v[1], m, l]
            * p_vnn[pol_v[2], l, n] to build the relevant matrix-element
            combinations for 2- and 3-band terms. The caller must ensure
            p_vnn has shapes consistent with pol_v and band indices in band_n.
        pol_v (list): List of polarization component indices used to select
            components from the first axis of p_vnn. The source code expects
            pol_v to be an indexable sequence with three entries (pol_v[0],
            pol_v[1], pol_v[2]) that pick which momentum components enter the
            tensor contraction for the desired SHG tensor element. Practical
            significance: pol_v defines the polarization geometry (e.g.,
            x,x,x or x,y,z) of the computed SHG contribution.
        band_n (list, optional): List of band indices to include in the
            triple-sum loops. If None (default), all bands are used (the
            function sets band_n = list(range(nb)) where nb == len(f_n)).
            Providing a subset lets the caller restrict the calculation to a
            valence/conduction window or a set of bands of interest to reduce
            cost. Each index in band_n must be valid for indexing f_n, E_n and
            p_vnn.
        ftol (float, optional): Occupation-difference tolerance (default
            0.0001). Two occupations are treated as effectively equal (and
            transition contributions skipped) when the absolute difference of
            their occupations is <= ftol. This prevents numerical noise from
            creating spurious contributions from degenerate or equally
            occupied bands. Lowering ftol makes the routine more sensitive to
            small occupation differences but can increase numerical noise.
        Etol (float, optional): Energy-difference tolerance (default 1e-6).
            Energy denominators with absolute values <= Etol are considered
            degenerate/singular and the corresponding terms are skipped to
            avoid numerical divergence from small denominators. Choose Etol
            consistent with the energy units and numerical precision of E_n.
        eshift (float, optional): Bandgap correction (default 0). A
            scissors-like correction that is applied in the code as an
            occupancy-weighted energy shift: Emn is computed as
            E_m - E_n + (f_n[n]-f_n[m]) * eshift. Practical significance:
            set eshift to a positive value to open a bandgap correction when
            comparing to experiment or when applying a post-processing
            scissor operator; leave at 0 to use raw DFT energies.
    
    Behavior, defaults, side effects, and failure modes:
        The function performs pure numerical computation and has no external
        side effects (it does not modify global state or files). It returns
        two numpy.ndarray objects (complex) of length equal to w_l.size,
        computed by summing band-pair and band-triplet contributions as in
        SHG velocity-gauge formulas. By default all bands (indices 0..nb-1)
        are included; restrict via band_n to reduce computational cost.
        The function relies on correct shapes and consistent indexing:
        mismatched lengths between f_n, E_n and the band indices in band_n
        or incompatible first-axis indices in p_vnn (with pol_v) will raise
        IndexError or ValueError from numpy. If ftol or Etol are set too
        small, denominators may approach zero and produce very large
        numerical values; conversely, setting them too large may artificially
        discard physically important contributions. The function uses
        time-reversal symmetry to skip terms with m <= n; ensure that
        band_n ordering and provided matrix elements respect the symmetry
        assumptions. The caller is responsible for unit consistency (energies,
        frequencies, eshift) across E_n, w_l and eshift.
    
    Returns:
        tuple (numpy.ndarray, numpy.ndarray): Two 1-D complex numpy arrays
        (sum2_l, sum3_l) of length w_l.size. sum2_l contains the computed
        two-band contributions (frequency-dependent) and sum3_l contains the
        three-band (divergence-free) contributions used in constructing the
        velocity-gauge SHG susceptibility. These arrays can be combined with
        physical prefactors and polarization geometry to yield macroscopic
        second-order response spectra.
    """
    from gpaw.nlopt.shg import shg_velocity_gauge
    return shg_velocity_gauge(w_l, f_n, E_n, p_vnn, pol_v, band_n, ftol, Etol, eshift)


################################################################################
# Source: gpaw.occupations.marzari_vanderbilt
# File: gpaw/occupations.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for marzari_vanderbilt because the docstring has no description for the argument 'eig'
################################################################################

def gpaw_occupations_marzari_vanderbilt(eig: numpy.ndarray, fermi_level: float, width: float):
    """Marzari-Vanderbilt cold-smearing occupation function used in GPAW to compute smeared electronic occupations, their energy derivatives, and per-state entropy energy corrections. This implements the Marzari-Vanderbilt "cold smearing" distribution (see DOI 10.1103/PhysRevLett.82.3296) and is intended for use in electronic-structure (DFT) calculations within GPAW to stabilize convergence for metallic or partially occupied systems by smoothing the occupation step at the Fermi level.
    
    This function evaluates the Marzari–Vanderbilt analytic expressions in a vectorized NumPy form. Given an array of single-particle eigenvalues and a chemical potential (fermi_level), it returns: (1) occupation numbers between 0 and 1 that replace the zero-temperature step function; (2) the derivative of these occupations with respect to the eigenvalue, useful for response or density-derivative calculations; and (3) a per-state energy-like entropy correction term that is used when computing the smeared free-energy correction to the total energy in DFT workflows. All returned arrays have the same shape as the input eig array. The algorithm uses width as the smearing parameter and performs elementwise operations (no in-place modification of inputs).
    
    Args:
        eig (numpy.ndarray): Array of single-particle eigenvalues (energies) for electronic states. In GPAW workflows this is typically the Kohn–Sham eigenvalue array produced by a diagonalization step. The function preserves the shape of eig and returns arrays with the same shape. The energy units must be consistent between eig and fermi_level.
        fermi_level (float): The chemical potential (Fermi level) used as the reference energy for occupations. This scalar shifts the eigenvalues before applying the smearing function; it must be given in the same energy units as eig. Practical significance: occupations are determined relative to this value to model partially filled states near the Fermi surface.
        width (float): Smearing width (sigma) controlling the extent of cold smearing. This scalar sets the energy scale over which the occupation step is smoothed. It must be non-zero; physically meaningful values are positive (width <= 0 will produce division-by-zero or nonphysical results). The choice of width affects convergence: very small widths approach the zero-temperature step and may cause numerical instabilities, while very large widths overly smear occupations and bias energies.
    
    Returns:
        Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]: Three NumPy arrays, each with the same shape as eig:
            f (numpy.ndarray): Occupation numbers computed using the Marzari–Vanderbilt (cold smearing) distribution. Values lie in the interval (approximately) [0, 1] and are used in GPAW to form the electronic density and occupation-weighted quantities in metallic or partially occupied systems.
            dfde (numpy.ndarray): Derivative of the occupation numbers with respect to eigenvalue (df/de). This array is used in response calculations, in constructing density-matrix derivatives, and when evaluating contributions that require the sensitivity of occupations to eigenvalue changes.
            e_entropy (numpy.ndarray): Per-state energy-like entropy correction defined in the implementation as -s * width (where s is computed internally). This array has the same energy units as eig and fermi_level and is used to form the smearing (entropy) correction to the total energy (free-energy correction) in DFT calculations with cold smearing.
    
    Behavior and failure modes:
        - The function is pure (no side effects) and operates via vectorized NumPy operations; inputs are not modified in-place and the outputs are new arrays.
        - If width == 0 a division-by-zero will occur and NumPy will produce Inf/NaN values; callers must ensure width is non-zero. Negative width values will mathematically produce results but are physically meaningless for smearing and may lead to nonphysical occupations.
        - NaN or infinite values in eig or fermi_level will propagate to the outputs according to NumPy broadcasting rules.
        - The function assumes energy-consistent inputs (eig and fermi_level in the same units); incorrect unit usage will lead to incorrect occupations and energy corrections.
    
    Reference:
        Marzari, N. and Vanderbilt, D., "Thermal Contraction of Electrons and the Marzari–Vanderbilt Cold Smearing", Phys. Rev. Lett. 82, 3296 (1999). DOI: 10.1103/PhysRevLett.82.3296
    """
    from gpaw.occupations import marzari_vanderbilt
    return marzari_vanderbilt(eig, fermi_level, width)


################################################################################
# Source: gpaw.occupations.methfessel_paxton
# File: gpaw/occupations.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for methfessel_paxton because the docstring has no description for the argument 'eig'
################################################################################

def gpaw_occupations_methfessel_paxton(
    eig: numpy.ndarray,
    fermi_level: float,
    width: float,
    order: int = 0
):
    """gpaw.occupations.methfessel_paxton computes the Methfessel–Paxton smearing distribution used in GPAW to obtain partial electronic occupations, their energy derivatives, and the per-state electronic entropy contribution for metallic or partially occupied systems. This function implements the standard Methfessel–Paxton expansion: a base Fermi-like occupation given by the complementary error function plus higher-order corrections constructed from Hermite polynomials and coff_function coefficients. It is used in GPAW/ASE workflows to stabilize self-consistent-field (SCF) convergence by smearing occupations near the Fermi level.
    
    Args:
        eig (numpy.ndarray): Array of single-particle eigenvalues (energies) for which occupations are required. The array must contain energies in the same units used by GPAW in the caller context (GPAW/ASE commonly reports energies in eV for user-facing output). The shape of the returned arrays matches the shape of eig; the function operates elementwise and is fully vectorized using NumPy.
        fermi_level (float): The Fermi level (chemical potential) in the same energy units as eig. This scalar shifts the center of the smearing distribution: states with eig < fermi_level are more occupied. Correct choice of fermi_level determines which states receive partial occupations and is critical for meaningful physical results.
        width (float): Smearing width (broadening) parameter in the same energy units as eig and fermi_level. This controls the scale of the transition region around the Fermi level. Larger width increases partial occupations away from the Fermi level and can improve SCF convergence for metals, while too large a width will alter physical occupation statistics. width must be nonzero; width == 0 will cause a division-by-zero error. The function uses width both to scale the reduced energy variable x = (eig - fermi_level) / width and to scale the returned entropy contribution.
        order (int): Non-negative integer order of the Methfessel–Paxton expansion (default 0). order = 0 yields a Fermi-like complementary error-function occupation (no Hermite polynomial corrections). Positive order adds higher-order oscillatory corrections via coff_function(n) and Hermite polynomials hermite_poly(2*i+1, x) and hermite_poly(2*i+2, x), which can improve approximation properties of the smearing but may introduce oscillatory behavior in occupations. The function does not internally coerce or validate order beyond relying on Python's range(order); passing a negative integer will result in no correction terms being added but is not a supported usage.
    
    Returns:
        Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]: A tuple of three NumPy arrays with the same shape as eig.
            The first element is f: the Methfessel–Paxton occupation numbers for each eigenvalue. These are dimensionless occupancies between approximately 0 and 1 produced by the complementary error function base plus optional Hermite corrections, and are intended to be used as partial occupancies in electronic-structure calculations (e.g., to form the electronic density).
            The second element is dfde: the derivative of the occupation with respect to eigenvalue (df/de). This has units of 1/energy (inverse of the units of eig and fermi_level) and is useful for evaluating smeared density-of-states contributions, forces, and for linear-response expressions where the sensitivity of occupations to energy is required.
            The third element is e_entropy: a per-eigenvalue electronic entropy contribution associated with the Methfessel–Paxton smearing. This has the same energy units as width (typically eV in GPAW user workflows) and is returned as a signed energy contribution per state; it is computed from the highest-order Hermite polynomial term and is commonly used to compute entropy-based free-energy corrections when smearing is applied.
    
    Behavior, side effects, defaults, and failure modes:
        The function is pure (no global side effects) and fully vectorized using NumPy operations; it returns new arrays and does not modify eig. It computes the reduced variable x = (eig - fermi_level) / width, a base occupation f = 0.5*(1 - erf(x)), and, if order > 0, adds correction terms using coff_function and hermite_poly with factors exp(-x**2). The derivative dfde is computed consistently including correction terms and scaled by 1/width. The entropy term is computed from the highest-order coefficient and polynomial and multiplied by -width to give an energy-like contribution.
        Invalid inputs lead to runtime errors: width == 0 triggers a ZeroDivisionError; non-array-like eig that cannot be broadcast with NumPy operations will raise a TypeError; providing a non-integer or otherwise inappropriate order may produce unexpected behavior since no explicit type coercion is performed. The function assumes coff_function and hermite_poly are available in the enclosing module and behave as expected; errors raised by those helper functions (e.g., for unsupported polynomial orders) will propagate to the caller.
        Default: order defaults to 0, yielding the complementary-error-function occupation without Hermite corrections.
    """
    from gpaw.occupations import methfessel_paxton
    return methfessel_paxton(eig, fermi_level, width, order)


################################################################################
# Source: gpaw.new.symmetry.find_lattice_symmetry
# File: gpaw/new/symmetry.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_new_symmetry_find_lattice_symmetry(
    cell_cv: numpy.ndarray,
    pbc_c: numpy.ndarray,
    tol: float,
    _backwards_compatible: bool = False
):
    """gpaw.new.symmetry.find_lattice_symmetry determines the set of lattice symmetry operations (3x3 integer matrices with elements in {-1, 0, 1}) that conserve the metric of a given unit cell and that do not swap axes with different periodic boundary conditions. This function is used in GPAW's symmetry handling to identify candidate point-group operations that map the cell basis vectors onto each other while preserving inter-vector lengths and respecting periodicity, which is important for exploiting symmetry in DFT calculations (for example reducing k-point sampling or identifying equivalent atoms).
    
    Args:
        cell_cv (numpy.ndarray): 3x3 array of Cartesian cell vectors that define the unit cell. Each row (or column, depending on calling convention) represents one basis vector in Cartesian coordinates; the function computes metric_cc = cell_cv.dot(cell_cv.T) and therefore expects a square 3x3 numeric array. The metric (inner products of cell vectors) is the quantity that must be conserved by symmetry operations. Supplying an array with incompatible shape or non-numeric entries will lead to NumPy broadcasting/indexing errors.
        pbc_c (numpy.ndarray): 1-D boolean array of length 3 indicating periodic boundary conditions along each Cartesian axis (True if periodic along that axis, False if non-periodic). The function uses pbc_c to build a 3x3 boolean matrix of axis-pair differences (via logical_xor.outer) and then forbids any symmetry operation that would swap two axes for which pbc differs, ensuring that non-periodic directions are not exchanged with periodic ones.
        tol (float): Numeric tolerance controlling how strictly the function requires conservation of the cell metric. The function computes metric_scc for each candidate integer matrix and compares the deviation abs(metric_scc - metric_cc).sum(2).sum(1) to a threshold. If _backwards_compatible is True the threshold is tol; otherwise the threshold is tol**2. Choose tol consistent with the units of metric_cc (squared length units) and the expected numerical noise; extremely small tol may yield an empty operation set, while extremely large tol may admit spurious operations.
        _backwards_compatible (bool): If True, use legacy comparison behavior where the summed absolute difference of metric matrices is compared to tol. If False (the default), compare the summed absolute difference to tol**2. This flag exists to preserve older code behavior when exact numeric interpretation of tol differs between versions; it does not otherwise change how candidate matrices are generated or how pbc constraints are applied.
    
    Behavior and side effects:
        The function enumerates all possible 3x3 matrices with elements in {-1, 0, 1} (3**9 = 19683 candidates) and filters them in two steps:
        1) Keep only matrices for which the transformed metric (U * metric_cc * U^T) matches the original metric within the threshold described above.
        2) Remove any remaining matrices that would exchange axes that have different periodic boundary conditions, as determined from pbc_c.
        There are no external side effects (no file I/O or global state mutation); the function is pure with respect to its inputs and returns the filtered set of operations. The operation enumeration and metric checks are implemented with NumPy vectorized operations; for very large numbers of calls this may have non-negligible CPU and memory cost.
    
    Failure modes:
        If cell_cv is not a 3x3 numeric array or pbc_c is not a boolean array of length 3, NumPy operations inside the function will raise ValueError, IndexError, or TypeError. Using a negative tol is allowed by the numeric comparisons but will typically result in an empty set of symmetry operations unless _backwards_compatible semantics and floating-point rounding make the comparison succeed.
    
    Returns:
        numpy.ndarray: Array of selected symmetry operations with shape (N, 3, 3), where N is the number of operations that passed both metric-conservation and periodic-boundary constraints. Each entry is a 3x3 integer matrix with elements in {-1, 0, 1} expressed in the 1-2-3 Cartesian basis (the same basis used to form cell_cv). If no operation satisfies the criteria, an array with shape (0, 3, 3) is returned.
    """
    from gpaw.new.symmetry import find_lattice_symmetry
    return find_lattice_symmetry(cell_cv, pbc_c, tol, _backwards_compatible)


################################################################################
# Source: gpaw.point_groups.check.sphere
# File: gpaw/point_groups/check.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for sphere because the docstring has no description for the argument 'radius'
################################################################################

def gpaw_point_groups_check_sphere(radius: float, grid_spacing: float):
    """gpaw.point_groups.check.sphere: Return Cartesian coordinates of grid points that lie inside or on a sphere of given radius centered at the origin in a uniform real-space grid. This helper is used by GPAW routines that need a discrete sampling of a spherical region on a regular grid (for example, symmetry checks, point-group operations, or localized real-space operations on the PAW grid).
    
    Args:
        radius (float): Radius of the sphere in the same length units as grid_spacing (e.g., Å when used together with ASE/GPAW coordinates). This controls which grid points are kept: any grid point whose squared distance from the origin is less than or equal to radius**2 is included. The code computes an integer number of grid steps npts = int(radius / grid_spacing) + 1 to construct the grid extent; typical use expects radius >= 0. If radius is zero the function will return only the grid points at the origin (subject to floating-point equality).
        grid_spacing (float): Distance between adjacent grid points along each Cartesian axis, in the same length units as radius. This must be a positive floating-point spacing representing the real-space resolution of the uniform grid used by GPAW. The function uses grid_spacing to build a cubic mesh of points at positions k * grid_spacing for integer k in [-npts, npts].
    
    Detailed behavior:
        The function first determines npts = int(radius / grid_spacing) + 1 and constructs a regular cubic mesh of coordinates x = linspace(-npts, npts, 2*npts+1) * grid_spacing along each axis. It then forms the 3D Cartesian coordinates of the full mesh and filters them by the condition x^2 + y^2 + z^2 <= radius^2 (inclusive of points exactly on the spherical boundary within floating-point precision). The returned array therefore lists only the grid points that fall inside or on the sphere. There are no external side effects; the function does not modify global state or input arguments.
    
    Defaults and performance notes:
        The choice npts = int(radius / grid_spacing) + 1 ensures a symmetric mesh that extends slightly beyond the radius to guarantee coverage of the spherical region with the supplied grid spacing. For small grid_spacing or large radius the temporary full cubic mesh has size (2*npts+1)^3 before filtering; memory and CPU cost grow roughly with the cube of npts (the final number of returned points scales approximately as (4/3)π (radius/grid_spacing)^3). Use coarser grid_spacing or smaller radius to limit memory use.
    
    Failure modes and preconditions:
        The implementation assumes grid_spacing > 0 and radius >= 0 for meaningful physical results. Passing grid_spacing <= 0 will lead to incorrect behavior or runtime errors (for example division by zero or an invalid linspace call). Extremely large radius/grid_spacing ratios can lead to high memory usage or long runtimes; the function does not guard against out-of-memory conditions and will propagate any exceptions raised by NumPy.
    
    Returns:
        numpy.ndarray: A 2-dimensional NumPy array with shape (M, 3), where M is the number of grid points inside or on the sphere. Each row is a Cartesian coordinate triple (x, y, z) in the same length units as the input parameters. The array is in floating-point dtype determined by NumPy operations and contains no additional metadata.
    """
    from gpaw.point_groups.check import sphere
    return sphere(radius, grid_spacing)


################################################################################
# Source: gpaw.nlopt.linear.calc_chi
# File: gpaw/nlopt/linear.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_nlopt_linear_calc_chi(
    w_l: numpy.ndarray,
    f_n: numpy.ndarray,
    E_n: numpy.ndarray,
    p_vnn: numpy.ndarray,
    pol_v: tuple,
    band_n: list = None,
    ftol: float = 0.0001,
    Etol: float = 1e-06,
    eshift: float = 0
):
    """calc_chi computes the band-summed linear-response quantity chi(omega) used in GPAW optical and response calculations.
    
    This function loops over pairs of electronic bands to accumulate a frequency-dependent response sum_l(omega) for the complex frequency points in w_l. It uses Fermi occupations f_n, band energies E_n, and momentum matrix elements p_vnn together with a polarization selector pol_v to form the contribution from each band pair. Time-reversal symmetry is used to reduce the double sum to pairs with m > n and the code multiplies by the appropriate symmetry and real-part factors. The routine is intended for use in GPAW workflows that compute optical properties or susceptibilities from PAW momentum matrix elements and Kohn–Sham eigenvalues.
    
    Args:
        w_l (numpy.ndarray): 1-D array of complex frequency points omega (or Matsubara/frequency grid) at which the response is evaluated. The returned array has length w_l.size and each element corresponds to one frequency in this array. This array is used in the denominator Emn*(Emn**2 - w_l**2) and therefore should be compatible with NumPy broadcasting with scalar Emn values.
        f_n (numpy.ndarray): 1-D array of Fermi occupation numbers for each band n. The length of f_n defines the number of bands nb considered when band_n is None. Differences f_n[n] - f_n[m] are used to weight contributions from transitions and to apply the optional bandgap correction via eshift.
        E_n (numpy.ndarray): 1-D array of band energies (Kohn–Sham eigenvalues) for each band n. Energy differences Emn = E_m - E_n enter the denominator and are also combined with the occupation differences to form the effective transition energies used in the response.
        p_vnn (numpy.ndarray): Array of momentum (or velocity) matrix elements with at least three indices: the first index selects a vector/tensor component, and the next two indices are band indices [pol_component, n, m]. The function accesses p_vnn[pol_v[0], n, m] and p_vnn[pol_v[1], m, n], so the shape must be compatible with the number of bands (len(f_n)) and the integer indices provided in pol_v.
        pol_v (tuple): Tuple of two indices (typically integers) selecting which tensor/vector components of p_vnn to multiply. The tuple elements are used as pol_v[0] and pol_v[1] in the product p_vnn[pol_v[0], n, m] * p_vnn[pol_v[1], m, n], so pol_v defines the polarization channel (for example an xx, xy, etc. component) of the response contribution.
        band_n (list): List of band indices to include in the double sum. If None (the default), the function uses all bands 0..nb-1 where nb = len(f_n). Provided indices must be valid indices for f_n, E_n and the band axes of p_vnn. Using a subset allows restricting the calculation to valence and conduction bands of interest as done in GPAW optical workflows.
        ftol (float): Tolerance on differences of occupations f_n used to identify effectively degenerate (or inactive) transitions. If abs(f_n[n] - f_n[m]) < ftol the pair is skipped. Default is 1e-4. This avoids numerical contributions from transitions with negligible occupation difference.
        Etol (float): Tolerance on energy differences used to identify degenerate or numerically problematic transitions. If abs(Emn) < Etol the pair is skipped. Default is 1e-6. This prevents division by very small Emn and suppresses contributions from near-degenerate states unless the user relaxes this threshold.
        eshift (float): Bandgap correction applied multiplicatively to the occupation difference: Emn is shifted by (f_n[n] - f_n[m]) * eshift. Default is 0. This parameter implements the simple band-gap correction used in some GPAW post-processing workflows where an energy offset is applied only to transitions weighted by occupation differences.
    
    Returns:
        numpy.ndarray: Complex 1-D array sum_l of length w_l.size containing the accumulated response sum for each frequency in w_l. Each element corresponds to the expression summed over band pairs:
        sum_l += 2 * (f_n[n] - f_n[m]) * Re[p_vnn[pol_v[0], n, m] * p_vnn[pol_v[1], m, n]] / (Emn * (Emn**2 - w_l**2))
        where the loop only includes pairs with m > n (time-reversal symmetry) and skips pairs failing the ftol/Etol tests.
    
    Behavior and side effects:
        The function does not modify its input arrays and returns a newly allocated NumPy array. If band_n is None, the function uses all bands determined from len(f_n). The implementation applies a factor of 2 for real-valued contributions and uses only m>n to exploit time-reversal symmetry; contributions from m<=n are omitted by design. The denominators can become large if Emn*(Emn**2 - w_l**2) is close to zero; the Etol and ftol tests filter some problematic cases but users should choose tolerances appropriate to their system to avoid numerical instabilities.
    
    Failure modes and errors:
        The function will raise typical NumPy/IndexError or TypeError exceptions if array shapes or indices are inconsistent (for example, if p_vnn does not have compatible band axes or pol_v contains out-of-range indices). Numerical overflow or large values may occur when Emn*(Emn**2 - w_l**2) is very small even if not strictly zero; adjust Etol/ftol or the frequency grid w_l to mitigate such issues. No other explicit error handling is performed by this routine.
    """
    from gpaw.nlopt.linear import calc_chi
    return calc_chi(w_l, f_n, E_n, p_vnn, pol_v, band_n, ftol, Etol, eshift)


################################################################################
# Source: gpaw.nlopt.shift.shift_current
# File: gpaw/nlopt/shift.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_nlopt_shift_shift_current(
    eta: float,
    w_l: numpy.ndarray,
    f_n: numpy.ndarray,
    E_n: numpy.ndarray,
    r_vnn: numpy.ndarray,
    rd_vvnn: numpy.ndarray,
    pol_v: tuple,
    band_n: list = None,
    ftol: float = 0.0001,
    Etol: float = 1e-06,
    eshift: float = 0.0
):
    """gpaw.nlopt.shift.shift_current computes the frequency-dependent, length-gauge two-band contribution to an optical response (commonly used as part of shift-current or similar nonlinear optical calculations) by looping over pairs of electronic bands. It is intended for use inside the GPAW density-functional-theory codebase where band energies, occupations and matrix elements are provided by a GPAW calculation. The routine constructs a 1D complex frequency-dependent array by summing imaginary parts of products of momentum matrix elements and generalized position-derivative tensors, weighted by Fermi occupation differences and Lorentzian broadening centered at interband transition energies.
    
    Args:
        eta (float): Broadening parameter (positive scalar) that sets the half-width of the Lorentzian used to model lifetime/line-broadening of interband transitions. In practice it controls the smoothing of spectral features in the computed frequency response.
        w_l (numpy.ndarray): 1D array of complex or real frequencies at which the response is evaluated. The returned array has the same length as w_l; w_l values must be given in the same energy/frequency units as E_n and eshift.
        f_n (numpy.ndarray): 1D array of Fermi occupations (floats) for each band index n. The length of f_n defines the total number of bands nb that will be used when band_n is None. Occupation differences f_n[n] - f_n[m] determine which band-pair transitions contribute; pairs with differences below ftol are skipped.
        E_n (numpy.ndarray): 1D array of band energies corresponding to the same band indexing as f_n. Differences E_n[m] - E_n[n] are used to form interband transition energies; these must be provided in the same unit system as w_l and eshift.
        r_vnn (numpy.ndarray): Array of momentum (or velocity) matrix elements indexed as r_vnn[pol_component, m, n]. The first index corresponds to a polarization/component index; the second and third indices correspond to band indices m and n respectively. r_vnn supplies the complex-valued matrix elements r_{v,mn} used in the two-band product.
        rd_vvnn (numpy.ndarray): Array of generalized derivatives of the position operator indexed as rd_vvnn[pol_a, pol_b, n, m]. The first two indices are polarization/component indices and the last two are band indices. rd_vvnn supplies the tensor elements ∂_v r_{b,nm} used together with r_vnn to build the integrand.
        pol_v (tuple): Length-3 tuple of integer indices (pol_a, pol_b, pol_c) selecting which components of r_vnn and rd_vvnn enter the specific tensor contraction for the computed tensor element. Entries of pol_v are used exactly as indices into r_vnn and rd_vvnn.
        band_n (list, optional): Sequence of integer band indices to include in the double loop. If None (default), all bands are used: band_n = list(range(nb)) where nb is len(f_n). The list controls which band pairs (n,m) are evaluated; only pairs with m > n are evaluated (time-reversal symmetry is used to avoid double counting).
        ftol (float, optional): Occupation-difference tolerance (default 1e-4). When absolute(f_n[n] - f_n[m]) <= ftol the band-pair contribution is treated as negligible and skipped. This avoids numerical noise from nearly equal occupations.
        Etol (float, optional): Energy-difference tolerance (default 1e-6). Intended to be the tolerance used to consider bands degenerate in energy when special handling is required. Note: in the current implementation Etol is accepted for API compatibility/documentation of degeneracy handling but is not used internally by the algorithm; callers should be aware that only ftol is used to skip small-occupation contributions.
        eshift (float, optional): Bandgap correction added to the Fermi-difference-weighted transition energy as fnm * eshift (default 0.0). This term allows a rigid shift of transitions proportional to occupation difference, used in some gap-correction schemes; it is added to Emn = E_n[m] - E_n[n] + fnm * eshift before forming the Lorentzian denominators.
    
    Returns:
        numpy.ndarray: 1D complex numpy array of length w_l.size. Each element is the summed, frequency-dependent contribution (multiplied by 2*pi) from evaluated band pairs to the specified tensor element in the length gauge. If inputs have incompatible shapes or pol_v contains invalid indices, the function will raise the corresponding IndexError or NumPy shape error. The function has no other side effects and does not modify its input arrays.
    
    Behavior, side effects, and failure modes:
        The function loops over band pairs (n,m) using time-reversal symmetry to only evaluate pairs with m > n. For each pair it computes fnm = f_n[n] - f_n[m] and Emn = E_n[m] - E_n[n] + fnm * eshift. If abs(fnm) <= ftol the pair is skipped. The spectral weight uses the imaginary part of specific contractions of r_vnn and rd_vvnn and a difference of two Lorentzians centered at ±Emn with half-width eta. The final result is scaled by 2*pi before being returned. If band_n is None, all bands implied by len(f_n) are used. Mismatched dimensions between f_n, E_n and the band indices or incorrect shapes for r_vnn/rd_vvnn will cause standard NumPy indexing/shape errors; the function performs no explicit shape validation beyond relying on these array accesses.
    """
    from gpaw.nlopt.shift import shift_current
    return shift_current(
        eta,
        w_l,
        f_n,
        E_n,
        r_vnn,
        rd_vvnn,
        pol_v,
        band_n,
        ftol,
        Etol,
        eshift
    )


################################################################################
# Source: gpaw.pseudopotential.get_radial_hartree_energy
# File: gpaw/pseudopotential.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_pseudopotential_get_radial_hartree_energy(r_g: numpy.ndarray, rho_g: numpy.ndarray):
    """Get energy of the l=0 (spherically symmetric) compensation charge on an
    equidistant radial grid used in GPAW pseudopotential/PAW routines.
    
    This function is used in the GPAW pseudopotential machinery to compute the
    electrostatic (Hartree) self-energy associated with the l=0 component of a
    compensation charge represented on a 1D radial grid. The routine assumes an
    equidistant radial grid and constructs the integrand used by the Hartree
    solver (hartree_solve) to obtain r*V_H(r) (where V_H is the Hartree potential).
    The final Hartree energy is obtained by integrating 2*pi * ∫ rho(r) V_H(r) r dr
    using the simple trapezoid-like scaling implemented in the source code.
    
    Args:
        r_g (numpy.ndarray): 1D array of radial grid points (r values) in
            ascending order representing the radial coordinate for the
            compensation charge. The function expects an equidistant grid so that
            dr = r_g[2] - r_g[1] is the uniform spacing used internally. The
            first point r_g[0] may be a small nonzero value (e.g. 1e-8) in some
            workflows to avoid division-by-zero in downstream Poisson solvers;
            such shifts are accepted and handled by this routine. The array is
            not modified in-place.
        rho_g (numpy.ndarray): 1D array of the same length as r_g containing the
            radial charge density values for the l=0 compensation charge. Each
            entry corresponds to rho(r) evaluated at the grid points r_g. The
            routine uses these values to form rho(r)*r*dr for the radial Poisson
            problem; rho_g is not modified in-place.
    
    Returns:
        float: The computed Hartree energy (a scalar) for the l=0 compensation
        charge on the provided equidistant radial grid. Numerically, the value is
        2.0 * pi * sum(dr * r_g * rho_g * (r * V_H(r))) where r*V_H(r) is obtained
        by calling hartree_solve(0, rho_r_dr_g, r_g, vh_r_g). The returned type is
        a Python float or a NumPy scalar depending on NumPy configuration.
    
    Behavior and notes:
        - The function computes dr = r_g[2] - r_g[1] and therefore requires that
          len(r_g) >= 3 and that the grid spacing is uniform; if these conditions
          are violated the result will be incorrect or an IndexError may be raised.
        - If rho_g and r_g have mismatched lengths a broadcasting or length
          mismatch error will occur.
        - The routine allocates an internal array vh_r_g (same length as r_g) to
          receive r*V_H(r) from the external hartree_solve function. hartree_solve
          is expected to solve the l=0 radial Poisson equation for the provided
          source term; any failures inside hartree_solve (convergence or domain
          errors) will propagate as exceptions.
        - No external state or input arrays are modified in-place by this
          function; all intermediate arrays are local. The function has no other
          side effects beyond calling hartree_solve.
        - Intended usage context: evaluation of the Hartree contribution of the
          compensation charge in GPAW's PAW/pseudopotential code paths where the
          compensation charge is represented on a spherical (l=0) radial grid.
    """
    from gpaw.pseudopotential import get_radial_hartree_energy
    return get_radial_hartree_energy(r_g, rho_g)


################################################################################
# Source: gpaw.response.chiks.create_get_temporal_part
# File: gpaw/response/chiks.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_chiks_create_get_temporal_part(bandsummation: str):
    """gpaw.response.chiks.create_get_temporal_part selects and returns the function that implements the temporal part of a band-summation based response calculation used in GPAW's response.chiks code path for density-functional theory (DFT) response/susceptibility evaluations.
    
    Args:
        bandsummation (str): Strategy identifier that determines which temporal-part implementation to use when assembling band-summation contributions to a response function. In the context of GPAW (a DFT code using PAW and ASE), this parameter controls how the time-/frequency-dependent factor that multiplies band-index sums is computed. Valid values are the literal strings 'double' and 'pairwise', corresponding to the implementations available in this module. This argument is required (no default) and must be supplied by the caller that constructs or configures response calculations.
    
    Returns:
        function: A callable implementing the chosen temporal-part computation. If bandsummation == 'double', the returned value is get_double_temporal_part; if bandsummation == 'pairwise', the returned value is get_pairwise_temporal_part. The returned callable is intended to be used by higher-level response routine(s) in gpaw.response.chiks to compute the temporal dependence of terms arising from band summations during susceptibility/response assembly.
    
    Behavior and side effects:
        This function is purely a selector/creator: it performs no numerical computation and has no side effects on program state, files, or global configuration. It deterministically returns one of two function objects from the same module based solely on the bandsummation string.
    
    Failure modes:
        If bandsummation is not exactly 'double' or 'pairwise', the function raises ValueError(bandsummation). The ValueError message is the supplied bandsummation value, enabling callers and higher-level code to identify the unsupported strategy string and handle configuration errors in response calculation setup.
    """
    from gpaw.response.chiks import create_get_temporal_part
    return create_get_temporal_part(bandsummation)


################################################################################
# Source: gpaw.quiz.encode
# File: gpaw/quiz.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for encode because the docstring has no description for the argument 'text'
################################################################################

def gpaw_quiz_encode(text: str):
    """gpaw.quiz.encode encodes a Unicode text string by performing a per-character substitution
    using the module-level mapping used to reproduce the transformation in the Python
    "The Zen of Python" (this.py). This function is part of the gpaw.quiz utilities and is
    intended for simple, deterministic text transformations (for example, quiz or
    Easter-egg style encodings that mirror the encoding used by Python's this module).
    
    Args:
        text (str): The input Unicode text to encode. Each character in this string is
            looked up in a module-level dictionary named `d` (the same kind of mapping
            used by Python's this.py implementation of "The Zen of Python"). For every
            character c in `text`, the function replaces c with d.get(c, c) and
            concatenates the results to produce the encoded string. The function expects
            a Python str and treats the input as a sequence of characters; it does not
            modify the input string in place.
    
    Returns:
        str: A new string containing the encoded text. The length of the returned string
        is equal to the length of the input string, and any character not present as a
        key in the module-level mapping `d` is preserved verbatim. The function has no
        side effects (it does not modify global state or the input string); it only
        returns the transformed text.
    
    Notes and failure modes:
        - The function relies on a module-level mapping named `d` to perform substitutions.
          If `d` is not defined in the module namespace when the function is called, a
          NameError will be raised.
        - The function assumes `text` is a str. Passing non-str objects may produce a
          TypeError during iteration or when attempting to join non-str elements into the
          result; such behavior is undefined by this function and callers should pass a
          str to ensure correct operation.
        - The transformation is deterministic and stateless: given the same `text` and
          the same module-level mapping `d`, the function will always return the same
          encoded string.
    """
    from gpaw.quiz import encode
    return encode(text)


################################################################################
# Source: gpaw.pw.descriptor.pad
# File: gpaw/pw/descriptor.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_pw_descriptor_pad(array: numpy.ndarray, N: int):
    """Pad a 1-D complex array with zeros up to a specified length N.
    
    This function is a small utility used in GPAW's plane-wave / descriptor code paths to ensure 1-D arrays of complex coefficients (for example plane-wave coefficients, Fourier components, or descriptor vectors) have a consistent length for further operations such as FFTs, vectorized linear algebra, or GPU-backed computations. The function preserves the original array object when no padding is required, otherwise it allocates a new 1-D complex array of length N and copies the original elements into the beginning, filling the remainder with zeros.
    
    Args:
        array (numpy.ndarray): A 1-D numpy array of complex numbers to be padded. If None is passed, the function returns None immediately (this is used in calling code to indicate the absence of data). The function expects a one-dimensional array representing a sequence of complex coefficients (e.g., plane-wave coefficients). If the provided array already has length N, the same object is returned (no copy). If the array is not a numpy.ndarray instance, the implementation allocates the result using the alternative array backend referenced in the source (cp), so the returned array will be allocated by that backend; the function still treats the input as a 1-D sequence. The input array itself is not modified.
        N (int): Target length (number of elements) for the output array. The result will have shape (N,) and complex dtype. N should be an integer large enough to hold the original data length; negative values are invalid and will cause allocation/validation errors. In the GPAW context, N is typically chosen to match a uniform grid, FFT buffer size, or a fixed descriptor length required by downstream algorithms.
    
    Returns:
        numpy.ndarray or None: If array is None, returns None (no side effects). If len(array) == N, returns the same array object passed in (identity is preserved to avoid unnecessary copying). If len(array) < N, returns a newly allocated 1-D complex array of length N containing the original elements in positions [0:len(array)] and zeros in positions [len(array):N]. When the input is a non-numpy ndarray, the returned object will be allocated with the alternative backend used in the source (cp), matching the backend of the array allocation step.
    
    Behavior and failure modes:
        The function assumes a 1-D input. If the input has length greater than N (len(array) > N), the assignment into the smaller target buffer will fail and raise an error (e.g., ValueError) — callers must ensure N >= len(array) when padding is intended. If N is negative or otherwise invalid for the underlying allocator, an exception will be raised during allocation. The function does not perform deep validation of array dimensionality beyond using len(array); passing higher-dimensional arrays will use their first dimension length and may lead to unexpected results. The output dtype is complex and the function does not preserve any additional metadata (such as strides beyond the created contiguous buffer) from the input.
    """
    from gpaw.pw.descriptor import pad
    return pad(array, N)


################################################################################
# Source: gpaw.response.chiks.get_ecut_to_encompass_centered_sphere
# File: gpaw/response/chiks.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_chiks_get_ecut_to_encompass_centered_sphere(
    q_v: numpy.ndarray,
    ecut: float
):
    """gpaw.response.chiks.get_ecut_to_encompass_centered_sphere computes the minimal plane-wave kinetic-energy cutoff (ecut) required so that a plane-wave basis centered at a reciprocal-space shift q_v contains all reciprocal lattice vectors G that lie inside the original gamma-centered sphere defined by |G|^2 < 2 * ecut. This function is used in GPAW's plane-wave response routines (gpaw.response.chiks) to adjust the energy cutoff when the plane-wave basis is translated by a q-vector so that no G-vectors are lost from the spherical cutoff region.
    
    Args:
        q_v (numpy.ndarray): A NumPy array representing the reciprocal-space shift vector q (the q-centering of the plane-wave basis). In the GPAW/DFT context this vector is the displacement in reciprocal space by which the plane-wave grid is centered; the function uses its Euclidean norm q = ||q_v|| to expand the original gamma-centered cutoff sphere. The array should be a real-valued vector (1-D) compatible with numpy.linalg.norm; passing incompatible types or shapes will cause numpy.linalg.norm to raise an error.
        ecut (float): The original kinetic-energy cutoff defining the gamma-centered sphere through |G|^2 < 2 * ecut. In GPAW plane-wave mode this is the plane-wave energy cutoff supplied by the user. This value is expected to be a non-negative float; negative values will make numpy.sqrt(2 * ecut) invalid (resulting in NaN or complex values) and therefore produce undefined results.
    
    Returns:
        float: The updated minimal kinetic-energy cutoff (ecut) after accounting for the q-centering. The returned float is computed by taking q = norm(q_v) and applying the analytic relation
        ecut_new = ecut + q * (sqrt(2 * ecut) + q / 2),
        which yields the smallest ecut such that a plane-wave basis centered at q contains all reciprocal-lattice vectors G that satisfied the original gamma-centered condition |G|^2 < 2 * ecut. There are no side effects; the function does not modify its inputs in place. Failure modes: if q_v is not a numeric numpy.ndarray or has an incompatible shape, numpy.linalg.norm will raise an exception; if ecut < 0 the computation is invalid and will produce NaN/complex values.
    """
    from gpaw.response.chiks import get_ecut_to_encompass_centered_sphere
    return get_ecut_to_encompass_centered_sphere(q_v, ecut)


################################################################################
# Source: gpaw.occupations.occupation_numbers
# File: gpaw/occupations.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_occupations_occupation_numbers(
    occ: dict,
    eig_skn: numpy.ndarray,
    weight_k: numpy.ndarray,
    nelectrons: float
):
    """Calculate occupation numbers from eigenvalues in eV and return occupations,
    Fermi level and related quantities. This function is deprecated; it issues a
    DeprecationWarning and delegates the actual calculation to an OccupationNumbers
    implementation created from the provided occ dictionary. It is used in the GPAW
    DFT workflow to convert band eigenvalues on IBZ k-points and a total electron
    count into per-spin, per-k-point, per-band occupation numbers (f_skn), the
    Fermi level in Hartree, the total magnetic moment, and the electronic entropy
    term (-S*T) in Hartree. The implementation flattens eigenvalues for use by the
    occupation routine, applies IBZ k-point weights, and reconstructs a
    (nspins, nibzkpts, nbands)-shaped occupation array consistent with eig_skn.
    
    Args:
        occ (dict): Occupation scheme specification used to construct an
            OccupationNumbers implementation. Practical examples from GPAW usage
            include {'name': 'fermi-dirac', 'width': 0.05} where width is given in
            eV. The dict controls how fractional occupations are computed (e.g.
            Fermi-Dirac smearing width or Methfessel-Paxton order). This function
            calls create_occ_calc(occ) internally and then occ.calculate(...).
        eig_skn (numpy.ndarray): Eigenvalues in electron volts (eV) arranged with
            the same indexing convention used by GPAW: shape should be
            (nspins, nibzkpts, nbands). The outer axis indexes spin channels,
            the middle axis indexes irreducible Brillouin zone (IBZ) k-points,
            and the inner axis indexes band eigenvalues. This array provides the
            input single-particle energies from which occupations are derived.
        weight_k (numpy.ndarray): IBZ k-point weights, a 1-D array of length
            nibzkpts that must sum to 1. These weights represent the fractional
            contribution of each IBZ k-point to the Brillouin zone integration.
            The function repeats or expects the occupation calculator to be given
            weights for each spin channel; internally weights are reused in the
            calculation and then applied to the returned per-(k,band) occupations.
            If weight_k does not sum to 1 or its length does not match the number
            of k-points in eig_skn, the resulting occupations will be incorrectly
            normalized or NumPy broadcasting/shape errors may occur.
        nelectrons (float): Total number of electrons in the system. This scalar
            is used to determine the occupation filling (sum of occupations should
            equal nelectrons). The value may be integer or floating point for
            partially occupied systems; it is scaled internally for the number of
            spin channels when calling the occupation routine.
    
    Returns:
        tuple: A 4-tuple containing the following entries.
            f_skn (numpy.ndarray): Occupation numbers shaped like eig_skn,
                i.e. (nspins, nibzkpts, nbands). The entries are dimensionless
                occupation probabilities per spin, k-point and band and are
                normalized so that their sum equals nelectrons (within numerical
                tolerance). For the single-spin (non-spin-polarized) case the
                implementation duplicates occupations to produce two spin
                channels and sets the magnetic moment to zero.
            fermi_level (float): The computed Fermi level given in Hartree units.
                Although input eigenvalues are provided in eV, the occupation
                calculation uses those energies to find the chemical potential and
                the returned value is converted to Hartree before being returned.
            magmom (float): Total magnetic moment in units of electrons (dimensionless),
                computed as the difference between the total occupations of the
                two spin channels (sum_up - sum_down). For the single-spin branch
                this is returned as 0.0 by construction.
            e_entropy (float): Electronic entropy contribution returned as -S*T
                in Hartree units. For single-spin (non-spin-polarized) input the
                entropy returned by the occupation calculator is doubled to match
                the duplicated occupations.
    
    Behavior and side effects:
        This function issues a DeprecationWarning and constructs an occupation
        calculator via create_occ_calc(occ), then calls its calculate(...) method.
        The occupation routine is given a flattened sequence of eigenvalue arrays
        (one array per spin and k-point) and a list of k-point weights replicated
        per spin. The returned per-(k,band) occupations from the occupation
        calculator are multiplied by the IBZ k-point weights before being
        rearranged into the f_skn array. For a single spin-channel input (len(eig_skn) == 1)
        occupations and entropy are doubled and the magnetic moment is set to
        0.0. The function converts the Fermi level and entropy from the units used
        internally by the occupation calculator into Hartree using the module's
        Hartree conversion constant before returning.
    
    Failure modes and notes:
        If weight_k length does not match the number of k-points in eig_skn or
        the shapes do not conform to the assumed (nspins, nibzkpts, nbands)
        structure, NumPy broadcasting errors or incorrect normalization of
        occupations may occur. The function relies on the occ.calculate(...)
        implementation to accept the flattened eigenvalue list and corresponding
        weight list; mismatches between occ configuration and the provided data
        may raise errors. Because this function is deprecated, callers are
        encouraged to use one of the explicit OccupationNumbers implementations
        provided by GPAW for more robust and future-proof occupation handling.
    """
    from gpaw.occupations import occupation_numbers
    return occupation_numbers(occ, eig_skn, weight_k, nelectrons)


################################################################################
# Source: gpaw.raman.raman.plot_raman
# File: gpaw/raman/raman.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_raman_raman_plot_raman(
    figname: str,
    RIsuffix: list,
    relative: bool = False,
    w_min: float = None,
    w_max: float = None
):
    """gpaw.raman.raman.plot_raman plots one or more Raman spectra from NumPy ".npy" Raman intensity files and saves the resulting matplotlib figure to disk.
    
    This function is used in the GPAW DFT workflow to visualize Raman intensities (for example, intensities computed from vibrational analyses or other post-processing steps) stored in files named with the pattern "RI_<suffix>.npy". The function loads the Raman-shift axis and intensity arrays from these files, optionally scales intensities to their maxima (relative plotting), locates spectral peaks in the first file, overlays vertical lines at significant peak positions, and writes a high-resolution figure (dpi=300) to the given filename. The Raman shift axis is treated in units of cm^-1 and intensities are treated as arbitrary units, consistent with typical GPAW/ASE post-processing conventions.
    
    Args:
        figname (str): Path and filename where the output figure will be saved. The file format is inferred from the filename extension (for example ".png", ".pdf"); the function calls matplotlib.pyplot.savefig with dpi=300. On success the file at figname is created or overwritten. If matplotlib cannot write to the location (permission error, invalid directory) an IOError/OSError may be raised by matplotlib.
        RIsuffix (str or list): Suffix or list of suffixes used to construct the expected NumPy files to load. For a single suffix given as a string, the function will load "RI_<RIsuffix>.npy" and plot a single spectrum without a legend. For a list of suffix strings, the function will load each file "RI_<name>.npy" for name in RIsuffix, plot them with distinct colors from the "inferno" colormap and include a legend using the supplied suffix strings as labels. Example usage: RIsuffix="0_1_455nm" loads "RI_0_1_455nm.npy"; RIsuffix=["0_1_455nm","0_2_532nm"] loads both files. The files must exist and be readable by numpy.load, otherwise a FileNotFoundError or numpy loading error will propagate.
        relative (bool): If True, normalize each loaded intensity spectrum by its maximum value before plotting (r -> r / max(r)). When relative is True the y-axis label is set to "I/I_max" and y-axis tick labels are hidden (plt.yticks([])). The default is False (plot raw intensities in arbitrary units).
        w_min (float): Lower bound (inclusive) of the Raman shift range to plot, in cm^-1. If None, the function treats the lower bound as 0.0 by default. The function filters both the Raman shift axis and intensities to the interval [w_min, w_max] before plotting and peak finding.
        w_max (float): Upper bound (inclusive) of the Raman shift range to plot, in cm^-1. If None, w_max is set to the maximum Raman shift present in the first RI file loaded (i.e., max(RI[0]) for the first file). This single value is then used for all spectra in a multi-file plot. Providing an explicit w_max overrides this behavior. If the provided w_max is outside the range of the data arrays the plotted selection will be empty or truncated accordingly.
    
    Behavior, expectations, and failure modes:
    - The function expects each "RI_<suffix>.npy" file to contain a NumPy array-like object where the first element (RI[0]) is the Raman shift axis (1D array, cm^-1) and the second element (RI[1]) is the corresponding intensity array (1D array, same length as RI[0]). If these indices are missing or the arrays have incompatible shapes, an IndexError, ValueError, or other numpy error may be raised.
    - Peak detection (scipy.signal.find_peaks) is performed only on the first loaded spectrum (first RI file). Vertical dashed grey lines are drawn at peaks whose intensities (from that first spectrum) exceed 5% of the maximum peak intensity found in that first spectrum. If no peaks are found, no vertical lines are drawn.
    - When multiple spectra are provided via a list of suffixes, each spectrum is plotted with a distinct color sampled from matplotlib's "inferno" colormap; labels in the legend correspond to the provided suffix strings in RIsuffix in the same order. When a single string suffix is provided, no legend is shown.
    - The function uses matplotlib.pyplot for plotting and calls plt.clf() at the end to clear the current figure; therefore subsequent plotting code using the same global pyplot state will start from a cleared figure.
    - Side effects include creating or overwriting the file specified by figname, and modifying/clearing the global matplotlib state. The function does not return the matplotlib figure object.
    - Errors that can propagate include FileNotFoundError or numpy.load errors when files are missing or corrupted, matplotlib errors when saving fails (IOError/OSError), and scipy/numpy errors during peak finding or array indexing if the data are malformed.
    
    Returns:
        None: This function does not return a value. Its primary effects are side effects: saving a raster/vector figure to the path given by figname (matplotlib.pyplot.savefig with dpi=300) and clearing the current matplotlib figure (matplotlib.pyplot.clf()).
    """
    from gpaw.raman.raman import plot_raman
    return plot_raman(figname, RIsuffix, relative, w_min, w_max)


################################################################################
# Source: gpaw.response.chiks.get_smat_components
# File: gpaw/response/chiks.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_chiks_get_smat_components(spincomponent: tuple, s1_t: int, s2_t: int):
    """Compute the product σ^μ_ss' σ^ν_s's for a specified pair of spin-component indices (μ, ν).
    
    This function is part of the gpaw.response.chiks routines used in GPAW (a DFT code based on the PAW method) to assemble spin-dependent contributions to response quantities. It retrieves two spin matrices corresponding to the two entries of spincomponent using the local smat(...) accessor and returns the product of the matrix element from the first matrix at row s1_t, column s2_t with the matrix element from the second matrix at row s2_t, column s1_t. In practical GPAW workflows this scalar enters sums over spin indices when building spin-resolved response tensors or kernels used in linear-response or susceptibility calculations.
    
    Args:
        spincomponent (tuple): A two-element tuple (μ, ν) selecting which spin components (Pauli-like matrices) to use. The first element selects μ for the left matrix and the second selects ν for the right matrix. The tuple order is significant because the function computes σ^μ[s1_t, s2_t] * σ^ν[s2_t, s1_t]. Values passed must be valid inputs for the module-level smat(...) function; invalid component identifiers will propagate whatever exception smat raises.
        s1_t (int): The integer row index s of the first matrix element σ^μ[s1_t, s2_t]. In typical two-component spinor representations used in GPAW this is 0 or 1 for spin-up/down, but the function accepts any integer index valid for the matrices returned by smat(...). If s1_t is out of range for those matrices an IndexError will be raised.
        s2_t (int): The integer column index s' of the first matrix element and row index of the second element, i.e. σ^μ[s1_t, s2_t] and σ^ν[s2_t, s1_t]. As with s1_t, this is typically 0 or 1 for two-component spins but must be a valid index for the matrices returned by smat(...); otherwise an IndexError will be raised.
    
    Returns:
        scalar: The scalar product smat(spincomponent[0])[s1_t, s2_t] * smat(spincomponent[1])[s2_t, s1_t]. The numeric type is the same as the matrix elements returned by smat (for example float or complex) and is intended for use in constructing spin-dependent response tensors. There are no side effects. Exceptions from invalid spincomponent values, or from out-of-range s1_t/s2_t indices, are propagated to the caller.
    """
    from gpaw.response.chiks import get_smat_components
    return get_smat_components(spincomponent, s1_t, s2_t)


################################################################################
# Source: gpaw.pseudopotential.screen_potential
# File: gpaw/pseudopotential.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_pseudopotential_screen_potential(
    r: numpy.ndarray,
    v: numpy.ndarray,
    charge: float,
    rcut: float = None,
    a: float = None
):
    """gpaw.pseudopotential.screen_potential splits a long-range, spherically symmetric radial potential into a short-ranged screened potential and a localized compensation charge density suitable for use in PAW/pseudopotential constructions and Hartree potential evaluation.
    
    Args:
        r (numpy.ndarray): 1D radial grid values (monotonic increasing). In the GPAW/PAW context this is the radial coordinate array (typically in atomic units, often Bohr) on which the input potential v is sampled. The function uses r to determine cutoffs, compute Gaussian compensation charges, and to return truncated arrays corresponding to the short-range region.
        v (numpy.ndarray): 1D radial potential sampled on the grid r. This is the long-ranged potential whose asymptotic behavior corresponds to charge/r (i.e., v(r) ~ -charge/r for large r, up to sign conventions used by the caller). The routine assumes v and r have matching shapes and that v describes the Coulomb tail to be screened.
        charge (float): Total point-like asymptotic charge Z that produces the 1/r tail in v. This scalar determines the amplitude of the compensation Gaussian charge and the analytic short-range correction vcomp that subtracts the long-range 1/r contribution from v.
        rcut (float, optional): Explicit cutoff radius (same units as r) at which the returned screened potential and compensation charge are truncated. If None (default), the function determines a reasonable cutoff by inspecting vr = v*r + charge and finding the radial index where the residual vr becomes sufficiently small (threshold 1e-4) and then extending slightly (searchsorted with 1.1 factor). The chosen rcut is then snapped to the nearest point on the provided grid r. If rcut is provided but does not fall within the domain of r (for example greater than r[-1]), indexing into r can raise IndexError.
        a (float, optional): Width parameter of the Gaussian used to represent the localized compensation charge (same units as r). If None (default) it is set to rcut / 5.0. The parameter a controls the spatial extent of the compensation density rhocomp and therefore how rapidly the analytic correction vcomp = charge * erf(r/(sqrt(2)*a)) / r removes the 1/r tail from v. Choosing a much smaller or larger a than the default changes the localization and may affect numerical behavior of downstream Hartree integrals.
    
    Behavior, side effects, defaults, and failure modes:
        The function constructs vr = v * r + charge to detect where the potential deviates from its Coulombic 1/r asymptote. If rcut is not supplied, it searches inward from the end of the grid until abs(vr[i]) >= 1e-4 and then sets the working cutoff slightly beyond that radius; this heuristic is intended to include the region where the Coulomb tail dominates while excluding negligible long-range tails. If r contains a zero at the first grid point, the code replaces r[0] with 1e-10 to avoid division-by-zero in analytic formulas. The width parameter a defaults to rcut/5.0, which has been found empirically important in GPAW pseudopotential setups; the choice affects the smoothness and localization of rhocomp and vcomp.
        The function computes a Gaussian compensation charge density on the truncated grid rshort = r[:icut] with normalization prefactor (sqrt(2*pi) * a)^(-3) so that the total integrated compensation charge equals charge on that grid. The analytic short-range correction vcomp is charge * erf(rshort/(sqrt(2)*a)) / rshort and is added to the input v truncated to the same radius to form vscreened. No global state is modified; the function returns two new numpy.ndarray objects corresponding to the truncated radius region.
        Failure modes include raising IndexError if rcut (explicit or determined) leads to icut == len(r) and subsequent code attempts to access r[icut], or if r is not monotonic so that searchsorted results are meaningless. If r and v have mismatched shapes or if r is extremely short, numpy indexing or arithmetic may raise IndexError or ValueError. If the heuristic used when rcut is None never meets the abs(vr[i]) >= 1e-4 condition (extremely pathological inputs), the while loop could underflow the index in an unintended way; in practice input potentials from GPAW setups produce the expected cutoff. The function does not perform unit conversions; the caller must ensure consistent units for r, v, charge, rcut, and a.
    
    Returns:
        vscreened (numpy.ndarray): Truncated screened potential defined on rshort = r[:icut]. This is computed as vscreened = v[:icut] + vcomp where vcomp = charge * erf(rshort/(sqrt(2)*a)) / rshort. The array length equals the number of retained radial grid points (icut), and the values are in the same units as the input v. The screened potential is short-ranged by construction and is intended to be combined with the Hartree potential of rhocomp to recover the original long-range v.
        rhocomp (numpy.ndarray): Localized compensation charge density sampled on the same truncated radial grid rshort. This Gaussian-shaped density is rhocomp = charge * (sqrt(2*pi) * a)**(-3) * exp(-0.5 * (rshort / a)**2) and integrates to the specified charge on the truncated grid. It is intended to be used as the source in vHartree[rhocomp] so that v(r) = vscreened(r) + vHartree[rhocomp](r) holds within the truncated region.
    """
    from gpaw.pseudopotential import screen_potential
    return screen_potential(r, v, charge, rcut, a)


################################################################################
# Source: gpaw.response.fxc_kernels.create_add_fxc
# File: gpaw/response/fxc_kernels.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for create_add_fxc because the docstring has no description for the argument 'fxc'
################################################################################

def gpaw_response_fxc_kernels_create_add_fxc(fxc: str, spincomponent: str):
    """Create and return an add_fxc function configured for a requested exchange-correlation
    kernel (fxc) and spin component (spincomponent) used by the GPAW linear-response
    module to assemble the exchange-correlation kernel contributions to response
    matrices. In the GPAW DFT/PAW response context (see gpaw.response), this factory
    binds the requested ALDA-type functional identifier to an internal implementation
    that adds either density-density or transverse spin f_xc contributions, so the
    returned callable can be invoked by response routines to modify the kernel.
    
    Args:
        fxc (str): Identifier of the exchange-correlation kernel variant to use.
            This selects the internal implementation behavior and must be one of the
            ALDA variants recognized by this code: 'ALDA_x', 'ALDA_X', or 'ALDA'.
            The function asserts membership in this set; if fxc is not one of these
            strings an AssertionError will be raised. In practice, these identifiers
            mean the code will use the (adiabatic) local density approximation (ALDA)
            form of f_xc when constructing kernel contributions for density or spin
            channels in GPAW's response calculations.
        spincomponent (str): Spin-channel selector string that determines which
            internal implementation is bound and returned. Accepted values and their
            meanings are:
            '00', 'uu', 'dd' — select the density-density (longitudinal) component;
                the function returns a functools.partial object wrapping the
                internal helper add_LDA_dens_fxc with fxc bound. In GPAW this
                corresponds to adding ALDA density f_xc contributions used when
                building the charge-density response block.
            '+-', '-+' — select the transverse spin component; the function returns
                a functools.partial object wrapping the internal helper
                add_LSDA_trans_fxc with fxc bound. In GPAW this corresponds to
                adding ALDA/LSDA transverse spin f_xc contributions used in spin
               -flip or transverse-spin response blocks.
            If spincomponent is not one of these accepted strings the function
            raises a ValueError(spincomponent), with the invalid string provided
            as the exception argument.
    
    Returns:
        callable: A callable (specifically a functools.partial object) that, when
        invoked by the response assembly code, performs the configured addition of
        the exchange-correlation kernel contribution. The returned callable has the
        same calling convention as the underlying internal helper (add_LDA_dens_fxc
        or add_LSDA_trans_fxc) but with its keyword argument fxc already bound to
        the requested identifier. There are no side effects from create_add_fxc
        itself; side effects occur when the returned callable is invoked (it will
        modify response-related data structures as intended by the internal helper).
        Failure modes: create_add_fxc raises AssertionError if fxc is not one of the
        allowed ALDA identifiers, and raises ValueError if spincomponent is not a
        supported spin-channel string.
    """
    from gpaw.response.fxc_kernels import create_add_fxc
    return create_add_fxc(fxc, spincomponent)


################################################################################
# Source: gpaw.raman.raman.calculate_raman_intensity
# File: gpaw/raman/raman.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_raman_raman_calculate_raman_intensity(
    w_ph: numpy.ndarray,
    d_i: int,
    d_o: int,
    suffix: str,
    T: float = 300
):
    """Calculate Raman intensities from a precomputed Raman tensor and phonon frequencies.
    This function is part of the GPAW Raman utilities and implements the post-processing
    step that converts mode-resolved Raman matrix elements (R_lab) into frequency-dependent
    Raman intensities using phonon frequencies, a Bose–Einstein occupation factor at a
    given temperature, and a Gaussian broadening. It reads and writes NumPy .npy files
    following the naming convention used by the GPAW Raman workflow and is intended to be
    used after a Raman tensor calculation that produced Rlab files.
    
    Args:
        w_ph (numpy.ndarray or str): Array of phonon frequencies in electronvolts (eV)
            with shape (n_modes,) or a filename (str) pointing to a .npy file that can
            be loaded with numpy.load to obtain such an array. In the GPAW Raman workflow
            these are the phonon eigenfrequencies used to compute the Bose–Einstein
            occupation factors and to place the Raman peaks. The function asserts that
            max(w_ph) < 1.0 to ensure the supplied frequencies are in eV units; if a
            string filename is given, the file is loaded before this check.
        d_i (int): Incoming polarization index. An integer index selecting the incoming
            polarization component used to pick the appropriate Raman-tensor file. The
            index maps to Cartesian components via the literal mapping 'xyz'[d_i], i.e.
            0->'x', 1->'y', 2->'z'. Providing a value outside 0..2 will raise an IndexError
            when constructing the Rlab filename.
        d_o (int): Outgoing polarization index. Same role and mapping as d_i but for the
            scattered (outgoing) polarization. The function loads the Rlab file that was
            computed for this incoming/outgoing polarization pair.
        suffix (str): Suffix string that is appended to input and output filenames to
            select the proper dataset, e.g. '633nm' or another identifier used by the
            user workflow. The function loads "Rlab_{in}{out}_{suffix}.npy" and writes
            "RI_{in}{out}_{suffix}.npy", where {in}/{out} are the characters from 'xyz'
            selected by d_i and d_o.
        T (float): Temperature in kelvin used in the Bose–Einstein occupation factor.
            Default is 300 K. T controls the prefactor occ = 1/(exp(w_ph/(k_B*T)) - 1) + 1
            used to compute the temperature-dependent contribution to the intensity.
    
    Behavior, side effects, and practical details:
        - File I/O: The function attempts to load the Raman matrix elements from a file
          named "Rlab_{in}{out}_{suffix}.npy" where {in} and {out} are 'x','y' or 'z'
          determined from d_i and d_o. The loaded array (tmp) is expected to contain a
          first entry tmp[0] that holds a frequency grid w (already in reciprocal
          centimeters, indicated as rcm in the code) and subsequent entries tmp[1:]
          containing complex Raman matrix elements per phonon mode (raman_lw). After
          processing the function saves a NumPy array named "RI_{in}{out}_{suffix}.npy"
          containing a stacked array with rows [w, int_bare, int_occ].
        - Array shapes and consistency: The function asserts that raman_lw.shape[0] equals
          len(w_ph). That is, the number of mode-resolved Raman matrix-element sets must
          match the number of phonon frequencies supplied in w_ph. If this assertion
          fails, processing is aborted.
        - Units and conversions: The input phonon frequencies w_ph must be given in eV.
          The internal frequency grid w read from the Rlab file is already in reciprocal
          centimeters (rcm). The code relies on a module-level conversion factor (invcm)
          to convert phonon frequencies from eV into the units of w when building the
          Gaussian broadening; this module-level constant must be available in the same
          module where this function is executed.
        - Computational details: For each phonon mode l the code computes a Bose–Einstein
          occupation prefactor occ = 1/(exp(w_ph[l]/(k_B*T)) - 1) + 1 (k_B provided via
          KtoeV = 8.617278e-5 eV/K) and a Gaussian broadening delta centered at the mode
          frequency (converted to the w grid). The bare intensity (int_bare) accumulates
          R * delta, where R is the element-wise squared magnitude of the complex Raman
          matrix elements for the mode. The temperature-weighted intensity (int_occ)
          accumulates occ / w_ph[l] * R * delta. The Gaussian broadening uses
          sigma=5. (sigma is the same units as w read from the Rlab file.)
        - Output format: The saved RI file contains a vertical stack numpy.vstack((w, int_bare, int_occ))
          and is written to "RI_{in}{out}_{suffix}.npy". The first row is the frequency grid
          w (in rcm), the second row is the bare (unoccupied) Raman intensity, and the
          third row is the occupation-weighted Raman intensity computed at temperature T.
        - Return value: The function does not return a Python object. All results are
          saved to disk as described below.
    
    Failure modes and exceptions:
        - FileNotFoundError (or numpy.load exception) if the Rlab file or a w_ph filename
          (when w_ph is a str) cannot be loaded.
        - AssertionError if max(w_ph) >= 1.0 (indicating frequencies are likely not in eV)
          or if the number of Raman-matrix sets in the Rlab file (raman_lw.shape[0]) does
          not match len(w_ph).
        - IndexError if d_i or d_o are not valid indices for the mapping 'xyz'[d_i]/'xyz'[d_o]
          (valid values are 0, 1, or 2).
        - ZeroDivisionError or floating-point exceptions if any entry of w_ph is exactly
          zero, because the code divides by w_ph[l] when computing int_occ.
        - Other runtime errors may arise from missing module-level constants (for example
          invcm required to convert eV to the frequency grid units) or from invalid array
          shapes in the Rlab file.
    
    Returns:
        None: The function does not return a value. Side effects: it reads the Raman tensor
        file "Rlab_{in}{out}_{suffix}.npy" and (if w_ph was provided as a filename) the
        phonon-frequency file given by w_ph; it writes the computed Raman intensity file
        "RI_{in}{out}_{suffix}.npy" containing a stacked NumPy array with rows [w, int_bare, int_occ].
    """
    from gpaw.raman.raman import calculate_raman_intensity
    return calculate_raman_intensity(w_ph, d_i, d_o, suffix, T)


################################################################################
# Source: gpaw.response.chiks.get_temporal_part
# File: gpaw/response/chiks.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_chiks_get_temporal_part(
    spincomponent: int,
    hz_z: numpy.ndarray,
    kptpair: tuple,
    bandsummation: str
):
    """Get the temporal part of a causal linear susceptibility x_t^μν(ħz) for a
    single spin component, evaluated at one or more complex frequency points.
    This function is part of GPAW's linear-response/response.chiks machinery used in
    DFT-based response calculations (for example optical or many-body response
    evaluations) and serves as a thin wrapper that selects a bands-summation
    implementation and evaluates it for the requested spin component, frequency
    points (ħz) and k-point pair.
    
    Args:
        spincomponent (int): Integer index selecting which spin component's
            susceptibility to compute in a spin-resolved calculation. In GPAW
            calculations this selects the spin channel for which the temporal part
            x_t^μν(ħz) is returned; typical use is 0..Nspin-1 when Nspin > 1.
        hz_z (numpy.ndarray): Array of complex frequency (energy) points ħz at
            which the causal susceptibility is evaluated. The array is passed
            directly to the selected bands-summation implementation and therefore
            should have the dtype and dimensionality expected by that implementation
            (commonly a one-dimensional array of complex values). These frequencies
            determine the energy dependence of x_t^μν(ħz).
        kptpair (tuple): Tuple identifying the k-point pair (typically a pair of
            indices or k-point identifiers) in the Brillouin zone between which
            the susceptibility is computed. The exact interpretation (e.g., integer
            indices into a k-point list) depends on the calling context in GPAW's
            response code; the order of the elements in the tuple is significant
            and must match the conventions used elsewhere in the response machinery.
        bandsummation (str): String key that selects the bands-summation strategy
            or implementation used to build the temporal part. This string is fed
            to create_get_temporal_part, which returns an evaluation function
            tailored to that strategy. The allowed values and their algorithmic
            implications are defined elsewhere in the response module; an invalid
            string will cause create_get_temporal_part to raise an error.
    
    Returns:
        numpy.ndarray: Complex-valued ndarray containing the temporal part of the
        causal linear susceptibility x_t^μν(ħz) evaluated for the requested
        spincomponent, frequency points (hz_z) and kptpair. The concrete array
        shape and axis ordering depend on the underlying basis and the chosen
        bandsummation implementation (for example, indices corresponding to the
        basis/function labels μ and ν and the frequency axis), so callers should
        interpret the returned array according to the specific bandsummation
        strategy they requested.
    
    Behavior and side effects:
        The function constructs a specialized evaluator by calling
        create_get_temporal_part(bandsummation) and immediately invokes that
        evaluator with the provided spincomponent, hz_z and kptpair. No file I/O is
        performed by this wrapper itself. Memory allocation and any internal
        caching are performed by the chosen bands-summation implementation.
    
    Failure modes:
        Type errors or mismatched array dtypes/dimensions for hz_z will typically
        raise TypeError or ValueError coming from the underlying implementation.
        Providing an out-of-range spincomponent or an invalid kptpair may raise
        IndexError or ValueError depending on the evaluator. An invalid
        bandsummation string will cause create_get_temporal_part to raise an
        informative error (e.g., ValueError) indicating unsupported strategies.
    """
    from gpaw.response.chiks import get_temporal_part
    return get_temporal_part(spincomponent, hz_z, kptpair, bandsummation)


################################################################################
# Source: gpaw.response.df.read_response_function
# File: gpaw/response/df.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_df_read_response_function(filename: str):
    """Read a stored frequency-dependent response function file produced for use with GPAW's
    frequency-domain response analyses (gpaw.response.df). This function parses a CSV-like
    text file (comma-separated values) that encodes a frequency grid and two response
    functions: the "noninteracting" response rf0_w and the "interacting" response rf_w.
    It is intended for post-processing or plotting of response data produced by GPAW
    linear-response or dielectric calculations and returns NumPy arrays suitable for
    numerical analysis in the GPAW/ASE workflow.
    
    Args:
        filename (str): Path to the stored response function file. The file must be a
            text file with comma (",") as delimiter and numeric entries. Each row
            corresponds to a single frequency point. Accepted column layouts are:
            - Three columns: (omega, rf0_real, rf_real). In this case both rf0_w and
              rf_w are real-valued and returned with dtype float.
            - Five columns: (omega, rf0_real, rf0_imag, rf_real, rf_imag). In this
              case rf0_w and rf_w are complex-valued; real parts are taken from the
              indicated columns and imaginary parts from the following columns.
            The function uses numpy.loadtxt(filename, delimiter=',') to read the file,
            so standard behaviors of numpy.loadtxt apply (for example FileNotFoundError
            if the path does not exist, or ValueError if non-numeric tokens are present).
    
    Returns:
        tuple: A 3-tuple (omega_w, rf0_w, rf_w) where:
            omega_w (numpy.ndarray): 1-D array of shape (N,) with dtype float containing
                the frequency grid read from the first column of the file. This is the
                independent variable (frequency or energy grid) used in GPAW response
                outputs.
            rf0_w (numpy.ndarray): 1-D array of shape (N,) containing the noninteracting
                response at each frequency. If the file had three columns this array has
                dtype float and contains real values; if the file had five columns this
                array has dtype complex with real and imaginary parts constructed from
                the corresponding columns.
            rf_w (numpy.ndarray): 1-D array of shape (N,) containing the interacting
                (screened) response at each frequency. The dtype and construction rules
                follow the same convention as rf0_w (real for three-column input,
                complex for five-column input).
    
    Raises:
        ValueError: If the loaded array has an unexpected number of columns (not 3 or 5),
            a ValueError is raised with the offending shape. numpy.loadtxt may also raise
            ValueError for malformed numeric data.
        OSError / FileNotFoundError: If the file cannot be opened or read, the underlying
            I/O error raised by numpy.loadtxt is propagated.
    
    Notes:
        The function has no side effects: it does not modify the input file or global
        state. It returns freshly allocated NumPy arrays that can be used directly in
        GPAW post-processing, plotting, or further numerical analysis. Files with a
        single row or unusual formatting that cause numpy.loadtxt to return a 1-D array
        instead of a 2-D array will typically result in an exception; ensure the file
        uses one row per frequency point and the correct comma-separated column layout.
    """
    from gpaw.response.df import read_response_function
    return read_response_function(filename)


################################################################################
# Source: gpaw.response.heisenberg.get_q0_index
# File: gpaw/response/heisenberg.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_heisenberg_get_q0_index(q_qc: numpy.ndarray):
    """gpaw.response.heisenberg.get_q0_index: Find and return the index of the zero wavevector (q = [0., 0., 0.]) in a q-vector array used in GPAW Heisenberg/response calculations.
    
    This function is used in GPAW's response.heisenberg routines to identify the q = 0 (Gamma) entry in an array of q-vectors (for example when assembling response functions or evaluating Heisenberg exchange parameters at the zero momentum transfer). It searches the provided NumPy array for a row that is exactly equal to [0., 0., 0.] and returns the integer index of the first matching row. The function performs an elementwise exact equality check, so callers should ensure that the zero vector is represented exactly (or preprocess the array to set small numerical values to zero) before calling.
    
    Args:
        q_qc (numpy.ndarray): 2-D NumPy array of q-vectors where each row is a Cartesian q-vector (commonly of shape (N, 3) for N q-points). In the GPAW Heisenberg/response context, q_qc represents the set of crystal/momentum transfer vectors q_c for which response quantities are evaluated. The function expects an ndarray so that axis-wise comparisons (axis=1) succeed; passing arrays with incorrect dimensionality (e.g., 1-D arrays) will raise an error from NumPy.
    
    Returns:
        int: Integer index of the first row in q_qc that is exactly [0., 0., 0.]. This index can be used to access the Gamma-point entry in arrays of response quantities or to select the q=0 contribution in Heisenberg parameter calculations. If multiple identical zero rows exist, the index of the first occurrence (lowest row index) is returned.
    
    Raises:
        ValueError: If no row exactly equal to [0., 0., 0.] is found in q_qc. The raised exception contains the message 'q_qc has to include q=0, i.e. q_c = [0., 0., 0.]'. This indicates the input must include an exact zero q-vector; because the function uses exact equality, near-zero floating-point values will not be treated as zero and should be handled by the caller (for example by thresholding or rounding) before calling.
    """
    from gpaw.response.heisenberg import get_q0_index
    return get_q0_index(q_qc)


################################################################################
# Source: gpaw.response.mpa_sampling.semi_homogenous_partition
# File: gpaw/response/mpa_sampling.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for semi_homogenous_partition because the docstring has no description for the argument 'npoles'
################################################################################

def gpaw_response_mpa_sampling_semi_homogenous_partition(npoles: int):
    """Semi-homogenous partition generator used in GPAW response MPA sampling to place n-poles (sampling points) between 0 and 1.
    
    This function constructs a semi-homogenous one-dimensional partition (grid) of npoles points on the interval [0, 1] following Eq. (18) of Ref. [1] and Eq. (11) of Ref. [2]. In the GPAW code base this partition is used by the multipole approximation (MPA) sampling of response functions to distribute sampling points such that smaller intervals are concentrated near zero (improving resolution where response functions typically vary rapidly) while retaining larger intervals further from zero. The returned array has length exactly npoles and represents the positions of the n-poles normalized to the unit interval.
    
    Args:
        npoles (int): Number of sampling points (n-poles) to place between 0 and 1. This integer controls the length of the returned one-dimensional partition array and the level of resolution: small npoles produce coarse partitions (special-cased for npoles == 1, 2, 3), while larger npoles produce a semi-homogenous grid composed of intervals of size dw, 2*dw (and occasionally 4*dw) where dw = 1/2**ceil(log2(npoles)). The function assumes npoles is a positive integer; passing values less than 1 is not handled by explicit argument validation and will result in a KeyError for small invalid integers or other errors when performing logarithms for non-positive values.
    
    Returns:
        Array1D: A one-dimensional array of length npoles containing the partition points in ascending order on the closed interval [0, 1]. The array always includes 0.0 as the first element; for small npoles the function returns predefined grids: {1: [0.0], 2: [0.0, 1.0], 3: [0.0, 0.5, 1.0]}. For npoles >= 4 the function computes the minimum interval dw = 1 / 2**ceil(log2(npoles)), determines the nearest lower power-of-two structure to organize interval multiplicities (lp = 2**int(log2(npoles - 1))), and builds the partition using a combination of intervals of size dw, 2*dw and, in the special case npoles == lp + 1, one interval of size 4*dw to keep the grid inhomogeneous. The construction has no side effects (it does not modify external state) and returns the computed grid; invalid npoles values (e.g., zero, negative integers, or non-integer types) will raise exceptions coming from the internal lookups or mathematical operations rather than from explicit input validation.
    
    References:
        DA. Leon et al., Phys. Rev. B 104, 115157 (2021) — Eq. (18).
        DA. Leon et al., Phys. Rev. B 107, 155130 (2023) — Eq. (11).
    """
    from gpaw.response.mpa_sampling import semi_homogenous_partition
    return semi_homogenous_partition(npoles)


################################################################################
# Source: gpaw.response.heisenberg.calculate_fm_magnon_energies
# File: gpaw/response/heisenberg.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_heisenberg_calculate_fm_magnon_energies(
    J_qabx: numpy.ndarray,
    q_qc: numpy.ndarray,
    mm_ax: numpy.ndarray
):
    """gpaw.response.heisenberg.calculate_fm_magnon_energies computes magnon eigenmode energies for a ferromagnetic system with an arbitrary number of magnetic sites in the unit cell, using isotropic exchange constants as a function of wave vector q.
    
    This function is used in the GPAW response/Heisenberg utilities to obtain the spin-wave (magnon) spectrum from isotropic exchange matrices J(q) for each q-point. It first constructs the dynamic spin-wave matrix
    H^ab(q) = g μ_B / sqrt(M_a M_b) [Σ_c J^ac(0) δ_ab - J^ab(q)]
    by calling generate_fm_dynamic_spin_wave_matrix, then diagonalizes H(q) for each q and any independent extra dimensions x to produce magnon eigenmode energies. The output energies correspond to the eigenvalues of the dynamic spin-wave matrix and are provided for each q-vector and mode index.
    
    Args:
        J_qabx (numpy.ndarray): Isotropic exchange constants as a function of q and sublattice indices a and b, with optional additional independent dimensions x. Practically, the first axis indexes q-points and the next two axes index sublattice sites a and b (so J_qabx[q, a, b, ...]). Any trailing axes (x) are treated independently: the function will compute a separate magnon spectrum for each combination of those extra indices. The values should represent the isotropic Heisenberg exchange interactions used to build the dynamic spin-wave matrix.
        q_qc (numpy.ndarray): q-vectors in relative coordinates. The array must include the q=0 vector and its ordering must match the first axis of J_qabx (i.e., the number and order of q-points). The last axis indexed by c enumerates the coordinate components of each q-vector in the chosen reciprocal/relative basis. These q-vectors determine the phase factors used in J^ab(q) and thus which spin-wave modes are computed.
        mm_ax (numpy.ndarray): Magnetic moments of the sublattice sites given in units of μ_B. The first axis indexes sublattice site a and any additional axes correspond to the same independent dimensions x as in J_qabx (i.e., mm_ax[a, ...] must broadcast consistently with the a and x dimensions of J_qabx). The magnetic moments M_a enter the dynamic spin-wave matrix as normalization factors sqrt(M_a M_b) and therefore directly affect the computed magnon energies.
    
    Returns:
        numpy.ndarray: Magnon eigenmode energies E_qnx as a function of q, mode index n, and the independent extra dimensions x. The shape corresponds to (number_of_q_points, number_of_modes, ...x...), where number_of_modes equals the number of magnetic sublattice sites a. Energies are returned as real-valued floats; they are the real parts of the eigenvalues of the dynamic spin-wave matrix. The energies are in the units consistent with the input J_qabx and the use of mm_ax in μ_B (the dynamic spin-wave matrix includes the factor g μ_B / sqrt(M_a M_b) as indicated above).
    
    Behavior and side effects:
        This function is pure (no persistent side effects) and performs the following steps: (1) calls generate_fm_dynamic_spin_wave_matrix(J_qabx, q_qc, mm_ax) to assemble H_qabx, (2) permutes axes to prepare matrices for diagonalization, (3) diagonalizes each H(q, x) with numpy.linalg.eig to obtain eigenvalues, (4) asserts that eigenvalues are (numerically) real and returns their real parts. No modifications are made to the input arrays.
    
    Failure modes and errors:
        An AssertionError is raised if the computed eigenvalues have non-negligible imaginary parts (numpy.allclose(E.imag, 0.) fails), which indicates invalid or inconsistent input exchange constants or numerical instability. numpy.linalg.LinAlgError may be raised if the eigenvalue solver fails for a given matrix. Errors will also occur if the array dimensions are inconsistent (for example, if the q-axis length in J_qabx does not match the number of q-vectors in q_qc, or if the sublattice axis a in mm_ax does not match the corresponding axis in J_qabx). Ensure q_qc contains q=0 and that mm_ax and the extra dimensions x align with J_qabx before calling.
    """
    from gpaw.response.heisenberg import calculate_fm_magnon_energies
    return calculate_fm_magnon_energies(J_qabx, q_qc, mm_ax)


################################################################################
# Source: gpaw.response.heisenberg.calculate_single_site_magnon_energies
# File: gpaw/response/heisenberg.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_heisenberg_calculate_single_site_magnon_energies(
    J_qx: numpy.ndarray,
    q_qc: numpy.ndarray,
    mm: float
):
    """Compute magnon energies for a system with a single magnetic site in the unit cell from isotropic exchange constants J(q).
    
    This function is used in GPAW's response/heisenberg workflow to convert isotropic exchange constants computed as functions of wave vector q into magnon energies (ħω(q)) for single-sublattice magnetic systems. The implementation assumes an isotropic exchange interaction and a single magnetic site per unit cell; under these assumptions the magnon energy is evaluated as the prefactor 2/mm times the difference J(0) - J(q), consistent with the common expression ħω(q) = (g μ_B / M) [J(0) - J(q)] when one uses g ≈ 2 and M expressed in units of μ_B.
    
    Args:
        J_qx (numpy.ndarray): Isotropic exchange constants J(q) sampled on a list of q-points. The first axis of J_qx must index q and therefore must have the same length as q_qc (the function asserts J_qx.shape[0] == q_qc.shape[0]). J_qx may contain any number of additional trailing dimensions x (for example different exchange channels, parameter sets, or other independent data axes); these extra dimensions are treated independently and preserved in the output. The array must be real-valued for an isotropic single-sublattice system: the function asserts that J_qx.imag is (numerically) zero and will raise an AssertionError if significant imaginary parts are present.
        q_qc (numpy.ndarray): q-vectors provided in relative (crystal) coordinates and sampled in the same order as the first axis of J_qx. The array must include the Γ point (q = 0) because the code locates the q=0 index with get_q0_index(q_qc) to obtain J(0). If q=0 is missing, get_q0_index will raise an error (propagated to the caller).
        mm (float): Magnetic moment of the single magnetic site in units of μ_B. This value is used as the denominator in the prefactor 2/mm; mm must be finite and non-zero (if mm == 0 a ZeroDivisionError or invalid energies will result). The physical meaning is the site magnetic moment used to convert exchange constants to magnon energies in the single-sublattice approximation.
    
    Behavior and side effects:
        The function checks that the number of q-points in J_qx matches q_qc and that J_qx is real-valued for an isotropic single-site system. It locates the index corresponding to q=0 using get_q0_index(q_qc) and extracts J(0) = J_qx[q0]. It then computes E_qx = 2. / mm * (J0_x[numpy.newaxis, ...] - J_qx) consistent with a g-factor set to approximately 2 and M given in μ_B. No in-place modification of the input arrays is performed; a new numpy.ndarray is returned. The function returns only the real part of the computed energies (E_qx.real) because for the assumed physical case the result should be real. There are no other side effects (no file I/O, no global state changes).
    
    Failure modes:
        AssertionError is raised if J_qx.shape[0] != q_qc.shape[0] or if J_qx has non-negligible imaginary parts. If q_qc does not contain q=0, get_q0_index will raise an error (for example ValueError) which is propagated. If mm is zero or not finite, division will fail or produce invalid values (ZeroDivisionError or infinities/NaNs). The function does not perform unit conversions; callers must ensure that J_qx and mm are provided in compatible units consistent with the interpretation ħω(q) = (g μ_B / M)[J(0) - J(q)].
    
    Returns:
        E_qx (numpy.ndarray): Magnon energies as a function of q and the additional x dimensions. The returned array has the same shape as the input J_qx. Values correspond to ħω(q) under the single-site isotropic approximation used by GPAW's Heisenberg/response utilities; the array is returned as real-valued (any residual imaginary parts are discarded).
    """
    from gpaw.response.heisenberg import calculate_single_site_magnon_energies
    return calculate_single_site_magnon_energies(J_qx, q_qc, mm)


################################################################################
# Source: gpaw.response.integrators.czher
# File: gpaw/response/integrators.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_integrators_czher(alpha: float, x: numpy.ndarray, A: numpy.ndarray):
    """gpaw.response.integrators.czher performs an in-place Hermitian rank-1 update of the upper triangular part of a square matrix A used in GPAW response integrators. In the context of GPAW (a density-functional theory code), this function is a low-level, BLAS-backed operation that adds a scaled outer product of a complex vector with its conjugate to an existing matrix, a common operation when updating density, response, or overlap matrices in iterative integrators.
    
    Args:
        alpha (float): Real scalar multiplier for the rank-1 update. This parameter scales the outer product before it is added to A and typically represents a prefactor arising from linear-algebra or physics formulas in GPAW response computations. The function passes this value to a BLAS zher routine; non-finite values (NaN or Inf) or inappropriate usage may propagate errors from the underlying BLAS call.
        x (numpy.ndarray): One-dimensional complex-valued input vector of length n. The vector provides the columns/rows for the rank-1 update via its complex conjugate. The code computes the outer product numpy.outer(x.conj(), x) and therefore expects x to support conjugation and length retrieval via len(x). In GPAW this vector commonly represents a state, mode, or response vector used when updating Hermitian matrices.
        A (numpy.ndarray): Two-dimensional, mutable numpy array representing the square matrix to be updated in-place. A must have shape (n, n) where n == len(x). Only the upper triangular part of A is updated by this routine (consistent with BLAS zher semantics); the rest of A is left unchanged by this call. A must be writeable; if A is not compatible with the BLAS wrapper or does not have a matching shape, the underlying call will raise an exception or the final assertion in this function may fail.
    
    Returns:
        None: The function performs the update as a side effect; it does not return a new array. After successful completion, A has been modified so that its upper triangular elements have been incremented by alpha * numpy.outer(x.conj(), x). Failure modes include shape mismatches between x and A (which will result in exceptions from numpy or the BLAS call), non-writeable A arrays, or an AssertionError if the underlying zher wrapper does not return the expected transposed array object. This function relies on a BLAS-level zher implementation for efficiency in GPAW's response integrators.
    """
    from gpaw.response.integrators import czher
    return czher(alpha, x, A)


################################################################################
# Source: gpaw.response.heisenberg.generate_fm_dynamic_spin_wave_matrix
# File: gpaw/response/heisenberg.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_heisenberg_generate_fm_dynamic_spin_wave_matrix(
    J_qabx: numpy.ndarray,
    q_qc: numpy.ndarray,
    mm_ax: numpy.ndarray
):
    """gpaw.response.heisenberg.generate_fm_dynamic_spin_wave_matrix: Generate the dynamic spin-wave matrix H_qabx for a collinear ferromagnet from isotropic exchange constants J_qabx.
    
    This routine implements the relation used in spin-wave (magnon) calculations for ferromagnets:
    H^ab(q) = (g μ_B) / sqrt(M_a M_b) [Σ_c J^ac(0) δ_ab - J^ab(q)],
    but in the implementation the magnetic-moment prefactor is computed explicitly as 2. / sqrt(M_a M_b) (see code). The function is intended for use inside GPAW's linear-response / Heisenberg-model utilities where J_qabx represents isotropic exchange interactions between sublattices a and b as a function of crystal momentum q and optional extra parameter dimensions x. The resulting H_qabx is the dynamic spin-wave matrix used to obtain spin-wave spectra and mode analysis for a ferromagnetic system within the assumptions of a collinear magnetic ground state and no spin-orbit coupling.
    
    Args:
        J_qabx (numpy.ndarray): Isotropic exchange constants J^ab(q). Array indexed as [q_index, a, b, ...x], where the first axis enumerates q-points and axes 1 and 2 correspond to sublattice indices a and b respectively. J_qabx may be complex but must satisfy Hermiticity J_qabx[q,a,b,...] = conj(J_qabx[q,b,a,...]) (the function asserts this). Any trailing dimensions x (J_qabx.shape[3:]) are treated independently and must match the trailing dimensions of mm_ax. The shape constraints enforced by the function are: J_qabx.ndim >= 3, J_qabx.shape[1] == J_qabx.shape[2], J_qabx.shape[0] == q_qc.shape[0], and J_qabx.shape[3:] == mm_ax.shape[1:].
    
        q_qc (numpy.ndarray): Array of q-vectors in relative (crystal) coordinates with shape (n_q, 3) or compatible shape where the first axis enumerates q-points. The array must include the Gamma point q = 0 because the implementation locates the index q0 = get_q0_index(q_qc) to obtain J^ab(0). If q=0 is not present, get_q0_index will fail or the function will raise an assertion. The q vectors determine the first axis correspondence to J_qabx.
    
        mm_ax (numpy.ndarray): Magnetic moments of the sublattice sites in units of Bohr magneton (μ_B). The first axis enumerates sublattices (length na), so mm_ax.shape[0] must equal the number of sublattices (J_qabx.shape[1]). mm_ax may contain additional trailing dimensions to represent parameter dependence (matching J_qabx.shape[3:]). The code computes a prefactor 2. / sqrt(M_a M_b) from these magnetic moments and uses it to normalize the dynamic matrix by sublattice magnetizations.
    
    Behavior and implementation details:
        - The function first validates array shapes and physical symmetries using assertions. If any of these checks fail an AssertionError is raised with an explanatory message:
            * Ensures J_qabx has at least three dimensions.
            * Ensures the two sublattice axes of J_qabx are square and match the length of mm_ax.
            * Ensures the q-axis length of J_qabx equals the number of q vectors in q_qc.
            * Ensures trailing parameter dimensions of J_qabx match those of mm_ax.
            * Ensures Hermiticity of J_qabx via numpy.allclose(J_qabx, numpy.conj(numpy.moveaxis(J_qabx, 2, 1))).
        - The function locates the index of q=0 using get_q0_index(q_qc) and extracts J0_acx = J_qabx[q0]. For a collinear system without spin-orbit coupling the code asserts that J0_acx is real (imaginary part near zero). If this check fails an AssertionError is raised, since [J^ab(q)]^* = J^ab(-q) and for q=0 reciprocity implies real values in this context.
        - The diagonal contribution Σ_c J^ac(0) δ_ab is constructed by summing J0_acx over the second sublattice index c and mapping the result onto a diagonal matrix in sublattice indices a,b.
        - The magnetic-moment normalization prefactor is built as mm_inv_abx = 2. / sqrt(M_a M_b) (outer-product form with possible trailing parameter dimensions) and broadcast over the q-axis.
        - The dynamic spin-wave matrix is computed exactly as in the code: H_qabx = mm_inv_abx[numpy.newaxis, ...] * (J0_abx[numpy.newaxis, ...] - J_qabx). This preserves the shape and dtype (including complex dtype if present) of J_qabx.
    
    Side effects and mutability:
        - The function does not write to disk or modify external state. It does not modify the input arrays J_qabx, q_qc, or mm_ax (no in-place changes are made), but standard NumPy broadcasting and view behavior apply to returned arrays.
        - The function depends on the helper get_q0_index(q_qc) to find the Gamma point; that helper must be available in the calling module.
    
    Failure modes:
        - AssertionError is raised when input shapes or physical symmetry conditions are violated (see above). The specific assertion messages from the code are preserved to aid debugging.
        - If q_qc does not contain q=0, get_q0_index(q_qc) may raise an error or return an invalid index, causing subsequent assertions to fail.
    
    Returns:
        H_qabx (numpy.ndarray): Dynamic spin-wave matrix with the same shape as the input J_qabx (i.e., [n_q, na, na, ...x]). Physically, H_qabx[q,a,b,...] is the normalized matrix element used to compute magnon eigenvalues and eigenvectors for wavevector q between sublattice indices a and b, with normalization by sublattice magnetic moments incorporated. The dtype follows from the arithmetic on J_qabx and mm_ax (complex if J_qabx is complex).
    """
    from gpaw.response.heisenberg import generate_fm_dynamic_spin_wave_matrix
    return generate_fm_dynamic_spin_wave_matrix(J_qabx, q_qc, mm_ax)


################################################################################
# Source: gpaw.response.pair_functions.read_susceptibility_array
# File: gpaw/response/pair_functions.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_pair_functions_read_susceptibility_array(filename: str):
    """Read a stored dynamic susceptibility array file produced by GPAW response calculations.
    
    Args:
        filename (str): Path to a .npz file produced by GPAW response modules that contains a stored dynamic susceptibility dataset. The function requires that the filename ends with the literal suffix ".npz" (this is enforced by an assertion). The file is opened with numpy.load and three specific arrays are extracted. The filename should be a filesystem path string pointing to an existing .npz archive created by GPAW or a compatible workflow.
    
    Returns:
        tuple: A 3-tuple containing the arrays extracted from the .npz file, returned in the following order:
            omega_w (numpy.ndarray): A one-dimensional numpy array holding the frequency sampling points (omega) used in the dynamic linear-response calculation. In GPAW response workflows this array represents the discrete frequencies at which the susceptibility was evaluated and is used to interpret and plot frequency-dependent response properties (for example, dielectric response or optical spectra).
            G_Gc (numpy.ndarray): A numpy array containing the reciprocal-space/coupling matrix data saved by the response calculation. In the GPAW response context this array represents the matrix or data structure used to describe reciprocal-space interactions or coupling between G-vectors (it is used with the susceptibility to reconstruct response quantities in reciprocal-space representations). Consumers of this function should treat this array as the same G_Gc object that GPAW wrote into the .npz archive.
            chi_wx (numpy.ndarray): A numpy array containing the dynamic susceptibility values produced by the response calculation. In GPAW this array encodes the frequency-dependent susceptibility (complex-valued in general) sampled on the frequency grid omega_w and on the same reciprocal-space or spatial index structure referenced by G_Gc. This array is the primary data used for post-processing, analysis, or plotting of response properties.
    
    Behavior and side effects:
        The function performs no modifications to the file contents; it reads the .npz archive with numpy.load and returns copies or views of the stored arrays. There are no external side effects beyond reading the file. The function relies on the presence of the exact keys 'omega_w', 'G_Gc', and 'chi_wx' inside the .npz file and returns the arrays in the order shown.
    
    Failure modes and exceptions:
        AssertionError: If filename does not end with the suffix ".npz", an AssertionError is raised with the provided filename as the message.
        FileNotFoundError (or OSError/IOError): If the file does not exist or cannot be opened by numpy.load.
        KeyError: If the .npz archive does not contain one of the required keys ('omega_w', 'G_Gc', 'chi_wx'), a KeyError will be raised when attempting to access the missing array.
        Any exceptions raised by numpy.load (for example if the file is not a valid .npz archive) will propagate to the caller.
    
    Usage notes:
        This function is intended for use in GPAW workflows that compute and store dynamic susceptibilities for linear-response analyses. After loading, the returned arrays may be passed to GPAW response post-processing routines or used directly for plotting and analysis of frequency-dependent response quantities.
    """
    from gpaw.response.pair_functions import read_susceptibility_array
    return read_susceptibility_array(filename)


################################################################################
# Source: gpaw.response.pair_functions.read_pair_function
# File: gpaw/response/pair_functions.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_pair_functions_read_pair_function(filename: str):
    """gpaw.response.pair_functions.read_pair_function: Read a stored pair function file and return the frequency/contour points and the complex pair function values as numpy arrays used by GPAW response calculations.
    
    Reads a comma-separated values (CSV) file produced by GPAW or compatible tools that store a pair function on a horizontal contour in the complex-frequency plane. In the GPAW response context, a "pair function" is a two-point response quantity used in many-body / linear-response routines; this function loads a saved representation so that response modules can reconstruct the frequency/contour-dependent complex pair function for further processing (integration, interpolation, or analytic continuation). The implementation uses numpy.loadtxt with delimiter=',' to parse numeric data and expects exactly three columns: the first column is the contour coordinate (omega), the second column is the real part of the pair function, and the third column is the imaginary part. The function constructs a 1-D floating array of contour points and a 1-D complex array of pair function values by combining the second and third columns.
    
    Args:
        filename (str): Path to the input file containing the stored pair function. The file must be a text CSV (comma-separated) file where each row corresponds to one contour point and the columns are, in order: omega (numeric, parsed as float), real part of the pair function (numeric), imaginary part of the pair function (numeric). The function calls numpy.loadtxt(filename, delimiter=','), so typical numpy.loadtxt formatting rules apply (for example, numeric strings are parsed to floats; non-numeric or malformed rows will raise an error). The filename is interpreted by the underlying I/O routines, so missing files or unreadable paths will result in the corresponding I/O exceptions raised by numpy.loadtxt / the Python runtime.
    
    Returns:
        omega_w (numpy.ndarray): 1-D numpy array with float dtype containing the contour coordinates (omega) read from the first column of the file. The length of this array equals the number of data rows in the file. These values represent the frequency or contour parameter points used by GPAW response calculations.
        pf_w (numpy.ndarray): 1-D numpy array with complex dtype containing the complex pair function values at the contour points. This array is constructed by taking the second column as the real part and the third column as the imaginary part of the complex pair function. The array length matches omega_w and is suitable for subsequent numerical operations in response workflows.
    
    Behavior and failure modes:
        - The function uses numpy.loadtxt(filename, delimiter=',') to read the entire file into a 2-D numeric array. Any I/O errors (file not found, permission denied) or numpy.loadtxt parsing errors (non-numeric tokens, inconsistent row lengths) will propagate as exceptions from numpy or the Python runtime.
        - After loading, the function requires that the parsed array have exactly three columns (d.shape[1] == 3). If this condition is not met, the function raises ValueError with message 'Unexpected array dimension {d.shape}', where {d.shape} is the actual shape of the parsed array. This enforces the expected CSV format for the horizontal-contour complex pair function representation.
        - There are no other side effects: the function does not modify files or global state; it only returns numpy arrays built from the file contents.
        - The returned numpy arrays use the numeric data as parsed by numpy.loadtxt; no additional validation of numerical ranges or physical units is performed here. It is the caller's responsibility to ensure the file encodes quantities in the expected units and conventions for downstream GPAW response code.
    """
    from gpaw.response.pair_functions import read_pair_function
    return read_pair_function(filename)


################################################################################
# Source: gpaw.response.pair_transitions.transitions_in_composite_index
# File: gpaw/response/pair_transitions.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_pair_transitions_transitions_in_composite_index(
    n1_M: numpy.ndarray,
    n2_M: numpy.ndarray,
    s1_S: numpy.ndarray,
    s2_S: numpy.ndarray
):
    """gpaw.response.pair_transitions.transitions_in_composite_index: Build flattened index arrays that enumerate transitions (n, s) -> (n', s') using a composite index t for use in GPAW response and pair-transition routines.
    
    This function constructs two meshgrids, one for the initial-state indices (n1_M with s1_S) and one for the final-state indices (n2_M with s2_S), and returns the four flattened arrays. In the context of GPAW response calculations (density-functional theory using the PAW method), this utility is used to vectorize and enumerate all combinations of band (n) and spin (s) indices for subsequent assembly of response matrices, transition lists, or batched linear-algebra operations. The function does not modify its inputs and has no side effects beyond allocating and returning new numpy arrays.
    
    Args:
        n1_M (numpy.ndarray): 1-D array of initial-state band indices n for the first index set (length M). These are the band indices that label the "from" state in transitions (n, s) -> (n', s'). In GPAW response code this typically represents a selection of bands (e.g. occupied bands) over which transitions are constructed.
        n2_M (numpy.ndarray): 1-D array of final-state band indices n' for the second index set (length M). These are the band indices that label the "to" state in transitions (n, s) -> (n', s'). This array is used together with s2_S to enumerate the final-state indices for transitions.
        s1_S (numpy.ndarray): 1-D array of initial-state spin indices s for the first spin set (length S). These are spin labels (or other small categorical indices) associated with the initial band indices n1_M. The function pairs every entry of s1_S with every entry of n1_M to form the initial-state side of the composite index.
        s2_S (numpy.ndarray): 1-D array of final-state spin indices s' for the second spin set (length S). These are spin labels associated with the final band indices n2_M. The function pairs every entry of s2_S with every entry of n2_M to form the final-state side of the composite index.
    
    Returns:
        tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray]: Four 1-D numpy arrays corresponding to the flattened meshgrids:
            The first array is the flattened n1_MS produced by meshgrid(n1_M, s1_S). Its length is len(s1_S) * len(n1_M) and it lists the band index n for each composite initial-state index t.
            The second array is the flattened n2_MS produced by meshgrid(n2_M, s2_S). Its length is len(s2_S) * len(n2_M) and it lists the band index n' for each composite final-state index t.
            The third array is the flattened s1_MS produced by meshgrid(n1_M, s1_S). Its length is len(s1_S) * len(n1_M) and it lists the spin index s for each composite initial-state index t.
            The fourth array is the flattened s2_MS produced by meshgrid(n2_M, s2_S). Its length is len(s2_S) * len(n2_M) and it lists the spin index s' for each composite final-state index t.
        These returned arrays are intended to be used in parallel (elementwise) such that the i-th element of each array gives the four indices (n, n', s, s') associated with a particular composite transition index t. If any input array is empty the corresponding outputs will be empty arrays. The function preserves the values and dtypes of the input numpy arrays; non-integer values (if present) are returned unchanged and may lead to downstream indexing errors if subsequently used as array indices.
    """
    from gpaw.response.pair_transitions import transitions_in_composite_index
    return transitions_in_composite_index(n1_M, n2_M, s1_S, s2_S)


################################################################################
# Source: gpaw.response.pair_transitions.remove_null_transitions
# File: gpaw/response/pair_transitions.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_pair_transitions_remove_null_transitions(
    n1_M: numpy.ndarray,
    n2_M: numpy.ndarray,
    nocc1: int = None,
    nocc2: int = None
):
    """Remove pairs of bands for which electronic transitions are impossible within a
    DFT/PAW calculation context.
    
    This function filters two parallel arrays of band indices that represent paired
    initial and final bands (for example, occupied -> unoccupied transitions used in
    response or excitation calculations). It removes any pair (n1, n2) where both
    bands are considered fully occupied or both are considered completely
    unoccupied based on the provided occupation thresholds. The function is used in
    GPAW response code to avoid forming transitions that are physically forbidden
    or irrelevant for response function assembly and subsequent linear-response
    calculations.
    
    Args:
        n1_M (numpy.ndarray): 1-D array of band indices (integers) representing the
            first band in each transition pair. Each element is interpreted as a
            band index (0-based) in the GPAW band ordering; indices < nocc1 are
            considered occupied if nocc1 is provided, and indices >= nocc2 are
            considered unoccupied if nocc2 is provided. The array must be aligned
            position-wise with n2_M: element i of n1_M pairs with element i of
            n2_M. If the arrays differ in length, iteration uses Python's zip
            semantics and will only process pairs up to the length of the shorter
            array (the excess elements are ignored).
        n2_M (numpy.ndarray): 1-D array of band indices (integers) representing the
            second band in each transition pair. Interpreted analogously to n1_M.
            The two arrays together define candidate transitions; this function
            returns filtered arrays containing only pairs that are allowed by the
            occupation thresholds.
        nocc1 (int or None): Optional integer threshold defining the upper bound
            (exclusive) for bands considered fully occupied in the domain of the
            first occupancy criterion. Any band index b with b < nocc1 is treated
            as fully occupied for the purpose of removing transitions. If None
            (default), the "both occupied" removal criterion is not applied.
            Typical use: pass the number of occupied bands (e.g., number of
            electrons/2 for spin-restricted cases) so that transitions between two
            occupied bands are discarded.
        nocc2 (int or None): Optional integer threshold defining the lower bound
            (inclusive) for bands considered completely unoccupied in the domain of
            the second occupancy criterion. Any band index b with b >= nocc2 is
            treated as completely unoccupied for the purpose of removing
            transitions. If None (default), the "both unoccupied" removal criterion
            is not applied. Typical use: pass the index after the highest band of
            interest so that transitions between two unoccupied bands are discarded.
    
    Behavior and side effects:
        The function iterates over pairs (n1, n2) formed by zip(n1_M, n2_M) and
        applies the following exclusion rules in order: if nocc1 is not None and
        both n1 < nocc1 and n2 < nocc1, the pair is skipped (both bands fully
        occupied); elif nocc2 is not None and both n1 >= nocc2 and n2 >= nocc2, the
        pair is skipped (both bands completely unoccupied). All other pairs are
        preserved in the same relative order as the inputs. The inputs n1_M and
        n2_M are not modified; the function constructs and returns new numpy arrays.
        If n1_M and n2_M have different lengths, only pairs up to the shorter length
        are considered (Python zip truncation). The function makes no I/O calls and
        has no other side effects.
    
    Failure modes and preconditions:
        The function assumes n1_M and n2_M are iterable numpy.ndarray objects whose
        elements can be meaningfully compared to the integer thresholds nocc1 and
        nocc2. If the arrays contain non-integer or negative values, or if the
        caller relies on processing elements beyond the shorter array length,
        results may be unexpected. The function does not perform explicit type
        conversions or bounds checking beyond the comparisons shown; callers should
        validate inputs according to the GPAW DFT/PAW domain conventions before
        calling.
    
    Returns:
        tuple of numpy.ndarray: A pair (n1_filtered, n2_filtered) of 1-D numpy
        arrays containing the filtered band-index pairs that remain after removal
        of null transitions. Each returned array preserves the original ordering of
        the accepted pairs and will typically have integer dtype; both arrays have
        the same length, which is less than or equal to min(len(n1_M), len(n2_M)).
    """
    from gpaw.response.pair_transitions import remove_null_transitions
    return remove_null_transitions(n1_M, n2_M, nocc1, nocc2)


################################################################################
# Source: gpaw.response.site_data.maximize
# File: gpaw/response/site_data.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_site_data_maximize(x_x: numpy.ndarray, f_x: numpy.ndarray):
    """Maximize a sampled function f(x) on a given interval and return the x-coordinate of a detected interior maximum together with the function value at that maximum. This routine is intended for use inside GPAW response/site_data analysis where one works with discrete samples of a function (for example a response function, density-related quantity, or any scalar site data obtained from a DFT calculation) and needs to locate a local peak inside the sampled interval.
    
    Args:
        x_x (numpy.ndarray): 1-D array of abscissas (x coordinates) that sample the interval on which f_x is defined. In the GPAW context these are typically real-space or reciprocal-space sample points associated with a response or site-specific quantity. The array must have the same length as f_x and should represent the sampling order along the interval (increasing or otherwise ordered consistently with f_x). This function does not modify x_x.
        f_x (numpy.ndarray): 1-D array of function values sampled at the coordinates given in x_x. Each entry f_x[i] is the function value at x_x[i]. The array must have the same length as x_x. This function uses numpy.argmax on f_x to locate the global sampled maximum index; it does not modify f_x.
    
    Behavior and practical details:
        The function finds the index of the maximum sampled value using numpy.argmax. If that maximum index lies on either endpoint of the sampled interval (index 0 or index len(x_x)-1), the routine treats this as "no interior local maximum found" and returns (numpy.nan, numpy.nan) to signal the absence of a well-defined interior peak. If the maximum index is strictly interior, the function delegates to gpaw.test.findpeak(x_x, f_x) and returns whatever (xmax, f_xmax) that helper computes. In typical GPAW usage, gpaw.test.findpeak is used to refine the peak position and value from the local neighborhood of the sampled maximum (for example via interpolation or fitting), so callers can expect a more precise peak location than the discrete sample index alone.
    
    Side effects and defaults:
        There are no side effects on inputs; x_x and f_x are not modified. There are no optional parameters or defaults. The function relies on numpy.argmax tie-breaking behavior: if multiple equal maximum values exist, numpy.argmax returns the first occurrence (lowest index), which determines whether the index is considered interior or an endpoint.
    
    Failure modes and exceptions:
        If x_x and f_x have mismatched lengths, contain non-numeric data, are not one-dimensional, or otherwise do not meet the expectations of numpy.argmax or gpaw.test.findpeak, an exception from numpy or gpaw.test.findpeak may be propagated to the caller. If the global sampled maximum lies at an endpoint, the function signals "no interior maximum" by returning NaN values rather than raising.
    
    Returns:
        tuple of two floats: (xmax, f_xmax). xmax is the x-coordinate of the detected interior maximum and f_xmax is the function value at that location. If no interior maximum is found (the sampled maximum is at an endpoint), returns (numpy.nan, numpy.nan) to indicate the absence of a valid interior peak.
    """
    from gpaw.response.site_data import maximize
    return maximize(x_x, f_x)


################################################################################
# Source: gpaw.response.site_kernels.cylindrical_geometry_factor
# File: gpaw/response/site_kernels.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_site_kernels_cylindrical_geometry_factor(
    Q_Qv: numpy.ndarray,
    ez_v: numpy.ndarray,
    rc: float,
    hc: float
):
    """Calculate the site-centered geometry factor Theta(Q) for a cylindrical site kernel (gpaw.response.site_kernels.cylindrical_geometry_factor).
    
    This function evaluates the Fourier-space integral of a uniform cylinder indicator function
    used by GPAW response kernels (the site kernel for a cylinder) and returns the
    geometry factor Theta(Q) for input wave vectors Q. In the GPAW DFT/response context
    this factor is the Fourier transform of a cylinder of radius rc and height hc
    aligned along the unit vector ez_v, multiplied by the cylinder volume V_cylinder =
    pi * rc**2 * hc. The returned array is used when constructing or applying
    site-centered response kernels in reciprocal space (for example, evaluating
    matrix elements of localized kernels or form-factors for cylindrical projector
    regions).
    
    The mathematical form implemented is
    Theta(Q) = V_cylinder * (2 J_1(Q_rho * rc) / (Q_rho * rc)) * sinc(Q_z * hc / 2),
    with Q_rho = |Q x ez_v| and Q_z = Q . ez_v, where J_1 is the Bessel function of
    the first kind of order one and sinc(x) = sin(x)/x. The code enforces the
    limiting value Theta(Q)/V_cylinder -> 1 for Q -> 0 by handling the Q_rho * rc ->
    0 limit explicitly.
    
    Args:
        Q_Qv (numpy.ndarray): Wave vectors at which to evaluate the site-centered geometry factor.
            The last axis must contain the Cartesian vector components (x,y,z) so that
            Q_Qv.shape == (..., 3). The leading axes (...) may have any tensor shape
            and will be preserved in the return value. Each vector is interpreted in the
            same Cartesian coordinate system as ez_v.
        ez_v (numpy.ndarray): Unit vector (shape (3,)) giving the normalized direction of the
            cylindrical axis (the "z" axis of the cylinder). This vector must be normalized
            to unit length within a tolerance of 1e-8 (assertion enforces |norm(ez_v)-1| < 1e-8).
            The sign of ez_v sets the cylinder axis orientation but does not affect the
            absolute value of Theta(Q) because Q_z appears inside a sinc and Q_rho is a norm.
        rc (float): Radius of the cylinder. Must be a Python float and rc > 0.0 (the function
            asserts isinstance(rc, float) and rc > 0.). rc defines the radial extent of the
            indicator function whose Fourier transform is computed.
        hc (float): Height of the cylinder. Must be a Python float and hc > 0.0 (the function
            asserts isinstance(hc, float) and hc > 0.). hc defines the axial extent of the
            cylinder; the axial factor used is sinc(Q_z * hc / 2).
    
    Behavior and numerical details:
        - The function computes V_cylinder = pi * rc**2 * hc and returns Theta_Q with the same
          units as volume (i.e., equal to the integral of exp(-i Q.r) over the cylinder).
        - The output array Theta_Q has shape equal to Q_Qv.shape[:-1]; values correspond to the
          geometry factor for each input vector Q.
        - The radial factor uses the Bessel function jv(1, x). To avoid division by zero at
          Q_rho * rc == 0 the implementation sets the radial prefactor to its limiting value
          1.0 for |Q_rho * rc| <= 1e-8 before multiplying by V_cylinder and the axial sinc.
        - The axial factor uses the normalized sinc function sinc(x) = sin(x)/x; the code calls
          the sinc implementation available in the surrounding module/namespace.
        - The implementation computes Q_z = absolute(Q . ez_v) and Q_rho = ||Q x ez_v|| so the
          result is independent of sign convention along ez_v for these scalar combinations.
        - The function operates elementwise over any leading tensor dimensions of Q_Qv and is
          purely functional (no side effects such as file I/O or global state modification).
    
    Failure modes and errors:
        - The function uses assertions to validate inputs. Violating any of these raises AssertionError:
            - Q_Qv.shape[-1] != 3
            - ez_v.shape != (3,)
            - abs(norm(ez_v) - 1.0) >= 1e-8
            - rc is not a float or rc <= 0.0
            - hc is not a float or hc <= 0.0
        - If Q_Qv contains non-finite values (NaN or Inf) or values that cause overflow in intermediate
          operations, the returned Theta_Q may contain NaNs or Infs and runtime warnings may be issued
          by NumPy/SciPy routines. The function does not catch these exceptions.
        - The numeric threshold for treating Q_rho * rc as zero is 1e-8; results for extremely small but
          nonzero arguments will use the limiting expression to maintain numerical stability.
    
    Returns:
        numpy.ndarray: Array of floats with shape Q_Qv.shape[:-1] containing the geometry factor Theta(Q)
        evaluated at each input wave vector. The values are dimensionful (units of volume), equal to
        V_cylinder times a dimensionless form factor. For Q -> 0 the values approach V_cylinder (so
        Theta(Q)/V_cylinder -> 1). No other side effects occur.
    """
    from gpaw.response.site_kernels import cylindrical_geometry_factor
    return cylindrical_geometry_factor(Q_Qv, ez_v, rc, hc)


################################################################################
# Source: gpaw.response.site_kernels.spherical_geometry_factor
# File: gpaw/response/site_kernels.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_site_kernels_spherical_geometry_factor(Q_Qv: numpy.ndarray, rc: float):
    """gpaw.response.site_kernels.spherical_geometry_factor — Calculate the site-centered geometry factor for a spherical site kernel used in GPAW response calculations.
    
    Computes the Fourier-space integral Θ(Q) = ∫ d^3r e^{-i Q·r} θ(|r| < r_c) for a sphere of radius rc and returns the geometry factor per wave-vector multiplied by the sphere volume. This function is used in the GPAW response/site_kernels code to construct site-centered spherical kernels in reciprocal space (e.g., when evaluating structure factors or site contributions to response functions in density-functional-theory simulations). The analytic expression implemented is Θ(Q) = V_sphere * 3 [sinc(|Q| r_c) - cos(|Q| r_c)] / (|Q| r_c)^2 with the limiting value Θ(Q) → V_sphere for |Q| r_c → 0. The implementation uses the Euclidean norm of the cartesian Q vectors, a small tolerance to avoid division by zero, and returns a real-valued array of geometry factors (units of volume, since the dimensionless factor is multiplied by the sphere volume).
    
    Args:
        Q_Qv (numpy.ndarray): Wave vectors at which to evaluate the spherical site geometry factor. The cartesian coordinates must be the last dimension of the array (size 3), so the expected shape is (..., 3). The leading dimensions (denoted Q in the source) can have any tensor structure corresponding to multiple Q points; the return array will have shape Q_Qv.shape[:-1]. Each entry Q_Qv[..., i] is interpreted in the same Cartesian coordinate system used by GPAW for reciprocal vectors.
        rc (float): Radius of the sphere (r_c). This is the real-space cutoff radius defining the spherical site kernel; it must be a positive Python float. The function asserts rc is a float and rc > 0 and uses rc to compute the dimensionless product |Q| r_c and the sphere volume V_sphere = 4π rc^3 / 3.
    
    Returns:
        numpy.ndarray: Real-valued array of geometry factors Θ(Q) with the same leading shape as Q_Qv (i.e., shape Q_Qv.shape[:-1]). Each element is the integral over the sphere of e^{-i Q·r} and therefore has the dimensions of volume (the function multiplies a dimensionless form factor by the sphere volume). The return dtype is float.
    
    Behavior, defaults, and failure modes:
        - The function requires Q_Qv.shape[-1] == 3; otherwise an AssertionError is raised.
        - The function requires rc to be a positive float; otherwise an AssertionError is raised.
        - To avoid division by zero at |Q| r_c ≈ 0, a numerical tolerance of 1e-8 is used: values with |Q| r_c <= 1e-8 are assigned the limiting value Θ(Q) = V_sphere (implemented by initializing the output to ones times V_sphere). This ensures the limit Θ(Q)/V_sphere → 1 for small arguments.
        - The computation uses the Euclidean norm of the last axis of Q_Qv (numpy.linalg.norm with axis=-1) and NumPy math functions for sinc and cosine; behavior for very large |Q| follows the analytic formula and is subject to standard floating-point rounding errors.
        - No in-place modification of the input array Q_Qv is performed; the function allocates and returns a new numpy.ndarray.
        - If Q_Qv contains NaN or infinite values in the last dimension, the result for those entries will be NaN or inf as propagated by NumPy operations.
    """
    from gpaw.response.site_kernels import spherical_geometry_factor
    return spherical_geometry_factor(Q_Qv, rc)


################################################################################
# Source: gpaw.response.susceptibility.read_eigenmode_lineshapes
# File: gpaw/response/susceptibility.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_susceptibility_read_eigenmode_lineshapes(filename: str):
    """gpaw.response.susceptibility.read_eigenmode_lineshapes: Read a stored eigenmode lineshapes file produced by GPAW response/susceptibility calculations and return the frequency grid and the per-eigenmode lineshape amplitudes as NumPy arrays.
    
    Args:
        filename (str): Path to a plaintext CSV file produced by GPAW's response/eigenmode export routines. The file must contain numeric data delimited by commas, where the first column is the sampled frequency grid (omega) and each subsequent column contains the corresponding lineshape amplitude for one eigenmode. The function expects at least one column (omega) and will attempt to convert all values to float. This parameter is used to locate and open the file for reading; no writing or modification of the file is performed.
    
    Returns:
        omega_w (numpy.ndarray): A one-dimensional NumPy array of dtype float containing the frequency grid read from the first column of the file. Shape is (N,), where N is the number of rows in the input file. In the GPAW response/susceptibility domain, these omega values represent the sampled frequency points at which eigenmode lineshapes a_wm were evaluated.
        a_wm (numpy.ndarray): A two-dimensional NumPy array of dtype float containing the lineshape amplitudes read from the remaining columns of the file. Shape is (N, M) where N is the number of rows (same as omega_w) and M is the number of eigenmodes (number of columns minus one). Each column m in a_wm gives the lineshape amplitude for eigenmode m across the frequency grid omega_w; these arrays are typically used downstream to reconstruct susceptibilities, spectra, or to plot mode-resolved response functions.
    
    Behavior and side effects:
        The function reads the entire file with numpy.loadtxt using delimiter=',' and converts all entries to float. It does not modify the input file or global program state. The returned arrays are newly allocated NumPy arrays.
    
    Failure modes and exceptions:
        If the file does not exist, Python will raise FileNotFoundError (or an OSError on some platforms). If the file cannot be parsed as a numeric CSV with a consistent number of columns per row, numpy.loadtxt will raise a ValueError. If the file contains non-numeric entries in places expected to be floats, a ValueError will be raised. The caller should ensure the file follows the expected CSV layout (first column omega, remaining columns eigenmode amplitudes) before calling this function.
    
    Usage notes:
        Typical use in the GPAW response workflow is to call this function to load saved eigenmode lineshapes and then combine the returned omega_w and a_wm to compute frequency-dependent susceptibilities or spectra, or to visualize mode-resolved contributions. The function preserves the ordering of frequency points and eigenmodes as stored in the file.
    """
    from gpaw.response.susceptibility import read_eigenmode_lineshapes
    return read_eigenmode_lineshapes(filename)


################################################################################
# Source: gpaw.response.susceptibility.read_full_spectral_weight
# File: gpaw/response/susceptibility.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_susceptibility_read_full_spectral_weight(filename: str):
    """gpaw.response.susceptibility.read_full_spectral_weight reads a stored full spectral weight file produced by GPAW susceptibility/response calculations and returns the frequency grid and corresponding spectral weight values as NumPy arrays.
    
    This function is used in the context of GPAW's linear-response and susceptibility analysis where a "full spectral weight" file stores pairs of frequency (omega) and spectral weight A(omega) values. The returned arrays can be used to reconstruct response functions, to plot spectral features, or to perform subsequent numerical integrations or convolutions in DFT-based response analyses.
    
    Args:
        filename (str): Path to a text file containing the stored full spectral weight. The file must be a comma-separated text file with two columns and one data row per frequency point: the first column is the frequency variable omega and the second column is the spectral weight A(omega). The argument is the filesystem path string that numpy.loadtxt will open and parse. Typical use is to supply a path produced by GPAW response utilities. If the file is missing, unreadable, or malformed, the function will propagate the underlying exceptions (e.g., FileNotFoundError/OSError for I/O errors or ValueError for parse errors).
    
    Returns:
        tuple: A tuple (omega_w, A_w) where
            omega_w (numpy.ndarray): 1-D array of floats containing the frequency grid read from the first column of the file. Its length N equals the number of rows in the file. In GPAW response workflows, these are the frequency sampling points at which the spectral weight was computed or stored.
            A_w (numpy.ndarray): 1-D array of floats containing the spectral weight values read from the second column of the file. It has the same length N as omega_w. In susceptibility calculations, A_w represents the spectral density or weight associated with each frequency omega_w and is used to build or analyze dynamical response functions.
    
    Behavior and side effects:
        The function uses numpy.loadtxt with delimiter=',' to parse the file and converts the two columns to NumPy arrays of float. There are no other side effects (no file writing, no global state mutation). The function will raise FileNotFoundError/OSError if the file cannot be opened, and ValueError if the file does not contain two numeric columns per row or contains non-numeric entries that cannot be converted to float. An empty file will result in empty 1-D NumPy arrays for both omega_w and A_w. Whitespace around values is permitted as handled by numpy.loadtxt. The function does not validate physical ranges (e.g., monotonicity of omega or positivity of A_w); such domain-specific checks should be performed by the caller if required.
    """
    from gpaw.response.susceptibility import read_full_spectral_weight
    return read_full_spectral_weight(filename)


################################################################################
# Source: gpaw.response.site_kernels.sinc
# File: gpaw/response/site_kernels.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_site_kernels_sinc(x: numpy.ndarray):
    """gpaw.response.site_kernels.sinc computes the mathematical sinc function sin(x)/x elementwise for a NumPy array. In the GPAW codebase (a DFT package using real-space uniform grids and site-centered kernels), this routine is used by response.site_kernels to build sinc-shaped kernels or interpolation/filter functions on grid-based representations. The implementation uses NumPy's normalized numpy.sinc (which implements sin(pi*y)/(pi*y)) and therefore evaluates numpy.sinc(x / numpy.pi) to produce sin(x)/x.
    
    Args:
        x (numpy.ndarray): Input array of numeric values interpreted as the argument(s) of the sinc function. Each element is treated as an angle in radians for the sine evaluation. The array may be any shape; the function computes the sinc value for every element independently. The caller must supply a numpy.ndarray; passing non-ndarray objects may raise an exception if they cannot be converted to an ndarray by NumPy.
    
    Returns:
        numpy.ndarray: A NumPy array with the same shape as x containing the elementwise values of sinc(x) = sin(x)/x. The dtype of the result follows NumPy's ufunc casting rules (typically a floating-point dtype for numeric inputs). The function does not modify the input array x; it returns a new array (or NumPy-managed view) containing the computed values. By mathematical continuity, elements of x that are exactly zero produce the value 1. Values such as NaN or Inf in x propagate according to NumPy's sin and division semantics (e.g., resulting NaN or implementation-defined values), so callers should sanitize inputs if deterministic handling of non-finite values is required.
    """
    from gpaw.response.site_kernels import sinc
    return sinc(x)


################################################################################
# Source: gpaw.response.site_kernels.parallelepipedic_geometry_factor
# File: gpaw/response/site_kernels.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_site_kernels_parallelepipedic_geometry_factor(
    Q_Qv: numpy.ndarray,
    cell_cv: numpy.ndarray
):
    """Calculate the site-centered geometry factor Theta(Q) for a parallelepipedic site kernel used in GPAW response calculations.
    
    This function evaluates the Fourier transform of the indicator function of a parallelepiped:
    Theta(Q) = ∫_V e^{-i Q·r} dr = V_parallelepiped * sinc(Q·a1 / 2) * sinc(Q·a2 / 2) * sinc(Q·a3 / 2),
    where a1, a2 and a3 are the parallelepipedic cell vectors. In the GPAW response context this geometry factor is used to represent a site-centered kernel in reciprocal space when assembling response functions or multiplying site contributions in Fourier space.
    
    Args:
        Q_Qv (numpy.ndarray): Wave vectors at which to evaluate the site-centered geometry factor. The cartesian coordinates must be the last dimension of the array (denoted by v), so the array must satisfy Q_Qv.shape = (..., 3). The leading index/indices (...) may have any tensor structure (for example a single vector with shape (3,), a batch of vectors with shape (N, 3), or higher-rank tensors). Each 3-component vector is interpreted as a cartesian wave vector Q in the same coordinate system as cell_cv.
        cell_cv (numpy.ndarray): Cell vectors of the parallelepiped with shape=(3, 3). The three rows (or first index entries) of cell_cv are interpreted as the parallelepipedic cell vectors a1, a2, a3 expressed in cartesian coordinates (v denotes cartesian coordinates). These vectors define the real-space parallelepiped whose indicator function is Fourier transformed.
    
    Returns:
        numpy.ndarray: The computed geometry factor Theta(Q) evaluated at each input wave vector. The return array has the same tensor structure as the leading indices of Q_Qv, i.e. shape = Q_Qv.shape[:-1]. Each element is the scalar value V_parallelepiped * sinc(Q·a1/2) * sinc(Q·a2/2) * sinc(Q·a3/2) for the corresponding input wave vector.
    
    Behavior, side effects, and failure modes:
        - The function performs no in-place modification of its inputs; it is pure and returns a newly allocated numpy.ndarray.
        - Internally the parallelepiped volume V_parallep is computed as abs(det(cell_cv)). The implementation requires a non-singular parallelepiped: it asserts that V_parallep > 1.e-8. If the volume is <= 1.e-8 an AssertionError is raised with the intent "Not a valid parallelepiped if volume vanishes".
        - The function asserts that Q_Qv.shape[-1] == 3 and that cell_cv.shape == (3, 3). If these shape requirements are not met an AssertionError is raised.
        - The sinc function is applied elementwise to the scalar arguments Q·a_i / 2. The implementation uses the sinc routine available in the module environment; users should ensure that the numerical definition of sinc used by this code matches their expectations (it is applied elementwise).
        - No dtype coercion or explicit dtype checks are performed beyond what numpy operations require; feeding non-numeric or incompatible dtypes may lead to numpy exceptions during matrix or determinant calculations.
    """
    from gpaw.response.site_kernels import parallelepipedic_geometry_factor
    return parallelepipedic_geometry_factor(Q_Qv, cell_cv)


################################################################################
# Source: gpaw.response.susceptibility.write_eigenmode_lineshapes
# File: gpaw/response/susceptibility.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_susceptibility_write_eigenmode_lineshapes(
    filename: str,
    omega_w: numpy.ndarray,
    a_wm: numpy.ndarray
):
    """gpaw.response.susceptibility.write_eigenmode_lineshapes writes frequency-dependent eigenmode lineshapes a^μν_n(ω) produced by GPAW response/susceptibility calculations to a plain-text file. This function is intended for post-processing and analysis workflows in density-functional theory (DFT) response calculations performed with GPAW: it exports the frequency axis (omega, in electronvolts) together with the corresponding eigenmode amplitudes for each mode so they can be inspected, plotted, or consumed by other tools.
    
    Args:
        filename (str): Path to the output file. The file is opened with mode 'w' so an existing file at this path will be overwritten. The file is written as human-readable text with a single header line prefixed by '#' and subsequent comma-separated numeric rows.
        omega_w (numpy.ndarray): One-dimensional array of frequency points (ω) in electronvolts. In the context of GPAW susceptibility/eigenmode output, this is the frequency axis at which the lineshapes a^μν_n(ω) have been evaluated. The code iterates over omega_w in lockstep with the rows of a_wm using zip, so omega_w should have a length equal to the first dimension of a_wm for a complete, one-to-one mapping; if lengths differ, only min(len(omega_w), number_of_rows_in_a_wm) rows are written because zip truncates to the shortest input.
        a_wm (numpy.ndarray): Two-dimensional array with shape (N, M) holding the eigenmode lineshape amplitudes a_m(ω) evaluated at the N frequency points. The second dimension M is the number of eigenmodes (indexed by m) and is used to produce M additional columns in the output. The function accesses a_wm.shape[1] to determine the number of mode columns, so a_wm must be a 2D numpy.ndarray; passing an array with fewer dimensions will raise an AttributeError or IndexError.
    
    Returns:
        None: This function does not return a value. Its sole effect is the side effect of creating or overwriting the file at filename and writing text data to it. The written file begins with a header line of the form
        #    omega [eV], a_0(w), a_1(w), ...
        followed by one data row per frequency pair produced by zip(omega_w, a_wm). Each numeric value is formatted with fixed-point notation and six decimal places (format specifier 11.6f) and columns are separated by comma and space. Possible failure modes include OSError/IOError if the file cannot be opened or written, and TypeError/AttributeError/IndexError if the provided arrays do not have the expected numpy.ndarray structure or dimensions.
    """
    from gpaw.response.susceptibility import write_eigenmode_lineshapes
    return write_eigenmode_lineshapes(filename, omega_w, a_wm)


################################################################################
# Source: gpaw.response.susceptibility.write_full_spectral_weight
# File: gpaw/response/susceptibility.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_susceptibility_write_full_spectral_weight(
    filename: str,
    omega_w: numpy.ndarray,
    A_w: numpy.ndarray
):
    """Write the sum of spectral weights A(ω) to a plain-text file for use in post-processing, plotting, or archival storage. This function is used in the GPAW response/susceptibility workflow to persist the computed frequency-dependent spectral weight A(ω) evaluated on a frequency grid ω for later analysis (for example, plotting optical or electronic response functions computed within density-functional theory using GPAW).
    
    Args:
        filename (str): Path to the output file where the two-column ASCII data will be written. The file is opened for text writing ('w') using the system default encoding, overwriting any existing file at that path. This argument is the destination on disk for the spectral-weight data and determines side effects (file creation/modification) of the function.
        omega_w (numpy.ndarray): 1D array of frequency points corresponding to the spectral weight values. Each element represents a frequency ω expressed in electronvolts (eV). The array must be iterable and is paired elementwise with A_w; only as many rows are written as the length of the shorter of the two provided iterables (zip behaviour).
        A_w (numpy.ndarray): 1D array of spectral-weight values A(ω) corresponding to the frequencies in omega_w. Each element is a numeric spectral weight (sum of spectral weights) produced by GPAW response/susceptibility calculations. The array must be iterable and align with omega_w; non-numeric entries will raise formatting errors when written.
    
    Returns:
        None: This function does not return a value. Its effect is a side effect: creating or overwriting the file at filename with a human-readable two-column table. The first line is a comment header "#   omega [eV],   A(w)" and subsequent lines contain the numeric values formatted with fixed-point notation (11 total characters, 6 digits after the decimal point) for both omega and A(ω).
    
    Behavior, defaults, and failure modes:
    - The file is written in text mode ('w') and will overwrite any existing file at filename without prompting.
    - The header line uses the literal column labels "omega [eV]" and "A(w)" to indicate the physical meaning of the two columns.
    - Numeric rows are written using the format specifier "{:11.6f}" for both columns, producing fixed-width, six-decimal precision output suitable for plotting tools.
    - If omega_w and A_w have different lengths, only min(len(omega_w), len(A_w)) rows are written because the function iterates with zip; this truncation is intentional but may be unexpected, so callers should ensure arrays are matched.
    - If filename cannot be opened for writing (permission issues, invalid path, filesystem full), the underlying open/print calls will raise OSError (or a subclass), which propagates to the caller.
    - If elements of omega_w or A_w are not convertible to a float for formatting, a TypeError or ValueError may be raised during string formatting.
    - The function does not perform input validation beyond relying on the iterable and formatting behaviour; callers should supply arrays consistent with GPAW response/susceptibility output (frequency grid in eV and corresponding summed spectral weights) to avoid runtime errors.
    """
    from gpaw.response.susceptibility import write_full_spectral_weight
    return write_full_spectral_weight(filename, omega_w, A_w)


################################################################################
# Source: gpaw.response.tool.get_degeneracy_matrix
# File: gpaw/response/tool.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_tool_get_degeneracy_matrix(eps_n: numpy.ndarray, tol: float = 0.001):
    """gpaw.response.tool.get_degeneracy_matrix generates a degeneracy-selection matrix and a list of representative energies for groups of (nearly) degenerate single-particle eigenvalues. This function is used in GPAW response and transition-summing code to identify and sum contributions from degenerate Kohn–Sham states: it produces a matrix whose rows select the members of each degenerate group and an array of one representative energy per group.
    
    Args:
        eps_n (numpy.ndarray): A one-dimensional NumPy array of single-particle energies (for example Kohn–Sham eigenvalues produced by a GPAW calculation). The function treats equal or nearly equal values that occur in contiguous positions of this array as degenerate; therefore, eps_n should be sorted in non-decreasing order if grouping of all equal energies is required. The practical significance in GPAW is that these energies are the basis for grouping states that should be summed together in response/transition calculations.
        tol (float): Absolute tolerance for degeneracy in the same units as eps_n. Two energies eps_n[i] and eps_n[j] are considered degenerate if abs(eps_n[i] - eps_n[j]) < tol. The default (0.001) is suitable for grouping energies that differ only by numerical noise; increase or decrease this value to control how strictly degeneracy is detected. tol must be a floating-point number; negative values are not meaningful and may lead to unexpected grouping behavior.
    
    Returns:
        tuple: A tuple (degmat, eps_N) with the following elements.
            degmat (numpy.ndarray): A 2-D NumPy array of shape (M, N) where N == len(eps_n) and M is the number of degenerate groups found. Each row is a selection vector composed of 1s and 0s: elements equal to 1 mark indices of eps_n that belong to that degeneracy group, elements equal to 0 mark indices not in the group. This matrix is intended to be used to sum or select all members of each degenerate set when constructing sums over states in response calculations.
            eps_N (numpy.ndarray): A 1-D NumPy array of length M giving the representative energy for each degenerate group. Each entry corresponds to the value of eps_n at the first index of the group (i.e., the first member encountered when scanning eps_n). This array is useful as the energy label for the grouped states.
    
    Behavior and side effects:
        The function scans eps_n from left to right and groups only contiguous entries whose pairwise absolute difference is less than tol. It does not sort eps_n; therefore, to ensure all identical energies are grouped together the caller must provide a sorted eps_n. There are no external side effects (no I/O, no modification of inputs). The function returns new NumPy arrays.
    
    Failure modes and errors:
        A TypeError or other exception may be raised if eps_n is not an array-like object of numeric values or if array operations fail. Providing an unsorted eps_n will lead to grouping based only on contiguous elements and can produce unexpected groups. Using an inappropriate tol (for example, a negative number) may result in incorrect or empty groupings.
    """
    from gpaw.response.tool import get_degeneracy_matrix
    return get_degeneracy_matrix(eps_n, tol)


################################################################################
# Source: gpaw.response.site_kernels.create_geometry_factor
# File: gpaw/response/site_kernels.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_site_kernels_create_geometry_factor(shape: str):
    """Creator function for the geometry factor factory used by gpaw.response.site_kernels.
    
    This function selects and returns a geometry-specific geometry-factor creator given a symbolic shape name. In the GPAW DFT/PAW response-kernel context, a "geometry factor" encodes the shape-dependent spatial weighting or kernel prefactor used by site kernels when computing local response contributions (for example, integrals or projections that depend on the region shape). create_geometry_factor is the factory selector component: it maps the exact string names used throughout gpaw.response.site_kernels to the corresponding geometry-factor implementation functions so that higher-level response code can obtain the correct shape-dependent routine.
    
    Args:
        shape (str): Symbolic name of the desired geometry factor. Must be one of the exact, case-sensitive strings understood by the site_kernels module: 'sphere', 'cylinder', or 'parallelepiped'. Each name selects a specific implementation: 'sphere' -> spherical_geometry_factor, 'cylinder' -> cylindrical_geometry_factor, and 'parallelepiped' -> parallelepipedic_geometry_factor. There is no default; callers must supply a valid string. This parameter controls which geometry-dependent weighting routine is returned and therefore determines how the site kernel treats spatial regions in response calculations.
    
    Returns:
        callable: The geometry-factor creator function corresponding to the requested shape. The returned callable is the implementation function used by gpaw.response.site_kernels to produce geometry-dependent factors for site kernels; it encapsulates the shape-specific algorithm and is intended to be invoked by the response machinery to obtain numeric geometry factors. The exact call signature of the returned callable is defined by the site_kernels implementation and is required by the rest of the response code.
    
    Raises:
        ValueError: If shape is not one of the supported strings. The function raises ValueError with the arguments ('Invalid site kernel shape:', shape) to indicate that an unrecognized geometry name was provided. This is a hard failure mode; callers should validate or handle the exception if shape may be external or user-supplied.
    
    Side effects:
        None. create_geometry_factor performs only a pure selection/mapping and returns a function object; it does not modify global state or the simulation setup.
    """
    from gpaw.response.site_kernels import create_geometry_factor
    return create_geometry_factor(shape)


################################################################################
# Source: gpaw.response.tool.lorz_fit
# File: gpaw/response/tool.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_tool_lorz_fit(
    x: numpy.ndarray,
    y: numpy.ndarray,
    npeak: int = 1,
    initpara: numpy.ndarray = None
):
    """gpaw.response.tool.lorz_fit fits one or two Lorentzian peak profiles to 1D data arrays using a least-squares optimizer. It is intended for analyzing spectral or response-like curves (for example peaks in density-of-states, spectral functions, or response spectra produced in GPAW DFT workflows) by returning a fitted curve and the optimized Lorentzian parameters. The implementation currently supports only a single Lorentzian (npeak == 1) or two Lorentzians (npeak == 2) and uses scipy.optimize.leastsq with a maximum of 2000 function evaluations.
    
    The fitted model for one Lorentzian peak is defined pointwise as:
        lorz(x) = A * w / ((x - x0)**2 + w**2) + y0
    where A is the peak amplitude scale, w is the half-width parameter controlling the peak width, x0 is the peak center in the same units as x, and y0 is a constant baseline offset. For two peaks the model is a sum of two such terms, each with its own set of parameters in the parameter vector described below.
    
    Args:
        x (numpy.ndarray): Independent variable array containing sampled x-values of the data to fit (e.g., energy, frequency, or other response variable from a GPAW calculation). The returned fitted curve yfit has the same shape and ordering as x. Values are used directly in the Lorentzian formula; no automatic normalization or unit conversion is performed.
        y (numpy.ndarray): Dependent variable array of the same shape as x containing the measured or computed data to be fitted (e.g., spectral intensity or response magnitude from GPAW). The fitter minimizes the residual y - model(x, params) in least-squares sense.
        npeak (int): Number of Lorentzian peaks to fit. Valid values are 1 or 2. The code raises ValueError when npeak > 2, since fits with more than two peaks are not implemented. Default is 1, which fits a single Lorentzian defined above.
        initpara (numpy.ndarray): Initial guess for the flattened parameter vector passed to the least-squares optimizer. For npeak == 1 the expected shape/length is 4 with ordering [A, x0, y0, w]. For npeak == 2 the expected shape/length is 8 with ordering [A1, x01, y01, w1, A2, x02, y02, w2], i.e., the four parameters for peak 1 followed by the four for peak 2. If initpara is None, the function uses built-in defaults: for npeak == 1 numpy.array([1., 0., 0., 0.1]) and for npeak == 2 numpy.array([1., 0., 0., 0.1, 3., 0., 0., 0.1]). These defaults serve as practical starting points when no domain-specific initial estimates are provided.
    
    Behavior, side effects, defaults, and failure modes:
        The function constructs an internal Lorentzian model and a residual function and then calls scipy.optimize.leastsq with a maximum of 2000 function evaluations (maxfev=2000). The optimization modifies only local variables and returns no filesystem or global side effects. The returned parameter vector is the optimizer output; if the optimizer does not converge within maxfev, scipy.optimize.leastsq may return a best-effort parameter array along with diagnostic information according to SciPy's API. The function raises ValueError explicitly when npeak > 2. The caller is responsible for providing x and y with compatible shapes and for interpreting the fitted parameters in the physical units of the input data (e.g., eV for energies when fitting spectra from GPAW). No automatic bounding or parameter constraints are applied by this routine.
    
    Returns:
        tuple:
            yfit (numpy.ndarray): Fitted dependent-variable array evaluated at the input x points using the optimized Lorentzian model. yfit has the same shape as x and is suitable for plotting or computing residuals against the original y.
            params (numpy.ndarray): Optimized parameter vector returned by the least-squares optimizer. For npeak == 1 this is an array of length 4 with ordering [A, x0, y0, w]; for npeak == 2 this is an array of length 8 with ordering [A1, x01, y01, w1, A2, x02, y02, w2]. These parameters have the practical meaning described above and can be used to report peak positions, amplitudes, baselines, and widths in the same units as the input data.
    """
    from gpaw.response.tool import lorz_fit
    return lorz_fit(x, y, npeak, initpara)


################################################################################
# Source: gpaw.rotation.Y_matrix
# File: gpaw/rotation.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_rotation_Y_matrix(l: int, U_vv: numpy.ndarray):
    """Compute the matrix of spherical-harmonic values for angular momentum l evaluated at a set of rotated sample points.
    
    This function is used in GPAW's rotation utilities to build the matrix of values of the internal Y(...) function (spherical-harmonic-like evaluator used in this module) for 2*l+1 sample points on the unit sphere. The sample points are taken from the module-level list sphere_lm[l] (one point per m1 = 0,...,2*l). Each sample point is rotated by the 3D linear transformation U_vv (typically a 3×3 rotation matrix in GPAW applications), and for each rotated point the function evaluates Y at indices L = l**2 + m2 for m2 = 0,...,2*l. The resulting matrix Y_mm has rows enumerating the input sample points (m1) and columns enumerating the evaluated Y indices derived from m2. In GPAW this matrix is a building block for constructing rotation operators in the angular-momentum-l subspace (for example when rotating PAW projectors, atomic-like basis functions, or related quantities between coordinate frames).
    
    Args:
        l (int): Angular momentum quantum number l >= 0 that selects the subspace size. The function uses 2*l+1 sample points and produces a square matrix of size (2*l+1)×(2*l+1). In practice l is a non-negative integer used throughout GPAW to index angular-momentum channels (e.g. s,p,d,...). If l is not an integer or is negative, the function will either behave incorrectly or raise exceptions (TypeError/IndexError/ValueError) when accessing sphere_lm or during array allocation.
        U_vv (numpy.ndarray): 3D linear transformation applied to each unit-sphere sample point before evaluation. The object must be a NumPy ndarray compatible with NumPy's dot product with a 3-element point (the code uses numpy.dot(point, U_vv)). In GPAW usage this is typically a 3×3 orthogonal rotation matrix (dtype float), but any ndarray with a shape and dtype that make the dot product valid is accepted. If U_vv has incompatible shape or is not an ndarray, NumPy will raise an appropriate exception (TypeError or ValueError). Note that if U_vv is not a proper rotation (orthonormal) matrix, the numerical values produced will correspond to the transformed coordinates but will not represent a geometric rotation.
    
    Returns:
        numpy.ndarray: A 2D NumPy array Y_mm with shape (2*l+1, 2*l+1). Entry Y_mm[m1, m2] equals Y(L, x, y, z) where L = l**2 + m2 and (x, y, z) = numpy.dot(sphere_lm[l][m1], U_vv). The matrix rows index the original sample points m1 = 0,...,2*l and the columns index the evaluated Y entries derived from m2 = 0,...,2*l. This returned array is the primary output used to assemble rotation matrices acting on the angular-momentum-l components in GPAW. No other side effects occur (the function is pure with respect to module state), but the function relies on the presence of the module-level sphere_lm list and the Y(...) evaluator; missing or inconsistent definitions of those will cause IndexError or NameError at runtime.
    
    Failure modes and notes:
        - If sphere_lm does not contain an entry for the provided l (IndexError), the function will raise an exception.
        - If U_vv is not shape-compatible with the 3-element sample points (ValueError/TypeError from numpy.dot), an exception will be raised.
        - If l is not an integer or is negative, behavior is undefined and typical Python errors (TypeError, ValueError, IndexError) may occur.
        - The function performs O((2*l+1)^2) evaluations of Y and uses memory proportional to (2*l+1)^2; for large l this can be computationally and memory intensive.
    """
    from gpaw.rotation import Y_matrix
    return Y_matrix(l, U_vv)


################################################################################
# Source: gpaw.sphere.integrate.find_two_closest_grid_points
# File: gpaw/sphere/integrate.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_sphere_integrate_find_two_closest_grid_points(r_g: numpy.ndarray, rcut: float):
    """gpaw.sphere.integrate.find_two_closest_grid_points finds the two grid-point indices in a radial grid array that are closest in absolute distance to a specified radial cutoff rcut. This function is used in GPAW's spherical integration utilities to map a physical radial cutoff (for example, the radius of a sphere around an atom used in PAW or real-space integrations) to the two nearest discrete grid points on the radial grid so that subsequent interpolation or selection of grid points can be performed.
    
    Detailed behavior: the function computes the absolute differences between each entry of the radial grid array r_g and the scalar cutoff rcut, then uses NumPy's partition to identify the two smallest absolute differences and the corresponding indices. The returned indices are the first occurrences in r_g that match those two smallest absolute differences. The implementation uses vectorized NumPy operations (abs and partition) and then numpy.where to locate indices.
    
    Args:
        r_g (numpy.ndarray): One-dimensional array of radial grid point coordinates (radial distances) in the same units as rcut. In the GPAW context this array typically represents a uniform or nonuniform real-space radial grid used for spherical integrals and atom-centered regions. The function expects r_g to be non-empty; an empty array will cause an indexing error.
        rcut (float): Scalar radial cutoff value (radius) in the same units as r_g. This is the target radius for which the two closest grid-point indices are desired (e.g., the radial boundary of a sphere around an atom used in integration or region selection).
    
    Returns:
        tuple: (g1, g2) where g1 and g2 are integers giving indices into r_g. g1 is the index of the grid point whose coordinate has one of the two smallest absolute differences |r_g - rcut|, and g2 is the index of the grid point with the other of the two smallest absolute differences. If multiple entries in r_g have identical distances equal to the smallest or second-smallest absolute difference, the function returns the first occurrence for each. There are no side effects.
    
    Failure modes and notes:
        - If r_g is empty, the function will raise an IndexError when attempting to extract indices; callers must ensure r_g contains at least two elements when two distinct indices are required.
        - If rcut lies outside the range of values in r_g, the function still returns the two indices corresponding to the closest endpoints of r_g (closest in absolute difference).
        - If r_g contains duplicate coordinates, the selection of which duplicate index is returned is the first matching index from numpy.where.
        - The function returns Python integer indices (they may be NumPy integer types depending on array dtype). The order of g1 and g2 corresponds to the order in which the two smallest absolute differences are found by the partition-and-where logic and should be treated as an unordered pair of the two nearest grid-point indices when used for interpolation or region definition.
    """
    from gpaw.sphere.integrate import find_two_closest_grid_points
    return find_two_closest_grid_points(r_g, rcut)


################################################################################
# Source: gpaw.sphere.integrate.find_volume_conserving_lambd
# File: gpaw/sphere/integrate.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_sphere_integrate_find_volume_conserving_lambd(
    rcut: float,
    drcut: float,
    r_g: numpy.ndarray = None
):
    """Determine the scaling factor λ (lambda) that makes a radial truncation function conserve the spherical volume.
    
    This function is used in GPAW's spherical integration and truncation utilities to find a multiplicative scaling parameter λ such that the numerically integrated, truncated radial weight function θ(r) yields the same total volume as an ideal sphere of radius rcut. In practice this is important when constructing smooth truncation/mask functions for spherical regions (for example PAW augmentation spheres or localized real-space cutoffs) on a radial grid: the function adjusts the truncation so that 4π ∫_0^rcut r^2 θ(r) dr = 4π rcut^3 / 3 within numerical tolerance.
    
    Args:
        rcut (float): Cutoff radius r_c of the sphere. This is the radius of the target sphere whose volume must be conserved by the truncated radial weight. The value is interpreted in the same length units as the caller's radial grid and other GPAW routines (no unit conversion is performed here).
        drcut (float): Radial grid spacing or differential parameter used to construct the uniform radial grid when r_g is not provided. When r_g is None, the function calls _uniform_radial_grid(rcut, drcut) to build a 1D radial grid from 0 up to rcut with spacing approximately drcut; drcut therefore controls the numerical resolution of the volume integral and affects the resulting λ through discretization error.
        r_g (numpy.ndarray or None): Optional 1D NumPy array of radial grid points (r values) to use for the numerical integration. If provided, these values are used directly by radial_truncation_function and radial_trapz to evaluate the integral 4π ∫ r^2 θ(r) dr. If r_g is None (the default), a uniform radial grid is constructed by calling _uniform_radial_grid(rcut, drcut). The array should represent radii spanning the region of interest up to rcut; providing a precomputed grid lets callers control grid placement and resolution explicitly.
    
    Returns:
        float: The optimized scaling factor λ (a scalar float). This λ is the value that the function found by minimizing the squared difference between the numerically integrated truncated-volume and the analytic sphere volume ref = 4π rcut^3 / 3. The minimization is performed with scipy.optimize.minimize using the L-BFGS-B method, an initial guess of 0.5, bounds (1e-8, 1 - 1e-8) to keep λ strictly between 0 and 1, and a function-tolerance option ftol = 1e-12 for convergence. No other side effects occur: inputs are not modified in place.
    
    Raises:
        Exception: If the internal optimization fails (opt_result.success is False), an Exception is raised with the message 'Could not find an appropriate truncation scaling λ' and the optimizer's diagnostic message appended. Failure indicates that a numerically acceptable λ could not be found with the given grid or parameters; callers should check grid resolution (drcut and r_g), rcut, and numerical stability of the truncation function.
    
    Notes:
        The function evaluates the truncated volume as vol = 4 * π * radial_trapz(theta_g, r_g), where theta_g = radial_truncation_function(r_g, rcut, drcut, lambda). Therefore the returned λ depends on the implementation and parameters of radial_truncation_function and on the numerical quadrature performed by radial_trapz. Because the result is determined by numerical minimization on a discrete grid, the accuracy of λ is controlled by drcut (or the spacing in r_g) and the optimizer tolerance.
    """
    from gpaw.sphere.integrate import find_volume_conserving_lambd
    return find_volume_conserving_lambd(rcut, drcut, r_g)


################################################################################
# Source: gpaw.sphere.integrate.integrate_lebedev
# File: gpaw/sphere/integrate.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_sphere_integrate_integrate_lebedev(f_nx: numpy.ndarray):
    """gpaw.sphere.integrate.integrate_lebedev integrates a function defined on a spherical
    grid over angular coordinates using a Lebedev quadrature appropriate for GPAW
    calculations (density-functional theory with PAW and real-space/atom-centered
    grids). This routine performs the angular part of a surface integral on the
    unit sphere and is typically used in GPAW to obtain angular averages or to
    reduce a function defined on a spherical angular grid to its radial or
    non-angular dependence.
    
    Args:
        f_nx (numpy.ndarray): Array containing values of the function f(r) sampled
            on a Lebedev angular grid. The first axis (index 0) enumerates the
            Lebedev quadrature points n and therefore must have a length equal to
            the number of angular quadrature points for the chosen Lebedev grid as
            provided by the module-global weight_n. The remaining axes (denoted x
            in the name f_nx) represent any extra dimensions (for example radial
            points, electronic band indices, spin components, or other tensorial
            degrees of freedom used in GPAW calculations). The array is not
            modified by this function; the integration is performed by contracting
            the first axis with the Lebedev weights. f_nx must be a NumPy array;
            providing an object of a different type will typically result in a
            TypeError from NumPy operations.
    
    Returns:
        numpy.ndarray: The result of integrating f over the angular coordinates,
        computed as 4*pi * sum_n weight_n * f[n,...] implemented as
        4. * numpy.tensordot(weight_n, f_nx, axes=([0], [0])). The returned array has
        the same shape as f_nx.shape[1:] (i.e., the extra dimensions x) and the
        NumPy dtype that results from multiplication/accumulation of weight_n and
        f_nx (usually a floating-point dtype). If f_nx is one-dimensional (only
        the n axis), a NumPy scalar or zero-dimensional ndarray is returned.
    
    Behavior, side effects, and failure modes:
        This function uses the module-global variable weight_n containing the
        Lebedev quadrature weights (so the length of weight_n must match
        f_nx.shape[0]). The factor 4*pi normalizes the quadrature for integration
        over the full unit sphere surface area (useful in DFT contexts when
        converting angular integrals to surface-averaged quantities). There are
        no side effects: f_nx is not modified and no global state is changed.
        Common failure modes include shape mismatches between weight_n and the
        first axis of f_nx (NumPy will raise a ValueError during tensordot) and
        passing non-array inputs (TypeError). NaN or infinite values in f_nx will
        propagate into the result. Large arrays may incur significant memory and
        compute cost during the contraction.
    """
    from gpaw.sphere.integrate import integrate_lebedev
    return integrate_lebedev(f_nx)


################################################################################
# Source: gpaw.rotation.rotation
# File: gpaw/rotation.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_rotation_rotation(l: int, U_vv: numpy.ndarray):
    """gpaw.rotation.rotation: compute the rotation (transformation) matrix for spherical harmonics of angular momentum l.
    
    Compute the transformation matrix that maps coefficients of one set of spherical harmonic basis functions Y_lm (denoted here as Y_lm1) to another rotated set Y_lm2 according to the rotation described by U_vv. This function is used in GPAW's PAW/atomic-basis infrastructure to rotate angular-momentum-resolved quantities (for example atomic orbitals, projector functions, or density-matrix blocks) when applying a symmetry operation or a spatial rotation. Internally the function constructs the rotation in the spherical-harmonic representation by calling Y_matrix(l, U_vv) and then applies the precomputed iY_lmm[l] transformation, returning the combined transformation matrix used to rotate coefficients associated with angular momentum l.
    
    Args:
        l (int): The angular momentum quantum number l for which the rotation is constructed. In the GPAW/PAW context this selects the subspace of spherical harmonics with magnetic quantum numbers m = -l, ..., +l; the transformation therefore operates on the (2*l + 1)-dimensional coefficient vector for that l. l must be a non-negative integer; passing a negative or non-integer value is invalid and will typically result in an error from the underlying construction routines.
        U_vv (numpy.ndarray): A NumPy array that encodes the rotation/symmetry operation in the vector (spatial) representation. This array is passed to Y_matrix(l, U_vv) to build the rotation in the spherical-harmonic basis. In practical GPAW use U_vv represents the rotation part of a symmetry operation or a rigid-body rotation applied to atomic-centered quantities. If U_vv has an incompatible shape or contents for Y_matrix, the underlying function will raise an exception.
    
    Returns:
        numpy.ndarray: A square transformation matrix that maps coefficient vectors in the Y_lm1 basis to the rotated Y_lm2 basis for the specified l. The matrix acts on the (2*l + 1)-dimensional space of magnetic quantum numbers and is constructed as the dot product of the precomputed inverse/real-to-complex spherical-harmonic conversion iY_lmm[l] and the rotation produced by Y_matrix(l, U_vv). The function has no side effects; it returns the matrix for use in rotating coefficients, densities, or projector/potential blocks. Errors are propagated from Y_matrix or NumPy operations if l or U_vv are invalid.
    """
    from gpaw.rotation import rotation
    return rotation(l, U_vv)


################################################################################
# Source: gpaw.sphere.integrate.integrate_radial_grid
# File: gpaw/sphere/integrate.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_sphere_integrate_integrate_radial_grid(
    f_xg: numpy.ndarray,
    r_g: numpy.ndarray,
    rcut: float = None
):
    """Integrate radial functions on a spherical radial grid.
    
    Computes the radial integral
        ∫ r^2 dr f(r)
    for each function represented on the input radial grid r_g. This routine is used in GPAW's spherical/atom-centered integration routines (e.g., when integrating radial parts of densities, projectors or other atom-centered quantities in the PAW framework). The function optionally truncates the grid at a cutoff radius rcut before performing the integration. Integration is performed with the radial trapezoidal rule implemented by radial_trapz; truncation (when requested) is performed by truncate_radial_grid.
    
    Args:
        f_xg (numpy.ndarray): Array containing the functions to integrate sampled on the radial grid r_g. The last axis of f_xg corresponds to the points of r_g. In typical GPAW use, f_xg has shape (n_x, n_g) where n_g == len(r_g) and n_x indexes different radial functions (for example different projectors, partial waves or spherical components). A 1-D array of length n_g (a single radial function) is also accepted. The values are the function values f(r) evaluated at the radii in r_g.
        r_g (numpy.ndarray): One-dimensional array of radial coordinates (grid points) at which f_xg is sampled. The values are radii r (in the length units used by GPAW, typically Å when interfacing via ASE) and must correspond to the last axis of f_xg. r_g is expected to be non-decreasing and cover the domain over which the integral is desired.
        rcut (float): Optional cutoff radius. If provided (not None), the function first calls truncate_radial_grid(f_xg, r_g, rcut) to restrict both f_xg and r_g to points with r <= rcut before integration. If rcut is None (the default) the full provided r_g range is used. Behavior when rcut is outside the range of r_g or when r_g is not sorted is determined by truncate_radial_grid and may raise a ValueError from that helper function.
    
    Returns:
        numpy.ndarray: Array f_x containing the integrals ∫ r^2 dr f(r) evaluated up to rcut (or up to the full r_g range when rcut is None). The returned array has the same leading axes as f_xg with the radial axis removed; for an input f_xg of shape (n_x, n_g) the return has shape (n_x,). For a single 1-D input array of length n_g a 0-D or 1-element numpy.ndarray (i.e., a scalar array) may be returned.
    
    Notes and failure modes:
        - The integration uses a radial trapezoidal rule (radial_trapz) and therefore assumes that r_g corresponds to the sampling points for which trapezoidal integration is appropriate.
        - The last axis length of f_xg must match len(r_g); a mismatch will typically result in an error from numpy broadcasting or from radial_trapz.
        - Non-monotonic r_g or duplicate grid points can lead to incorrect results; such issues may raise errors in truncate_radial_grid or radial_trapz.
        - No global state is modified. The function may allocate and return new arrays if truncation is performed.
    """
    from gpaw.sphere.integrate import integrate_radial_grid
    return integrate_radial_grid(f_xg, r_g, rcut)


################################################################################
# Source: gpaw.setup.correct_occ_numbers
# File: gpaw/setup.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_setup_correct_occ_numbers(
    f_j: numpy.ndarray,
    degeneracy_j: numpy.ndarray,
    jsorted: list,
    correction: float,
    eps: float = 1e-12
):
    """gpaw.setup.correct_occ_numbers: Modify a per-state occupation array in-place to distribute a specified total electron correction across eigenstates used in a DFT (GPAW) calculation.
    
    This function is used in the GPAW electronic-structure code to adjust occupation numbers f_j (the number of electrons occupying each eigenstate) so that the total electron count matches a desired correction. The routine implements a simple, deterministic redistribution: for a positive correction it fills lowest-energy eigenstates first (up to each state's degeneracy), and for a negative correction it empties highest-energy eigenstates first (down to zero). This is commonly used when enforcing an integer change in electron number or when correcting occupations after population analysis or mixing steps.
    
    Args:
        f_j (numpy.ndarray): Array of current occupation numbers per eigenstate. Each entry f_j[j] is the current (possibly fractional) number of electrons assigned to eigenstate j. This array is modified in-place by the function; callers should provide a mutable numpy.ndarray with numeric dtype. The practical significance in GPAW is that f_j determines electronic occupations used in energy, density, and force calculations.
        degeneracy_j (numpy.ndarray): Array of maximum allowed occupation (degeneracy) per eigenstate. Each entry degeneracy_j[j] gives the upper bound for f_j[j] when adding electrons (for example, the spin and orbital degeneracy associated with that eigenstate). Values are used as limits; the function will not increase f_j[j] above degeneracy_j[j]. The array must be indexable with the indices in jsorted and have compatible shape/length with f_j for meaningful results.
        jsorted (list): List of integer indices that orders eigenstates by increasing energy (lowest first). The ordering is used to decide which states receive added electrons (iterate forward) and which states lose electrons (iterate in reverse). The list must contain indices valid for indexing f_j and degeneracy_j. If indices are missing or out of range, an IndexError will be raised by array indexing operations.
        correction (float): Total number of electrons to add (positive value) or remove (negative value) across all states. The function will attempt to apply this correction by increasing or decreasing elements of f_j subject to bounds implied by degeneracy_j (upper bound) and zero (lower bound). The unit and practical meaning are number of electrons; fractional corrections are allowed and commonly occur in smearing or grand-canonical adjustments.
        eps (float): Numerical tolerance used to decide when the remaining correction is effectively zero and the loop can stop. Default is 1e-12. Because floating-point arithmetic and fractional occupations are used in DFT, a small epsilon prevents infinite loops due to rounding; callers can pass a different eps to relax or tighten the stopping criterion.
    
    Behavior, side effects, defaults, and failure modes:
        The function mutates f_j in-place and returns no value (see Returns). For correction > 0, it iterates over jsorted from lowest- to highest-energy index and for each state j adds c = min(correction, degeneracy_j[j] - f_j[j]) to f_j[j], subtracting c from the remaining correction, and stops when the remaining correction is < eps. For correction < 0, it iterates over jsorted in reverse order (highest-energy first) and for each state j removes c = min(-correction, f_j[j]) from f_j[j], adding c to correction, and stops when the remaining correction is > -eps. The algorithm enforces 0 <= f_j[j] <= degeneracy_j[j] for all modified entries.
        If the requested correction cannot be fully distributed because all states are saturated at their bounds (all f_j == degeneracy_j when adding, or all f_j == 0 when removing), the function will exhaust available capacity and return with a nonzero remaining correction; it does not raise an exception in that case. If jsorted contains invalid indices or f_j/degeneracy_j are not indexable with those indices, numpy will raise IndexError. If inputs have incompatible dtypes or are not numeric arrays/lists, NumPy operations may raise TypeError or ValueError.
        The default eps = 1e-12 is appropriate for typical double-precision occupation arithmetic in GPAW; callers may adjust it when working with lower precision or when intentionally allowing larger residual corrections.
    
    Returns:
        None: The function does not return a value. Instead, it applies the electron-number correction by mutating the provided f_j numpy.ndarray in-place so that the total occupation distribution reflects the applied correction subject to per-state degeneracy limits and the eps tolerance.
    """
    from gpaw.setup import correct_occ_numbers
    return correct_occ_numbers(f_j, degeneracy_j, jsorted, correction, eps)


################################################################################
# Source: gpaw.sphere.integrate.radial_trapz
# File: gpaw/sphere/integrate.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_sphere_integrate_radial_trapz(f_xg: numpy.ndarray, r_g: numpy.ndarray):
    """gpaw.sphere.integrate.radial_trapz computes the integral of r^2 f(r) over a radial grid using a piecewise linear (trapezoidal) rule tailored for radial integrals used in GPAW DFT calculations.
    
    This function is used in the GPAW code base to accumulate radial integrals (for example, integrals of radial parts of densities, projectors or basis-function contributions) by assuming that the radial function f(r) is sampled on a one-dimensional radial grid r_g and is linearly interpolated between consecutive grid points. For each interval r0 <= r <= r1 the integral of r^2 f(r) is evaluated analytically for the linear interpolant and the contributions from all intervals are summed. The method is exact for piecewise-linear f(r) and otherwise is an approximation whose accuracy depends on the radial grid resolution.
    
    Args:
        f_xg (numpy.ndarray): Array of sampled function values f on the radial grid. The last axis of this array must index the radial grid points and therefore its length must equal len(r_g). Other leading axes (denoted by "x" in the name) may represent multiple functions, angular channels, or additional data dimensions so that the function computes one radial integral per leading-index tuple. The array is not modified by the function.
        r_g (numpy.ndarray): One-dimensional numpy array of radial grid points (r values) in non-negative units consistent with f_xg. The grid must be in strictly ascending order (r_g[i+1] > r_g[i]) and all entries must be >= 0.0; the code uses these grid points to form the piecewise integration intervals.
    
    Behavior, side effects, defaults, and failure modes:
        The function linearly interpolates f(r) on each interval [r0, r1] and evaluates the integral
        ∫_{r0}^{r1} r^2 f(r) dr using the analytic expression obtained for a linear interpolant. The contribution from each interval is computed as
        (r1^3 f(r1) - r0^3 f(r0)) / 4 + (r1^3 - r0^3) * (r1 f(r0) - r0 f(r1)) / (12 (r1 - r0)),
        and these contributions are summed over all intervals.
        There are no in-place modifications to the inputs and no other side effects (no file I/O, no global state changes).
        Preconditions checked by assertions:
            - An AssertionError is raised if any r_g value is negative (the implementation asserts numpy.all(r_g >= 0.0)).
            - An AssertionError is raised if the last axis length of f_xg does not equal len(r_g) (the implementation asserts f_xg.shape[-1] == len(r_g)).
            - An AssertionError with the message 'Please give the radial grid in ascending order' is raised if any interval width r1 - r0 is not strictly positive (the implementation asserts numpy.all(r1_g - r0_g > 0.)).
        Numerical accuracy: the method is exact for piecewise-linear f(r) and otherwise is an approximation; accuracy improves with finer radial grids. The function accepts r0 = 0.0 as a valid grid point.
    
    Returns:
        numpy.ndarray: The integrated values over r of r^2 f(r) for each leading-index tuple in f_xg. The returned array has shape f_xg.shape[:-1] (i.e., the input shape with the final radial axis removed). Each element equals the sum over radial intervals of the analytic integral of r^2 times the linear interpolant of f(r) on that interval.
    """
    from gpaw.sphere.integrate import radial_trapz
    return radial_trapz(f_xg, r_g)


################################################################################
# Source: gpaw.sphere.integrate.radial_truncation_function_spline
# File: gpaw/sphere/integrate.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_sphere_integrate_radial_truncation_function_spline(
    rcut: float,
    drcut: float,
    lambd: float = None
):
    """Generate a spline representation of the radial truncation function θ(r < rcut) suitable for spherical-harmonic expansions used in GPAW's sphere integration routines.
    
    This function constructs a radial grid governed by rcut and drcut, evaluates the radial truncation function on that grid using the provided or volume-conserving lambda parameter, and returns a Spline object that encodes the l=0 spherical-harmonic expansion coefficient of the truncation. In the context of GPAW (a DFT code using the PAW method and atom-centered spherical integrations), this spline is used to smoothly truncate atom-centered functions within the cutoff radius rcut, with drcut controlling the transition width of the truncation and lambd controlling the shape so that physically important properties (for example, the truncated volume) can be conserved.
    
    Args:
        rcut (float): Radial cutoff distance (in the same length units used by the caller) that defines the nominal support of the truncation function θ(r < rcut). Practically, rcut sets the outer radius beyond which the truncation function is (approximately) zero; it is used to build the radial grid and to determine the returned spline's rmax. Must be provided as a floating-point scalar consistent with the caller's unit system.
        drcut (float): Radial smoothing width (float) that determines the grid spacing and the transition region over which θ(r) goes from near 1 (inside the atom-centered region) to near 0 (outside rcut). drcut controls the resolution and smoothness of the radial truncation; it is passed to the internal uniform radial grid generator and to the radial_truncation_function evaluator. Provide a positive float appropriate for the desired smoothness and numerical resolution.
        lambd (float or None): Shape parameter (float) that modifies the functional form of the radial truncation. If lambd is None (the default), the function calls find_volume_conserving_lambd(rcut, drcut) to compute a lambda that enforces the intended volume-conserving property for the truncation function on the chosen grid. If supplied, this value is used directly to generate the truncation function. In GPAW workflows, choosing lambd=None is convenient because it selects a lambda consistent with the volume-conservation requirement used by the code; supplying an explicit lambd allows testing or alternative truncation behaviors.
    
    Returns:
        Spline: A Spline instance representing the l=0 spherical-harmonic expansion coefficient of the radial truncation function. Concretely, the returned spline was constructed with l=0 and rmax equal to the maximum radius of the internal radial grid, and its tabulated values f_g are sqrt(4π) * theta_g so that the l=0 spherical-harmonic (Y_{l=0} = 1/sqrt(4π)) reconstructs the radial truncation θ(r). The returned Spline is ready for use in GPAW's spherical integration and expansion routines that expect l=0 expansion coefficients.
    
    Behavior, defaults, and failure modes:
        The function performs no in-place modifications of caller data; it allocates an internal radial grid r_g via _uniform_radial_grid(rcut, drcut), evaluates the truncation theta_g = radial_truncation_function(r_g, rcut, drcut, lambd), scales by sqrt(4π) to obtain the l=0 coefficient, and returns Spline.from_data(...). If lambd is None, find_volume_conserving_lambd is invoked to compute a suitable lambda; any exceptions raised by that routine, by _uniform_radial_grid, by radial_truncation_function, or by Spline.from_data (for example due to invalid numeric values or inconsistent arguments) propagate to the caller. Callers should ensure that rcut and drcut are finite floats appropriate for the physical system and numerical resolution; providing incompatible or non-finite values may lead to ValueError, TypeError, or other exceptions from the underlying utilities.
    """
    from gpaw.sphere.integrate import radial_truncation_function_spline
    return radial_truncation_function_spline(rcut, drcut, lambd)


################################################################################
# Source: gpaw.sphere.integrate.radial_truncation_function
# File: gpaw/sphere/integrate.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_sphere_integrate_radial_truncation_function(
    r_g: numpy.ndarray,
    rcut: float,
    drcut: float = None,
    lambd: float = None
):
    """Generate a smooth radial truncation function θ(r < rc) on a radial grid and return its values on that grid.
    
    This function is used in GPAW's spherical integration and PAW-related routines to smoothly truncate radial functions at a cutoff radius rc while preserving the spherical integration volume (4π rc^3 / 3) when requested. The truncation is piecewise: the returned function θ(r) equals 1 well inside the cutoff, equals 0 well outside the cutoff, and interpolates smoothly in a transition region of width Δrc centered on r = rc. The interpolation uses a nonanalytic but infinitely differentiable bump function f(x) = exp(-1/x) for x > 0 and f(x) = 0 otherwise so that all derivatives of θ(r) are continuous across the transition region. If drcut is not provided, a default Δrc is chosen to match twice the local sampling spacing of the input radial grid near rcut. If lambd is not provided, it is computed to conserve the spherical integration volume using find_volume_conserving_lambd. The function performs several input validity checks and will raise AssertionError if they fail.
    
    Args:
        r_g (numpy.ndarray): One-dimensional array of radial grid points (r >= 0). This array defines the radial coordinates at which θ(r) is evaluated. The units and meaning of r_g must be consistent with rcut; the function does not change r_g and returns a new array of the same shape. The code asserts that all entries satisfy r_g >= 0.
        rcut (float): Cutoff radius rc where the truncation is centered. rc must be positive (rcut > 0). The function constructs a transition region of half-width Δrc/2 around rcut and requires rcut - Δrc/2 >= 0. rcut determines the location of the smooth interpolation and is used when computing a default drcut and when computing lambd to conserve integration volume.
        drcut (float = None): Optional transition width Δrc (full width of the interpolation region). If provided, it must be positive (drcut > 0) and satisfy rcut - drcut/2 >= 0. If drcut is None, the function chooses a default Δrc equal to twice the local grid spacing around rcut: it locates the two grid points closest to rcut using find_two_closest_grid_points(r_g, rcut) and sets drcut = 2 * abs(r_g[g2] - r_g[g1]). The chosen Δrc defines the interpolation interval (rcut - Δrc/2, rcut + Δrc/2) where the smooth transition between 1 and 0 occurs.
        lambd (float = None): Optional intermediate value λ at r = rcut (0 < λ < 1). If provided, it must satisfy 0 < lambd < 1. If lambd is None, the function computes a value that conserves the spherical integration volume (4π rcut^3 / 3) on the provided radial grid by calling find_volume_conserving_lambd(rcut, drcut, r_g). By construction, θ(rcut) == λ when rcut lies on the grid (or is evaluated via the interpolation formula).
    
    Returns:
        numpy.ndarray: Array theta_g with the same shape as r_g containing the truncation values θ(r) on the input radial grid. The array consists of:
            - values equal to 1 for r <= rcut - drcut/2,
            - values equal to 0 for r >= rcut + drcut/2,
            - a smooth transition for r in (rcut - drcut/2, rcut + drcut/2) computed as
              f(1/2 - (r-rcut)/Δrc) / ( f(1/2 - (r-rcut)/Δrc) + (1 - λ) f(1/2 + (r-rcut)/Δrc) / λ ),
              where f(x) = exp(-1/x) for x > 0 and f(x) = 0 for x <= 0.
        The returned values lie between 0 and 1 and have continuous derivatives of all orders across the interpolation region. The input r_g is not modified.
    
    Behavior and failure modes:
        - The function asserts that all r_g >= 0. If this fails, an AssertionError is raised.
        - It asserts rcut > 0 and drcut > 0 (after possibly setting a default) and rcut - drcut/2 >= 0; violation raises AssertionError.
        - It asserts 0 < lambd < 1 (after possibly computing a default); violation raises AssertionError.
        - It asserts that the grid contains at least one point at or beyond rcut + drcut/2 so that the outside region exists on the grid; otherwise an AssertionError is raised.
        - No inputs are modified in-place; the function returns a newly allocated numpy.ndarray.
        - The function relies on helper routines find_two_closest_grid_points and find_volume_conserving_lambd to determine defaults; errors in those helper functions will propagate.
    """
    from gpaw.sphere.integrate import radial_truncation_function
    return radial_truncation_function(r_g, rcut, drcut, lambd)


################################################################################
# Source: gpaw.sphere.integrate.truncate_radial_grid
# File: gpaw/sphere/integrate.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_sphere_integrate_truncate_radial_grid(
    f_xg: numpy.ndarray,
    r_g: numpy.ndarray,
    rcut: float
):
    """Truncate the radial-grid representation of a radial function f(r) at r = rcut.
    
    This function is used in GPAW's spherical integration utilities (gpaw.sphere.integrate) to restrict a radial sampling of a function to the interior of a sphere of radius rcut. In the context of the GPAW DFT code (which uses atom-centered spherical integrations for PAW and related operations), f_xg typically encodes values of a radial-dependent quantity (for example, radial parts of basis functions, densities or integrands) sampled on a 1D radial grid r_g; truncating at rcut is required when performing integrals or applying sphere-localized operations up to a specified cutoff radius.
    
    Args:
        f_xg (numpy.ndarray): Function values sampled on the radial grid. The radial axis is expected to be the last axis of this array (i.e., f_xg[..., g] corresponds to radius r_g[g]). The array may be multi-dimensional in the non-radial directions (denoted x in the source), and these axes are preserved. The practical role of f_xg is to provide the values that will be kept for radii r <= rcut; if rcut is not present in r_g, a value f(rcut) is inserted by linear interpolation along the radial axis.
        r_g (numpy.ndarray): One-dimensional array of radial grid point coordinates that correspond to the last axis of f_xg. r_g supplies the radial sampling points for f_xg and must contain at least one value greater than or equal to rcut (otherwise the function asserts). The returned r_g contains only the grid points r <= rcut; if rcut was not already present, it will be appended and included in the returned array.
        rcut (float): Cutoff radius at which to truncate the radial representation. Must be strictly positive (rcut > 0). If rcut is not already one of the values in r_g, the function inserts rcut into the grid and computes f(rcut) by linear interpolation between the two nearest grid points (using find_two_closest_grid_points). In GPAW workflows, rcut defines the spherical domain boundary for radial integrations or sphere-local operations.
    
    Behavior and side effects:
        If rcut is already present in r_g, the function selects all grid points with r <= rcut (inclusive) and returns f_xg and r_g restricted to those points.
        If rcut is not present, the function locates the two grid points in r_g closest to rcut (via find_two_closest_grid_points), computes the interpolated value f(rcut) with a linear interpolation weight lambd = (rcut - r1)/(r2 - r1) and inserts rcut and the corresponding f(rcut) into the grid and function array before truncating to r <= rcut.
        The function operates by moving the radial axis of f_xg to the front, performing the interpolation and appends with numpy operations, then moves the radial axis back to the last position. The returned arrays are new numpy arrays (numpy.append creates copies); the original input arrays passed by the caller are not modified in-place by this function.
        The interpolation preserves all non-radial axes (the x indices in the source code) so that multi-dimensional data structures used in GPAW remain consistent after truncation.
    
    Failure modes and assertions:
        The function asserts that rcut > 0 and that r_g contains at least one grid point >= rcut; if either check fails an AssertionError is raised.
        If the shapes of f_xg and r_g are inconsistent (for example if the length of r_g does not match the size of the last axis of f_xg), numpy indexing or broadcasting operations used internally will raise an exception (e.g., IndexError or ValueError). The function assumes r_g is a one-dimensional array of radial coordinates corresponding to the last axis of f_xg.
        The interpolation step assumes there exist two distinct grid points around rcut; find_two_closest_grid_points is relied upon to provide appropriate indices.
    
    Returns:
        f_xg (numpy.ndarray): The truncated function values containing only samples at radii r <= rcut. The radial axis remains the last axis of the returned array, and any added f(rcut) value (when rcut was not originally present) is included.
        r_g (numpy.ndarray): The one-dimensional radial grid containing only points r <= rcut. If rcut was not originally in r_g it is appended and included in the returned array.
    """
    from gpaw.sphere.integrate import truncate_radial_grid
    return truncate_radial_grid(f_xg, r_g, rcut)


################################################################################
# Source: gpaw.spherical_harmonics.Y0
# File: gpaw/spherical_harmonics.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_spherical_harmonics_Y0(l: int, m: int):
    """Y0(l, m)
    A SymPy-based constructor for the spherical harmonic Y_l^m expressed in Cartesian
    symbols (x, y, z). This function returns a simplified SymPy expression for the
    angular function used in atomic, orbital and projector definitions inside GPAW's
    PAW and atom-centered basis-function machinery. The expression is written in the
    SymPy symbols x, y, z (from sympy.abc) and is normalized by the factor
    c = sqrt((2*l + 1) * fac(l - m) / fac(l + m) / 4 / pi) computed with SymPy's
    factorial and sqrt. For typical use on the unit sphere, z corresponds to cos(theta)
    and x,y to the Cartesian components on the unit sphere; to obtain the usual
    theta/phi form substitute x = sin(theta)*cos(phi), y = sin(theta)*sin(phi),
    z = cos(theta).
    
    Args:
        l (int): The orbital quantum number l (degree) of the spherical harmonic.
            In GPAW this corresponds to the angular momentum label of atom-centered
            basis functions and PAW projectors. It must be an integer with l >= 0.
            The implementation uses SymPy factorials fac(l - m) and fac(l + m), so
            providing a value of l that does not satisfy l >= abs(m) or a non-integer
            will cause SymPy factorial or associated Legendre function calls to fail.
        m (int): The magnetic quantum number m (order) of the spherical harmonic.
            In GPAW this selects the specific angular component within the l multiplet.
            It must be an integer satisfying -l <= m <= l. The code branches on the
            sign of m to produce the standard (x + I*y)^m or (x - I*y)^{-m} prefactors
            and combines them with the associated Legendre function assoc_legendre(l, m, z).
            Passing a non-integer or an m outside the allowed range will result in
            exceptions raised by SymPy routines (e.g. factorial or assoc_legendre).
    
    Returns:
        sympy.Expr: A simplified SymPy expression for the spherical harmonic Y_l^m as a
        function of the SymPy symbols x, y, z. The returned expression is algebraically
        simplified by sympy.simplify and includes the normalization factor computed
        with SymPy factorial and sqrt. There are no side effects; use SymPy substitution
        to evaluate the function on numerical theta/phi or Cartesian coordinates. If the
        input arguments are invalid (non-integer types, l < 0, or |m| > l), SymPy's
        factorial or assoc_legendre functions will raise errors (e.g. ValueError or
        SymPy-specific exceptions), which propagate to the caller.
    """
    from gpaw.spherical_harmonics import Y0
    return Y0(l, m)


################################################################################
# Source: gpaw.sphere.rshe.calculate_reduced_rshe
# File: gpaw/sphere/rshe.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_sphere_rshe_calculate_reduced_rshe(
    rgd: tuple,
    f_ng: numpy.ndarray,
    Y_nL: numpy.ndarray,
    lmax: int = -1,
    wmin: float = None
):
    """gpaw.sphere.rshe.calculate_reduced_rshe
    Expand a scalar function sampled on a spherical grid into a RealSphericalHarmonicsExpansion
    and reduce the number of expansion coefficients according to significance criteria.
    This function is used in the GPAW DFT codebase (projector-augmented wave / atom-centered
    representations) to compress angular expansions of functions defined on spherical
    grids (for example atom-centered radial/angular functions), reducing memory use and
    computational cost while preserving the most significant real spherical harmonic
    components.
    
    Args:
        rgd (tuple): Spherical grid descriptor. This tuple is passed to
            RealSphericalHarmonicsExpansion.from_spherical_grid and therefore specifies
            the radial and angular sampling (grid geometry) on which f_ng is defined.
            In the GPAW workflow, rgd identifies the discrete spherical sampling used
            for atom-centered functions; providing an rgd that does not match f_ng or
            Y_nL in shape or meaning will cause the underlying constructor to raise an
            exception.
        f_ng (numpy.ndarray): Function values sampled on the spherical grid described by
            rgd. In GPAW this is typically a real-valued array containing the values of
            a radial/angular function (n indexes radial points or radial shells, g
            indexes angular sample points) whose real spherical harmonic expansion is
            desired. The routine uses these samples to build the initial expansion;
            non-finite values or shape mismatches will propagate errors from the
            expansion constructor or assessor.
        Y_nL (numpy.ndarray): Real spherical harmonic basis sampled on the same spherical
            grid as f_ng. This array provides the basis functions (indexed consistently
            with f_ng) used to form the expansion coefficients. The entries must be
            compatible with the rgd and f_ng sampling; inconsistent sizing or ordering
            will cause failures in the construction or assessment steps.
        lmax (int): Upper bound on angular momentum L used when assessing or enforcing
            reduction. The default -1 means do not impose an extra maximum beyond what
            the input data and basis imply; positive integers restrict the assessment
            and final reduced expansion to components with angular momentum L <= lmax.
            This parameter controls practical significance in GPAW workflows by allowing
            the caller to limit the angular complexity (and thus computational cost) of
            the returned expansion.
        wmin (float): Optional threshold for component significance used by
            assess_rshe_reduction. When provided, components with weights below wmin are
            considered insignificant and may be discarded. If None (the default), the
            reduction routine uses its own internal default thresholding behavior.
            Providing a float allows explicit control over compression versus accuracy.
            Supplying an out-of-range or non-finite value will result in errors from the
            assessor.
    
    Returns:
        tuple: A pair (rshe, info_string).
            rshe (RealSphericalHarmonicsExpansion): The reduced real spherical harmonic
                expansion object produced by RealSphericalHarmonicsExpansion.from_spherical_grid
                and subsequently reduced by rshe.reduce_expansion(L_M). This object contains
                the retained expansion coefficients and associated metadata and is the
                compressed representation that should be used in downstream GPAW routines
                that expect a RealSphericalHarmonicsExpansion.
            info_string (str): Human-readable summary produced by assess_rshe_reduction
                describing which components were kept or discarded, the criteria used
                (including effective lmax and wmin), and simple diagnostics (such as
                estimated error or weights). This string is intended for logging and
                decision tracing in preprocessing and optimization of atom-centered
                representations.
    
    Behavior and side effects:
        The function constructs an initial RealSphericalHarmonicsExpansion from the
        provided spherical grid and samples, calls assess_rshe_reduction(f_ng, rshe,
        lmax=lmax, wmin=wmin) to determine which expansion components can be removed,
        and then calls rshe.reduce_expansion(L_M) to obtain a new RealSphericalHarmonicsExpansion
        containing only the retained components. There are no in-place modifications of
        the provided f_ng or Y_nL arrays; the returned rshe is a new object. The info_string
        is intended to be logged or inspected by the caller for verification of the
        reduction decision.
    
    Failure modes:
        The function propagates errors from RealSphericalHarmonicsExpansion.from_spherical_grid,
        assess_rshe_reduction, and reduce_expansion. Typical failure causes include:
        mismatched shapes between rgd, f_ng, and Y_nL; invalid or non-finite numerical
        values in f_ng or Y_nL; and invalid parameter types (for example a non-integer
        lmax). These will usually raise TypeError, ValueError, or class-specific exceptions
        from the underlying GPAW routines.
    """
    from gpaw.sphere.rshe import calculate_reduced_rshe
    return calculate_reduced_rshe(rgd, f_ng, Y_nL, lmax, wmin)


################################################################################
# Source: gpaw.response.tool.find_peaks
# File: gpaw/response/tool.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_response_tool_find_peaks(
    x: numpy.ndarray,
    y: numpy.ndarray,
    threshold: tuple = None
):
    """gpaw.response.tool.find_peaks locates local maxima (peaks) in a 1D curve defined by paired arrays x and y and returns their (x, y) coordinates as a numpy array. This function is intended for use in GPAW response/spectral analysis workflows (for example, finding peaks in spectra, density-of-states, or response functions computed by the GPAW DFT code) where one needs to extract positions and magnitudes of local maxima within optional x/y ranges.
    
    Args:
        x (numpy.ndarray): One-dimensional array of independent variable values (e.g., energy, frequency, distance) with length N. This array must be a numpy.ndarray with ndim == 1. The ordering and spacing of x are used only for reporting peak positions; the algorithm inspects neighbors by index, so x does not need to be uniformly spaced but must align elementwise with y.
        y (numpy.ndarray): One-dimensional array of dependent variable values (e.g., intensity, density) with length N matching x. This array must be a numpy.ndarray with ndim == 1 and the same shape as x. Peaks are identified where y[i] is strictly greater than both immediate neighbors y[i-1] and y[i+1], subject to threshold filtering described below.
        threshold (tuple): Optional 4-tuple (xmin, xmax, ymin, ymax) that constrains the search to points satisfying xmin <= x <= xmax and ymin <= y <= ymax. The default is None, which is interpreted as the full ranges of the provided arrays and is expanded internally to (x.min(), x.max(), y.min(), y.max()). The function accepts shorter tuples and extends them according to the following rules (these behaviors follow the implementation and are important for correct usage):
            - If a non-tuple is supplied (e.g., a single numeric value), it is first wrapped into a 1-tuple.
            - If length == 1: interpreted as (xmin,) and extended to (xmin, x.max(), y.min(), y.max()).
            - If length == 2: interpreted as (xmin, xmax) and extended to (xmin, xmax, y.min(), y.max()).
            - If length == 3: interpreted as (xmin, xmax, ymin) and extended to (xmin, xmax, ymin, y.max()).
            - If length >= 4: the first four entries are used as (xmin, xmax, ymin, ymax); additional entries are ignored.
          Comparisons against these thresholds are inclusive (>= for minima and <= for maxima). Note: providing an empty tuple (()) will lead to an IndexError because the code expects at least one element or None.
    
    Behavior and side effects:
        - The function asserts that x and y are numpy.ndarray instances, are one-dimensional, and have the same length; failing any of these assertions raises AssertionError.
        - Peak selection requires that a candidate point lies within the inclusive x and y thresholds and that y[i] is strictly greater than both immediate neighbors y[i-1] and y[i+1]. The first and last points (indices 0 and N-1) are not considered because they lack two neighbors.
        - The function performs a single pass through the arrays (O(N) time complexity) and has no external side effects (it does not modify inputs or global state).
        - If elements of threshold are not comparable to x/y (e.g., non-numeric types), comparisons may raise TypeError.
        - If no peaks satisfy the criteria, the function returns an empty array with shape (0, 2).
    
    Returns:
        numpy.ndarray: A two-dimensional numpy array with shape (n_peaks, 2). Each row contains the (x, y) coordinates of a detected peak in the order they appear in the input arrays. n_peaks is the number of peaks found; if no peaks are found, an array of shape (0, 2) is returned. The dtype is the default numpy float type produced by numpy.zeros in the implementation.
    """
    from gpaw.response.tool import find_peaks
    return find_peaks(x, y, threshold)


################################################################################
# Source: gpaw.sphere.rshe.get_reduction_info_string
# File: gpaw/sphere/rshe.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_sphere_rshe_get_reduction_info_string(
    L_M: list,
    fw_gL: numpy.ndarray,
    rshew_L: list
):
    """gpaw.sphere.rshe.get_reduction_info_string: Construct a human-readable information string that summarizes which coefficients of a reduced real-spherical-harmonic expansion are included, how individual coefficients contribute, and how much of the surface norm square is covered on average by the selected subset.
    
    Args:
        L_M (list): List of integer indices selecting which expansion coefficients (indexed by L) are included in the reduced expansion. In the GPAW/rshe domain these indices correspond to particular (l,m) real-spherical-harmonic coefficient slots. The list is used verbatim to determine the boolean "included" flag for each coefficient and to index columns of fw_gL when computing coverage. Entries should be valid column indices for fw_gL; invalid indices will raise an IndexError from numpy when accessed.
        fw_gL (numpy.ndarray): 2-D numeric array of weights with shape (N_surface_points, N_coefficients) where columns correspond to L indices used in the rshe_L list and rows correspond to surface/grid points on which the expansion is evaluated. Each element is a weight (float-like) contributing to the local surface norm square for the given coefficient. This array is transposed and iterated column-wise inside the function; it is also summed across the selected columns L_M per row and averaged across rows to compute the average coverage. Passing a non-numeric array or an array with a mismatched number of columns relative to rshew_L may raise numpy errors.
        rshew_L (list): Sequence (list) of per-coefficient rshe objects or numeric summaries corresponding to each L index. Each element provides the per-coefficient metadata or weight distribution that get_rshe_coefficient_info_string formats into a per-line description. The length of rshew_L must match the number of columns in fw_gL; otherwise zip(fw_gL.T, rshew_L) will truncate to the shorter sequence and per-coefficient reporting will not cover all fw_gL columns.
    
    Returns:
        str: A single concatenated string containing multiple lines. The string begins with a header row showing the formatted columns "(l,m)", "max weight", "avg weight", and "included". For each L index (enumerated from 0 to len(rshew_L)-1) one line is appended consisting of the output from get_rshe_coefficient_info_string(L, included, rshew, fw_g) where:
            - L is the coefficient index;
            - included is a boolean determined by membership of L in L_M;
            - rshew is the corresponding element from rshew_L;
            - fw_g is the corresponding column from fw_gL (weights across surface/grid points).
        After the per-coefficient lines the function appends two summary lines:
            - An "In total" line giving avg_cov, the average over surface/grid points of the sum of fw_gL weights for the selected coefficients L_M; this value quantifies how much of the surface norm square is covered on average by the reduced expansion.
            - A "tot_avg_cov" line giving the average over surface/grid points of the sum of fw_gL weights across all coefficients; this is the maximum average coverage that could be achieved if no reduction were applied.
        The returned string is intended for logging or text output in GPAW workflows to help users and developers inspect the effect of coefficient reduction on the representation of the surface norm square.
    
    Behavior, side effects, defaults, and failure modes:
        - The function has no external side effects (it does not modify inputs, write files, or change global state); it only reads inputs and returns a formatted string.
        - The function relies on get_rshe_coefficient_info_string to format each coefficient line; if that function is not available or raises an exception, this function will propagate that exception.
        - Average coverage values are computed with numpy: avg_cov = numpy.average(numpy.sum(fw_gL[:, L_M], axis=1)) and tot_avg_cov = numpy.average(numpy.sum(fw_gL, axis=1)). If L_M is empty, avg_cov evaluates to 0.0 (average of zeros) or may raise an error depending on numpy version/behavior with empty selections; in typical numpy usage selecting no columns yields a zero-length sum per row and numpy.average over those sums yields 0.0, but callers should be aware of potential warnings.
        - If fw_gL is not a 2-D numeric numpy.ndarray or has fewer columns than the indices implied by rshew_L or L_M, numpy indexing and arithmetic operations will raise IndexError, ValueError, or TypeError.
        - The function assumes that columns of fw_gL correspond in order to elements of rshew_L; mismatched ordering will produce misleading reports but will not be detected automatically.
        - The numerical interpretation of "coverage" and "surface norm square" follows the rshe/sphere conventions used in GPAW for reduced expansions: the returned coverage fractions are unitless ratios of summed squared-surface contributions and are meaningful to users analyzing how much of the original surface representation is preserved by the selected subset of coefficients.
    """
    from gpaw.sphere.rshe import get_reduction_info_string
    return get_reduction_info_string(L_M, fw_gL, rshew_L)


################################################################################
# Source: gpaw.spherical_harmonics.Yarr
# File: gpaw/spherical_harmonics.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_spherical_harmonics_Yarr(L_M: list, R_Av: numpy.ndarray):
    """gpaw.spherical_harmonics.Yarr computes polynomial spherical-harmonic functions identified by angular indices L_M at a batch of position vectors R_Av and returns their values as a NumPy array. This function is used in GPAW’s PAW/atomic-basis machinery to evaluate monomial-based spherical harmonics (assembled from coefficient/exponent terms stored in the module-level YL table) on arrays of Cartesian coordinates for building atom-centered basis functions, projector functions, or multipole moments in DFT calculations.
    
    Args:
        L_M (list): A list of integer angular indices L that select which spherical-harmonic polynomials to evaluate. Each element L is used to index the module-level YL table (YL[L]) which must provide an iterable of (coefficient, exponent_tuple) pairs. The order of L_M determines the first axis of the returned array: output index M corresponds to L_M[M]. Supplying an L value not present in YL will raise an IndexError or KeyError from the lookup.
        R_Av (numpy.ndarray): Array of Cartesian position vectors at which to evaluate the spherical harmonics. The last axis of R_Av indexes the Cartesian components (for example, x, y, z) and must have the same length as the exponent tuples n stored in YL[L]. R_Av may have any leading array-shaped "A"-like index (for example shape (N,3) or (n1,n2,3)); the function computes values for every element of that leading index. R_Av must contain numeric types compatible with NumPy arithmetic (e.g., float); mismatched shapes or incompatible dtypes lead to NumPy broadcasting or TypeError/ValueError exceptions.
    
    Returns:
        numpy.ndarray: A NumPy array Y_MA of shape (len(L_M), *R_Av.shape[:-1]) and default floating dtype (numpy.float64) containing the evaluated spherical-harmonic polynomial values. The first axis M corresponds to the entries of L_M and the remaining axes correspond to the array-like index A of R_Av. The function does not modify its inputs; it reads the module-level YL table and uses NumPy operations to accumulate c * prod(R_Av**n, axis=-1) terms for each (c, n) in YL[L]. Failure modes include lookup errors if an L in L_M is invalid, shape mismatches if R_Av’s last dimension does not match exponent tuple lengths, and dtype/broadcasting errors from invalid R_Av contents. Performance note: the implementation uses nested Python loops over L_M and the terms in YL[L] and could be further vectorized for speed, but as written it is memory-efficient and avoids in-place modification of inputs.
    """
    from gpaw.spherical_harmonics import Yarr
    return Yarr(L_M, R_Av)


################################################################################
# Source: gpaw.sphere.rshe.get_rshe_coefficient_info_string
# File: gpaw/sphere/rshe.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_sphere_rshe_get_rshe_coefficient_info_string(
    L: int,
    included: bool,
    rshew: float,
    fw_g: numpy.ndarray
):
    """Construct and return a single-line, human-readable info string describing the
    weight and inclusion status of one RSHE (real-space spherical-harmonic)
    coefficient used in GPAW reporting. This function is used in GPAW's
    sphere.rshe routines to present per-coefficient diagnostic information
    for density / potential expansions (e.g. in PAW or grid-based analyses)
    in text output or log files.
    
    Args:
        L (int): Linear index that encodes the spherical-harmonic angular
            quantum numbers. Internally the function decodes L to obtain
            l and m via l = int(numpy.sqrt(L)) and m = L - l * (l + 1). In the
            GPAW RSHE context, l identifies the angular momentum order of the
            coefficient and m identifies the component within that order; the
            decoded (l,m) pair is used as the textual label for the coefficient.
        included (bool): Boolean flag indicating whether this coefficient was
            included in the set of coefficients (for example, included in a
            truncated expansion or selection criterion). The function converts
            this flag to the literal string 'yes' or 'no' in the returned
            info string so that output clearly documents whether the coefficient
            contributed to subsequent sums or analyses.
        rshew (float): The RSHE weight value associated with this coefficient.
            This floating-point value represents the coefficient's computed
            weight (for example, its contribution to a norm or selection metric)
            and is printed in the info string with eight decimal places to aid
            numerical comparison and human inspection in GPAW logs.
        fw_g (numpy.ndarray): Array of numeric weights (one per grid point or
            G-vector) associated with this coefficient in the underlying
            discretization. The function reports the maximum value of this array
            (computed with numpy.max) as an indicator of the largest local or
            reciprocal-space contribution for the coefficient. This array is not
            modified by the function; only its maximum is queried for reporting.
    
    Behavior and side effects:
        The function decodes L into (l,m), maps included to the literal 'yes'
        or 'no', computes numpy.max(fw_g), and formats a fixed-width string with
        the following four fields in order: the coefficient label "(l,m)",
        the maximum of fw_g printed with eight decimal places, the rshew value
        printed with eight decimal places, and the inclusion string. The exact
        format string used is '{:6}  {:1.8f}  {:1.8f}  {:8}'.format(...).
        There are no side effects: inputs are not modified and no I/O is
        performed.
    
    Failure modes and notes:
        If fw_g is empty, numpy.max(fw_g) raises a ValueError; callers should
        ensure fw_g contains at least one numeric entry. If fw_g contains
        non-numeric types or NaNs in contexts where max is undefined, numpy
        may raise TypeError or produce NaN results. If L is not a non-negative
        integer or encodes an invalid (l,m) combination, the internal decoding
        (int(numpy.sqrt(L))) can raise TypeError or produce incorrect labels;
        callers should pass valid integer indices according to the encoding
        used by the surrounding RSHE code. The function does not perform
        extensive validation beyond these operations.
    
    Returns:
        str: A single formatted line describing the coefficient. The returned
        string contains four fields: the coefficient label "(l,m)", the maximum
        value of fw_g (formatted with 8 decimals), the rshew value
        (formatted with 8 decimals), and the inclusion status ('yes' or 'no'),
        separated by two spaces as controlled by the internal format string.
    """
    from gpaw.sphere.rshe import get_rshe_coefficient_info_string
    return get_rshe_coefficient_info_string(L, included, rshew, fw_g)


################################################################################
# Source: gpaw.spherical_harmonics.fix_exponents
# File: gpaw/spherical_harmonics.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_spherical_harmonics_fix_exponents(coeffs: dict, l: int):
    """Fix exponents so every multi-index has total degree l.
    
    This function is used in the GPAW spherical harmonics code to convert a dictionary
    representation of polynomial/spherical-harmonic coefficients into an equivalent
    representation where every multi-index (nx, ny, nz) has nx + ny + nz == l. In
    the GPAW/PAW context, polynomial monomials or projector expansions are often
    organized by total angular momentum (degree) l; this routine ensures that the
    coefficient dictionary is expressed only in terms of multi-indices whose total
    degree equals the requested angular momentum l. The routine preserves symbolic
    coefficients (the implementation uses sympy.Number(0) as a neutral element) and
    accumulates contributions to the same multi-index.
    
    Args:
        coeffs (dict): Mapping from 3-tuples of integer exponents (nx, ny, nz) to
            coefficient objects. Each key is expected to be a tuple of three
            integers representing the powers of x, y, z in a monomial used in
            spherical-harmonic or polynomial expansions. Each value is a numeric or
            symbolic coefficient (for example a SymPy expression or Number). The
            function does not mutate this input dictionary; it reads keys and
            values and constructs a new dictionary.
        l (int): Target total degree (angular momentum) for all multi-indices. This
            is the integer l used in spherical-harmonic related expansions in GPAW.
            The routine will transform coefficients so that every returned key
            satisfies nx + ny + nz == l. Typical use is to call this with l equal
            to the desired angular momentum.
    
    Returns:
        dict: A new dictionary mapping 3-tuples of integer exponents (nx, ny, nz)
        to coefficient objects (the same kind of numeric or symbolic objects as in
        the input). The returned dictionary satisfies the invariant that every key
        tuple sums to l (nx + ny + nz == l). Coefficients that become exactly
        zero are removed from the returned dictionary. If multiple input entries
        contribute to the same output multi-index, their coefficients are added
        (symbolic addition is supported via SymPy types).
    
    Behavior and implementation details:
        The function iterates over all entries in coeffs. For an entry whose
        exponent sum already equals l, the coefficient is carried over unchanged
        (and accumulated if other contributions map to the same tuple). For an
        entry whose exponent sum is not l, the routine distributes that coefficient
        to three new multi-indices obtained by adding 2 to nx, or to ny, or to nz,
        respectively (i.e., (nx+2, ny, nz), (nx, ny+2, nz), (nx, ny, nz+2)). This
        increases the total degree of those terms by 2 per application. After one
        pass, zero-valued coefficients are filtered out. If any keys in the
        intermediate dictionary still do not sum to l, the function recursively
        calls itself until all keys satisfy the sum == l invariant.
    
    Side effects and performance:
        The function has no side effects on external state and does not modify the
        input dict; it returns a freshly created dict. It may perform multiple
        passes (recursion) for entries that require increasing their degree by
        repeated increments of 2. For large dictionaries or large differences
        between current degrees and l this may be computationally expensive.
    
    Failure modes and preconditions:
        The algorithm increases total degree by 2 for terms that do not match l.
        Therefore, if any input multi-index has a total degree greater than l, the
        function cannot reduce it and will never reach the invariant; this will
        lead to unbounded recursion and ultimately a RecursionError. Similarly, if
        the parity of an input total degree differs from the parity of l (i.e.,
        their difference is odd), repeated additions of 2 cannot make them equal;
        this also prevents termination. Callers must ensure that input exponents
        are compatible with the target l (typically initial sums are <= l and
        have matching parity), otherwise the function may not terminate.
    """
    from gpaw.spherical_harmonics import fix_exponents
    return fix_exponents(coeffs, l)


################################################################################
# Source: gpaw.symmetry.sfrac
# File: gpaw/symmetry.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for sfrac because the docstring has no description for the argument 'f'
################################################################################

def gpaw_symmetry_sfrac(f: float):
    """Format a floating-point number as a simple rational fraction string for use in GPAW symmetry and crystallographic output.
    
    This function is a utility used in gpaw.symmetry to produce human-readable fractional values commonly encountered in crystallography and density-functional theory workflows (for example when writing fractional atomic coordinates, symmetry operation parameters, or lattice fractions). It returns a short textual representation: the exact string "0" when the input is exactly zero, and otherwise a "numerator/denominator" representation computed by the internal frac(f) helper. The output is intended for formatting and printing in text output files and logs produced by GPAW and related ASE-based workflows.
    
    Args:
        f (float): A floating-point number representing a value that should be expressed as a simple fraction. Typical use is a fractional coordinate or symmetry parameter such as 0.5 which will be rendered as '1/2'. The function tests for exact equality to zero using the Python equality operator (f == 0), so very small nonzero floats close to zero will not be treated as zero unless they compare equal to 0. The function accepts standard Python floats; non-finite values (NaN, inf) are not specially handled by this wrapper and will be passed to frac(f), which may raise an exception.
    
    Returns:
        str: A short string representation of the input as a fraction suitable for human-readable GPAW output. If the input is exactly zero the function returns the string '0'. For other values it returns a string of the form '%d/%d' where the numerator and denominator are the two integers returned by frac(f) (for example 0.5 -> '1/2', 2/3 -> '2/3'). This function has no side effects other than calling frac(f) and formatting its result; any errors for inputs that frac cannot handle will propagate as exceptions from frac.
    """
    from gpaw.symmetry import sfrac
    return sfrac(f)


################################################################################
# Source: gpaw.spherical_harmonics.nablarlYL
# File: gpaw/spherical_harmonics.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_spherical_harmonics_nablarlYL(L: int, R: tuple):
    """Compute the Cartesian gradient (partial derivatives with respect to x, y and z) of a real solid spherical harmonic of degree L evaluated at the 3D Cartesian position R. This function is part of gpaw.spherical_harmonics and is used in the GPAW codebase (a DFT/PAW electronic-structure package) wherever analytic gradients of real solid spherical harmonics are required, for example when forming angular derivatives for atom-centered basis functions, PAW augmentation terms, multipole expansions, or other operations that require ∇Y_L(r) in Cartesian coordinates.
    
    Args:
        L (int): Angular momentum degree index identifying which real solid spherical harmonic to differentiate. In the GPAW spherical harmonics implementation this index is used to index the module-level sequence YL (i.e., terms = YL[L]). Each entry YL[L] is expected to be an iterable of terms describing a polynomial representation of the solid harmonic: each term is a 2-tuple (N, (powx, powy, powz)) where N is a numeric coefficient and powx, powy, powz are integer exponents for the Cartesian monomial x**powx * y**powy * z**powz that contributes to the solid harmonic of degree L. The value of L therefore selects the set of polynomial terms that define the real solid spherical harmonic used in GPAW calculations.
        R (tuple): A length-3 tuple representing the Cartesian coordinates (x, y, z) where the gradient is evaluated. The elements should be numeric scalars (e.g., Python int or float) representing the position relative to the origin or an atomic center in the GPAW coordinate conventions. The function unpacks R as x, y, z and raises a Python ValueError if R cannot be unpacked into three values.
    
    Behavior, side effects, defaults, and failure modes:
        This function reads the global YL data structure (module-level) and has no other side effects; it does not modify YL or any other global state. For the chosen L it iterates over terms = YL[L] and accumulates the partial derivatives according to the formula implemented in the source:
        dYdx += N * powx * x**abs(powx - 1) * y**powy * z**powz
        dYdy += N * powy * x**powx * y**abs(powy - 1) * z**powz
        dYdz += N * powz * x**powx * y**powy * z**abs(powz - 1)
        The implementation uses abs(pow - 1) for the exponent on the coordinate to avoid negative exponents when pow == 0; this mirrors the polynomial representation stored in YL and ensures that evaluating the derivative for terms with zero powers does not attempt to raise zero to a negative power. The routine therefore assumes that YL[L] provides integer exponents and numeric coefficients consistent with GPAW's real solid spherical harmonic representation.
        Typical failure modes:
        - If L is not a valid index/key for the YL container, an IndexError or KeyError will be raised when accessing YL[L].
        - If R is not a length-3 iterable, unpacking will raise a ValueError.
        - If any coordinate in R is not numeric, or if YL contains non-numeric coefficients/exponents incompatible with Python exponentiation, TypeError or ValueError may be raised during arithmetic.
        - The function does not perform domain checks on L beyond indexing YL and does not normalize the returned gradient; it returns the raw polynomial derivative contributions as computed.
        This function is deterministic and has no randomness or hidden I/O. It is intended for use inside GPAW's spherical-harmonic and PAW machinery and expects YL to be populated according to GPAW's internal conventions.
    
    Returns:
        tuple: A 3-tuple (dYdx, dYdy, dYdz) of numeric values (typically floats) giving the partial derivatives of the real solid spherical harmonic of degree L with respect to x, y and z at the input position R. These returned components are the Cartesian gradient ∇Y_L evaluated at R and can be used directly in downstream GPAW calculations that require spatial derivatives of angular functions.
    """
    from gpaw.spherical_harmonics import nablarlYL
    return nablarlYL(L, R)


################################################################################
# Source: gpaw.spherical_harmonics.poly_coeffs
# File: gpaw/spherical_harmonics.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_spherical_harmonics_poly_coeffs(l: int, m: int):
    """gpaw.spherical_harmonics.poly_coeffs: Compute SymPy polynomial coefficients for the spherical harmonic S(l, m) expanded as a polynomial in the Cartesian coordinates x, y and z.
    
    This function evaluates the symbolic spherical harmonic S(l, m) (as provided by the enclosing gpaw.spherical_harmonics module) and returns the non-zero coefficients of its polynomial expansion in the Cartesian variables x, y and z. In the context of GPAW (a DFT/PAW code), these coefficients are used when converting angular parts of spherical harmonics to Cartesian polynomial form, for example when constructing atom-centered projectors or basis-function angular parts. The returned mapping lists only non-zero coefficients; each key is the triple of non-negative integer exponents (nx, ny, nz) for x**nx * y**ny * z**nz and the corresponding value is the SymPy coefficient multiplying that monomial.
    
    Args:
        l (int): Degree index of the spherical harmonic. In GPAW this integer identifies the angular dependence (commonly associated with orbital angular momentum in atomic/PAW contexts). The function passes l to the module-level S(l, m) spherical-harmonic constructor; l must therefore be an integer acceptable to that constructor.
        m (int): Order index of the spherical harmonic. In GPAW this integer selects the specific azimuthal component of the angular dependence. The function passes m to the module-level S(l, m) spherical-harmonic constructor; m must therefore be an integer acceptable to that constructor.
    
    Returns:
        dict: A dictionary mapping (nx, ny, nz) tuples to SymPy expressions. Each key is a 3-tuple of non-negative integers (nx, ny, nz) giving the exponent of x, y and z respectively in a monomial x**nx * y**ny * z**nz. Each value is the SymPy coefficient for that monomial in the polynomial expansion of S(l, m). Only monomials with non-zero coefficients are included.
    
    Behavior and side effects:
        - The function imports sympy.Poly and the symbolic names x, y, z at call time and uses the module-level S(l, m) object to obtain the spherical harmonic expression. It constructs univariate polynomial objects in x, then y, then z to extract coefficients and uses enumerate(reversed(...)) so that the index corresponds to the exponent of each variable (0 for constant term, 1 for linear term, etc.).
        - No global state is modified; the function has no side effects beyond the SymPy objects it creates and returns.
    
    Failure modes and exceptions:
        - ImportError may be raised if the SymPy library or the required symbols are not available when the function is called.
        - NameError or similar may be raised if the module-level S symbol (spherical-harmonic constructor) is not defined in the gpaw.spherical_harmonics namespace where this function executes.
        - TypeError or ValueError may be raised by the underlying SymPy routines (or by S) if l or m are not valid inputs for the spherical-harmonic constructor or for polynomial construction.
        - The function does not validate numeric ranges for l and m itself; it relies on the behavior of S(l, m) and SymPy.Poly to handle invalid values.
    """
    from gpaw.spherical_harmonics import poly_coeffs
    return poly_coeffs(l, m)


################################################################################
# Source: gpaw.tddft.spectrum.photoabsorption_spectrum
# File: gpaw/tddft/spectrum.py
# Category: valid
################################################################################

def gpaw_tddft_spectrum_photoabsorption_spectrum(
    dipole_moment_file: str,
    spectrum_file: str,
    folding: str = "Gauss",
    width: float = 0.2123,
    e_min: float = 0.0,
    e_max: float = 30.0,
    delta_e: float = 0.05
):
    """Calculates and writes a photoabsorption spectrum (dipole strength function) from a time-dependent dipole moment file produced by a time-dependent DFT (TDDFT) simulation in the GPAW code. In the GPAW/TDDFT context this function reads a file containing the time-dependent dipole moment, computes the frequency-domain dipole strength function (units of 1/eV) that should integrate to the number of valence electrons, applies a spectral folding (broadening) kernel, converts atomic units to electronvolts (division by au_to_eV), and writes the resulting spectrum to an output file. The function performs printing and file-writing only on the MPI root process (world.rank == 0). It delegates the numerical transform and folding to helper routines (calculate_photoabsorption and write_spectrum) and prints a measure of sinc contamination computed during the processing.
    
    Args:
        dipole_moment_file (str): Name of the input file that contains the time-dependent dipole moment trace produced by a TDDFT run with GPAW. This file is read to obtain the time series of dipole components from which the frequency-dependent dipole strength function is calculated. The function will fail if the file does not exist or is not in the expected format produced by the GPAW TDDFT utilities.
        spectrum_file (str): Name of the output file where the calculated photoabsorption spectrum is written. The output is the dipole strength function as a function of energy (in eV). Writing is performed on the MPI root process only (world.rank == 0); other MPI ranks do not create this file.
        folding (str): Folding (broadening) kernel applied to the discrete frequency-domain response to produce a continuous spectrum. Accepted values are 'Gauss' for Gaussian broadening or 'Lorentz' for Lorentzian broadening (the code uses the exact strings 'Gauss' and 'Lorentz'). The choice affects the physical appearance of peaks: Gaussian mimics instrumental/thermal broadening while Lorentzian models lifetime (damping) broadening.
        width (float): Width parameter of the chosen folding kernel in electronvolts (eV). For folding == 'Gauss', this is the Gaussian sigma used in the kernel Gaussian = 1/(sigma sqrt(2pi)) exp(-(1/2)(omega/sigma)^2). For folding == 'Lorentz', this is the Lorentzian Gamma used in the kernel Lorentzian = (1/pi) (1/2) Gamma / [omega^2 + ((1/2) Gamma)^2]. This parameter must be positive; non-positive values will produce an invalid kernel and typically cause an error or meaningless spectrum.
        e_min (float): Minimum energy (in eV) included in the output spectrum. The spectrum is evaluated and saved over the energy interval [e_min, e_max]. Typical TDDFT spectra use e_min >= 0.0; setting e_min >= e_max will result in an empty spectrum or an error depending on downstream processing.
        e_max (float): Maximum energy (in eV) included in the output spectrum. Defines the upper bound of the energy grid used to evaluate the dipole strength function. Values should be chosen based on the expected excitation energies of the system; too small a value will truncate relevant features.
        delta_e (float): Energy grid spacing (resolution) in eV used when evaluating and writing the spectrum between e_min and e_max. Smaller delta_e gives finer resolution but increases output size and computation. delta_e must be positive; non-positive values will produce an error or invalid output.
    
    Returns:
        None: The function does not return a Python value. Side effects are: reading dipole_moment_file, computing the dipole strength function (with conversion from atomic units to eV), writing the computed spectrum to spectrum_file on the MPI root process, and printing status messages and a "Sinc contamination" diagnostic to standard output on the MPI root. Failure modes include missing or malformed input files, invalid folding string (not 'Gauss' or 'Lorentz'), non-positive width or delta_e, or inconsistent energy bounds (e_min >= e_max), which will typically raise errors in the underlying processing routines.
    """
    from gpaw.tddft.spectrum import photoabsorption_spectrum
    return photoabsorption_spectrum(
        dipole_moment_file,
        spectrum_file,
        folding,
        width,
        e_min,
        e_max,
        delta_e
    )


################################################################################
# Source: gpaw.spherical_harmonics.S
# File: gpaw/spherical_harmonics.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_spherical_harmonics_S(l: int, m: int):
    """gpaw.spherical_harmonics.S: SymPy representation of the real-valued spherical harmonic S_lm. This function constructs a real-valued angular function S(l,m) by forming specific real linear combinations of the complex spherical harmonics Y0(l,m) and Y0(l,-m) using SymPy objects. In the GPAW DFT/PAW context (see README), these real spherical harmonics are used as angular parts of atomic orbitals, projector functions, and PAW partial waves when a real angular basis is required instead of complex spherical harmonics.
    
    Behavior summary: for m > 0 the function returns the normalized real combination (Y0(l,m) + (-1)**m Y0(l,-m))/sqrt(2) times the phase (-1)**m; for m < 0 it returns the normalized imaginary combination -(Y0(l,m) - (-1)**m Y0(l,-m)) / (sqrt(2)*I); for m == 0 it returns Y0(l,0) unchanged. The implementation imports SymPy symbols I, Number, and sqrt at call time and depends on a module-level function or callable Y0(l, m) that provides complex spherical harmonics as SymPy expressions.
    
    Args:
        l (int): Angular momentum quantum number (degree) of the spherical harmonic. In the DFT/PAW domain this corresponds to the orbital angular momentum channel (e.g., l = 0 for s, l = 1 for p). Must be an integer (typically non-negative); mathematically valid values satisfy l >= 0 and integer. Supplying values outside the mathematical domain may lead to errors from Y0 or SymPy.
        m (int): Magnetic quantum number (order) of the spherical harmonic. In the DFT/PAW domain m distinguishes the different magnetic substates for a given l. Must be an integer satisfying -l <= m <= l for mathematically valid spherical harmonics; the function branches on the sign of m to construct the corresponding real combination.
    
    Returns:
        sympy.Expr: A SymPy expression representing the real-valued spherical harmonic S_lm constructed from Y0. The returned object is intended to be a real-valued SymPy expression for integer l and m in the physical range, suitable for symbolic manipulations or for converting to numerical functions used when building real angular basis functions in GPAW.
    
    Side effects and dependencies:
        The function performs local imports from SymPy (I, Number, sqrt) at call time and therefore requires SymPy to be installed; if SymPy is missing an ImportError will be raised. The function also depends on a module-level callable Y0(l, m) that returns complex spherical harmonics as SymPy expressions; if Y0 is not defined a NameError will be raised at runtime.
    
    Failure modes:
        Passing non-integer or out-of-range values for l or m may produce incorrect symbolic expressions or raise exceptions coming from Y0 or SymPy. No internal validation is performed beyond the integer comparisons and arithmetic shown above.
    
    Side effects:
        None beyond importing SymPy symbols and calling Y0; the function does not mutate global state.
    """
    from gpaw.spherical_harmonics import S
    return S(l, m)


################################################################################
# Source: gpaw.tddft.spectrum.read_dipole_moment_file
# File: gpaw/tddft/spectrum.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_tddft_spectrum_read_dipole_moment_file(fname: str, remove_duplicates: bool = True):
    """gpaw.tddft.spectrum.read_dipole_moment_file reads a time-dependent dipole moment data file produced for time-dependent density-functional theory (TDDFT) calculations in GPAW and returns the recorded kicks (applied perturbations), the time grid, the norm time series, and the dipole moment components needed for spectrum analysis.
    
    This function is used when processing TDDFT propagation outputs to build spectra or analyze time-dependent response: it calls lower-level readers (read_td_file_data and read_td_file_kicks) to parse a file containing a time column, a norm column, and one or more dipole-component columns, plus any recorded "kicks" (instantaneous perturbations). The first data column after the time column is interpreted as the norm and subsequent columns as dipole moment components. No file writing occurs; the function only reads and returns in-memory Python objects that can be consumed by post-processing routines in the GPAW TDDFT spectrum workflow.
    
    Args:
        fname (str): Path to the dipole moment data file to read. This should be the filename produced by GPAW TDDFT propagation or an equivalent text file formatted for read_td_file_data/read_td_file_kicks. The function will attempt to open and parse this file; a FileNotFoundError is raised if the path does not exist and parsing errors (for example malformed numeric columns) raise a ValueError or the underlying I/O exception raised by the helper readers.
        remove_duplicates (bool): If True (default), remove data rows that have overlapping time values (duplicate time stamps) when constructing the time series. Overlapping time values are considered identical or repeated time entries encountered in the file; when duplicates are removed the first encountered values are kept and later rows with the same time are discarded. If False, no duplicate-time filtering is performed and all rows from the file are preserved in the returned arrays. This option controls deduplication behavior during parsing and may affect the length and alignment of the returned arrays used for Fourier transforms or other spectrum analysis.
    
    Returns:
        kick_i (list): List of kicks (applied perturbations) found in the file. Each element is a dictionary describing one kick and contains at least the keys "strength_v" and "time" as produced by read_td_file_kicks. "strength_v" records the vector or scalar magnitude of the perturbation and "time" gives the timestamp at which the kick was applied. These kicks are used to identify and interpret the initial perturbations that generated the system response in TDDFT spectrum calculations.
        time_t (array): Array of time values (the time grid) extracted from the file and optionally deduplicated according to remove_duplicates. This array defines the sample times for norm_t and dm_tv and is used directly for time-to-frequency transforms and plotting the time evolution.
        norm_t (array): Array of norm values corresponding to time_t. The first data column after the time column in the file is interpreted as the norm; norm_t is used for monitoring numerical conservation and diagnosing propagation stability in TDDFT runs.
        dm_tv (array): Array of dipole moment values with one row per time value in time_t and one or more columns for dipole components (the remaining data columns after the norm column). These dipole moment time series are the primary observable for computing absorption spectra and other linear-response properties.
    
    Raises:
        FileNotFoundError: If the file specified by fname does not exist.
        ValueError: If the file exists but cannot be parsed into the expected numeric columns (for example wrong format or inconsistent column counts). Exceptions may also propagate from the helper functions read_td_file_data and read_td_file_kicks.
    """
    from gpaw.tddft.spectrum import read_dipole_moment_file
    return read_dipole_moment_file(fname, remove_duplicates)


################################################################################
# Source: gpaw.test.findpeak
# File: gpaw/test/__init__.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for findpeak because the docstring has no description for the argument 'x'
################################################################################

def gpaw_test_findpeak(x: numpy.ndarray, y: numpy.ndarray):
    """gpaw.test.findpeak finds the sub-sample peak location and peak value by fitting a quadratic (second-degree) polynomial to the three sampled points around the maximum sample. This function is used in GPAW tests and utilities to refine the location and value of a peak (for example, a spectral peak, a maximum in an energy curve, or any locally peaked 1D sampled quantity produced by DFT calculations) from discrete samples without requiring a denser grid.
    
    Args:
        x (numpy.ndarray): One-dimensional array of sample x-coordinates (independent variable). This array must have the same length as y and provide the x positions corresponding to the sampled values in y. Typical usage in GPAW tests is with evenly or nearly evenly spaced x (e.g., frequency, energy, or spatial coordinate grids); the function centers the quadratic fit on the sample at the index of the maximum y value by subtracting x[i] before fitting to improve numerical stability.
        y (numpy.ndarray): One-dimensional array of sampled values (dependent variable) with the same length as x. The peak is located by finding the index i = y.argmax() and fitting a quadratic through the three points y[i-1], y[i], y[i+1]. y represents a quantity computed in DFT contexts such as a spectral intensity or energy along a scan; the function assumes a single local maximum at the chosen index.
    
    Behavior and practical details:
        - The function locates the index i of the maximum entry in y using numpy.argmax(), then selects the three neighboring points x[i-1:i+2] and y[i-1:i+2]. It shifts the selected x values by subtracting x[i] before calling numpy.polyfit to compute quadratic coefficients (a, b, c) for improved numerical stability.
        - The fitted quadratic is y_fit(dx) = a*dx**2 + b*dx + c where dx is measured relative to x[i]. The function computes the vertex dx = -0.5*b/a and returns x0 = x[i] + dx and y0 = y_fit(dx).
        - The implementation requires that the fitted quadratic opens downward (a < 0). If the fitted coefficient a is not negative, an AssertionError is raised. This serves as an internal consistency check that the chosen point is a local maximum compatible with a concave-down quadratic approximation.
        - No global smoothing or multi-point fitting beyond the three nearest points is performed; this is intended as a simple, fast local refinement used in tests and diagnostics.
        - The function does not modify its inputs.
    
    Failure modes and exceptions:
        - IndexError will be raised if the global maximum occurs at the first or last sample (i == 0 or i == len(y) - 1) or if the arrays are shorter than 3 elements, because the code requires the three-point slice x[i-1:i+2]. Callers should ensure the maximum is not at the boundary or pad the data before calling.
        - AssertionError is raised if the quadratic fit yields a >= 0, indicating the three-point fit is not concave downward and thus not suitable for locating a local peak by vertex formula.
        - ValueError or TypeError may be raised by numpy.polyfit if x and y are not real one-dimensional numpy.ndarray objects or contain invalid values (NaN/Inf) incompatible with polynomial fitting.
        - The function assumes x and y have matching lengths; mismatched lengths will cause indexing errors.
    
    Returns:
        Tuple[float, float]: A pair (x0, y0) where x0 is a float giving the refined peak position (same units as x) obtained from the vertex of the fitted quadratic, and y0 is a float giving the corresponding peak value (same units as y) evaluated from the fitted quadratic. These refined values are useful in GPAW tests and analysis for sub-grid resolution estimates of peak location and magnitude.
    """
    from gpaw.test import findpeak
    return findpeak(x, y)


################################################################################
# Source: gpaw.tddft.spectrum.read_td_file_kicks
# File: gpaw/tddft/spectrum.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_tddft_spectrum_read_td_file_kicks(fname: str):
    """Read kicks from a GPAW time-dependent data file produced by real-time TDDFT runs and return them as a list of parsed kick records.
    
    Args:
        fname (str): Path to the time-dependent data file to read. In the GPAW tddft.spectrum workflow this file is expected to contain text lines beginning with the literal "# Kick" followed by a "Kick = [...]" vector and optionally a "Time = ..." token on the same line. The function opens this path using the built-in open() and will raise standard I/O exceptions (FileNotFoundError, PermissionError, etc.) if the file cannot be opened.
    
    Returns:
        list: A list of kick dictionaries preserving the order encountered in the file. Each dictionary contains the following keys:
            'strength_v' (numpy.ndarray): A length-3 numpy array of floats parsed from the "Kick = [k0, k1, k2]" field on the line. These three components are the Cartesian components of the applied impulse/perturbation recorded in the GPAW time-dependent output; their physical units are those used by the producing simulation file.
            'time' (float): The time parsed from the "Time = ..." token on the same line, representing the simulation time at which the kick was recorded. If the "Time" token is absent, the function prints the literal string "time not found" to standard output and uses the default value 0.0.
            'velocity' (bool): True if the substring "velocity" appears in the same line (indicating the kick was recorded as a velocity-type perturbation in the output), otherwise False.
    
    Behavior and side effects:
        The function scans the file line by line and only attempts to parse lines that start exactly with "# Kick". For each such line it uses regular-expression parsing to extract the three numeric kick components and the optional time token. If the expected "Kick = [...]" pattern is not found on a line that begins with "# Kick", an AssertionError with the message "Kick not found" is raised. Numeric parsing of the kick components and time uses float conversions and may raise ValueError if the numeric text is malformed. The function prints "time not found" to standard output when the "Time" token is missing and sets time to 0.0 in that case. The returned list contains one dictionary per parsed kick, in the same order as they appear in the file.
    """
    from gpaw.tddft.spectrum import read_td_file_kicks
    return read_td_file_kicks(fname)


################################################################################
# Source: gpaw.tetrahedron.bja1
# File: gpaw/tetrahedron.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for bja1 because the docstring has no description for the argument 'e1'
################################################################################

def gpaw_tetrahedron_bja1(
    e1: numpy.ndarray,
    e2: numpy.ndarray,
    e3: numpy.ndarray,
    e4: numpy.ndarray
):
    """Compute the scalar and vector quantities defined in Eqs. (A2) and (C2) of
    Blöchl, Jepsen and Andersen. This function implements the algebraic form
    used in the tetrahedron integration method commonly employed in density
    functional theory (DFT) to obtain energy-dependent weights from the four
    vertex energies of a tetrahedron. It returns a scalar combination (the
    negative dot product of e1**3 with an intermediate factor) and a vector
    proportional to e1**2 times the same intermediate factor; both quantities
    are returned exactly as computed in the source implementation:
    x = 1.0/((e2 - e1)*(e3 - e1)*(e4 - e1))
    and the function returns (-(e1**3).dot(x), 3 * e1**2 * x).
    
    Args:
        e1 (numpy.ndarray): 1D array of real-valued energies corresponding to
            the first vertex of each tetrahedron. In the tetrahedron method
            context (as in the referenced paper), e1 is the energy at vertex 1
            and is used to build the polynomial combinations in Eqs. (A2) and
            (C2). The array must be one-dimensional and have the same shape as
            e2, e3 and e4; the implementation uses elementwise arithmetic and a
            dot product, so matching shapes are required.
        e2 (numpy.ndarray): 1D array of real-valued energies corresponding to
            the second vertex of each tetrahedron. e2 participates in the
            denominator factors (e2 - e1) that define the intermediate factor x
            = 1.0/((e2 - e1)*(e3 - e1)*(e4 - e1)). Must be the same shape as e1,
            e3 and e4.
        e3 (numpy.ndarray): 1D array of real-valued energies corresponding to
            the third vertex of each tetrahedron. Like e2, e3 appears in the
            denominator factors that determine x. Must be the same shape as the
            other inputs.
        e4 (numpy.ndarray): 1D array of real-valued energies corresponding to
            the fourth vertex of each tetrahedron. Appears in the denominator
            factors defining x and must have the same shape as e1, e2 and e3.
    
    Returns:
        Tuple[float, numpy.ndarray]: A pair (a, b) where:
            a (float): Scalar equal to -(e1**3).dot(x). Practically, this is the
                scalar coefficient produced by summing the elementwise product
                of e1**3 and the intermediate factor x; in the tetrahedron
                integration scheme this corresponds to the quantity given in
                Eq. (A2)/(C2) after contraction over the per-vertex arrays.
            b (numpy.ndarray): 1D numpy.ndarray equal to 3 * e1**2 * x. This
                vector has the same shape as the input arrays and represents the
                per-vertex contribution proportional to the derivative-like
                combination appearing in the referenced equations (Eq. (C2)),
                used to assemble energy-dependent integration weights.
    
    Behavior and side effects:
        This function is pure (no side effects) and implemented with
        vectorized NumPy operations for efficiency. It does not allocate
        defensive copies of the inputs beyond what NumPy creates for the
        intermediate expressions; callers should not rely on any in-place
        modification of their arrays by this function.
    
    Failure modes and numerical considerations:
        If any element of (e2 - e1)*(e3 - e1)*(e4 - e1) is zero, the intermediate
        factor x contains an infinite or NaN entry; NumPy will generate runtime
        warnings and the returned values will contain inf/NaN accordingly. Mismatched
        shapes among e1, e2, e3 and e4 will cause NumPy broadcasting errors (typically
        a ValueError). Very small denominators can produce large magnitudes and
        potential floating-point overflow; callers should ensure the four vertex
        energies are distinct where required by the underlying tetrahedron
        integration theory.
    """
    from gpaw.tetrahedron import bja1
    return bja1(e1, e2, e3, e4)


################################################################################
# Source: gpaw.symmetry.frac
# File: gpaw/symmetry.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for frac because the docstring has no description for the argument 'f'
################################################################################

def gpaw_symmetry_frac(f: float, n: int = 120, tol: float = 1e-06):
    """gpaw.symmetry.frac converts a floating-point number to a simplified rational fraction (numerator, denominator) suitable for use in symmetry and fractional-coordinate handling inside GPAW, the DFT/PAW code. The function is intended to take a float that represents a fractional coordinate or rational symmetry parameter and return small integer numerator and denominator pairs that are exact rationals used by symmetry routines and other parts of GPAW that require rational representations.
    
    Args:
        f (float): The floating-point value to convert to a fraction. In the GPAW symmetry context this typically represents a fractional coordinate or a component of a symmetry operation that is expected to be rational. If f is exactly 0.0 the function returns the canonical fraction (0, 1). Negative values are accepted and converted according to the same rounding and gcd simplification rules as positive values.
        n (int): The maximum denominator used when searching for a rational representation of f. The default value is 2 * 3 * 4 * 5 (evaluates to 120 in the function signature) which biases the routine toward small, commonly used denominators in crystallography and symmetry (for example denominators like 2, 3, 4, 5 and their combinations). The algorithm multiplies f by n and checks whether the product is close to an integer within the tolerance; if so that integer is used as the numerator before simplification.
        tol (float): Absolute tolerance on the floating-point representation used to determine whether n * f is sufficiently close to an integer. The test performed is abs(n * f - round(n * f)) <= n * tol. This tolerance compensates for floating-point rounding errors produced by numeric computations in GPAW. The default 1e-6 is chosen to be small relative to typical floating-point noise but large enough to accept practically exact rationals produced by computations.
    
    Returns:
        Tuple[int, int]: A tuple (numerator, denominator) of integers giving the simplified rational equivalent of f. The returned fraction is reduced by dividing numerator and denominator by their greatest common divisor (gcd). The denominator is guaranteed to be a positive integer less than or equal to n (unless f is 0, in which case the returned denominator is 1). No floating-point values are returned; this integer pair is intended for exact comparisons and storage in symmetry data structures.
    
    Behavior and failure modes: The function first handles the exact zero case and returns (0, 1). It then computes x = n * f and checks whether x is within n * tol of the nearest integer. If the distance abs(x - round(x)) is greater than n * tol the function raises ValueError to signal that f cannot be represented as a rational with denominator bounded by n within the requested tolerance; this exception is used by calling code to detect non-rational or noisy values that should not be accepted as exact symmetry fractions. If the check passes, x is rounded to the nearest integer, reduced with gcd(x, n), and the simplified numerator and denominator are returned. The function is pure (no side effects), uses integer arithmetic after rounding, and is inexpensive for the small default n used in crystallographic/symmetry contexts.
    """
    from gpaw.symmetry import frac
    return frac(f, n, tol)


################################################################################
# Source: gpaw.tddft.spectrum.polarizability_spectrum
# File: gpaw/tddft/spectrum.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_tddft_spectrum_polarizability_spectrum(
    dipole_moment_file: str,
    spectrum_file: str,
    folding: str = "Gauss",
    width: float = 0.2123,
    e_min: float = 0.0,
    e_max: float = 30.0,
    delta_e: float = 0.05
):
    """gpaw.tddft.spectrum.polarizability_spectrum computes and writes a frequency-domain polarizability spectrum from a time-dependent dipole moment file produced by a real-time TDDFT calculation within GPAW. The routine reads the dipole vs time data, Fourier-transforms and folds (broadens) the raw spectrum with a chosen kernel (Gaussian or Lorentzian), converts the computed polarizability from atomic units to eV-based units, and writes the resulting energy-dependent polarizability to a text file. This function is typically used to obtain optical response quantities (absorption, polarizability) from real-time propagation outputs for analysis and plotting.
    
    Args:
        dipole_moment_file (str): Name of the input file containing the time-dependent dipole moment produced by a TDDFT real-time propagation in GPAW. The file is parsed by the underlying write_spectrum/calculate_polarizability routines; if the file is missing or malformed those routines will raise an I/O or parsing error. This parameter identifies the source of the dipole vs time data that is transformed into a polarizability spectrum.
        spectrum_file (str): Name of the output file to which the computed polarizability spectrum is written. On successful completion this file will contain the energy axis (in eV) and the corresponding polarizability values (converted from atomic units). The file is created/overwritten by the function on the MPI rank 0 process.
        folding (str): Folding kernel to use for spectral broadening. Acceptable values are 'Gauss' or 'Lorentz' to select Gaussian or Lorentzian broadening respectively. This choice controls the lineshape applied to the discrete frequency components obtained from the Fourier transform of the dipole signal and thereby models lifetime/broadening effects in the spectrum. Passing any other string is unsupported and may cause the underlying write_spectrum routine to raise an error.
        width (float): Width parameter of the folding kernel (in the same energy units, eV). For Gaussian folding this is the Gaussian sigma; the Gaussian kernel used is 1/(sigma sqrt(2pi)) * exp(-(1/2) (omega/sigma)^2). For Lorentzian folding this is the full width at half maximum parameter Gamma used in the Lorentzian kernel (1/pi) * (1/2 Gamma) / [omega^2 + ((1/2 Gamma))^2]. The default 0.2123 corresponds to a small finite broadening applied to individual transitions; setting width<=0 is invalid and may produce incorrect results or raise errors in the folding routine.
        e_min (float): Minimum energy (in eV) shown in the output spectrum. The computed spectrum is evaluated on an energy grid that spans [e_min, e_max]; values outside this interval are not written to spectrum_file. If e_min >= e_max the behavior depends on the underlying spectrum routine and may raise an error or produce an empty output.
        e_max (float): Maximum energy (in eV) shown in the output spectrum. See e_min for notes about the energy range and validity checks.
        delta_e (float): Energy resolution (in eV) of the output spectrum, i.e., the spacing between successive energy points in the written spectrum. Very small delta_e increases output size and computational cost; delta_e<=0 is invalid and may raise an error.
    
    Returns:
        None: This function does not return a Python value. Instead it has the following side effects: on MPI world rank 0 it performs the polarizability calculation, converts the result from atomic units to eV-based units by dividing the computed polarizability by au_to_eV**2, writes the energy vs polarizability data to spectrum_file (labelled as 'Polarizability' and 'alpha'), and prints progress messages and the reported "Sinc contamination" metric to standard output. On non-root MPI ranks the function performs no I/O and does not produce output. Typical failure modes are file I/O errors (missing or malformed dipole_moment_file), invalid folding or numerical parameters, and exceptions propagated from the underlying calculate_polarizability or write_spectrum routines.
    """
    from gpaw.tddft.spectrum import polarizability_spectrum
    return polarizability_spectrum(
        dipole_moment_file,
        spectrum_file,
        folding,
        width,
        e_min,
        e_max,
        delta_e
    )


################################################################################
# Source: gpaw.tetrahedron.bja2b
# File: gpaw/tetrahedron.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for bja2b because the docstring has no description for the argument 'e1'
################################################################################

def gpaw_tetrahedron_bja2b(
    e1: numpy.ndarray,
    e2: numpy.ndarray,
    e3: numpy.ndarray,
    e4: numpy.ndarray
):
    """gpaw.tetrahedron.bja2b computes the four tetrahedron-integration weights (w1, w2, w3, w4) from four vertex energies using the analytic formulas given in Eq. (B7)–(B10) of Blöchl, Jepsen and Andersen. This function is used in GPAW's tetrahedron integration routines for density-functional theory (DFT) calculations (projector-augmented wave method) to obtain the contribution of a single tetrahedron to integrated quantities such as the density of states or band energy by linear interpolation inside the tetrahedron.
    
    Args:
        e1 (numpy.ndarray): One-dimensional array of energies at tetrahedron vertex 1. Each element corresponds to an energy value for a particular k-point / band or an energy sample; the array must have the same shape as e2, e3 and e4. In the context of GPAW tetrahedron integration, e1 represents the energy value at the first corner of a tetrahedron used to compute analytic integration weights according to Blöchl, Jepsen and Andersen.
        e2 (numpy.ndarray): One-dimensional array of energies at tetrahedron vertex 2. Same shape and role as e1 but for the second corner. The ordering of e1, e2, e3, e4 matches the vertex ordering used in the analytic formulas (Eqs. B7–B10).
        e3 (numpy.ndarray): One-dimensional array of energies at tetrahedron vertex 3. Same shape and role as e1 and e2 but for the third corner. These inputs are combined elementwise to compute the weight components w1..w4.
        e4 (numpy.ndarray): One-dimensional array of energies at tetrahedron vertex 4. Same shape and role as the other e-parameters but for the fourth corner. All four arrays are used together in rational expressions; the function performs no input validation beyond numpy broadcasting rules.
    
    Returns:
        numpy.ndarray: A two-dimensional numpy array containing the four weight arrays stacked along the first axis: array([w1, w2, w3, w4]). Each w_i has the same shape as the input one-dimensional arrays, so the returned array has shape (4, N) where N is the length of the input arrays. The weights are dimensionless coefficients used to distribute a tetrahedron's contribution to integrated quantities (for example, when accumulating the density of states or integrated band energies across k-points). The returned weights follow the definitions in Eq. (B7)–(B10) of Blöchl, Jepsen and Andersen.
    
    Notes:
        - The implementation follows the algebraic expressions (B7–B10) directly and performs elementwise arithmetic with numpy. There are no side effects; the function returns the computed weights and does not modify its inputs or global state.
        - Numerical failure modes: if any pair of input energies produce zero denominators (for example, two equal energies such that e3 == e1 or e4 == e2, etc.), the expressions will produce infinities or NaNs due to division by zero. The function does not catch or correct these singular cases; callers should ensure input energies are ordered and perturbed as required by the tetrahedron integration scheme or handle NaN/inf results after the call.
        - Inputs should be numeric numpy arrays (floating point) and are expected to represent energies consistent with the units used elsewhere in GPAW (typically electronvolts when interacting with ASE-level APIs).
    """
    from gpaw.tetrahedron import bja2b
    return bja2b(e1, e2, e3, e4)


################################################################################
# Source: gpaw.tetrahedron.bja1b
# File: gpaw/tetrahedron.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for bja1b because the docstring has no description for the argument 'e1'
################################################################################

def gpaw_tetrahedron_bja1b(
    e1: numpy.ndarray,
    e2: numpy.ndarray,
    e3: numpy.ndarray,
    e4: numpy.ndarray
):
    """gpaw.tetrahedron.bja1b computes the Blöchl–Jepsen–Andersen (BJA) tetrahedron coefficients (Eq. (B2)–(B5) in the referenced paper) used in GPAW's tetrahedron integration routines. This function implements the algebraic form of the BJA weights: it computes the common prefactor C and the four vertex weights w1, w2, w3 and w4 from four input energy arrays corresponding to the tetrahedron vertex energies. In the context of GPAW (a density-functional theory code), these weights are used to distribute contributions (for example to density of states, occupations, or integrals over the Brillouin zone) from a tetrahedron to its four vertices.
    
    Args:
        e1 (numpy.ndarray): One-dimensional array of energy values E1 at the first vertex of each tetrahedron. Practically, e1 contains the energy value (in the same energy units used by the caller) associated with the first corner of many tetrahedra or many k-point/tetrahedron combinations. This argument must be a numpy.ndarray and is used elementwise in the algebraic formula for the BJA prefactor C = -0.25 * e1**3 / ((e2 - e1)*(e3 - e1)*(e4 - e1)). All arithmetic is performed elementwise; e1 is expected to be broadcast-compatible with e2, e3 and e4 and typically has shape (N,) where N is the number of tetrahedra or k-point samples.
        e2 (numpy.ndarray): One-dimensional array of energy values E2 at the second vertex of each tetrahedron. e2 must be a numpy.ndarray with the same length/shape as e1 (or broadcastable to that shape). It appears in the denominators of the prefactor and in the intermediate weight formulas w2 = -C * e1 / (e2 - e1). If e2 equals e1 for any element, this will produce a division-by-zero for that element (see Failure modes).
        e3 (numpy.ndarray): One-dimensional array of energy values E3 at the third vertex of each tetrahedron. e3 must be a numpy.ndarray and likewise broadcast-compatible with e1. It is used in the denominator terms and in computing w3 = -C * e1 / (e3 - e1).
        e4 (numpy.ndarray): One-dimensional array of energy values E4 at the fourth vertex of each tetrahedron. e4 must be a numpy.ndarray and broadcast-compatible with e1. It is used in the denominator terms and in computing w4 = -C * e1 / (e4 - e1).
    
    Behavior and practical significance:
        This function implements Eqs. (B2)–(B5) from Blöchl, Jepsen and Andersen to produce four weights per tetrahedron that are combined in higher-level tetrahedron-integration routines inside GPAW. The computation is fully vectorized using NumPy and returns weights for each input element in the provided arrays. The returned first axis corresponds to the four vertex weights [w1, w2, w3, w4] computed as:
            C = -0.25 * e1**3 / ((e2 - e1) * (e3 - e1) * (e4 - e1))
            w2 = -C * e1 / (e2 - e1)
            w3 = -C * e1 / (e3 - e1)
            w4 = -C * e1 / (e4 - e1)
            w1 = 4*C - w2 - w3 - w4
        The function performs no I/O, modifies no global state, and has no side effects beyond returning its result.
    
    Failure modes and numerical considerations:
        If any denominators (e2 - e1), (e3 - e1) or (e4 - e1) are zero for an element (for example when two or more vertex energies are identical), the elementwise operations will produce division-by-zero, yielding infinities or NaNs in the result for that element. Callers must ensure inputs avoid exact degeneracies or handle the resulting NaNs/Infs appropriately. Large differences in magnitude between e1 and the other energies can also cause numerical instability due to cancellation or overflow in the cubic and division operations. Inputs should be real-valued numpy.ndarray objects; complex inputs will be processed by NumPy arithmetic but are not the intended use.
    
    Returns:
        numpy.ndarray: Two-dimensional numpy array of weights with shape (4, ...) where the first axis indexes the four vertex weights [w1, w2, w3, w4] produced per input element. For typical one-dimensional inputs of length N this is an array with shape (4, N). Each column (or corresponding element along trailing axes) gives the four BJA weights for a single tetrahedron or k-point/tetrahedron sample. No mutation of input arrays occurs; the result is a newly allocated numpy.ndarray.
    """
    from gpaw.tetrahedron import bja1b
    return bja1b(e1, e2, e3, e4)


################################################################################
# Source: gpaw.tddft.spectrum.read_td_file_data
# File: gpaw/tddft/spectrum.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_tddft_spectrum_read_td_file_data(fname: str, remove_duplicates: bool = True):
    """gpaw.tddft.spectrum.read_td_file_data reads a whitespace-separated text file produced by a time-dependent (TD) GPAW calculation and returns the time axis and corresponding recorded observables. The function is used when processing TDDFT time-series output (for example, dipole moment components or other time-dependent observables) to prepare input arrays for spectrum analysis routines in the gpaw.tddft.spectrum workflow.
    
    Args:
        fname (str): Path to the input text file containing time-dependent data. The file is expected to be a whitespace-separated numeric text file readable by numpy.loadtxt: the first column must contain time values and every subsequent column contains a recorded observable at those times. The practical significance is that this filename points to TDDFT output produced during a real-time propagation or similar GPAW calculation; the function will attempt to open and parse this file with numpy.loadtxt, so standard filesystem and numpy I/O failure modes apply (e.g., FileNotFoundError/OSError if the file does not exist or cannot be read, ValueError if the file contents cannot be converted to floating-point numbers, or IndexError if the file has insufficient columns).
        remove_duplicates (bool): If True (the default), filter out rows that appear after an abrupt restart or overlapping time sequence so that the returned time array is non-decreasing in the sense of the implemented algorithm. Concretely, the function scans the time values in file order, keeps the first occurrence of each non-decreasing run and marks any later rows where the time value decreases (strictly less than the running maximum) as duplicates to be removed. Equality (time value equal to the running maximum) is treated as non-decreasing and retained; this preserves step-like data such as immediately before and after a kick. The practical role of this option is to remove duplicated or restarted segments produced when a time-dependent calculation was stopped and restarted, keeping the initial segment values (first encountered) and discarding later overlapping sections. When duplicates are removed, the function prints a summary message "Removed N duplicates" to standard output as a side effect. Set to False to return the raw data without this filtering.
    
    Returns:
        time_t (numpy.ndarray): 1-D numpy array of time values read from the first column of the file, filtered according to remove_duplicates if requested. This array has length equal to the number of retained time steps and dtype float (as produced by numpy.loadtxt). The returned time axis is intended to be used as the independent variable for subsequent TDDFT spectrum analysis routines in gpaw.tddft.spectrum.
        data_ti (numpy.ndarray): 2-D numpy array of recorded observables read from the remaining columns of the file (all columns after the first). The array has shape (len(time_t), M) where M is the number of data columns present in the file; rows correspond to the retained time points in time_t. The naming in code (data_ti) reflects an index convention where the first index runs over time and the second over different observable components. This array is used directly by downstream processing (for example, Fourier transforming dipole components to obtain absorption spectra).
    
    Behavior and failure modes:
        The function uses numpy.loadtxt to read numeric data; errors from numpy.loadtxt (OSError/FileNotFoundError for missing files, ValueError for malformed numeric data) propagate to the caller. If the file contains only a single column, data_ti will be an empty 2-D array with shape (N, 0) where N is the number of time rows; if the file is empty or has fewer rows/columns than required for indexing the first column, numpy will raise an exception. The duplicate-removal algorithm runs in a single pass over the time array and retains the first encountered values when overlapping time ranges occur; it treats equal times as non-decreasing to preserve step-like signals. When duplicates are found and removed, a message indicating the number removed is printed to standard output. No other files are written and no global state is modified.
    """
    from gpaw.tddft.spectrum import read_td_file_data
    return read_td_file_data(fname, remove_duplicates)


################################################################################
# Source: gpaw.tetrahedron.bja2
# File: gpaw/tetrahedron.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for bja2 because the docstring has no description for the argument 'e1'
################################################################################

def gpaw_tetrahedron_bja2(
    e1: numpy.ndarray,
    e2: numpy.ndarray,
    e3: numpy.ndarray,
    e4: numpy.ndarray
):
    """gpaw.tetrahedron.bja2 computes coefficient and coefficient-derivative arrays used in the analytic tetrahedron integration following Eqs. (A3) and (C3) of Blöchl, Jepsen and Andersen. This function is used in GPAW's tetrahedron-method routines for evaluating contributions to integrals over the Brillouin zone in density-functional theory (DFT) calculations: given energies at the four corners of a tetrahedron (for a set of bands or sampling points represented as 1-D arrays), it returns a scalar combination used as a weight and a 1-D array of related coefficients that enter the tetrahedron integration formulas.
    
    Args:
        e1 (numpy.ndarray): One-dimensional array of energy values at tetrahedron corner 1. Each element corresponds to a particular band or sampling point; arrays e1, e2, e3 and e4 must have the same shape. In the GPAW/DFT context these are typically single-band energies sampled at the four vertices of a tetrahedron in k-space.
        e2 (numpy.ndarray): One-dimensional array of energy values at tetrahedron corner 2, parallel in meaning and shape to e1. e2 participates in the polynomial combinations and dot products that produce the returned scalar and coefficient array.
        e3 (numpy.ndarray): One-dimensional array of energy values at tetrahedron corner 3. e3 appears in denominator factors (e3 - e1) and (e3 - e2) and thus influences the weights computed from Eqs. (A3)/(C3).
        e4 (numpy.ndarray): One-dimensional array of energy values at tetrahedron corner 4. e4 appears in denominator factors (e4 - e1) and (e4 - e2) and similarly influences the computed coefficients.
    
    Returns:
        Tuple[float, numpy.ndarray]: A pair (w, c) where
            w (float): A scalar obtained by taking the dot product of an intermediate 1-D array (computed from e1..e4 per Eq. (A3)/(C3)) with a polynomial expression in e2. In practical GPAW usage, this scalar acts as a combined weight or contribution from the tetrahedron to an integrated quantity (for example, partial occupations or density-of-states contributions) after summation over tetrahedra and bands.
            c (numpy.ndarray): A one-dimensional array of the same shape as the input arrays representing derivative-like coefficients (the elementwise factor returned by the second expression in the implementation). These coefficients are used together with w in downstream tetrahedron-method formulas to construct final integration weights or gradients with respect to the input energies.
    
    Behavior and notes:
        - The function implements algebraic combinations of the four input 1-D energy arrays following Blöchl, Jepsen and Andersen (Eqs. A3 and C3). The first returned value is produced by a dot product that reduces an intermediate 1-D array to a scalar; the second returned value is the elementwise coefficient array produced by multiplication of intermediate factors.
        - All input arrays must be one-dimensional and have identical shapes; the function performs elementwise arithmetic and a dot product that assumes matching lengths. If shapes differ, NumPy will raise a ValueError during broadcasting or the dot product.
        - Division by zero or very small denominators can occur when any of e3 == e1, e4 == e1, e3 == e2, or e4 == e2 (elementwise). Such cases lead to infinities or NaNs in the result; callers should ensure that input energies are distinct enough for stable evaluation or handle degenerate tetrahedra before calling this function.
        - The function has no side effects: it does not modify its inputs and returns new NumPy objects. It does not perform I/O.
        - No defaults are used; all four arguments are required.
        - Failure modes include NumPy exceptions raised for invalid shapes, and propagation of NaN/Inf when denominators are zero or when inputs contain NaNs/Infs. Users should validate energies or apply small regularization if required by their application.
    """
    from gpaw.tetrahedron import bja2
    return bja2(e1, e2, e3, e4)


################################################################################
# Source: gpaw.tddft.spectrum.read_magnetic_moment_file
# File: gpaw/tddft/spectrum.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_tddft_spectrum_read_magnetic_moment_file(
    fname: str,
    remove_duplicates: bool = True
):
    """Read time-dependent magnetic moment data file used by GPAW time-dependent DFT (TDDFT) spectrum analysis.
    
    This function parses a file produced for TD magnetic-moment time evolution and returns the recorded perturbation (kick) events and the sampled magnetic moment time series. It is used in GPAW's gpaw.tddft.spectrum workflow to load previously saved time-dependent magnetic moment data for post-processing, e.g. calculating response spectra from time-domain magnetic moments. Internally this function calls read_td_file_data(fname, remove_duplicates) to obtain the time and magnetic-moment arrays and read_td_file_kicks(fname) to obtain the list of kicks.
    
    Args:
        fname (str): Path to the time-dependent magnetic moment data file to read. This should be a file produced by the GPAW TDDFT routines that store magnetic-moment time traces and kick metadata. The function will open and parse this file; if the file does not exist or cannot be parsed it will raise a FileNotFoundError, OSError, or ValueError propagated from the underlying reader.
        remove_duplicates (bool = True): If True, remove data entries that have overlapping (identical) time values when constructing the time and magnetic-moment arrays. Overlapping entries commonly arise from concatenated or partially overlapping output files; when duplicates are removed, the first encountered value for each duplicated time is kept and subsequent entries for the same time are discarded. If False, all entries are kept in the order they appear in the file. Default is True.
    
    Returns:
        kick_i (list): List of kick events read from the file. Each element is a dictionary describing a perturbation applied during the TD simulation and contains at least the keys "strength_v" and "time". "strength_v" holds the kick strength value(s) as recorded in the file and represents the magnitude (and, if vector-valued, direction) of the perturbation applied to the system's magnetic moment; "time" gives the simulation time at which the kick was applied as recorded in the file. These kick dictionaries are used in TDDFT spectrum analysis to identify when and how the system was perturbed.
        time_t (array): Array of time values sampled in the magnetic-moment time series. This array contains the times corresponding to the rows or samples in mm_tv as read from the file (after optional duplicate removal). These time values are used as the independent variable for time-domain analysis and Fourier transforms when computing spectra.
        mm_tv (array): Array of magnetic moment values sampled at the times in time_t. The array is the recorded magnetic moment time series read from the file and corresponds elementwise to time_t. This data is the primary observable for computing magnetic response functions and spectra in GPAW TDDFT post-processing.
    
    Exceptions and failure modes:
        The function will raise FileNotFoundError or OSError if the file at fname cannot be opened. It may raise ValueError (or other parsing-related exceptions) if the file format is not recognized or contains inconsistent/invalid data. If duplicate time handling is important for downstream analysis, set remove_duplicates appropriately to avoid unintended removal or retention of samples.
    """
    from gpaw.tddft.spectrum import read_magnetic_moment_file
    return read_magnetic_moment_file(fname, remove_duplicates)


################################################################################
# Source: gpaw.tddft.spectrum.clean_td_data
# File: gpaw/tddft/spectrum.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_tddft_spectrum_clean_td_data(
    kick_i: list,
    time_t: numpy.ndarray,
    data_ti: numpy.ndarray
):
    """gpaw.tddft.spectrum.clean_td_data prunes and aligns time-dependent TDDFT data to a single perturbation ("kick") used in real-time propagation calculations. In the GPAW TDDFT spectrum workflow this function enforces that exactly one kick is present, discards all time and data samples that occur before the kick, and shifts the time axis so that the kick occurs at time zero. This alignment is necessary for correct post-processing of the time-dependent response (for example, constructing Fourier transforms to obtain excitation spectra).
    
    Args:
        kick_i (list): List of kicks provided by the TDDFT driver. Each element is expected to be a dictionary describing a single perturbation applied to the system; the code accesses the first element's keys 'strength_v', 'velocity', and 'time'. In the GPAW TDDFT context these dictionaries represent instantaneous velocity/field perturbations whose 'time' is the physical time at which the perturbation was applied. This function requires that the list contains exactly one kick; if more than one kick is present a RuntimeError is raised. If the list is empty an IndexError will occur when attempting to read the first element.
        time_t (numpy.ndarray): 1-D NumPy array of time points (monotonically increasing) corresponding to the rows or first axis of data_ti. In TDDFT simulations this is the sequence of physical times at which observables were recorded. The function filters this array to include only times greater than or equal to the kick time and then subtracts the kick time so that the returned time_t starts at exactly 0.0. Note that the code uses exact equality to assert the post-subtraction first element equals 0.0; an AssertionError will be raised if floating-point representation or input times prevent exact equality.
        data_ti (numpy.ndarray): NumPy array of time-dependent observables aligned with time_t (for example dipole or current as a function of time). The first axis of data_ti is assumed to correspond to the entries in time_t. The function returns the subset of data_ti corresponding to times at or after the kick time. Depending on NumPy's internal layout and slicing rules, the returned array may be a view of the original array or a copy.
    
    Returns:
        tuple: A 4-tuple (kick_v, velocity, time_t, data_ti) where
            kick_v: Extracted perturbation strength taken from the first (and only) kick dictionary under the key 'strength_v'. In TDDFT spectrum calculations this value represents the amplitude of the instantaneous perturbation used to generate the linear response; it is returned so downstream analysis knows the perturbation magnitude.
            velocity: Extracted value taken from the first kick dictionary under the key 'velocity'. In the GPAW TDDFT context this is typically the direction or velocity vector associated with the kick and is returned so post-processing routines can associate the filtered time series with the correct perturbation direction.
            time_t (numpy.ndarray): Filtered and time-shifted NumPy array of time values such that time_t[0] == 0.0 and all returned times are >= 0.0. This is suitable for Fourier transforms and other analyses that assume the perturbation occurred at t = 0.
            data_ti (numpy.ndarray): Filtered data array corresponding to the returned time_t, containing only samples at or after the kick and aligned with the shifted time axis.
    
    Behavior and side effects:
        The function enforces that exactly one kick is present and raises RuntimeError('Multiple kicks') if more than one kick is found. It reads the first kick dictionary without validation beyond key access; missing keys will raise a KeyError. Times strictly before the kick time are discarded; the function then subtracts the kick time from the retained times so that the kick occurs at zero. The function does not modify the original kick_i list object, but the returned time_t and data_ti may be views into the original arrays depending on NumPy slicing semantics.
    
    Failure modes:
        RuntimeError if more than one kick is provided.
        IndexError if kick_i is empty (attempting to access kick_i[0]).
        KeyError if the expected keys ('strength_v', 'velocity', 'time') are missing from the first kick dictionary.
        AssertionError if after subtracting the kick time the first element of the filtered time array is not exactly 0.0 (this can occur due to floating-point representation or if the kick time is not present in time_t).
    """
    from gpaw.tddft.spectrum import clean_td_data
    return clean_td_data(kick_i, time_t, data_ti)


################################################################################
# Source: gpaw.tddft.spectrum.rotatory_strength_spectrum
# File: gpaw/tddft/spectrum.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_tddft_spectrum_rotatory_strength_spectrum(
    magnetic_moment_files: list,
    spectrum_file: str,
    folding: str = "Gauss",
    width: float = 0.2123,
    e_min: float = 0.0,
    e_max: float = 30.0,
    delta_e: float = 0.05
):
    """gpaw.tddft.spectrum.rotatory_strength_spectrum calculates a rotatory strength spectrum from real-time time-dependent magnetic moment files produced by GPAW real-time TDDFT propagations. The function reads magnetic moment traces for kicks in the x, y and z directions, checks consistency of the kicks and kick strengths, folds the frequency-resolved response with a specified lineshape (Gaussian or Lorentzian), converts atomic-unit results to the CGS units used for optical rotatory strength reporting, and writes a two-column spectrum file (energy in eV and rotatory strength in 1e-40 cgs / eV) with a human-readable header describing propagation parameters and folding.
    
    Args:
        magnetic_moment_files (list of string): Paths to the time-dependent magnetic moment files produced by real-time TDDFT propagations. The function expects one file per Cartesian kick direction (x, y, z). Each file must encode the kick direction and strength, the time grid, and the time-dependent magnetic moment traces. These files are read with read_magnetic_moment_file and cleaned with clean_td_data; the function verifies that each file corresponds to a single Cartesian kick and that all files were generated with the same kick strength. If these checks fail, a RuntimeError is raised.
        spectrum_file (string): Path to the output spectrum file that will be created (overwritten) by this function on rank 0. The file contains a comment header with total propagation time (in fs), unique non-zero time steps (in attoseconds), kick strength (atomic units), folding type and width (converted to eV), followed by two-column numerical data: energy (eV) and R (1e-40 cgs / eV). I/O errors when opening or writing this file will propagate.
        folding ('Gauss' or 'Lorentz'): Folding type (string) that determines the lineshape applied to the discrete frequency response. Accepted literal values are 'Gauss' for Gaussian folding and 'Lorentz' for Lorentzian folding. The Folding class is used internally to construct the folding object; its .folding, .width, and .fwhm attributes are printed in the output header. Invalid folding values will be handled by the Folding constructor (errors from that class will propagate).
        width (float): Folding width parameter passed to Folding(folding, width). For Gaussian folding this parameter corresponds to the Gaussian sigma used by the Folding object; for Lorentzian folding it corresponds to the Lorentzian Gamma used by the Folding object. The function prints the numeric width multiplied by au_to_eV in the output header to show the width in eV and also reports the full width at half maximum (FWHM) in eV as folding.fwhm * au_to_eV. Any units interpretation follows the Folding implementation; the value is used without additional scaling prior to conversion for the header.
        e_min (float): Minimum energy (in eV) included in the output spectrum. This defines the lower bound of the energy grid passed to FoldedFrequencies. Typical use is to limit the printed spectrum to an energy window of interest from time-dependent propagation results.
        e_max (float): Maximum energy (in eV) included in the output spectrum. The energy grid is constructed with numpy.arange(e_min, e_max + 0.5 * delta_e, delta_e) so that the upper end is included when it falls on the grid defined by delta_e.
        delta_e (float): Energy resolution (in eV) of the output spectrum (grid spacing). The frequency grid used for folding and output is constructed with step delta_e; choosing a small delta_e increases spectral resolution and output size.
    
    Behavior and side effects:
        - This function only performs work on MPI rank 0. If executed in a parallel environment where world.rank != 0, the function returns immediately and no file is written on those ranks.
        - The function constructs an energy grid freqs = numpy.arange(e_min, e_max + 0.5 * delta_e, delta_e), builds a Folding(folding, width) object, and a FoldedFrequencies instance which are used to fold the time-domain response into frequency space.
        - For each file in magnetic_moment_files, the function calls read_magnetic_moment_file to obtain the kick information, time array, and magnetic moment time-series, then clean_td_data to normalize/clean the traces. It accumulates the minimum total propagation time across files and collects unique non-zero time step values for reporting.
        - The rotatory strength is computed by summing the frequency-domain contributions from each Cartesian kick via calculate_rotatory_strength_components and accumulating into rot_w. After summation, values are scaled by the factor rot_au_to_cgs * 1e40 / au_to_eV to convert from atomic units used in the internal propagation to the CGS units used for optical rotatory strength reporting (printed as "R (1e-40 cgs / eV)" in the output file).
        - The function writes a header with total propagation time (converted to fs using au_to_fs), time steps (converted to attoseconds using au_to_as), kick strength (atomic units), folding type and width (shown in eV), then writes the numerical two-column data with columns Energy (eV) and R (1e-40 cgs / eV). The numerical formatting uses high precision for the rotatory strength values.
    
    Failure modes and exceptions:
        - If any magnetic_moment_files entry does not contain a single Cartesian kick (i.e., if a file indicates non-zero kick components in more than one Cartesian direction), the function raises RuntimeError('The magnetic moment files must be for kicks in x, y, and z directions.').
        - If the kick strengths inferred from different files differ, the function raises RuntimeError('The magnetic moment files must have been calculated with the same kick strength.').
        - I/O errors (file not found, permission denied) from reading input files or writing the output file will propagate as corresponding Python exceptions.
        - Errors raised by helper classes and functions used internally (Folding, FoldedFrequencies, read_magnetic_moment_file, clean_td_data, calculate_rotatory_strength_components) will propagate; these may indicate malformed input, invalid folding parameters, or numerical problems.
        - When running under MPI, only rank 0 writes the output file; other ranks exit the function early without error but produce no output.
    
    Returns:
        None: This function does not return a Python value. Its practical effect is a side effect: creation (or overwriting) of the file specified by spectrum_file on MPI rank 0 containing the rotatory strength spectrum. The output format is a commented header describing propagation and folding parameters followed by two numeric columns: energy (eV) and rotatory strength (reported in 1e-40 cgs / eV).
    """
    from gpaw.tddft.spectrum import rotatory_strength_spectrum
    return rotatory_strength_spectrum(
        magnetic_moment_files,
        spectrum_file,
        folding,
        width,
        e_min,
        e_max,
        delta_e
    )


################################################################################
# Source: gpaw.tetrahedron.bja3
# File: gpaw/tetrahedron.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for bja3 because the docstring has no description for the argument 'e1'
################################################################################

def gpaw_tetrahedron_bja3(
    e1: numpy.ndarray,
    e2: numpy.ndarray,
    e3: numpy.ndarray,
    e4: numpy.ndarray
):
    """gpaw.tetrahedron.bja3 computes coefficients from Equations (A4) and (C4) of Blöchl, Jepsen and Andersen used in the tetrahedron integration scheme in density-functional theory (DFT) calculations performed by GPAW. The function produces one scalar and one array of coefficients that are used to form tetrahedron integration weights (for example when integrating the density of states or occupancy-related quantities over tetrahedra in reciprocal space).
    
    This implementation follows the algebra in the cited BJA equations: it forms the reciprocal of the product (e4 - e1)*(e4 - e2)*(e4 - e3) elementwise and then returns a scalar formed as len(e1) - x.dot(e4**3) together with an array 3*x*e4**2. These quantities are directly used by the GPAW tetrahedron routines to assemble integrals over energy within a tetrahedron.
    
    Args:
        e1 (numpy.ndarray): One-dimensional array of energies (eigenvalues) corresponding to corner 1 of each tetrahedron. In GPAW's tetrahedron integration context, this typically represents the energy values at a set of samples (e.g., k-points or bands) associated with the first vertex of each tetrahedron. The array length determines the number of samples; len(e1) is used in the scalar computation. e1 must have the same shape as e2, e3 and e4.
        e2 (numpy.ndarray): One-dimensional array of energies corresponding to corner 2 of each tetrahedron. Practically, e2 is the energy at the second vertex for the same set of samples as e1. It must be the same shape and ordering as e1 so that elementwise operations produce meaningful per-sample coefficients.
        e3 (numpy.ndarray): One-dimensional array of energies corresponding to corner 3 of each tetrahedron. Like e1 and e2, e3 provides the third-vertex energies for the same samples and must match their shape and ordering.
        e4 (numpy.ndarray): One-dimensional array of energies corresponding to corner 4 of each tetrahedron. e4 is used as the distinguished vertex in the algebra of Equations (A4) and (C4); it appears both in the denominator product (e4 - e1)*(e4 - e2)*(e4 - e3) and in powers e4**2 and e4**3. e4 must match the shape of e1, e2 and e3.
    
    Returns:
        Tuple[float, numpy.ndarray]: A tuple (a, b) where:
            a (float): Scalar coefficient computed as len(e1) - x.dot(e4**3), with x = 1.0/((e4 - e1)*(e4 - e2)*(e4 - e3)). In the tetrahedron integration context this scalar contributes to normalization/aggregate terms in the analytical expressions derived in BJA Eq. (A4)/(C4). The returned value is a Python float (NumPy scalar convertible to float).
            b (numpy.ndarray): One-dimensional array of the same shape as the input arrays, computed as 3 * x * e4**2. These per-sample coefficients are the elementwise contributions that, together with the scalar a, are used to build tetrahedron integration weights or related polynomial integrands as prescribed by the BJA formulas.
    
    Behavior and side effects:
        The function performs elementwise NumPy arithmetic: subtraction, multiplication, power, reciprocal and dot product. It has no side effects (it does not modify its inputs, global state, or files) and is deterministic for given inputs.
    
    Failure modes and numerical cautions:
        The function assumes e1, e2, e3 and e4 are one-dimensional numpy.ndarray objects of identical shape and ordering (corresponding samples across the four tetrahedron corners). If shapes differ, NumPy broadcasting rules may produce unexpected results or raise a ValueError on incompatible shapes.
        If any element of (e4 - e1)*(e4 - e2)*(e4 - e3) is zero or extremely small, the reciprocal x will be infinite or very large and NumPy will emit RuntimeWarnings and produce inf/NaN entries in the outputs. Such singularities correspond to degenerate tetrahedral energy configurations (e4 equal to one of the other corner energies) and should be avoided or treated with a suitable regularization strategy in the calling code.
        The function does not perform explicit type checking; passing non-numpy sequences may work if NumPy can coerce them, but this is not guaranteed.
    
    Reference:
        Implements Equations (A4) and (C4) from Blöchl, Jepsen and Andersen as used in GPAW's tetrahedron integration utilities.
    """
    from gpaw.tetrahedron import bja3
    return bja3(e1, e2, e3, e4)


################################################################################
# Source: gpaw.tetrahedron.count
# File: gpaw/tetrahedron.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for count because the docstring has no description for the argument 'fermi_level'
################################################################################

def gpaw_tetrahedron_count(fermi_level: float, eig_in: numpy.ndarray, i_ktq: numpy.ndarray):
    """Count electrons using the tetrahedron interpolation method in GPAW.
    
    This function is used within GPAW (a density-functional theory code) to determine the number of electrons and the derivative of the electron count with respect to the Fermi level by evaluating eigenvalue occupations with a tetrahedron-based interpolation across k-points and bands. The routine expects raw single-particle eigenvalues (in the same energy units as the provided fermi_level) and an index array that maps tetrahedra to eigenvalue entries. The result is typically used in metallic/partial-occupation electronic-structure calculations to obtain a smooth electron count and its sensitivity to changes in the Fermi level for self-consistent-field or post-processing steps.
    
    Args:
        fermi_level (float): The Fermi level (scalar) in the same energy units as eig_in. The function subtracts this value from eig_in to form energies relative to the Fermi level (eig_in - fermi_level), and occupation is determined from the sign of these relative energies. A finite float is required; passing an incompatible type will raise a TypeError during numeric operations.
        eig_in (numpy.ndarray): A 2D array of eigenvalues (Array2D in the original source) containing single-particle energies for the system. The code treats eig_in as a two-dimensional array and computes occupied states with (eig_in - fermi_level) < 0.0 along axis=1, so the second axis indexes bands while the first axis indexes the corresponding k-point / state index used together with i_ktq. Values must be numeric and in the same units as fermi_level. If eig_in has incompatible shape or cannot be indexed by i_ktq, the function will raise an IndexError or ValueError.
        i_ktq (numpy.ndarray): An integer index array (Array3D in the original source) used to select eigenvalues for each tetrahedron and k-point combination. The implementation uses ntetra = 6 * i_ktq.shape[0] to compute the total number of tetrahedra considered; i_ktq is used to index the first axis of eig_in (eig_in[i_ktq, n1:n2]) to extract eigenvalues for tetrahedron vertices. This array therefore maps tetrahedra (and implicitly k-point subdivisions) to indices in eig_in and must be a valid integer-indexing array. Passing an array with incompatible dimensionality or invalid indices will raise an indexing error.
    
    Behavior and side effects:
        The function subtracts fermi_level from eig_in to obtain energies relative to the Fermi level, classifies occupied states by negative relative energy, and computes nocc_i = (eig_in < 0.0).sum(axis=1). It finds the minimum (n1) and maximum (n2) number of occupied bands across the relevant index set. If n1 == n2 (no partial occupations across the examined bands), the function returns early with the integer electron count ne = n1 and derivative dnedef = 0.0. Otherwise it constructs a flattened array of tetrahedron vertex energies between band indices n1 and n2, sorts them per tetrahedron, and evaluates partial-occupation contributions using specialized tetrahedron subroutines (bja1, bja2, bja3) selected by the pattern of sign changes in the sorted vertex energies. The aggregated contributions are normalized by ntetra = 6 * i_ktq.shape[0] to yield a fractional occupation contribution per tetrahedron. There are no side effects on input arrays (no in-place modification of inputs outside the local subtraction eig_in = eig_in - fermi_level) beyond creating local arrays; the function is effectively pure from the caller's perspective.
    
    Defaults and assumptions:
        There are no optional parameters or defaults in the signature. The function assumes eig_in and fermi_level use consistent energy units and that i_ktq is a correct integer indexing array for eig_in. It assumes the helper functions bja1, bja2, and bja3 (used to compute partial occupations and derivatives for different tetrahedron sign patterns) are available in the module namespace and return numeric results compatible with summation and normalization performed here.
    
    Failure modes:
        The function will raise typical NumPy/Indexing exceptions if eig_in and i_ktq have incompatible shapes or if i_ktq contains out-of-bounds indices. A TypeError or ValueError may occur if inputs are not numeric arrays or fermi_level is not a float-compatible scalar. If all relevant eigenvalues are equal to zero or produce unexpected sign patterns that the helper routines cannot handle, the behavior depends on those helper routines and may propagate their exceptions. When n1 == n2 no tetrahedron interpolation is attempted and the derivative is set to zero.
    
    Returns:
        Tuple[float, float]: A pair (ne, dnedef) where
            ne (float): The computed number of electrons (dimensionless count) obtained by summing integer occupations and fractional tetrahedron contributions normalized by the total number of tetrahedra (ntetra = 6 * i_ktq.shape[0]). In the common GPAW workflow this is the electron count used for charge conservation or to adjust occupation in metallic systems.
            dnedef (float): The derivative of the electron count with respect to the Fermi level (dN/dE_f). This value is computed from the tetrahedron contributions (via bja1/bja2/bja3 calls) and summed and normalized by ntetra. It gives the sensitivity of the electron count to small changes in fermi_level and is used in procedures that require knowledge of how occupations change with energy (for example, locating the Fermi level for a target electron number).
    """
    from gpaw.tetrahedron import count
    return count(fermi_level, eig_in, i_ktq)


################################################################################
# Source: gpaw.tetrahedron.triangulate_everything
# File: gpaw/tetrahedron.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for triangulate_everything because the docstring has no description for the argument 'size_c'
################################################################################

def gpaw_tetrahedron_triangulate_everything(
    size_c: numpy.ndarray,
    ABC_tqc: numpy.ndarray,
    i_k: numpy.ndarray
):
    """Triangulate the whole Brillouin zone (BZ) by constructing a mapping from every
    BZ k-point and tetrahedron corner to the corresponding irreducible BZ (IBZ)
    k-point index. This function is used in GPAW's tetrahedron-based Brillouin
    zone integration machinery where the full BZ is generated from a small set of
    tetrahedron corner offsets (ABC_tqc) and grid sizes (size_c), and where each
    full-BZ k-point is mapped to an IBZ index via i_k. The practical significance
    is that the returned mapping i_ktq can be used to assemble integrals over all
    tetrahedra for properties such as density of states or BZ integrals in DFT
    calculations performed by GPAW.
    
    Args:
        size_c (numpy.ndarray): 1-D integer array of grid sizes along the three
            reciprocal-lattice axes. Its product nbzk = size_c.prod() defines the
            total number of grid points in the full BZ (nbzk = number of k-points).
            Each element is expected to be a positive integer; zeros or negative
            values will cause errors in index computations. This parameter defines
            the modular arithmetic used when wrapping indices into the grid; it is
            passed to numpy.unravel_index and numpy.ravel_multi_index as the shape
            of the full-grid index space.
        ABC_tqc (numpy.ndarray): 3-D integer array of relative corner offsets for
            tetrahedra. The first axis enumerates the three reciprocal directions
            (A, B, C); the remaining two axes enumerate tetrahedra (t) and their
            corners (q). In typical GPAW usage this has shape (3, 6, 4): three
            coordinate components for six tetrahedra with four corners each. These
            offsets are added to absolute grid coordinates (from size_c) to produce
            the absolute indices of each tetrahedron corner in the full BZ. Values
            must be integer offsets; they are combined with size_c and wrapped
            modulo size_c during index computation.
        i_k (numpy.ndarray): 1-D integer array that maps each full-BZ linear
            k-point index (0, 1, ..., nbzk - 1) to an IBZ k-point index
            (0, 1, ..., nibzk - 1). The length of i_k must be nbzk (the product of
            entries in size_c). The array provides the IBZ index for every full-BZ
            point and is used to convert absolute corner indices into IBZ indices
            for the returned mapping.
    
    Returns:
        numpy.ndarray: Integer array i_ktq with shape (nbzk, 6, 4) that maps the
        tuple (k, t, q) to an IBZ k-point index. Here k ranges over all full-BZ
        k-points (0..nbzk-1), t ranges over the six tetrahedra associated with a
        grid point (0..5), and q ranges over the four corners of each tetrahedron
        (0..3). The mapping is computed by (1) enumerating full-BZ grid coordinates
        from size_c, (2) adding the relative corner offsets ABC_tqc to obtain the
        absolute corner coordinates for every tetrahedron and every k-point,
        (3) converting those coordinates to linear full-BZ indices with wrapping
        (numpy.ravel_multi_index with mode='wrap'), and (4) applying i_k to obtain
        IBZ indices. The returned array has the same integer dtype as i_k.
    
    Raises/Failure modes:
        TypeError or ValueError may be raised if input arrays have incompatible
        shapes or dtypes (for example, size_c must be 1-D with three positive
        integer entries, ABC_tqc must be integer offsets that broadcast correctly
        with size_c, and i_k must have length equal to the product of size_c).
        numpy.ravel_multi_index may raise an error if size_c contains nonpositive
        entries. Index wrapping is performed (mode='wrap'), so out-of-range corner
        offsets in ABC_tqc are reduced modulo size_c rather than raising an error.
    
    Side effects:
        None. The function is pure: it computes and returns the mapping array and
        does not modify its input arrays.
    """
    from gpaw.tetrahedron import triangulate_everything
    return triangulate_everything(size_c, ABC_tqc, i_k)


################################################################################
# Source: gpaw.tetrahedron.triangulate_submesh
# File: gpaw/tetrahedron.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for triangulate_submesh because the docstring has no description for the argument 'rcell_cv'
################################################################################

def gpaw_tetrahedron_triangulate_submesh(rcell_cv: numpy.ndarray):
    """gpaw.tetrahedron.triangulate_submesh: Compute the fixed triangulation of a hexahedral cell (the unit cube mapped by the provided real-space cell matrix) into six tetrahedra and return the Cartesian coordinates of the tetrahedra vertices.
    
    This function is used inside GPAW's tetrahedron-related routines to produce a stable decomposition of a parallelepiped cell (defined by the real-space cell matrix rcell_cv) into six non-degenerate tetrahedra. The decomposition is obtained by Delaunay triangulation of the eight corner points of the unit cube after mapping them to Cartesian coordinates with rcell_cv, followed by removal of any zero-volume (degenerate) tetrahedra. The resulting array of tetrahedra can be used for mesh generation, numerical integration, interpolation, or any other algorithm in GPAW that requires a tetrahedral subdivision of a simulation cell.
    
    Args:
        rcell_cv (numpy.ndarray): A 2-D numeric array representing the real-space cell mapping used to convert unit-cube (fractional) coordinates [A, B, C] with A,B,C in {0,1} to Cartesian coordinates via row-vector multiplication: cart = [A, B, C].dot(rcell_cv). In practice rcell_cv is expected to be a 3x3 array (shape (3, 3)) containing the cell vectors needed to map the unit cube into the simulation cell in Cartesian space. Supplying an array with incompatible shape or non-numeric entries will raise an exception when the function attempts the matrix multiplication or Delaunay triangulation.
    
    Returns:
        numpy.ndarray: A 3-D array of shape (6, 4, 3) containing the Cartesian coordinates of the six tetrahedra. The first axis indexes the six tetrahedra produced by the triangulation. The second axis enumerates the four vertices of each tetrahedron. The third axis contains the three Cartesian coordinate components (x, y, z) of each vertex. Each returned tetrahedron has non-zero volume: degenerate (zero-volume) tetrahedra are removed before returning.
    
    Behavior, side effects, defaults, and failure modes:
        The function performs no external side effects and is deterministic for a given numeric input. Internally it constructs the eight corner points of the unit cube, maps them to Cartesian coordinates by multiplying with rcell_cv, computes a Delaunay triangulation of those eight points, and selects the tetrahedra from that triangulation. Any tetrahedra with zero volume (determinant of the three edge vectors equal to zero) are removed. The function asserts that exactly six non-degenerate tetrahedra remain; if this assertion fails an AssertionError is raised. Other exceptions that can be raised include errors from the underlying Delaunay routine (e.g., if the triangulation library cannot handle the input points) or from invalid input shapes/types during the dot product or determinant computation. Users should ensure rcell_cv defines a valid, non-degenerate mapping of the unit cube (typically a 3x3 matrix of real numbers) to avoid such errors.
    """
    from gpaw.tetrahedron import triangulate_submesh
    return triangulate_submesh(rcell_cv)


################################################################################
# Source: gpaw.tetrahedron.bja3b
# File: gpaw/tetrahedron.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for bja3b because the docstring has no description for the argument 'e1'
################################################################################

def gpaw_tetrahedron_bja3b(
    e1: numpy.ndarray,
    e2: numpy.ndarray,
    e3: numpy.ndarray,
    e4: numpy.ndarray
):
    """gpaw.tetrahedron.bja3b computes the elementwise tetrahedron interpolation weights w1, w2, w3 and w4 using the analytic formulas given in Blöchl, Jepsen and Andersen (Eqs. B14–B17). These weights are used in GPAW's tetrahedron-method integrations (for example k-point integrations and density-of-states calculations) to distribute contributions from a tetrahedron's four vertices according to their vertex energies. The implementation is vectorized and operates on NumPy arrays to produce weights for one or many energy points in a single call.
    
    Args:
        e1 (numpy.ndarray): Energy values at tetrahedron vertex 1. Expected to be a one-dimensional NumPy array (Array1D) containing the energy(s) for the first vertex of each tetrahedron. In the context of GPAW's tetrahedron integration, e1 is one of the four vertex energies used to compute the interpolation weight w1 for each energy entry. All input arrays must have the same shape or be broadcastable to a common shape; typically they are 1D arrays of the same length corresponding to multiple energy points or integration samples.
        e2 (numpy.ndarray): Energy values at tetrahedron vertex 2. Same expectations as e1: a one-dimensional NumPy array holding the second vertex energy for each tetrahedron or sample. This argument is used to compute the interpolation weight w2 according to Eq. (B15) of Blöchl, Jepsen and Andersen.
        e3 (numpy.ndarray): Energy values at tetrahedron vertex 3. Same expectations as e1 and e2. This array supplies the third vertex energy for each tetrahedron and is used to compute the interpolation weight w3 according to Eq. (B16) of Blöchl, Jepsen and Andersen.
        e4 (numpy.ndarray): Energy values at tetrahedron vertex 4 (the vertex singled out in Eqs. B14–B17). Same expectations as the other e-arrays. In the formulas implemented here e4 plays a special role (it appears in denominators and in the cubic prefactor C); therefore e4 should correspond to the vertex energy referenced by the analytic expressions from Blöchl, Jepsen and Andersen.
    
    Behavior and side effects:
        The function evaluates the algebraic expressions C = 0.25 * e4**3 / ((e4 - e1) * (e4 - e2) * (e4 - e3)), w1 = 0.25 - C * e4 / (e4 - e1), w2 = 0.25 - C * e4 / (e4 - e2), w3 = 0.25 - C * e4 / (e4 - e3) and w4 = 1.0 - 4 * C - w1 - w2 - w3 elementwise using NumPy. The implementation is pure numerical and has no side effects (it does not modify inputs, global state, or I/O). Inputs are processed elementwise and NumPy broadcasting rules apply if shapes differ, but typical and recommended use is with 1D arrays of identical length representing multiple samples.
    
    Defaults and practical significance:
        There are no default parameter values; all four energy arrays must be provided. In GPAW and related DFT workflows, these weights determine how quantities (for example spectral weight or occupancy contributions) are apportioned among tetrahedron vertices when performing integrals over the Brillouin zone or computing densities of states.
    
    Failure modes and numerical issues:
        If any denominator (e4 - e1), (e4 - e2) or (e4 - e3) is zero or numerically extremely small, the computation will produce infinities or NaNs and may raise NumPy runtime warnings or errors due to division by zero. This occurs, for example, if e4 equals one of the other vertex energies; users must ensure the vertex energies are distinct enough for stable evaluation or handle singular cases separately. Mismatched input shapes that cannot be broadcast together will raise a NumPy broadcasting error.
    
    Returns:
        numpy.ndarray: An array of interpolation weights with the first axis of length 4 corresponding to [w1, w2, w3, w4] computed elementwise. For typical 1D input arrays of length N (Array1D), the return has shape (4, N) where row 0 contains w1 for each sample, row 1 contains w2, row 2 contains w3, and row 3 contains w4. If the inputs are scalar or broadcast to scalars, a 1D array of length 4 is returned. These weights are the values defined by Eqs. (B14)–(B17) in Blöchl, Jepsen and Andersen and are intended for use in GPAW's tetrahedron integration routines.
    """
    from gpaw.tetrahedron import bja3b
    return bja3b(e1, e2, e3, e4)


################################################################################
# Source: gpaw.unfold.find_K_from_k
# File: gpaw/unfold.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_unfold_find_K_from_k(k: numpy.ndarray, M: numpy.ndarray):
    """Gets a k vector in scaled (fractional) coordinates and returns a mapped K vector and the unfolding integer vector G, both in scaled coordinates. This function is used in GPAW's band-structure unfolding routines to map k-points between cells (for example between a primitive cell and a supercell) and to record which reciprocal-lattice integer vector was added or subtracted during the mapping.
    
    Args:
        k (numpy.ndarray): A length-3 array giving a k-point in scaled (fractional) coordinates. In the GPAW unfolding context, each component of k is the coordinate along a reciprocal-lattice basis (i.e., a fractional reciprocal coordinate). The function expects k to have three components because it computes KG = M.dot(k) and then processes the three components individually. Supplying an array with a different shape will cause numpy.dot or the subsequent indexing/loops to raise an error.
        M (numpy.ndarray): A 3x3 numeric matrix used to transform the input k into the target scaled coordinate system (KG = M.dot(k)). In unfolding workflows this matrix typically represents the integer transformation between reciprocal-lattice bases (for example, the mapping from primitive to supercell reciprocal coordinates). M must be numeric and conformable with k for matrix multiplication (normally shape (3, 3)); incorrect shapes or non-numeric entries will lead to numpy errors.
    
    Behavior and details:
        The function computes KG = M.dot(k). It then examines each of the three components KG[i] and, using small numerical thresholds (0.5000001 and -0.4999999), determines whether an integer reciprocal-lattice vector should be recorded in the unfolding vector G and removed from KG. If KG[i] > 0.5000001, the function treats KG[i] as offset by an integer amount: it sets G[i] to int(round(KG[i])) and subtracts that integer from KG[i]. If KG[i] < -0.4999999, it sets G[i] to int(round(KG[i])) and adds abs(round(KG[i])) to KG[i]. The thresholds are chosen to avoid changing components that are exactly or very close to +/-0.5 due to floating-point round-off. After this adjustment KG contains the mapped K vector components reduced by integer amounts so that they lie within the principal region defined by the implemented tolerances (approximately centered near zero), and G contains the corresponding integer shifts that were applied.
        The function does not modify its inputs k or M; it constructs and returns new arrays. It uses numpy.dot for the linear transformation and numpy.round for computing integer shifts.
    
    Failure modes and numeric considerations:
        If k does not have three components or if M is not conformable for the dot product (for example not 3x3), numpy.dot will raise a broadcasting or shape-related error. If k or M contain non-numeric types, numpy operations will raise a TypeError. The numeric thresholds (0.5000001 and -0.4999999) mean that components extremely close to +/-0.5 may or may not be treated as requiring an integer shift depending on floating-point representation; callers should be aware of this tolerance when preparing k and M and when interpreting boundary cases.
    
    Returns:
        (numpy.ndarray, numpy.ndarray): A tuple (KG, G) where KG is a length-3 numpy.ndarray of floats representing the mapped K vector in scaled coordinates after removal of integer reciprocal-lattice components, and G is a length-3 numpy.ndarray of integers (dtype int) giving the integer unfolding vector in scaled coordinates. In GPAW unfolding workflows, KG is the K-point inside the chosen principal cell and G identifies which reciprocal-lattice integer vector was subtracted or added to map the original k into KG.
    """
    from gpaw.unfold import find_K_from_k
    return find_K_from_k(k, M)


################################################################################
# Source: gpaw.tetrahedron.weights
# File: gpaw/tetrahedron.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_tetrahedron_weights(
    eig_in: numpy.ndarray,
    i_ktq: numpy.ndarray,
    improved: bool = False
):
    """Calculate occupation numbers using the tetrahedron integration scheme used in GPAW for Brillouin-zone integration and density-functional theory (DFT) calculations.
    
    Args:
        eig_in (numpy.ndarray): 2-D array of single-particle eigenvalues (energies) used to determine occupations. The first axis indexes the electronic state positions that are referenced by the tetrahedron mapping in i_ktq (typically combined k-point / spin indices), and the second axis indexes band indices. This function treats eigenvalues less than 0.0 as occupied when counting fully occupied bands per k-point. The practical role of eig_in in the GPAW tetrahedron method is to provide the band-energy spectrum from which partial occupancies are computed for use in charge-density and total-energy calculations.
        i_ktq (numpy.ndarray): 3-D integer array that maps tetrahedra to the indices of eig_in. The expected layout (as used by this routine) is (N_k, 6, 4), where N_k is the number of k-point-like entries and the second dimension enumerates the six tetrahedra associated with each k-like index and the last dimension lists the four vertices (indices into the first axis of eig_in) of each tetrahedron. This mapping is used to gather eigenvalues at tetrahedron vertices, compute tetrahedron-specific weight distributions, and then scatter the resulting fractional occupations back to the corresponding rows of the output occupancy array. If i_ktq has incompatible shape or contains out-of-range indices, the function will raise standard indexing errors.
        improved (bool = False): If False (the default), use the standard tetrahedron weight formulas to compute fractional occupations for bands that are partially occupied across tetrahedra. If True, apply the additional improved correction terms computed by the auxiliary routines (used in GPAW to reduce integration error) that depend on derivatives of the weight functions; this adjusts the tetrahedron weights with higher-order contributions. The boolean controls whether those extra correction contributions are included in the returned occupation numbers.
    
    Behavior and practical details:
        The routine first determines, for each row indexed by the first axis of eig_in, how many bands are strictly negative (eig_in < 0.0). These counts are used to define n1 (the minimum number of fully occupied bands over all k-like indices) and n2 (the maximum number). All bands with index < n1 are treated as fully occupied: internally they are assigned an integer total weight of 6 for each corresponding state and later scaled by 1/6 so they become occupancy 1.0 in the returned array. If n1 == n2 (no partially occupied bands across the dataset), the function returns immediately after assigning the fully occupied bands, producing an array identical in shape to eig_in where occupied states have value 1.0 and others 0.0 (subject to the scaling described below).
        For the band indices in the range [n1, n2) (the potentially partially occupied bands), the function collects eigenvalues at tetrahedron vertices using i_ktq, sorts them within each tetrahedron, and computes tetrahedron weights according to the standard tetrahedron formulas. These computed weights are accumulated into the corresponding entries of the output occupancy array by scattering back to the indices given in i_ktq. If improved is True, additional correction terms (computed by auxiliary weight-derivative routines used elsewhere in GPAW) are added to the tetrahedron weights before scattering.
        After assembling contributions from all tetrahedra, the function multiplies the accumulated integer-scaled weights by 1/6 to produce the final occupation numbers. The returned array is therefore of the same shape as eig_in and contains floating-point occupancy values (physically interpreted as occupations used in density and energy calculations).
    
    Returns:
        numpy.ndarray: A 2-D array with the same shape as eig_in containing occupation numbers for each state/band. Fully occupied bands (as determined by eig_in < 0.0 and the per-row minimum n1) will be 1.0 after the final scaling; partially occupied bands receive fractional values computed from the tetrahedron weights (and optional improved corrections). The function does not modify eig_in or i_ktq in-place; it returns a newly allocated array.
    
    Failure modes and side effects:
        The function is pure in the sense that it has no external side effects beyond allocating and returning the occupancy array. It will raise standard Python/NumPy exceptions for invalid inputs: IndexError or ValueError if i_ktq contains indices outside the valid range for eig_in or has an unexpected shape, and NameError or AttributeError if required internal auxiliary weight routines are absent or misbound in the module. Numerical results assume the conventional GPAW sign convention where eigenvalues < 0.0 are treated as occupied; incorrect conventions or pre-shifted eigenvalues will lead to incorrect occupation assignments. Default behavior corresponds to improved=False.
    """
    from gpaw.tetrahedron import weights
    return weights(eig_in, i_ktq, improved)


################################################################################
# Source: gpaw.unfold.make_colormap
# File: gpaw/unfold.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_unfold_make_colormap(main_color: str):
    """Create a matplotlib LinearSegmentedColormap tailored for GPAW unfolding plots.
    
    This function constructs a custom colormap named 'mymap' that is used by gpaw.unfold plotting utilities such as plot_spectral and plot_band_structure. The colormap maps normalized scalar values in the range [0.0, 1.0] to RGBA colors by defining per-channel control points (position, left-value, right-value) at normalized positions 0.0, 0.25, 0.5 and 1.0. The selected main_color selects which RGB channel is emphasized and determines the per-channel control-point dictionary (cdict). The 'green' variant additionally defines an 'alpha' channel to introduce a varying transparency across the colormap. This function performs an import from matplotlib.colors and returns a LinearSegmentedColormap instance suitable for use with matplotlib plotting routines that visualize electronic densities, spectral functions, or band weights produced by GPAW.
    
    Args:
        main_color (str): The primary color to emphasize in the generated colormap. Accepted literal values are 'blue', 'red', and 'green' as implemented in the source code. Each value selects a distinct color dictionary (cdict) that explicitly sets control points for the 'red', 'green', and 'blue' channels; the 'green' choice also adds an 'alpha' channel to control transparency. The control points are specified at normalized positions 0.0, 0.25, 0.5 and 1.0 and follow matplotlib's LinearSegmentedColormap convention (position, left-value, right-value). This parameter is required; there is no default. If a value other than the documented literals is provided (or if main_color is not a string), the function will not define cdict and will fail when attempting to construct the colormap.
    
    Returns:
        LinearSegmentedColormap: A matplotlib.colors.LinearSegmentedColormap instance named 'mymap' constructed from the selected cdict. The returned object maps normalized scalar inputs (0.0 to 1.0) to RGBA colors according to the per-channel control points and is intended to be passed to matplotlib plotting functions used in GPAW's spectral and band-structure visualizations.
    
    Raises and failure modes:
        ImportError: If matplotlib is not available, the import of LinearSegmentedColormap will raise ImportError.
        UnboundLocalError: If main_color is not one of the implemented literals ('blue', 'red', 'green'), the local variable cdict will remain undefined and attempting to construct the LinearSegmentedColormap will raise UnboundLocalError.
        Other matplotlib errors: If matplotlib rejects the provided color dictionary for any reason, the underlying matplotlib call may raise its own exceptions.
    
    Side effects and notes:
        The function does not mutate global state; it only imports from matplotlib and returns a new LinearSegmentedColormap object. The colormap is named 'mymap' inside matplotlib and can be reused or registered with matplotlib if desired by the caller. The colormap control points and the presence of an alpha channel for the 'green' option are chosen to produce visually distinct palettes for use in GPAW plotting routines.
    """
    from gpaw.unfold import make_colormap
    return make_colormap(main_color)


################################################################################
# Source: gpaw.upf.parse_upf
# File: gpaw/upf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_upf_parse_upf(fname: str):
    """Parse UPF pseudopotential file and return a dictionary of parsed pseudopotential data used by GPAW for PAW/DFT calculations.
    
    This function reads a UPF (Unified Pseudopotential Format) file from the path given by fname and produces a structured dictionary containing header metadata, radial meshes, local and non-local potentials, projector data, pseudo-wavefunctions, and atomic reference density. GPAW uses these parsed fields when constructing pseudopotentials and projector-augmented-wave components for plane-wave, real-space, or atom-centered-basis calculations. The parser accepts both (mostly) XML-like UPF files and the older non-well-formed FORTRAN-style variants: when the root XML parsing fails the file is wrapped in a synthetic <xml>…</xml> root and reparsed. The parser also recognizes files marked version "2.0.1" (v201) and applies version-specific conversions and type coercions.
    
    Args:
        fname (str): Filesystem path to the UPF pseudopotential file to parse. This is the same filename that will be recorded in the returned dictionary under the 'fname' key. The function attempts to parse the file as XML using xmlparse(fname); if that raises a ParseError the function will open fname and reparse its contents after surrounding them with a synthetic root tag. File I/O errors (e.g. FileNotFoundError, OSError) from opening the file will propagate. The value must be a path string; the function does not accept file-like objects.
    
    Detailed behavior and side effects:
    - The function first tries xmlparse(fname).getroot() to obtain an XML root. If xmlparse raises ParseError the function reads the raw file contents with open(fname).read() and reparses them using fromstring after wrapping them with '<xml>' and '</xml>'. This fallback is necessary because many UPF files are not well-formed XML but contain XML-like tags mixed with free-format FORTRAN output.
    - A boolean flag v201 is set when the parsed root element has attribute version == '2.0.1'. When v201 is True the parser expects specific attributes on elements and converts header values (strings 'T'/'F' → booleans, numeric strings → int/float). When v201 is False the parser follows the older, non-XML header layout and extracts values from free-format header lines.
    - The helper toarray(element) converts an XML element containing whitespace-separated numeric text into a NumPy ndarray of dtype float. It asserts that the element attribute 'type' equals 'real' and that the 'size' attribute matches the number of numeric entries. If the element has a 'cutoff_radius_index' attribute, the returned array is truncated at that index. The function documents and enforces these checks with assertions; assertion failures raise AssertionError.
    - Local and non-local potentials that are originally in Rydberg units in many UPF files are converted to Hartree by multiplying by 0.5 where the code contains 0.5 * toarray(...). Specifically, 'vlocal' and the DIJ non-local matrix (when present) are converted this way.
    - The parser constructs projector and pseudo-wavefunction entries as UPFStateSpec instances (as created in this module). For v201 files, projector elements named PP_BETA.* or PP_BETA are parsed using element attributes (index, label, angular_momentum) and their numeric arrays. For older formats projectors are parsed from whitespace-tokenized lines and assembled into UPFStateSpec similarly. The returned UPFStateSpec objects encode index, label, angular momentum (l), radial values (numpy array), and when available occupation and principal quantum number 'n'. The presence and exact fields of UPFStateSpec instances reflect the contents of the UPF file and the format version.
    - For the non-local coupling matrix (DIJ) the parser either reads a PP_DIJ element (v201) and converts it to Hartree, or for the old format builds a symmetric D_ij matrix from explicit triplets in the file and converts it to Hartree.
    - The function uses multiple assertions and casts (int(), float()) to validate that token counts and declared sizes match actual data. If the file does not conform to expected token counts or attribute values these assertions or conversions will raise AssertionError or ValueError.
    - No global state is modified by this function aside from reading the file; the only file I/O performed is reading fname (and only once in the normal XML parse path or twice if xmlparse fails). The function does not write to disk.
    
    Returns:
        dict: A dictionary containing the parsed UPF pseudopotential data. The dictionary always contains at least:
            'fname' (str): The input filename passed to the function.
            'info' (str): Raw textual content of the PP_INFO element from the UPF file; typically human-readable comments or provenance information.
            'header' (dict): Header metadata parsed from PP_HEADER. For version '2.0.1' many header entries are coerced to Python booleans (e.g. 'is_paw', 'has_so'), ints (e.g. 'l_max', 'mesh_size', 'number_of_proj'), or floats (e.g. 'z_valence', 'total_psenergy', 'wfc_cutoff', 'rho_cutoff') as appropriate. For older formats header fields are extracted from free-format header lines and include keys such as 'element', 'z_valence', 'total_psenergy', 'l_max', 'mesh_size', 'number_of_wfc', and 'number_of_proj'.
            'r' (numpy.ndarray): Radial mesh array parsed from PP_R (converted by toarray). This is a 1D float ndarray representing the radial grid points used for tabulated quantities.
            'rab' (numpy.ndarray): Auxiliary radial array parsed from PP_RAB (converted by toarray).
            'vlocal' (numpy.ndarray): Local pseudopotential values sampled on the radial mesh; returned as a NumPy float array and converted to Hartree by multiplying by 0.5 (source values are typically in Rydberg).
            'projectors' (list): List of UPFStateSpec instances representing projector functions (PP_BETA entries). Each UPFStateSpec contains index, label, angular momentum, and a NumPy array of radial values (and may include additional attributes when available).
            'DIJ' (numpy.ndarray): Non-local coupling matrix (D_ij) as a NumPy 2D float array in Hartree units when present. For older formats this is assembled from explicit index-value triplets; for v201 it is read from a PP_DIJ element.
            'states' (list): List of UPFStateSpec instances representing pseudo-wavefunctions (PP_PSWFC entries). For v201 entries include index, label, l, radial values, occupation, and n where provided; for older formats occupation may be parsed from line headers.
            'rhoatom' (numpy.ndarray): Atomic reference density sampled on the radial mesh (parsed from PP_RHOATOM via toarray).
        The exact set of keys and the presence of particular numeric arrays depend on the UPF file version and contents. Consumers in GPAW should expect NumPy arrays and UPFStateSpec objects and handle KeyError if optional blocks are missing.
    
    Failure modes and exceptions:
    - FileNotFoundError or OSError if fname cannot be opened for reading.
    - ParseError from xmlparse may be raised in the initial attempt, but the function catches it and retries with a wrapped string; a subsequent XML parsing error from fromstring will propagate as an exception.
    - AssertionError if expected attributes, sizes, or token counts do not match the file contents (e.g. 'type' attribute not 'real', declared size mismatch, projector index mismatches).
    - ValueError when converting tokens to float or int if numeric tokens are malformed.
    - Other exceptions from xml parsing libraries or NumPy may propagate.
    
    Usage note:
    This parser is intended for use within GPAW to load UPF pseudopotential data produced by various pseudopotential generators (including older non-XML emitters). The returned dictionary is consumed by GPAW routines that construct PAW projectors, non-local operators, and reference atomic densities for DFT calculations.
    """
    from gpaw.upf import parse_upf
    return parse_upf(fname)


################################################################################
# Source: gpaw.unfold.plot_spectral_function
# File: gpaw/unfold.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_unfold_plot_spectral_function(
    filename: str,
    color: str = "blue",
    eref: float = None,
    emin: float = None,
    emax: float = None,
    scale: float = 1
):
    """Plot the spectral function corresponding to a band-structure k-point path and display/save it as a PNG image.
    
    This function is used in the GPAW unfolding context to visualize the spectral function A(k, E) along a path of k-points (the same quantity used to interpret band-structure and many-body spectral features in density-functional-theory (DFT) workflows). It reads precomputed data from a pickle file produced by the unfolding routines, normalizes and (optionally) shifts the energy axis, converts the spectral function to an image using a colormap, draws k-point tick marks and special-point labels, saves the image to disk, and opens a matplotlib window showing the result. The spectral intensity is normalized to its maximum and then multiplied by the provided scale factor so intensities are shown between 0 and 1 (colormap vmin/vmax = 0/1).
    
    Args:
        filename (str): Base filename (without extension) of the pickle file containing saved spectral-function data. The function will open filename + '.pckl' and expects a pickled tuple (e, A_ke, x, X, points_name) where:
            e is a 1D numpy array of energies (eV) along which the spectral function is defined; A_ke is a 2D numpy array representing the spectral function values (k × E or E × k as produced by the unfolding routines) that will be transposed and reshaped for plotting; x is a 1D array giving the horizontal coordinate (cumulative k-path distance) used for the imshow extent; X is a sequence of coordinates for special k-point vertical markers; points_name is a sequence of labels for those special k-points. This file is produced by the GPAW unfolding calculations and is required for plotting; if the file cannot be opened an error message is printed and the function exits with SystemExit.
        color (str): Colormap base color name passed to the local make_colormap routine to construct the colormap used for the image. The default 'blue' produces a blue-based colormap. This parameter controls the visual appearance of spectral intensity (practical significance: helps distinguish states visually when inspecting band structure or many-body features).
        eref (float): Reference energy (in the same units as e, e.g., eV) to subtract from the energy axis before plotting. If provided, e <- e - eref. This is typically used to set a reference such as the Fermi level (e.g., eref = e_fermi) so that energies are plotted relative to that reference. If None (default), no shift is applied.
        emin (float): Minimum energy bound for the vertical plot axis (eV). If None (default), emin is set to the minimum value of the (possibly shifted) energy array e. Use this to focus the plotted energy window manually; if set outside the data range the axis will reflect the provided value but the image extent is determined from the loaded e array.
        emax (float): Maximum energy bound for the vertical plot axis (eV). If None (default), emax is set to the maximum value of the (possibly shifted) energy array e. Use this to limit the plotted energy window manually; similar notes as for emin apply.
        scale (float): Multiplicative scale factor applied to the normalized spectral function after transposition (default 1). Internally the spectral data A_ke is normalized by dividing by its maximum value (A_ke /= numpy.max(A_ke)), then transposed and multiplied by scale (A_ek = A_ke.T * scale). Use scale to amplify or attenuate the displayed intensities relative to the normalized maximum.
    
    Returns:
        None: This function does not return a Python value. Side effects include reading the file filename + '.pckl', printing status messages to stdout, saving a PNG image to filename + '_spec.png', and displaying a matplotlib figure window via plt.show(). The saved image contains the plotted spectral-function intensity with k-point vertical markers and labeled special points.
    
    Behavior, defaults, and failure modes:
        - File input: The function opens filename + '.pckl' using pickle.load and expects the exact tuple structure described above. If the file cannot be opened (OSError), the function prints "You Need to Calculate the SF first!" and exits by raising SystemExit. If the pickle contents do not match the expected arrays/sequence, downstream operations (array arithmetic, indexing, reshape) may raise standard Python or NumPy exceptions (e.g., IndexError, ValueError, TypeError).
        - Energy shifting: If eref is provided it is subtracted from the loaded energy array e before computing emin/emax defaults.
        - Axis bounds: If emin or emax are provided they override automatic selection; if left as None they default to the min/max of e after any eref shift.
        - Normalization and scaling: The spectral function A_ke is normalized by its maximum value using numpy.max(A_ke). If numpy.max(A_ke) == 0 this will lead to division by zero and NumPy may raise a RuntimeWarning or produce NaNs/Infs; callers should ensure the saved spectral data contains nonzero values or handle warnings.
        - Colormap: make_colormap(color) is invoked; invalid color names or an unavailable make_colormap implementation may raise an exception. The function assumes make_colormap and matplotlib.pyplot are available in the module namespace.
        - Plotting and output: The function creates a matplotlib figure, draws a dashed horizontal zero-energy line, vertical k-point marker lines at positions X[1:-1], sets tick labels to points_name, and uses plt.imshow with extent determined by [0, x[-1], e.min(), e.max()] and vmin=0, vmax=1. The plotted image is translated vertically by +0.23 before colormap mapping (consistent with the original plotting routine). The resulting figure is saved to filename + '_spec.png' and then displayed; in non-interactive environments plt.show() may block or require a non-interactive backend to produce the saved file.
        - Dependencies and environment: This plotting function depends on NumPy, matplotlib, pickle, and the local make_colormap routine. It is intended for post-processing/visualization of spectral-function data generated by GPAW unfolding tools and assumes the data format and units produced by those tools.
    """
    from gpaw.unfold import plot_spectral_function
    return plot_spectral_function(filename, color, eref, emin, emax, scale)


################################################################################
# Source: gpaw.utilities.divrl
# File: gpaw/utilities/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_divrl(a_g: numpy.ndarray, l: int, r_g: numpy.ndarray):
    """gpaw.utilities.divrl: divide a radial-array by r**l with safe extrapolation to the origin.
    
    This utility is used in GPAW (a DFT code based on the PAW method and real-space/ radial grids) to convert a radial quantity that scales as r**l into a regular function at the origin by dividing by r**l on the nonzero radial grid points and estimating the value at the origin by a small-r extrapolation. In practical GPAW workflows this is useful for processing radial parts of partial waves, projector functions, augmentation quantities or any spherical-harmonic component that behaves like r**l times a smooth function near r = 0.
    
    Args:
        a_g (numpy.ndarray): Array of radial values sampled on the radial grid r_g. This array is treated as the numerator to be divided by r**l on indices 1:; index 0 is treated as the origin and is not directly divided to avoid division-by-zero. The function returns a copy of this array with elementwise division applied (for l > 0) and with index 0 set by an extrapolation. The caller should provide a 1D numeric numpy.ndarray whose shape matches r_g; the dtype and shape are preserved in the returned array.
        l (int): Integer angular-momentum-like exponent. When l > 0 the routine divides a_g[1:] by r_g[1:]**l and computes a_g[0] by an extrapolation that assumes the resulting function b(r) = a(r)/r**l has the small-r expansion b(r) ≈ A + B r**2. When l <= 0 the function makes no division and simply returns a copy of a_g. This parameter controls the physical operation of removing the r**l factor from radial quantities in GPAW workflows.
        r_g (numpy.ndarray): Radial grid values corresponding to a_g. r_g[0] is interpreted as the origin (typically 0.0) and r_g[1:], r_g[2], ... are the positive grid points used for elementwise division and extrapolation. This must be a 1D numeric numpy.ndarray of the same length as a_g. The routine uses r_g[1:3] to compute the extrapolated value at the origin, so at least three grid points (len(r_g) >= 3) are required.
    
    Returns:
        numpy.ndarray: A new numpy.ndarray b_g with the same shape and dtype as a_g. If l > 0 then for all indices i >= 1 the returned array satisfies b_g[i] = a_g[i] / (r_g[i]**l), and b_g[0] is set to the extrapolated value
        (b_g[0] = (b_g[1] * r_g[2]**2 - b_g[2] * r_g[1]**2) / (r_g[2]**2 - r_g[1]**2))
        which is the A coefficient obtained by assuming b(r) ≈ A + B r**2 at small r. If l <= 0 the returned array is a copy of a_g with no further changes. The input arrays are not modified; all modifications occur in the returned copy.
    
    Notes, behavior and failure modes:
        - The function does not modify a_g or r_g in place; it returns a copy.
        - The code only performs the division for l > 0. For l == 0 or negative l values the function returns a direct copy of a_g.
        - To compute the extrapolated origin value the function reads r_g[1] and r_g[2] (and the corresponding a_g[1], a_g[2]). Therefore len(a_g) and len(r_g) must be at least 3 and equal; otherwise an IndexError will be raised.
        - If any entry of r_g[1:] is zero and l > 0, a division-by-zero will occur when computing a_g[1:] / r_g[1:]**l, which will raise or produce infinities depending on numpy settings.
        - If r_g[1] == r_g[2] then the extrapolation denominator (r_g[2]**2 - r_g[1]**2) becomes zero and a ZeroDivisionError or invalid floating-point result will occur.
        - The extrapolation assumes the regular small-r behavior b(r) ≈ A + B r**2 (typical for radial functions after dividing out r**l in spherical problems). If the true small-r behavior differs significantly from this ansatz, the extrapolated b_g[0] may be inaccurate.
        - This routine performs elementwise exponentiation and division using numpy semantics; numerical precision and floating-point exceptions follow numpy and platform rules.
    """
    from gpaw.utilities import divrl
    return divrl(a_g, l, r_g)


################################################################################
# Source: gpaw.unfold.plot_band_structure
# File: gpaw/unfold.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_unfold_plot_band_structure(
    e_mK: numpy.ndarray,
    P_mK: numpy.ndarray,
    x: numpy.ndarray,
    X: list,
    points_name: list,
    weights_mK: numpy.ndarray = None,
    color: str = "red",
    fit: bool = True,
    nfit: int = 200
):
    """Plot band structure using projection weights P_mK and show each band-state as a filled circle whose color and size encode projection weight information used in unfolding analyses in density-functional theory (DFT) calculations performed with GPAW.
    
    Args:
        e_mK (numpy.ndarray): Array of single-particle energies in electronvolts for all bands and k-points. From the source code usage, this is expected to be a 2-D array shaped (n_bands, n_kpoints) where each row corresponds to a band index m and each column to a k-point K along a path in reciprocal space. In the GPAW/ASE DFT context this array contains the band energies computed for a (possibly unfolded) band-structure calculation and is plotted on the vertical (energy) axis.
        P_mK (numpy.ndarray): Array of projection weights used to color the scatter points. This must have the same shape as e_mK (n_bands, n_kpoints). Values are interpreted between 0.0 and 1.0 by the plotting routine (vmin=0., vmax=1.) and are mapped to colors using a colormap created from the color argument. In unfolding workflows P_mK typically encodes how strongly each supercell band-state projects onto a chosen primitive-cell character.
        x (numpy.ndarray): 1-D array of positions along the k-path (cumulative k-point distance) to be used as the horizontal axis. Its length must equal n_kpoints (the number of columns in e_mK and P_mK). The function tiles this array for all bands to position every energy point horizontally.
        X (list): List of float positions along the same k-path used to draw vertical separators and to set xtick locations. Typical usage in band-structure plotting is to pass the cumulative distances of high-symmetry k-points; X[1:-1] are drawn as vertical guide lines. The list length must match the length of points_name for xtick labeling.
        points_name (list): List of strings (or values convertible to strings) giving tick labels for the positions in X. In practical GPAW plotting this is the list of high-symmetry k-point labels (for example ['G', 'X', 'M', 'G']), used to annotate the horizontal axis. The number of entries must equal len(X).
        weights_mK (numpy.ndarray, optional): Optional array of the same shape as e_mK and P_mK providing an additional scaling factor for marker sizes. If None (the default), the function uses a copy of P_mK for marker sizes. If provided, the array is multiplied in-place by P_mK (weights_mK *= P_mK.copy()), so the caller's array will be modified by this scaling operation. Marker sizes are computed as 20. * weights_mK and therefore scale linearly with these values. This argument allows separating a size-modulating weight from the color-mapping weight P_mK, e.g., when combining projection amplitudes with other per-state metrics.
        color (str): Name of the base color passed to make_colormap to create a matplotlib colormap used for mapping P_mK values to colors. The default is "red". The function delegates colormap construction to make_colormap(color) and then uses that colormap with vmin=0.0 and vmax=1.0 to visualize P_mK.
        fit (bool): Boolean flag included for API compatibility. In the current implementation this parameter is accepted but unused (default True). It suggests whether a smoothing/fit of band lines should be performed, but the function does not implement any fitting behavior; setting it has no effect.
        nfit (int): Integer included for API compatibility (default 200). In the current implementation this parameter is accepted but unused. It is commonly used in other plotting utilities to set the number of interpolation points for fitted/smoothed band lines; here it has no effect.
    
    Returns:
        None: This function does not return a Python object. Instead it has the side effect of creating a matplotlib figure, plotting the band energies and projection-weight-encoded scatter markers, drawing a dashed zero-energy reference line and vertical separators at internal high-symmetry positions, setting axis ticks/labels, and calling plt.show() to display the figure. It also prints the message "Plotting Bands Structure" to standard output when called. Note that if weights_mK is provided it is modified in-place by multiplication with P_mK.copy().
    
    Behavioral notes and failure modes:
        - The routine expects e_mK, P_mK and (if provided) weights_mK to be numpy.ndarrays with compatible shapes (n_bands, n_kpoints). x must be a 1-D numpy.ndarray of length n_kpoints. X and points_name must be lists of equal length. Mismatched shapes or lengths will raise numpy/IndexError/ValueError during tiling, reshaping, or xtick setting.
        - Color mapping is clipped to the range [0, 1] (vmin=0.0, vmax=1.0). If P_mK contains values outside this range the colormap will be saturated at the endpoints.
        - Marker sizes are computed as 20. * weights_mK; negative or NaN values in weights_mK may lead to invalid marker sizes or plotting errors from matplotlib.
        - The function requires matplotlib.pyplot to be importable; if matplotlib is unavailable an ImportError will be raised before plotting.
        - The fit and nfit arguments are present for API compatibility with other band-plot utilities but are currently ignored; no smoothing or line fitting is performed by this function.
    """
    from gpaw.unfold import plot_band_structure
    return plot_band_structure(
        e_mK,
        P_mK,
        x,
        X,
        points_name,
        weights_mK,
        color,
        fit,
        nfit
    )


################################################################################
# Source: gpaw.utilities.h2gpts
# File: gpaw/utilities/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_h2gpts(h: float, cell_cv: numpy.ndarray, idiv: int = 4):
    """Convert a desired real-space grid spacing into a number of grid points per cell direction used by GPAW.
    
    This utility function is part of gpaw.utilities and is used by GPAW (a DFT code using real-space uniform grids and multigrid methods) to convert a target real-space grid spacing (h) and a Cartesian unit cell (cell_cv) into an integer number of grid points along each of the three cell directions. The returned grid-point counts are rounded to the nearest multiple of idiv and are enforced to be at least idiv. This is important in GPAW for constructing real-space grids that match desired spatial resolution, for ensuring compatibility with multigrid coarsening/solver levels and with algorithms that require grid dimensions divisible by a small integer block size.
    
    Args:
        h (float): Desired real-space grid spacing in the same length units as cell_cv. This is the target distance between adjacent grid points in Cartesian space. h must be positive; if h is zero or negative the function will perform a division by h which leads to invalid or undefined results.
        cell_cv (numpy.ndarray): 3x3 array representing the unit cell in Cartesian coordinates (each column/row orientation follows the convention used in calling code). The function uses numpy.linalg.inv(cell_cv) to compute characteristic lengths and therefore requires a square, non-singular 3x3 array. If cell_cv is not invertible or does not have shape (3, 3), numpy.linalg.inv or subsequent array operations will raise a numpy.linalg.LinAlgError or a shape-related exception.
        idiv (int): Positive integer divisor (default 4) used to force the number of grid points in each direction to be a multiple of idiv. Typical choices (such as the default 4) are used in GPAW to ensure grid sizes compatible with multigrid levels and certain FFT/blocking requirements. idiv must be a positive integer; non-positive or non-integer values will produce incorrect results or runtime errors.
    
    Returns:
        numpy.ndarray: 1-D integer array of length 3. Each element gives the number of grid points along the corresponding cell direction computed as follows:
        1) Compute L_c = (numpy.linalg.inv(cell_cv)**2).sum(0)**-0.5 (as in the source): a vector of characteristic lengths derived from the inverted cell matrix used to estimate how many points are needed along each direction for spacing h.
        2) Compute the raw required counts L_c / h, scale by 1/idiv, round to the nearest integer by adding 0.5 and truncating to int, then multiply by idiv to obtain values divisible by idiv.
        3) Enforce a minimum of idiv using numpy.maximum.
        The returned dtype is an integer numpy array (result of .astype(int) in the implementation). These values are intended to be used directly as numbers of grid points in GPAW real-space grid setup.
    
    Behavior and failure modes:
        - Units: h and the coordinate units of cell_cv must match (for example both in Ångström). Mismatched units will yield incorrect grid densities.
        - Minimum and divisibility: The function guarantees each returned grid-point count is at least idiv and divisible by idiv.
        - No explicit validation: The implementation does not explicitly validate inputs beyond relying on numpy operations. If cell_cv is singular, numpy.linalg.inv will raise numpy.linalg.LinAlgError. If h is zero or negative or idiv is non-positive, the result is undefined and may raise exceptions or produce nonsensical integers.
        - Intended use: Use the returned array to set the number of real-space grid points per cell direction when creating GPAW real-space grids (e.g., for PW/real-space modes or multigrid setups).
    """
    from gpaw.utilities import h2gpts
    return h2gpts(h, cell_cv, idiv)


################################################################################
# Source: gpaw.utilities.method
# File: gpaw/utilities/__init__.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for pack_density because the docstring has no description for the argument 'A'
################################################################################

def gpaw_utilities_method(A: numpy.ndarray):
    """gpaw.utilities.method: Pack off-diagonal sum used by GPAW to compress Hermitian 2D arrays (for example density or overlap matrices) into a 1D vector by summing symmetric off-diagonal elements. This packing is used in GPAW (a density-functional theory code) to reduce storage and to prepare matrix data for communication, serialization, or algorithms that operate on the independent elements of a Hermitian matrix.
    
    This function expects a square, two-dimensional numpy array that represents a Hermitian matrix (real or complex). It transforms an n x n matrix A into a 1D numpy.ndarray of length n*(n+1)//2 by iterating over the upper triangular part (including diagonal) and, for off-diagonal elements, storing the sum a_ij + a_ji. For example, the 3x3 matrix
       / a00 a01 a02 \
       | a10 a11 a12 |
       \ a20 a21 a22 /
    is transformed to the vector
       (a00, a01 + a10, a02 + a20, a11, a12 + a21, a22)
    which corresponds to scanning rows i = 0..n-1 and for each i appending elements for j = i..n-1: a_ij + a_ji (with diagonal elements appearing unchanged).
    
    Args:
        A (numpy.ndarray): A 2-dimensional, square numpy array representing a Hermitian matrix used in GPAW DFT workflows (for example a density matrix). The function asserts A.ndim == 2, A.shape[0] == A.shape[1], and A.dtype in [float, complex]; if any of these conditions fail an AssertionError is raised. The dtype check follows the source code's exact check and therefore expects numpy dtypes that are recognized as matching Python float or complex in the current build.
    
    Returns:
        numpy.ndarray: A 1-dimensional numpy array containing the packed values. The length is n*(n+1)//2 for an input array of shape (n, n). The order is upper-triangular by increasing row index i and, for each i, columns j from i to n-1; off-diagonal entries are summed as a_ij + a_ji. No in-place modification of A is performed; the function delegates the actual packing to the underlying cgpaw.pack implementation and returns its result.
    
    Failure modes and side effects:
        The function raises AssertionError if A is not 2D, not square, or if A.dtype is not one of the checked types. Additional errors may be raised by the underlying cgpaw.pack call (e.g., if the C extension encounters internal errors). There are no other side effects beyond calling cgpaw.pack and returning its output.
    """
    from gpaw.utilities import method
    return method(A)


################################################################################
# Source: gpaw.utilities.uncamelcase
# File: gpaw/utilities/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_uncamelcase(name: str):
    """gpaw.utilities.uncamelcase converts a CamelCase identifier into a space-separated,
    human-readable string of words. This is used in the GPAW DFT codebase to turn
    programmatic names (for example class names, mode identifiers, or option keys)
    into labels suitable for log output, user-facing messages, simple GUIs, or
    documentation where readable words are preferred over concatenated identifiers.
    
    The function uses the regular expression pattern '([A-Z]{1}[a-z]+)' to split
    the input string into segments consisting of an uppercase letter followed by
    one or more lowercase letters; it then joins the non-empty segments with a
    single ASCII space. Because of this pattern, acronyms or runs of consecutive
    uppercase letters that are not followed by lowercase letters remain attached
    to adjacent segments (for example, "XMLParser" becomes "XML Parser" because
    "Parser" matches the pattern while "XML" does not). The function makes no
    modifications to digits, underscores, punctuation, or existing spaces beyond
    the splitting described here.
    
    Args:
        name (str): The input identifier in CamelCase form to be converted. This
            should be a Python str instance representing a programmatic name used
            in GPAW (for example a class or option name). The function expects
            exactly this type; passing a non-str value will raise a TypeError when
            the underlying re.split is invoked. An empty string is accepted and
            yields an empty string as output.
    
    Returns:
        str: A new string containing the input decomposed into space-separated
        words according to the regex '([A-Z]{1}[a-z]+)'. The return value is safe
        for use as a human-readable label in logs, text files, simple user
        interfaces, and documentation generated from programmatic names. There are
        no side effects.
    """
    from gpaw.utilities import uncamelcase
    return uncamelcase(name)


################################################################################
# Source: gpaw.utilities.element_from_packed
# File: gpaw/utilities/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_element_from_packed(M: numpy.ndarray, i: int, j: int):
    """gpaw.utilities.element_from_packed returns a single matrix element from a packed array created by the corresponding pack routine used in GPAW. It reconstructs the (i, j) entry of a square matrix stored in a compact 1D packed format that represents the diagonal and off-diagonal elements of symmetric or Hermitian matrices that commonly appear in density-functional theory (DFT) calculations (for example, overlap, density, or Hamiltonian matrices in GPAW).
    
    This function computes the matrix dimension n from the length of the packed array, looks up the packed index for the (i, j) pair using packed_index, and then returns the stored diagonal value or the appropriately scaled/conjugated off-diagonal value so that the returned value corresponds to the original full matrix element. It performs no in-place modifications of M.
    
    Args:
        M (numpy.ndarray): One-dimensional packed array produced by the pack routine. The array stores diagonal and off-diagonal entries in a compact order; its length determines the implied matrix dimension n via n = int(sqrt(2 * len(M) + 0.25)). Elements of M may be real or complex; the dtype of M determines the dtype of the returned element. This array must have been constructed with the same packing convention expected by this function.
        i (int): Row index of the requested matrix element in the full square matrix. Must satisfy 0 <= i < n where n is derived from len(M). This index is used together with j to compute the packed index; if i >= n an AssertionError is raised by the function.
        j (int): Column index of the requested matrix element in the full square matrix. Must satisfy 0 <= j < n where n is derived from len(M). If j >= n an AssertionError is raised by the function.
    
    Returns:
        numpy.number or numpy.scalar: The reconstructed matrix element at position (i, j) in the full square matrix. If i == j the stored diagonal value M[p] is returned unchanged. If i > j the function returns 0.5 * M[p]; if i < j it returns 0.5 * numpy.conjugate(M[p]). The returned scalar has the same numerical dtype as elements of M (real or complex) and represents the practical matrix element used in GPAW calculations.
    
    Notes:
        - The function asserts that i and j are both strictly less than the derived matrix dimension n and will raise AssertionError if that condition is not met.
        - If M was not produced by the compatible pack routine (i.e., its length or ordering does not match the expected packed format), the computed n will be incorrect and this function may raise IndexError or return meaningless values.
        - Negative indices are not explicitly handled by this function; using negative i or j may lead to unexpected behavior or IndexError from the packed_index lookup.
        - There are no side effects: M is not modified. This function is intended for reconstructing individual elements for further use in GPAW workflows (for example, assembling full matrices for diagnostics, I/O, or post-processing).
    """
    from gpaw.utilities import element_from_packed
    return element_from_packed(M, i, j)


################################################################################
# Source: gpaw.utilities.acwf.work
# File: gpaw/utilities/acwf.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for work because the docstring has no description for the argument 'structure'
################################################################################

def gpaw_utilities_acwf_work(
    structure: str,
    symbol: str,
    setup_name: str = "",
    mode: str = "pw"
):
    """Do single equation-of-state (EOS) calculations using the PBE exchange-correlation functional and write results to a JSON file.
    
    Args:
        structure (str): Identifier of the structure to be used for the EOS calculation. This string is forwarded verbatim to run_eos_calculation and is also used to construct the output filename "<mode>-<structure>.json" when the current MPI rank is 0. In practice this is typically a label or pathname that run_eos_calculation accepts to locate or describe the atomic geometry for a GPAW DFT calculation.
        symbol (str): Chemical symbol or species identifier (string) associated with the structure. When setup_name is provided, this symbol is used as the key in the GPAW setups mapping sent to run_eos_calculation (params['setups'] = {symbol: setup_name}). It identifies which atomic species the provided PAW setup name should replace for the calculation.
        setup_name (str): Name of a PAW setup (string) to override the default setup for the given symbol. If this parameter is the empty string (default), no explicit setups mapping is passed to run_eos_calculation and the calculation uses the default setup selection. If non-empty, the function adds params['setups'] = {symbol: setup_name} so run_eos_calculation uses the specified setup for the given species.
        mode (str): Calculation mode selector (string). If mode == 'pw' (the default) the function configures plane-wave mode with a cutoff energy of 1000 eV by setting params['mode'] = dict(name='pw', ecut=1000). For any other string value the function configures a localized-atomic-orbital calculation by setting params['mode'] = 'lcao', using a 'dzp' basis (params['basis'] = 'dzp') and a real-space grid spacing h = 0.12 (params['h'] = 0.12). The mode therefore determines whether the EOS calculation is run in GPAW plane-wave or LCAO mode.
    
    Additional behavior and defaults:
        The function builds a params dictionary for run_eos_calculation with fixed numerical defaults tuned for a single EOS run: exchange-correlation functional 'PBE' (params['xc'] = 'PBE'), electronic occupations set to Fermi-Dirac with width 0.0612 (params['occupations'] = dict(name='fermi-dirac', width=0.0612)), k-point sampling expressed as a density of 6.0 (params['kpts'] = dict(density=6.0)), and a self-consistency convergence criterion for the density of 1e-6 (params['convergence'] = dict(density=1e-6)). These defaults are applied regardless of mode, and the mode-specific settings shown above are added afterward.
        The function calls run_eos_calculation(structure, symbol, **params) to perform the EOS computation. The return value of run_eos_calculation is captured in the local variable data.
        If the MPI communicator object named world is present and world.rank == 0, the function serializes data to JSON (json.dumps with indent=1) and writes it to a file named "<mode>-<structure>.json" in the current working directory. This file-writing side effect occurs only on the rank-0 process to avoid multiple processes writing the same file in parallel.
    
    Failure modes and side effects:
        The function does not return the calculation data; it returns None and therefore its primary effects are to run the EOS calculation and (on rank 0) write the JSON file. Exceptions raised by run_eos_calculation (for example due to input errors, missing resources, or convergence failures) are propagated to the caller. JSON serialization will fail if the returned data contains objects that are not JSON-serializable; such serialization errors will raise an exception and prevent file writing. File creation can fail due to filesystem permissions, insufficient disk space, or other I/O errors, which will raise exceptions on the rank-0 process. In MPI runs, only the process for which world.rank == 0 attempts to write the output file; other ranks do not write the file.
    
    Returns:
        None: The function does not return the EOS result data to the caller. Instead, it invokes run_eos_calculation to perform the calculation and, when running on MPI rank 0, writes the returned data as JSON to the file "<mode>-<structure>.json".
    """
    from gpaw.utilities.acwf import work
    return work(structure, symbol, setup_name, mode)


################################################################################
# Source: gpaw.utilities.pack_hermitian
# File: gpaw/utilities/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_pack_hermitian(M2: numpy.ndarray, tolerance: float = 1e-10):
    """Pack Hermitian matrices into a compact 1D representation used in GPAW for
    storage and transport of Hermitian operators (for example density matrices,
    Hamiltonians, overlap matrices) where only the independent upper-triangle
    elements and diagonals are needed. This function is used in the GPAW code
    base to reduce memory and communication costs by converting an n x n Hermitian
    matrix into a packed vector of length n*(n+1)//2. When given a 3D array it
    applies the same packing to each 2D slice (useful for batches of matrices,
    e.g., k-point or spin channels).
    
    Args:
        M2 (numpy.ndarray): A square 2D NumPy array (n x n) representing a matrix
            that is expected to be Hermitian (M2[r, c] == conj(M2[c, r])) or a
            3D NumPy array (k x n x n) representing a stack of k such square
            matrices. The dtype of M2 determines the dtype of the returned array
            (for complex-valued operators use a complex dtype). Each 2D slice is
            packed by emitting elements in row-major triangular order: for r from
            0 to n-1 emit the diagonal element M2[r, r] followed by the averaged
            upper-triangle elements (M2[r, c] + conj(M2[c, r]))/2 for c > r.
            The function requires square matrices; passing a non-square array
            will raise an IndexError during indexing.
        tolerance (float): Absolute tolerance used to check Hermiticity. For each
            off-diagonal pair (r, c) the absolute difference
            abs(M2[r, c] - conj(M2[c, r])) is computed and must be strictly
            less than this tolerance, otherwise an AssertionError is raised.
            Default is 1e-10. This parameter controls how much numerical
            non-Hermiticity (for example from rounding or I/O) is tolerated before
            the packing fails.
    
    Returns:
        numpy.ndarray: If M2 is 2D (n x n) returns a 1D NumPy array of length
        n*(n+1)//2 containing the packed elements in the order:
        (M2[0,0],
         (M2[0,1] + conj(M2[1,0]))/2,
         (M2[0,2] + conj(M2[2,0]))/2,
         M2[1,1],
         (M2[1,2] + conj(M2[2,1]))/2,
         M2[2,2], ...)
        If M2 is 3D (k x n x n) returns a 2D NumPy array with shape
        (k, n*(n+1)//2) where each row is the packed representation of the
        corresponding 2D slice. The returned array preserves the numeric dtype of
        the input (e.g., complex128 for complex matrices). On success the packed
        values are exact averages of symmetric entries; on failure an AssertionError
        is raised as described above.
    
    Behavior, side effects, defaults, and failure modes:
        - Diagonal elements are copied directly; off-diagonal elements are stored
          as the arithmetic average of the upper-triangle element and the complex
          conjugate of the corresponding lower-triangle element: (M2[r,c] +
          conj(M2[c,r]))/2. This enforces Hermiticity in the packed representation
          when small numerical asymmetries are present.
        - The function checks Hermiticity by computing error = abs(M2[r,c] -
          conj(M2[c,r])) for each off-diagonal pair. If error >= tolerance an
          AssertionError is raised with a message indicating the observed error;
          this signals that the input matrix is not Hermitian within the requested
          tolerance and prevents silent corruption of Hermitian assumptions used
          elsewhere in GPAW.
        - If M2 has ndim == 3 the function maps this packing over the first axis,
          returning an array of packed rows. The shape and dtype of the result are
          determined by the inputs and NumPy semantics.
        - The default tolerance 1e-10 is chosen for typical double-precision
          numerical noise encountered in DFT calculations; adjust it only if you
          understand the numerical implications in your workflow.
        - Non-square inputs will lead to indexing errors; extremely large matrices
          will allocate an array of size n*(n+1)//2 which may be memory intensive.
    """
    from gpaw.utilities import pack_hermitian
    return pack_hermitian(M2, tolerance)


################################################################################
# Source: gpaw.utilities.packed_index
# File: gpaw/utilities/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_packed_index(i1: int, i2: int, ni: int):
    """gpaw.utilities.packed_index returns a single integer index corresponding to a pair of matrix indices (i1, i2) when a symmetric ni x ni matrix is stored in packed one-dimensional form. This function is used within GPAW (a density-functional theory code) to reduce memory and improve cache locality by storing only the triangular part of symmetric or Hermitian matrices (for example, overlap, density or Hamiltonian blocks) in a linear array. The mapping is symmetric: the pair (i1, i2) and (i2, i1) produce the same packed index so that a single stored value represents both symmetric matrix elements.
    
    Args:
        i1 (int): First matrix index (row index). This is the integer position along the first matrix axis and, in the expected use within GPAW, should be in the range 0..ni-1. The function does not perform bounds checking; passing indices outside the expected range may produce a result that is not meaningful for packed storage.
        i2 (int): Second matrix index (column index). This is the integer position along the second matrix axis and, in the expected use within GPAW, should be in the range 0..ni-1. The ordering of i1 and i2 does not affect the returned packed index: packed_index(i1, i2, ni) == packed_index(i2, i1, ni).
        ni (int): Size of the square matrix (number of rows and columns). This determines the total number of elements in the full matrix (ni*ni) and the number of stored packed elements (ni*(ni+1)//2 for triangular storage). ni is used in the arithmetic formula that maps a sorted pair of indices to a unique linear offset. The function does not validate ni; negative or zero values are permitted by the code but will not produce a meaningful packed index for matrix storage.
    
    Returns:
        int: The packed one-dimensional index corresponding to the unordered pair (i1, i2). For valid inputs with 0 <= i1, i2 < ni the returned value lies in the range 0..(ni*(ni+1)//2 - 1) and identifies the location in a contiguous array holding the upper (or equivalently lower) triangular elements of the symmetric matrix. The operation is pure (no side effects) and computed in constant time using integer arithmetic. Note that the function performs no bounds or type checking; callers are responsible for ensuring that the inputs are integers and that ni matches the matrix dimension used for packing.
    """
    from gpaw.utilities import packed_index
    return packed_index(i1, i2, ni)


################################################################################
# Source: gpaw.utilities.acwf.reference_structure
# File: gpaw/utilities/acwf.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for reference_structure because the docstring has no description for the argument 'symbol'
################################################################################

def gpaw_utilities_acwf_reference_structure(symbol: str, name: str):
    """Create and return an ASE Atoms object for a specified ACWF structure scaled to the WIEN2K reference volume.
    
    This function gpaw.utilities.acwf.reference_structure selects an ACWF structure template from the module-level acwf_structures mapping using the provided name, makes a copy of that template to avoid mutating the global template, and scales the unit cell and atomic positions so that the resulting cell volume matches the WIEN2K reference volume for the given chemical element symbol as stored in the module-level volumes mapping. For two oxygen-containing ACWF names ('X4O10' and 'XO') a cube-root-of-two correction is applied to the linear scaling factor to account for a difference in formula-unit convention in the stored WIEN2K volumes. After scaling, any placeholder atomic numbers equal to 0 in the structure template are replaced with the atomic number for the provided element symbol using the module-level atomic_numbers mapping. The returned Atoms object is suitable for use in GPAW DFT calculations and ASE-based workflows where a standardized reference lattice (WIEN2K volume) is required.
    
    Args:
        symbol (str): Chemical element symbol used to select the WIEN2K reference volume and the atomic number. The function looks up volumes[symbol][name] to obtain the target volume for the combination of element and ACWF structure. This parameter determines which element-specific volume is applied and which atomic number replaces any zeros in the template. Passing a symbol not present in the module-level volumes or atomic_numbers mappings will raise a KeyError.
        name (str): Key identifying which ACWF structure template to use from the module-level acwf_structures mapping. The function uses acwf_structures[name].copy() to obtain a working ASE Atoms template. The name selects which structural prototype (for example, 'X4O10' or 'XO') will be scaled to the WIEN2K volume. Passing a name not present in acwf_structures or not present under volumes[symbol] will raise a KeyError.
    
    Returns:
        Atoms: An ASE Atoms instance created by copying the selected acwf_structures[name] template, with its cell and atomic positions scaled so that the cell volume equals volumes[symbol][name]. The returned Atoms object has had any atomic numbers equal to 0 in the template replaced by atomic_numbers[symbol]. Side effects: none on the module-level templates because a copy is used; the function does not write files or modify global state beyond relying on the module-level mappings acwf_structures, volumes, and atomic_numbers. Failure modes: KeyError if symbol or name keys are missing in the required mappings; ZeroDivisionError if the template's initial volume (atoms.get_volume()) is zero; AttributeError or TypeError if the template does not provide ASE Atoms methods (get_volume, set_cell) expected by this function.
    """
    from gpaw.utilities.acwf import reference_structure
    return reference_structure(symbol, name)


################################################################################
# Source: gpaw.utilities.unpack_hermitian
# File: gpaw/utilities/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_unpack_hermitian(M: numpy.ndarray):
    """gpaw.utilities.unpack_hermitian unpacks a 1D packed representation of a Hermitian matrix (produced by the companion pack_hermitian routine) into a full 2D numpy.ndarray. This routine is used in GPAW to reconstruct full Hermitian matrices that are compressed for storage or communication (for example, when storing triangular matrix elements such as overlap, density, or Hamiltonian blocks in DFT workflows). The function accepts either a single packed 1D array or a 2D array whose rows are independent packed arrays and returns the corresponding full Hermitian matrix or a stack of matrices.
    
    Args:
        M (numpy.ndarray): Input array holding packed Hermitian data. If M.ndim == 1, M is interpreted as a single packed representation of a Hermitian matrix and must be contiguous in memory (is_contiguous(M) must be True). The length of M must be consistent with a triangular packing: there must exist an integer n such that len(M) == n*(n+1)/2; the code computes n as int(sqrt(0.25 + 2.0 * len(M))). If M.ndim == 2, each row of M is treated as an independent packed 1D array and the function returns a stacked array of full matrices (one matrix per row). The function detects the scalar kind of M (real or complex) and dispatches to specialized unpack routines: for complex-valued arrays it calls cgpaw.unpack_complex to preserve complex entries; for real-valued arrays it calls cgpaw.unpack.
    
    Returns:
        numpy.ndarray: The unpacked full Hermitian matrix or a stack of full Hermitian matrices. For a 1D input M the return has shape (n, n) where n is the matrix dimension computed from len(M) and the returned array uses the same scalar kind/character code as the input dtype. For a 2D input M with shape (m, L) the return has shape (m, n, n) where each of the m rows is unpacked to an (n, n) Hermitian matrix.
    
    Behavior and side effects:
        The function requires contiguous input memory for 1D packed arrays and asserts this with is_contiguous(M); a non-contiguous 1D input will cause an AssertionError. If the length of a 1D packed array is not consistent with any integer n via the triangular-packing formula, the computed n will be incorrect and unpacking may produce incorrect results or raise an error from the underlying C unpack routine. The function performs no in-place modification of the input M; it allocates and returns a newly created numpy.ndarray (or an array of such matrices when M.ndim == 2). The actual element placement and conjugation to form a Hermitian matrix is performed by the underlying cgpaw.unpack or cgpaw.unpack_complex routines called by this function.
    
    Failure modes:
        AssertionError is raised if a 1D input is not contiguous or if the ndim assumptions are violated. If len(M) does not match a valid triangular packing length, behavior is undefined: the function may return an incorrectly sized matrix or underlying C code may raise an error. The function does not validate detailed dtype compatibility beyond choosing the complex unpack path when M.dtype == complex; callers should ensure the input dtype matches expected numeric types used elsewhere in GPAW.
    """
    from gpaw.utilities import unpack_hermitian
    return unpack_hermitian(M)


################################################################################
# Source: gpaw.utilities.unpack_density
# File: gpaw/utilities/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_unpack_density(M: numpy.ndarray):
    """Unpack a packed density representation into a full 2D Hermitian density matrix.
    
    This function is used in GPAW to reconstruct density matrices (Hermitian arrays used in density-functional theory calculations) from a compact packed representation produced by the corresponding pack_density routine. The packed representation is typically used for compact storage or communication of the independent elements of a Hermitian density matrix. unpack_density reverses that packing by first calling unpack_hermitian on the packed data and then applying a fixed rescaling: all matrix elements are multiplied by 0.5 and the diagonal elements are multiplied by 2 to restore the original diagonal magnitudes. For batch inputs (2D arrays), each row is treated as a separate packed vector and unpacked independently into a full Hermitian matrix; the result is a stacked array of unpacked matrices.
    
    Args:
        M (numpy.ndarray): Input packed density data. If M is a 1D numpy.ndarray it is interpreted as a single packed representation of a Hermitian density matrix produced by pack_density and the function returns a single 2D numpy.ndarray containing the unpacked Hermitian matrix. If M is a 2D numpy.ndarray it is interpreted as a collection of packed vectors (one per row); each row is unpacked and the function returns a numpy.ndarray stacking the resulting 2D Hermitian matrices along a new first axis. The function expects that the input follows the packing convention used by pack_density; passing arrays that do not follow that convention will produce incorrect results. The exact length/shape requirements of each packed vector are determined by unpack_hermitian and must match what pack_density produces.
    
    Returns:
        numpy.ndarray: The unpacked Hermitian density matrix or matrices. For a 1D input M, returns a 2D numpy.ndarray representing the full Hermitian matrix. For a 2D input M, returns a 3D numpy.ndarray with shape (M.shape[0], n, n) where each slice along the first axis is the unpacked n-by-n Hermitian matrix corresponding to the respective input row. The dtype of the returned array is determined by the input and by unpack_hermitian. The returned matrices are (within numerical precision) Hermitian (conjugate symmetric) and have had the diagonal entries restored to their original scale by the post-unpack rescaling applied in this function.
    
    Behavior and failure modes:
        This function performs no in-place modification of the input; it returns new numpy arrays. It relies on unpack_hermitian to expand the packed representation; any errors or shape mismatches raised by unpack_hermitian (for example, if a packed vector has an unexpected length) will propagate to the caller. The function is intended only for inputs packed with the GPAW pack_density convention; applying it to arbitrary arrays will not produce meaningful physical density matrices. Inputs with ndim other than 1 or 2 are not supported and will typically result in an error from unpack_hermitian or subsequent numpy operations.
    """
    from gpaw.utilities import unpack_density
    return unpack_density(M)


################################################################################
# Source: gpaw.utilities.unpacked_indices
# File: gpaw/utilities/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_unpacked_indices(p: int, ni: int):
    """gpaw.utilities.unpacked_indices returns the pair of 0-based matrix indices (i, j) that correspond to a linear packed index p into the upper triangle (including the diagonal) of an ni-by-ni square matrix. This function is used in GPAW to map a single packed index used for memory- and performance-efficient storage of symmetric matrices (for example, density or overlap matrices in DFT calculations) back to its two-dimensional coordinates in the full matrix. The packed ordering enumerates entries row by row for the upper triangle: (0,0), (0,1), ..., (0,ni-1), (1,1), (1,2), ..., (ni-1,ni-1).
    
    Args:
        p (int): Packed linear index into the upper triangle storage. Must satisfy 0 <= p < ni*(ni + 1)//2. This integer identifies a single element in the compacted upper-triangle array used by GPAW data structures and algorithms.
        ni (int): The dimension of the square matrix (number of rows and columns). This is the size parameter used to interpret the packed index p and to compute the corresponding 2D indices. ni is expected to be an integer representing the matrix size.
    
    Returns:
        tuple: A pair of ints (i, j) where i is the row index and j is the column index in 0-based indexing. The returned indices satisfy 0 <= i <= j < ni and correspond to the same matrix element that was encoded by the packed index p. The function computes i using an analytic formula (involving a floating-point square root and int conversion) and computes j by subtracting the number of packed entries preceding row i; both outputs are Python ints.
    
    Raises:
        AssertionError: If the precondition 0 <= p < ni*(ni + 1)//2 is not met. This indicates that p does not refer to a valid position in the packed upper-triangle storage for a matrix of dimension ni.
    
    Side effects:
        None. The function is pure and does not modify inputs or external state. It performs arithmetic (including a floating-point square root) and returns a new tuple of integers.
    """
    from gpaw.utilities import unpacked_indices
    return unpacked_indices(p, ni)


################################################################################
# Source: gpaw.utilities.blas.axpy
# File: gpaw/utilities/blas.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_blas_axpy(alpha: float, x: numpy.ndarray, y: numpy.ndarray):
    """gpaw.utilities.blas.axpy: In-place BLAS-style axpy operation that updates a target vector y with a scaled source vector x according to y <- alpha * x + y. This routine is a small, performance-critical building block used throughout GPAW for linear-algebra vector updates (for example in iterative solvers, multigrid operations and other routines that rely on BLAS semantics) and dispatches to a type-specific implementation based on the NumPy dtype of x.
    
    This function performs the numeric operation elementwise and modifies y in-place. It requires both x and y to be contiguous NumPy arrays (C- or Fortran-contiguous as indicated by x.flags.contiguous / y.flags.contiguous) and flattens them with ravel() before calling the backend implementation. If x has zero elements the function returns immediately and y is left unchanged.
    
    Args:
        alpha (float): Scalar multiplier applied to x before addition. In the GPAW context this scalar typically arises from linear-algebra algorithm coefficients (step sizes, scaling factors, or combination coefficients). There is no default; the caller supplies the value to control how x contributes to the update of y.
        x (numpy.ndarray): Source array to be scaled and added into y. Must be a contiguous NumPy array (x.flags.contiguous must be True) and contain the same total number of elements as y. The implementation dispatches a specialized backend based on numpy.dtype(x.dtype).type, so x.dtype determines which low-level axpy routine is used. The array is flattened (ravel()) to a 1-D view for the elementwise operation. If x.size == 0 the function performs no action and returns immediately.
        y (numpy.ndarray): Target array that is updated in-place to hold the result y <- alpha * x + y. Must be a contiguous NumPy array (y.flags.contiguous must be True) and contain the same total number of elements as x. The array is flattened (ravel()) before the update; after the call the original y object will contain the updated values.
    
    Returns:
        None: This function does not return a value. Its effect is purely a side effect: the contents of the input array y are modified in-place to contain the result of the operation. If x.size == 0, y is not modified.
    
    Raises and failure modes:
        AssertionError: If x.flags.contiguous or y.flags.contiguous is False, an AssertionError is raised because the implementation requires contiguous memory layout. An AssertionError may also be raised if the backend returns an array object that is not the same object as y (internal consistency check).
        KeyError or LookupError: If there is no registered backend implementation for the dtype of x, the dispatch which_axpy[numpy.dtype(x.dtype).type] may raise a KeyError/LookupError (i.e., the dtype is not supported by the available axpy implementations).
        ValueError or backend errors: If x and y do not have the same total number of elements, the backend implementation will typically fail (shape/length mismatch) or produce undefined behavior; callers must ensure matching sizes prior to calling axpy.
    """
    from gpaw.utilities.blas import axpy
    return axpy(alpha, x, y)


################################################################################
# Source: gpaw.utilities.blas.gemmdot
# File: gpaw/utilities/blas.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_blas_gemmdot(
    a: numpy.ndarray,
    b: numpy.ndarray,
    alpha: float = 1.0,
    beta: float = 1.0,
    out: numpy.ndarray = None,
    trans: str = "n"
):
    """Matrix multiplication using BLAS GEMM for GPAW linear-algebra operations.
    
    This function performs the operation out <- alpha * a . b + beta * out using a BLAS
    gemm routine (via the internal mmmx wrapper) and is intended for dense linear
    algebra operations that occur throughout GPAW (for example, multiplying blocks
    of arrays that represent coefficients, density matrices, or intermediate
    operators in DFT calculations). The implementation maps inputs with arbitrary
    leading dimensions to 2D matrices, calls a high-performance GEMM implementation,
    and then reshapes the result back to the appropriate multi-dimensional shape
    expected by GPAW code paths.
    
    Args:
        a (numpy.ndarray): Left operand array. Must be a NumPy array. The matrix
            multiplication sums over the last axis of a. For example, if a has
            shape (..., M, K) it will be mapped to a 2D matrix with shape
            (M_prod, K) before calling GEMM, where M_prod is the product of the
            leading dimensions of a prior to the last axis. The dtype of a
            determines the dtype of any newly allocated output array when out is
            None. In the special vector-vector case (a.ndim == 1 and b.ndim == 1)
            a is treated as a 1D vector and a scalar result is returned (see
            Returns).
        b (numpy.ndarray): Right operand array. Must be a NumPy array. The index
            used for the product-sum depends on the trans parameter: if trans
            == 'n' the sum is over the first axis of b; if trans == 't' or
            trans == 'c' the sum is over the last axis of b. For example, if
            trans == 'n' and b has shape (K, N, ...) it will be mapped so that
            K matches a's last axis and the result has trailing dimensions
            corresponding to b's remaining axes. The array is reshaped internally
            to a 2D matrix before calling GEMM.
        alpha (float): Scalar multiplier for the product term. Defaults to 1.0.
            The product a . b is computed and multiplied by alpha before being
            added to the beta-scaled out. This follows the standard BLAS GEMM
            interface used for scaling the product term.
        beta (float): Scalar multiplier for the existing out array. Defaults to
            1.0. When out is provided, its current contents are scaled by beta
            and then the scaled product (alpha * a . b) is added. If out is None,
            a zero array is created and the beta factor has no effect other than
            the documented semantics.
        out (numpy.ndarray): Output array to store the result. If provided, it
            will be reshaped and overwritten in place according to the required
            2D GEMM shape, and then reshaped back to the multidimensional result
            shape before being returned. If out is None (the default), a new
            NumPy array of zeros with the appropriate shape and dtype a.dtype is
            allocated. Note: in the 1D-1D vector-vector special case an out value
            must not be provided (the implementation asserts out is None) and a
            scalar is returned instead.
        trans (str): Specifies whether b is used transposed/conjugate-transposed
            or not. Accepted values are 'n' for no transpose, 't' for transpose,
            and 'c' for conjugate-transpose. If trans == 'n' the contraction is
            over the first axis of b; if trans == 't' or 'c' the contraction is
            over the last axis of b. If trans == 'c' the complex conjugate of b
            is used in the multiplication. Defaults to "n".
    
    Behavior, side effects, and failure modes:
        - The function maps multi-dimensional inputs to 2D matrices by collapsing
          all leading dimensions (everything except the last axis of a, and the
          corresponding contracting axis of b) to allow a single GEMM call to
          perform the contraction. After GEMM returns, the result is reshaped to
          ashape[:-1] + bshape[1:] when trans == 'n', or to ashape[:-1] +
          bshape[:-1] when trans == 't' or 'c'.
        - For the vector-vector case (both a and b are 1D) the function returns a
          scalar: alpha * dot(a, b) for trans != 'c', or alpha * vdot(b, a) for
          trans == 'c' (vdot conjugates its first argument). In this case out
          must be None (the function asserts this), and no in-place write occurs.
        - If out is None, a zero-initialized NumPy array is allocated with shape
          determined as above and dtype equal to a.dtype. This is done because
          some BLAS implementations (for example ATLAS) cannot handle uninitialized
          output arrays.
        - If out is provided, it will be reshaped to the required 2D GEMM shape
          and its contents will be overwritten according to the formula
          out <- alpha * a . b + beta * out. The caller should ensure out has
          sufficient size and a compatible dtype; otherwise reshape or BLAS calls
          will fail.
        - The function relies on the internal mmmx BLAS wrapper for the actual
          matrix multiply. Shape incompatibilities (mismatched contraction
          dimensions) or invalid trans arguments will typically cause a runtime
          error either during the reshaping steps or when mmmx performs the GEMM.
        - trans must be one of 'n', 't', or 'c'. Other values are not supported
          and may be treated as transpose modes by the implementation, leading to
          incorrect results or runtime errors.
        - No additional type coercion is performed beyond NumPy's standard casting
          rules; providing non-NumPy-array inputs for a or b will raise errors.
        - The function is optimized for performance via a single BLAS GEMM call,
          so its internal reshaping means that any view semantics of out may be
          lost when it is reshaped and overwritten; the final returned array is
          reshaped back to the logical multidimensional result shape.
    
    Returns:
        numpy.ndarray or scalar: The result of the operation out <- alpha * a . b +
        beta * out. In the general (non-vector) case a numpy.ndarray is returned;
        the returned array is either the same object passed as out (after being
        reshaped and overwritten) or a newly allocated array when out was None.
        In the special case where both a and b are 1D arrays a scalar (NumPy
        scalar) is returned: alpha * a.dot(b) for trans != 'c', or
        alpha * numpy.vdot(b, a) for trans == 'c'. The returned array has logical
        shape ashape[:-1] + bshape[1:] when trans == 'n', and ashape[:-1] +
        bshape[:-1] when trans == 't' or 'c'.
    """
    from gpaw.utilities.blas import gemmdot
    return gemmdot(a, b, alpha, beta, out, trans)


################################################################################
# Source: gpaw.utilities.blas.to2d
# File: gpaw/utilities/blas.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for to2d because the docstring has no description for the argument 'array'
################################################################################

def gpaw_utilities_blas_to2d(array: numpy.ndarray):
    """gpaw.utilities.blas.to2d returns a 2D NumPy array view (or copy when necessary) by preserving the original array's first axis and flattening all remaining axes into the second axis. This utility is used in GPAW's BLAS-related code to present multidimensional data (for example, blocks of wavefunction coefficients, density matrices, or batched vectors) as 2D matrices suitable for BLAS/ScaLAPACK routines and other linear-algebra operations required by the DFT calculations described in the README.
    
    Args:
        array (numpy.ndarray): Input n-dimensional array to be reshaped for BLAS-style matrix operations. The function treats array.shape[0] as the leading dimension (number of rows) and combines all remaining axes array.shape[1:] into a single trailing dimension (number of columns). The input must be a NumPy ndarray and must have at least one dimension (ndim >= 1). Typical use in GPAW: convert arrays of shape (N, A, B, ...) representing N independent vectors/blocks each with A*B*... degrees of freedom into shape (N, A*B*...) so they can be passed to BLAS routines.
    
    Returns:
        numpy.ndarray: A 2D array with shape (array.shape[0], prod(array.shape[1:])). The returned object is a view of the original array when NumPy can reshape without copying (preserving memory layout); if the original memory layout does not permit a view, NumPy will return a copy. The second dimension equals the product of the original trailing dimensions, so no data is duplicated conceptually unless a copy is required by memory layout.
    
    Behavior, side effects, defaults, and failure modes:
        - Behavior: The function computes shape = array.shape and returns array.reshape((shape[0], prod(shape[1:]))). This preserves the first axis and flattens the rest into a single axis.
        - Side effects: There are no in-place modifications to the contents of the input array. However, since the function may return either a view or a copy, modifying the returned array may or may not affect the original array depending on whether a view was returned.
        - Memory/layout considerations: If the input array's memory layout (C- or Fortran-contiguous or with suitable strides) allows a reshape without copying, the result is a view; otherwise NumPy makes a copy to produce the requested 2D shape. Code that relies on aliasing must account for this possibility.
        - Requirements: The input must be a NumPy ndarray with at least one dimension (ndim >= 1). A 1-D array of shape (N,) is converted to shape (N, 1).
        - Failure modes: If array is not an object with a .shape and .reshape method (for example, not a NumPy ndarray), a TypeError or AttributeError may be raised. If the input has zero dimensions (a scalar, ndim == 0), accessing shape[0] raises an IndexError. Other reshape-related errors originate from NumPy and will be propagated.
    
    Example:
        >>> to2d(numpy.zeros((2, 3, 4))).shape
        (2, 12)
    """
    from gpaw.utilities.blas import to2d
    return to2d(array)


################################################################################
# Source: gpaw.utilities.blas.gpu_dotu
# File: gpaw/utilities/blas.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_blas_gpu_dotu(a: numpy.ndarray, b: numpy.ndarray):
    """gpaw.utilities.blas.gpu_dotu: Compute the element-wise dot product on the GPU without conjugating the first vector for complex inputs.
    
    Performs the operation sum_ijk... a[ijk...] * b[ijk...] using the GPU-backed C routine cgpaw.dotu_gpu. This function is intended for high-performance linear-algebra kernels inside GPAW (a DFT code that relies on BLAS and optional GPU acceleration) where a bilinear dot product (no conjugation of the first argument) is required rather than the Hermitian inner product. The computation delegates to the underlying GPU implementation and reads raw device pointers from the NumPy array buffer objects (a.data.ptr and b.data.ptr).
    
    Behavior and side effects:
    This function assumes that the input arrays refer to memory laid out contiguously in a single buffer and that both arrays have identical shapes and compatible numeric dtypes. In debug builds (module-level debug is True) these conditions are asserted: both arrays must be contiguous and both must have either a floating or a complex dtype, and their shapes must match. When debug is False the function does not perform Python-level validation and invalid inputs (non-contiguous arrays, mismatched shapes, or incompatible dtypes) will be passed directly to the C/GPU routine, which may raise an exception or produce undefined results. The function calls the C extension cgpaw.dotu_gpu and therefore requires that the corresponding native extension is available; if it is not available, calling this function will raise an ImportError or other exception from the underlying call.
    
    Args:
        a (numpy.ndarray): Left-hand operand array. Must be a contiguous NumPy array with a floating or complex dtype used in GPAW (the same dtype as b). The array may have any shape (1-D, multi-D); the operation is performed elementwise over all indices. For complex dtypes, note that elements of a are NOT conjugated before multiplication, so the result is a bilinear form rather than the usual Hermitian inner product.
        b (numpy.ndarray): Right-hand operand array. Must be a contiguous NumPy array with the same shape and dtype as a. The values of b are multiplied elementwise with the corresponding values of a on the GPU.
    
    Returns:
        numpy scalar: A numeric scalar (NumPy scalar of the same dtype as the input arrays) equal to the sum over all elements of a * b (elementwise multiplication without conjugation of a). If the inputs are invalid and module-level debug is True, an AssertionError is raised before the GPU call; otherwise, errors or undefined behavior may result from the underlying C/GPU routine.
    """
    from gpaw.utilities.blas import gpu_dotu
    return gpu_dotu(a, b)


################################################################################
# Source: gpaw.utilities.blas.gpu_dotc
# File: gpaw/utilities/blas.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_blas_gpu_dotc(a: numpy.ndarray, b: numpy.ndarray):
    """gpaw.utilities.blas.gpu_dotc computes the dot product of two equally-shaped NumPy arrays, conjugating the first array when the arrays have complex dtype, and performs the computation using the GPAW GPU BLAS backend (cgpaw.dotc_gpu). This function is used in GPAW DFT codepath to obtain inner products/overlaps of discretized wavefunctions or other field arrays stored as NumPy arrays; using the GPU implementation accelerates linear-algebra operations in high-performance electronic-structure calculations.
    
    This function computes the scalar
        sum_{ijk...} conj(a[ijk...]) * b[ijk...]
    where conj() denotes complex conjugation applied to elements of a when a is complex. For real-valued arrays the operation reduces to the standard dot product sum_{ijk...} a[ijk...] * b[ijk...]. The operation is performed over all elements of the arrays; multi-dimensional arrays are treated elementwise and collapsed into a single scalar result.
    
    Args:
        a (numpy.ndarray): Left-hand input array whose elements are conjugated when complex. Must be a contiguous NumPy array (memory-contiguous buffer as checked by the GPAW is_contiguous helper) of either real (float) or complex dtype as used in GPAW. The array provides the data pointer passed to the underlying GPU routine (a.data.ptr). The shape of a determines the shape required for b. The array is not modified by this function; it is only read.
        b (numpy.ndarray): Right-hand input array to be multiplied elementwise with the conjugated elements of a. Must be a contiguous NumPy array of the same dtype category (both real or both complex) and exactly the same shape as a. The array is not modified by this function; it is only read.
    
    Returns:
        numpy.number: A scalar NumPy numeric value representing the computed dot product. The dtype of the returned scalar matches the dtype of the input arrays (real float -> real scalar, complex -> complex scalar). The value equals the sum over all elements of conj(a) * b as described above.
    
    Behavior and failure modes:
    - The function relies on the GPAW C backend cgpaw.dotc_gpu, called as cgpaw.dotc_gpu(a.data.ptr, a.shape, b.data.ptr, a.dtype). It therefore expects that the NumPy arrays expose a raw data pointer compatible with that backend.
    - Inputs must be memory-contiguous and have identical shapes and compatible dtypes (both real or both complex). When the module-level debug flag is enabled, violations of these conditions trigger Python AssertionError via internal checks (is_contiguous and shape equality). When not in debug mode, passing non-contiguous arrays or mismatched shapes/dtypes may lead to undefined behavior or errors propagated from the underlying C/GPU routine.
    - The function does not copy, transpose, or otherwise mutate the input arrays; it reads their buffers and computes the scalar result on the GPU. It is intended for use in GPAW workflows that store large arrays representing wavefunctions, densities, or matrix blocks and need GPU-accelerated inner products.
    - Any errors from the underlying GPU/backend (for example, driver issues, unsupported dtypes on the GPU, or invalid pointers) are surfaced from the cgpaw.dotc_gpu call and are not wrapped by this Python function.
    """
    from gpaw.utilities.blas import gpu_dotc
    return gpu_dotc(a, b)


################################################################################
# Source: gpaw.utilities.blas.gpu_r2k
# File: gpaw/utilities/blas.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_blas_gpu_r2k(
    alpha: float,
    a: numpy.ndarray,
    b: numpy.ndarray,
    beta: float,
    c: numpy.ndarray,
    trans: str = "c"
):
    """gpaw.utilities.blas.gpu_r2k launches the compiled cgpaw.r2k_gpu routine to perform a BLAS-like rank-2k update using either the GPU or CPU implementation available in the cgpaw extension. In the GPAW DFT codebase this function is used to accelerate linear-algebra kernels (for example updates of density- or Hamiltonian-related matrices) by forwarding raw numpy array memory and shape information to the low-level C/CUDA implementation.
    
    Args:
        alpha (float): Scalar multiplier for the matrix product term(s) in the underlying r2k operation. In GPAW linear-algebra kernels this scale factor adjusts the contribution of the computed product (for example scaling a product that updates a density matrix or intermediate buffer).
        a (numpy.ndarray): Left input array whose data pointer and shape are forwarded to the low-level cgpaw.r2k_gpu implementation. The array provides the memory buffer and dtype used by the C/CUDA kernel (a.dtype is passed to the extension). a must be a numeric numpy.ndarray compatible with the other arrays; its shape and memory layout determine how the low-level routine interprets the matrix data.
        b (numpy.ndarray): Right input array whose data pointer and shape are forwarded to the low-level cgpaw.r2k_gpu implementation. b is used together with a by the underlying r2k routine to compute the product term(s) that are scaled by alpha. b must be a numeric numpy.ndarray compatible in dtype and shape semantics with a and c for the intended r2k operation.
        beta (float): Scalar multiplier applied to the existing contents of c before accumulation of the product term(s). In GPAW workflows this allows in-place accumulation of results using the common BLAS pattern C := alpha * (products of A and B) + beta * C.
        c (numpy.ndarray): Output/accumulator array whose data pointer and shape are forwarded to cgpaw.r2k_gpu. The function updates c in-place according to the semantics of the underlying r2k routine (scaled accumulation). c must be a numeric numpy.ndarray with a memory layout and dtype compatible with the low-level implementation; its contents are overwritten/updated as a side effect.
        trans (str): Character flag forwarded to the low-level implementation to control transpose/conjugation semantics used by the r2k operation. The default value is 'c'. This argument instructs the cgpaw.r2k_gpu routine how to interpret/transform a and b (for example whether to use a, a^T, or a^H forms) when forming the product; the exact semantics are defined by the compiled cgpaw extension.
    
    Returns:
        None: This function does not return a value. Its primary effect is the in-place modification of the numpy.ndarray c according to the r2k operation implemented in the cgpaw extension. The function operates by calling cgpaw.r2k_gpu with raw data pointers (a.data.ptr, b.data.ptr, c.data.ptr), shapes, and a.dtype, and therefore delegates all numerical work and most error checking to the compiled extension.
    
    Behavior, side effects, and failure modes:
        This wrapper forwards raw numpy memory pointers and shapes to the compiled cgpaw.r2k_gpu routine, which will select and launch either a GPU or CPU implementation. Because only a.dtype is forwarded as the dtype argument, a, b and c should have compatible dtypes; mismatched dtypes or shapes incompatible with the underlying r2k semantics will typically cause the compiled routine to raise an error. Arrays must be valid numpy.ndarray objects exposing .data.ptr and .shape; non-numeric arrays or invalid memory pointers lead to errors from the extension. Any runtime faults, CUDA errors, or device-memory issues originate from the cgpaw extension and are propagated to the caller. Use this function when an in-place, efficient GPU-accelerated or CPU fallback BLAS-like rank-2k update is required in GPAW linear-algebra kernels.
    """
    from gpaw.utilities.blas import gpu_r2k
    return gpu_r2k(alpha, a, b, beta, c, trans)


################################################################################
# Source: gpaw.utilities.blas.gpu_gemv
# File: gpaw/utilities/blas.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_blas_gpu_gemv(
    alpha: float,
    a: numpy.ndarray,
    x: numpy.ndarray,
    beta: float,
    y: numpy.ndarray,
    trans: str = "t"
):
    """gpaw.utilities.blas.gpu_gemv performs a GPU-accelerated general matrix-vector product (BLAS level-2) used throughout GPAW for operations such as applying matrix operators to state vectors in density-functional theory workflows. The function computes the in-place update
    
    y <- alpha * a.x + beta * y
    
    where the meaning of the matrix-vector product a.x depends on the trans parameter and the dimensionality of a. This routine delegates the heavy work to the underlying cgpaw.gemv_gpu implementation and is intended to provide a fast, device-accelerated alternative to NumPy dot for the specific array/layout conventions used in GPAW.
    
    Args:
        alpha (float): Scalar multiplier for the matrix-vector product term. In the DFT/linear-algebra context used by GPAW, alpha scales the contribution of a.x (for example, to combine contributions from different Hamiltonian terms). Must be a Python float per the function signature; it is applied elementwise to the product before addition to the scaled y.
        a (numpy.ndarray): N-dimensional array representing the matrix (or stack of matrices) to multiply with x. The array must be C-contiguous (a.flags.c_contiguous is required). Valid dtypes are float or complex as used in GPAW linear algebra. The interpretation of a relative to x and y depends on trans: if trans == 'n', the product-sum is performed over the first dimension of a; if trans == 't' or 'c', the product-sum is performed over the last dimension of a. Shape constraints enforced by the implementation (and asserted in debug mode) are: x.ndim == 1, y.ndim == a.ndim - 1, and either (for trans == 'n') a.shape[0] == x.shape[0] and a.shape[1:] == y.shape, or (for trans == 't' or 'c') a.shape[-1] == x.shape[0] and a.shape[:-1] == y.shape. In practical GPAW usage, a typically represents Hamiltonian blocks or overlap-like tensor blocks arranged so that y has one fewer dimension than a.
        x (numpy.ndarray): One-dimensional vector (ndim == 1) to be multiplied by a. Its length must match the appropriate dimension of a as described above (a.shape[0] when trans == 'n', or a.shape[-1] when trans == 't' or 'c'). x.dtype must match a.dtype (both float or both complex) as expected by the GPU routine. In GPAW workflows x often represents a wavefunction or a data column acted on by matrix operators.
        beta (float): Scalar multiplier for the existing contents of y. beta scales y in-place before adding the alpha * a.x contribution. Must be a Python float per the signature. Typical use in GPAW is to combine new contributions with previously accumulated data or to implement linear combinations in iterative algorithms.
        y (numpy.ndarray): Output array that is updated in-place to store the result y <- alpha * a.x + beta * y. y must be C-contiguous (y.flags.c_contiguous is required) and its number of dimensions must equal a.ndim - 1 as described above. The dtype of y must match a and x (float or complex). Because the operation is done in-place, callers should ensure that overwriting y is acceptable; y serves both as input (for the scaled beta*y term) and as the output destination.
        trans (str): Specifies which dimension of a is contracted with x and whether to apply complex conjugation. Allowed values are 'n', 't', and 'c'. If trans == 'n', the product sums over the first dimension of a (no transpose semantics). If trans == 't', the product sums over the last dimension of a and behaves like numpy.dot when a is a 2-D matrix and x is a vector (this is the default). If trans == 'c', the same as 't' but uses the complex conjugate of a during the product (relevant when a.dtype is complex). The default is "t", reflecting the common GPAW convention where the last axis of multi-dimensional operator arrays corresponds to the vector index.
    
    Returns:
        None: The function does not return a value. Instead, it updates the provided y array in-place to hold the result y <- alpha * a.x + beta * y. Side effects include writing to the memory backing y; therefore callers must supply a writable numpy.ndarray y with the correct dtype, shape, and C-contiguity.
    
    Behavior, side effects, and failure modes:
    - The operation is performed on the GPU via the cgpaw.gemv_gpu backend; pointers to the underlying array data are passed to that routine. Incorrect memory layout, non-C-contiguous arrays for a or y, mismatched dtypes, or incompatible shapes may lead to assertion failures in debug mode or to undefined behavior or crashes in the GPU backend.
    - Arrays must use dtype float or complex consistent across a, x, and y. alpha and beta are floats as per the signature; the implementation expects these scalars and uses them to scale the product and existing y, respectively.
    - For trans == 'c', the complex conjugate of a is used; this is relevant only when a.dtype is complex.
    - The function requires that x is one-dimensional and that y has exactly one fewer dimension than a, as described under the parameter a. These shape conventions match how GPAW arranges block operators and vectors in its linear-algebra kernels.
    - This routine is intended for performance-critical linear-algebra in GPAW (e.g., applying Hamiltonian or overlap operators to wavefunction vectors) and relies on the underlying cgpaw.gemv_gpu implementation for performance and correctness on supported GPU devices. If the GPU backend is not available or the provided arrays violate the stated layout/dtype requirements, callers should fall back to CPU-based NumPy/SciPy routines.
    """
    from gpaw.utilities.blas import gpu_gemv
    return gpu_gemv(alpha, a, x, beta, y, trans)


################################################################################
# Source: gpaw.utilities.blas.gpu_mmm
# File: gpaw/utilities/blas.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_blas_gpu_mmm(
    alpha: float,
    a: numpy.ndarray,
    opa: str,
    b: numpy.ndarray,
    opb: str,
    beta: float,
    c: numpy.ndarray
):
    """gpaw.utilities.blas.gpu_mmm launches the compiled C extension implementation of a general dense matrix-matrix multiplication (GEMM) used by GPAW linear-algebra code. The function delegates the work to cgpaw.mmm_gpu which typically executes a GPU-accelerated kernel when GPAW was built with GPU support; otherwise the compiled extension may execute a CPU implementation. This routine implements the BLAS-like operation C <- alpha * op(A) * op(B) + beta * C and is used inside GPAW for performance-critical dense linear-algebra operations that appear, for example, in Hamiltonian and overlap matrix manipulations.
    
    Args:
        alpha (float): Scalar multiplier applied to the matrix product op(A)*op(B). In the GEMM formula C <- alpha * op(A) * op(B) + beta * C, alpha scales the product term. Use a Python float; it is passed through to the compiled cgpaw.mmm_gpu routine.
        a (numpy.ndarray): Left input matrix A. This is a contiguous or strided NumPy array whose memory pointer is taken from a.data.ptr and whose leading dimension is derived as a.strides[0] // a.itemsize. The array provides element values and layout for op(A). Its shape and strides must be consistent with opa and with B so that the matrix product dimensions match; mismatched shapes will cause a runtime error in the compiled routine.
        opa (str): Character flag controlling the operation applied to A before multiplication. The value 'N' indicates no transpose (op(A) = A). The flag is forwarded as-is to cgpaw.mmm_gpu so it must follow the conventions accepted by that compiled routine (BLAS-like transpose flags are typical in GPAW usage). The choice of opa determines how the dimensions of A are interpreted when checking compatibility with B and C.
        b (numpy.ndarray): Right input matrix B. This is a NumPy array whose pointer is taken from b.data.ptr and whose leading dimension is computed as b.strides[0] // b.itemsize. Its shape and strides must be consistent with opb and with A so that the inner dimension k of the product op(A)*op(B) matches. The function computes m, n, k internally from a.shape and b.shape using opa/opb as in the source code.
        opb (str): Character flag controlling the operation applied to B before multiplication. The value 'N' indicates no transpose (op(B) = B). The flag is forwarded to cgpaw.mmm_gpu and must follow the conventions accepted by that compiled routine. opb affects how B's shape is interpreted when determining dimensions m, n, k.
        beta (float): Scalar multiplier applied to the existing contents of C in the GEMM formula C <- alpha * op(A) * op(B) + beta * C. Use a Python float; it is passed to the compiled routine and scales C in-place before adding the product term.
        c (numpy.ndarray): Output matrix C that is updated in-place. The array's memory pointer is taken from c.data.ptr and its leading dimension is computed as c.strides[0] // c.itemsize. The function overwrites or updates the contents of c according to the GEMM formula; no new array is allocated and the result is written directly into the provided c buffer. The dtype and itemsize of c must be compatible with A and B as expected by the compiled extension.
    
    Returns:
        None: The function has no Python return value. Side effects: the array c is modified in-place to contain the result of the GEMM operation C <- alpha * op(A) * op(B) + beta * C. Errors and failure modes: a mismatch between the inferred dimensions (m, n, k) and the actual array shapes, incompatible dtypes or itemsize, nonstandard array objects lacking a.data.ptr, or a compiled extension that lacks GPU support may cause cgpaw.mmm_gpu to raise a runtime exception. The leading dimensions (lda, ldb, ldc) are derived from the arrays' strides and itemsize (lda = a.strides[0] // a.itemsize, etc.), so atypical stride layouts may produce incorrect behavior or errors in the compiled routine.
    """
    from gpaw.utilities.blas import gpu_mmm
    return gpu_mmm(alpha, a, opa, b, opb, beta, c)


################################################################################
# Source: gpaw.utilities.blas.gpu_rk
# File: gpaw/utilities/blas.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_blas_gpu_rk(
    alpha: float,
    a: numpy.ndarray,
    beta: float,
    c: numpy.ndarray,
    trans: str = "c"
):
    """gpaw.utilities.blas.gpu_rk launches the GPAW C-extension implementation of the rank-k update routine (rk) and dispatches it to a CPU or GPU backend. This wrapper is used inside GPAW's linear-algebra/BLAS utilities to perform a scaled rank-k update on the matrix represented by c using data from a, enabling accelerated dense-matrix operations that occur frequently in density-functional-theory (DFT) calculations implemented by GPAW. The function is a thin Python wrapper that passes raw array pointers, shapes, and dtype information to the cgpaw.rk_gpu routine; it therefore enforces requirements on the provided NumPy arrays (memory layout and pointer accessibility) and performs the update in-place on c.
    
    Args:
        alpha (float): Scalar multiplier for the contribution computed from a. In the DFT/BLAS context, alpha scales the rank-k term derived from the array a before it is accumulated into c. The value is forwarded unchanged to the underlying cgpaw.rk_gpu call.
        a (numpy.ndarray): Input array providing matrix data for the rank-k update. This array must be a NumPy ndarray object with an accessible .data.ptr attribute and a valid .shape tuple; its memory layout and dtype determine how the C-extension interprets element storage. The function passes a.data.ptr, a.shape and a.dtype directly to cgpaw.rk_gpu. The caller is responsible for ensuring that a has the correct dimensionality and shape expected by the underlying rk operation; mismatched or incompatible shapes will cause the C-extension to raise an error.
        beta (float): Scalar multiplier applied to the existing contents of c before the rank-k contribution from a is added. In practice, beta scales the current matrix c (in-place) as part of the combined update c := beta*c + alpha*(rk-term-from-a). The value is forwarded unchanged to the underlying cgpaw.rk_gpu call.
        c (numpy.ndarray): Target array that is updated in-place by this function. This must be a NumPy ndarray with an accessible .data.ptr attribute and a valid .shape tuple. After successful return, the contents of c have been overwritten according to the rk update implemented by cgpaw.rk_gpu. The caller must ensure c has the correct shape, dtype and memory layout for the operation; otherwise the C-extension may raise an exception.
        trans (str): Transposition flag accepted for API compatibility (default "c"). The wrapper signature accepts this flag but the current implementation of this Python wrapper does not forward or use trans when calling cgpaw.rk_gpu; it is therefore ignored here. The parameter is present to preserve a consistent API with other BLAS-like wrappers in GPAW. Default: "c".
    
    Behavior and side effects:
        This function does not return a value; instead it modifies the contents of the numpy.ndarray c in-place according to the rk operation implemented by the cgpaw.rk_gpu C-extension. The wrapper extracts low-level information from the provided NumPy arrays (data pointer, shape, dtype) and passes them to cgpaw.rk_gpu. Because raw pointers are passed, the arrays must be valid and alive for the duration of the call and must expose a .data.ptr attribute accessible from Python. Typical requirements are that arrays be contiguous and have a supported dtype; the exact dtype support is determined by the compiled cgpaw extension and is derived from a.dtype passed to the extension.
    
    Failure modes and errors:
        If the provided arguments do not meet the expectations of the wrapper or the C-extension, the call can raise exceptions. Possible failure modes include AttributeError or TypeError if a or c do not expose the required .data.ptr attribute or are not NumPy ndarrays, ValueError if a.shape and c.shape are incompatible for the underlying rk operation, and runtime errors propagated from the cgpaw.rk_gpu extension (for example, due to unsupported dtypes, GPU allocation failures, or internal computation errors). Because trans is not used by this wrapper, passing a value intended to change behavior will have no effect.
    
    Returns:
        None: The function returns no value. Its practical effect is the in-place modification of the numpy.ndarray c according to the rk update computed by the cgpaw.rk_gpu C-extension.
    """
    from gpaw.utilities.blas import gpu_rk
    return gpu_rk(alpha, a, beta, c, trans)


################################################################################
# Source: gpaw.utilities.ekin.dekindecut
# File: gpaw/utilities/ekin.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for dekindecut because the docstring has no description for the argument 'G'
################################################################################

def gpaw_utilities_ekin_dekindecut(G: numpy.ndarray, de: numpy.ndarray, ecut: float):
    """gpaw.utilities.ekin.dekindecut: Compute a linear interpolation of the array de at the reciprocal-space magnitude corresponding to a plane-wave kinetic-energy cutoff and return the value normalized by that magnitude. This function is used in GPAW's plane-wave related utilities to estimate the slope/value of a spectral quantity (de) at the cutoff boundary defined by ecut; in the GPAW codebase this helps determine contributions at the kinetic energy cutoff when working with plane-wave expansions and related extrapolations.
    
    Args:
        G (numpy.ndarray): 1D array of reciprocal-space magnitudes (G values) sampled for the spectral quantity de. G is expected to be a monotonically increasing, evenly spaced 1D array with at least two elements so that spacing dG = G[1] is meaningful. The caller must ensure G and ecut share a consistent unit system so that G0 = sqrt(2 * ecut) is numerically compatible with the values in G.
        de (numpy.ndarray): 1D array of the same shape as G containing the spectral quantity values corresponding to each entry in G. In the GPAW plane-wave context, de typically represents a derivative or density-like quantity sampled as a function of |G|; it is used here only to produce a local linear interpolation near the cutoff. The function will use de[g:g+2] together with G[g:g+2] to form a linear fit, so de must provide at least two entries around the cutoff index.
        ecut (float): Plane-wave kinetic-energy cutoff value used to define the cutoff magnitude G0 = sqrt(2 * ecut). ecut must be provided in the same energy units consistent with the G array and the calling code (no automatic unit conversion is performed). This parameter controls which interval of G is used for the linear interpolation.
    
    This function performs the following steps and has the following behavioral assumptions and failure modes:
    - It computes G0 = sqrt(2 * ecut) and determines the interval index g = int(G0 / dG) using dG = G[1]. This implicitly assumes the G array uses constant spacing equal to G[1] and that G[0] corresponds to zero or to the start of the regular grid.
    - It constructs a first-degree polynomial (linear fit) through the two neighboring points G[g] and G[g+1] with values de[g] and de[g+1] using numpy.polyfit and evaluates that polynomial at G0 to obtain dedG (the interpolated de at G0).
    - It returns dedG divided by G0. If G0 == 0 (for example, ecut == 0), the division by G0 will raise a ZeroDivisionError or produce an invalid numerical result; callers should avoid ecut == 0 or handle that case separately.
    - If G does not contain at least two elements, or if the computed index g is out of range so that G[g:g+2] does not provide two points, the function will raise an IndexError or produce an incorrect interpolation. The function does not perform validation beyond relying on the slice G[g:g+2].
    - Because the implementation uses only the two points nearest the cutoff for a linear fit, the result is a local linear interpolation (or extrapolation if G0 lies outside the range covered by G[g:g+2]) and may be inaccurate if de varies nonlinearly over the interval or if the grid spacing is not uniform.
    
    Returns:
        float: The scalar dedecut, equal to the linearly interpolated value of de at G0 (dedG) divided by G0. In the GPAW plane-wave context, dedecut represents the interpolated spectral quantity normalized by the cutoff magnitude and can be used in further calculations that require the value of de at the kinetic-energy cutoff. No state is modified; the function has no side effects beyond computing and returning this value.
    """
    from gpaw.utilities.ekin import dekindecut
    return dekindecut(G, de, ecut)


################################################################################
# Source: gpaw.utilities.dos.delta
# File: gpaw/utilities/dos.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_dos_delta(x: numpy.ndarray, x0: float, width: float, mode: str = "Gauss"):
    """Return a normalized approximation to the Dirac delta function centered at x0 on a numerical grid.
    
    This function is used in GPAW's DOS (density of states) and spectral-broadening utilities to convert discrete eigenvalues into a smooth spectral distribution. Given a numerical grid x (for example an energy grid in eV when using ASE/GPAW energy units), delta(x, x0, width, mode) produces a normalized kernel (area = 1) located at x0 with a controllable broadening width and choice of functional form. The default mode 'Gauss' is the common Gaussian broadening used to smooth DOS; 'Lorentz' gives the Lorentzian (Cauchy) shape often used to model lifetime broadening.
    
    Args:
        x (numpy.ndarray): Numerical grid where the kernel is evaluated. In DFT/DOS contexts this is typically an energy grid (e.g. in eV when energies are expressed in ASE/GPAW units). The returned array has the same shape as x. x is expected to be a numpy.ndarray; values that are NaN or Inf in x will propagate to the result.
        x0 (float): Center position of the kernel on the same axis and in the same units as x (e.g. an eigenvalue in eV). This is the location of the approximated delta peak.
        width (float): Broadening parameter (positive float) controlling the kernel width, in the same units as x and x0. For Gaussian mode this parameter is the standard-width scaling used in the implementation so that the returned Gaussian is normalized to unit area; for Lorentz mode the implementation uses width so that the Lorentzian half-width at half-maximum equals width/2 and the kernel is normalized to unit area. The function does not validate width; width <= 0 will lead to division-by-zero or invalid values.
        mode (str = "Gauss"): Shape of the broadening kernel. Accepted values implemented in the code are:
            'Gauss' — Gaussian kernel: exp(-((x - x0) / width)**2) / (sqrt(pi) * width). This is the default and yields a normalized Gaussian with unit area.
            'Lorentz' — Lorentzian (Cauchy) kernel: (2 / pi / width) / (((x - x0) / (width / 2))**2 + 1). In the implementation this form is algebraically equivalent to the standard normalized Lorentzian with half-width at half-maximum = width/2.
        Note: the implementation applies numpy.clip to the squared or exponential arguments with bounds [-100.0, 100.0] to avoid underflow/overflow in the exponential and large argument values; this effectively sets extremely small tails to values ~exp(-100) and prevents numerical overflow.
    
    Returns:
        numpy.ndarray: Array of the same shape as x containing the evaluated kernel values. For valid modes ('Gauss' or 'Lorentz') the returned kernel is normalized to unit area (i.e., integrates to 1 over x when x spans the real line with appropriate resolution). If mode is not 'Gauss' or 'Lorentz', the function reaches the end without a return statement and thus returns None (this is the current behavior of the implementation and should be treated as an invalid mode). No other side effects occur.
    
    Behavior, defaults, and failure modes:
        - Default behavior is Gaussian broadening ('Gauss').
        - Numerical clipping of arguments to the exponential / squared terms uses the hard limits -100.0 and 100.0, chosen to balance numerical stability and faithful tail behavior; values beyond these thresholds are effectively truncated, making tails smaller than ~3.7e-44 negligible.
        - The function performs elementwise numpy operations and returns a numpy.ndarray. Scalar x0 and width are broadcast against x.
        - The function does not check or enforce width > 0. Providing width <= 0 will produce division-by-zero warnings, Infs, NaNs, or a runtime exception depending on the environment.
        - Providing a mode string other than the two implemented options results in an implicit None return; callers should validate mode before calling if they require explicit error signaling.
        - There are no I/O side effects. The kernel values are intended for constructing densities of states or broadened spectral functions in GPAW workflows.
    """
    from gpaw.utilities.dos import delta
    return delta(x, x0, width, mode)


################################################################################
# Source: gpaw.utilities.dos.fold
# File: gpaw/utilities/dos.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_dos_fold(
    energies: list,
    weights: list,
    npts: int,
    width: float,
    mode: str = "Gauss"
):
    """gpaw.utilities.dos.fold: Compute a broadened density-of-states (DOS) by placing a weighted delta kernel at each supplied energy and summing them on a uniform energy grid.
    
    This function is used in the GPAW DFT post-processing workflow to convert a discrete set of eigenvalues (energies) and their spectral weights into a continuous DOS by folding each discrete level with a finite-width kernel. The output energy axis and DOS are suitable for plotting, further analysis, or comparison with experiments. The routine determines the energy window automatically from the supplied energies and the broadening width, constructs an evenly spaced grid with npts points, and calls the module-local delta(e, e0, width, mode=mode) routine to generate the broadened contribution of each level.
    
    Args:
        energies (list): Iterable of numeric eigenvalues (discrete energies) representing e.g. Kohn–Sham eigenvalues from a GPAW calculation. These values define the centers of the delta kernels. Units must be consistent with width (typically the same energy units used elsewhere in the GPAW calculation, e.g. eV). The minimum and maximum of this list determine the default energy window via min(energies) - 5*width and max(energies) + 5*width.
        weights (list): Iterable of numeric weights corresponding to each entry in energies. Each weight multiplies the kernel for the matching energy, so weights encode spectral intensity (for example occupation numbers or projection weights). If len(weights) != len(energies), Python's zip is used: extra elements in the longer iterable are ignored, which may lead to silently truncated input — ensure the two lists match in length.
        npts (int): Number of points in the output energy grid. This integer determines the resolution of the returned energy axis and the length of the DOS array. npts must be a positive integer; npts <= 0 or a non-integer may result in an empty array or an error from numpy.linspace.
        width (float): Broadening parameter passed to the delta kernel that controls the width of each broadened peak. width should be a positive float measured in the same energy units as energies. width <= 0 is not meaningful for broadening and may produce incorrect or singular behavior depending on the delta implementation.
        mode (str): String selecting the shape of the broadening kernel passed to the internal delta(e, e0, width, mode=mode) function. The default value is "Gauss", which requests Gaussian broadening. Other accepted strings depend on the implementation of delta in gpaw.utilities.dos; unknown mode values may cause that function to raise an error. Default: "Gauss".
    
    Behavior and side effects:
        The function computes emin = min(energies) - 5 * width and emax = max(energies) + 5 * width, constructs a 1D numpy energy grid e = numpy.linspace(emin, emax, npts), initializes a zero DOS array dos_e of length npts, and for each paired (e0, w) from zip(energies, weights) adds w * delta(e, e0, width, mode=mode) to dos_e. It does not modify the input lists. The choice of the 5*width padding on each side is intended to ensure the broadened tails of kernels near the extremes are captured; change this logic in the caller if a different padding is required. The routine relies on the module-local delta implementation for the precise kernel shape, normalization, and handling of mode. This function has no other side effects (no I/O, no global state modification).
    
    Failure modes and warnings:
        If energies or weights contain non-numeric entries, numeric conversion errors will occur. If energies is empty, calling min() / max() will raise a ValueError. If weights has a different length than energies, extra elements will be ignored by zip, possibly leading to unintended truncation; the caller should ensure lengths match. If npts is not a positive integer, numpy.linspace may produce an empty array or raise an error. If width <= 0 or mode is not supported by the delta implementation, the behavior is undefined and may raise exceptions from the delta routine.
    
    Returns:
        tuple: A tuple (e, dos_e) where e is a 1D numpy.ndarray of length npts containing the uniformly spaced energy grid spanning [min(energies) - 5*width, max(energies) + 5*width], and dos_e is a 1D numpy.ndarray of length npts containing the summed, weighted, broadened density-of-states values on that grid. These arrays are intended for plotting or further numerical analysis in the GPAW DFT workflow.
    """
    from gpaw.utilities.dos import fold
    return fold(energies, weights, npts, width, mode)


################################################################################
# Source: gpaw.utilities.hardware.dhms
# File: gpaw/utilities/hardware.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_hardware_dhms(secs: float):
    """gpaw.utilities.hardware.dhms converts a duration given in seconds into a four-element list representing days, hours, minutes and seconds. This utility is intended for formatting and reporting elapsed wall-clock or CPU time (for example in GPAW calculation logs and performance messages) where a human-readable decomposition of a floating-point seconds value is required.
    
    Args:
        secs (float): Elapsed time in seconds. This value is treated as a numeric duration (typically reported by timers or perf counters in GPAW). The function accepts fractional seconds and uses integer arithmetic to compute whole days, hours and minutes; the final seconds value is rounded to the nearest integer. No validation is performed to enforce non-negativity; for negative inputs the computation uses Python's floor-division and modulus semantics which may yield a negative days component combined with non-negative hours/minutes/seconds computed from the modular remainder.
    
    Returns:
        list: A list of four integers [days, hours, minutes, seconds]. days is obtained by integer division by 86400, hours by division of the remainder by 3600, minutes by division of the next remainder by 60, and seconds is the remaining seconds rounded to the nearest integer. The returned values are suitable for display (e.g. "D days, H hours, M minutes, S seconds") but may not sum exactly to the original secs due to integer truncation and rounding.
    
    Behavior and side effects:
        The function performs no I/O or global state changes; it purely computes and returns the decomposition. Fractional input seconds are handled: days/hours/minutes are computed by successive floor-like divisions and remainders; the final seconds component is computed as int(remaining + 0.5) which implements rounding to the nearest whole second. The function does not raise custom exceptions; however, passing a non-numeric type for secs will raise the normal Python TypeError or related exception from the arithmetic operations.
    
    Failure modes and notes:
        The function does not validate or clamp input ranges. For very large magnitudes of secs, integer conversion may be limited by platform memory, and the usual floating-point precision limits apply to the input. Negative secs values produce a days value computed by floor-division and hour/minute/second values derived from the positive modular remainder; this can look counterintuitive (e.g. days negative while hours/minutes/seconds are non-negative). Use non-negative secs for conventional elapsed-time formatting.
    """
    from gpaw.utilities.hardware import dhms
    return dhms(secs)


################################################################################
# Source: gpaw.utilities.gl_quadrature.gauss
# File: gpaw/utilities/gl_quadrature.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_gl_quadrature_gauss(xmin: float, xmax: float, funct: int, ng: int = 10):
    """gpaw.utilities.gl_quadrature.gauss computes a one-dimensional Gauss (Gaussian) quadrature
    approximation of the definite integral of an integrand over a finite interval.
    This function is used in the GPAW codebase (a DFT package) for numerically
    evaluating integrals that arise in electronic-structure calculations where a
    high-accuracy weighted sum over predefined Gauss nodes and weights on the
    reference interval [-1, 1] is mapped to the target interval [xmin, xmax].
    The implementation uses precomputed node and weight tables (_nodes and
    _weights) and applies the linear change of variables x = 0.5*(dx*y + xmin + xmax),
    with weight factor 0.5*dx, where dx = xmax - xmin. The weight function is 1.0
    (i.e., ordinary Gauss-Legendre quadrature).
    
    Args:
        xmin (float): Left boundary of the integration domain. In GPAW usage this
            is the lower limit of the interval [xmin, xmax] over which the integral
            is approximated. The function maps the reference nodes in [-1, 1] to
            points within [xmin, xmax] using a linear transformation. If xmin == xmax
            the function returns 0.0 (up to floating-point rounding) because the
            interval length is zero.
        xmax (float): Right boundary of the integration domain. In GPAW usage this
            is the upper limit of the interval [xmin, xmax]. The function assumes a
            finite interval and performs the mapping described above; swapping
            xmin and xmax will change the sign of the returned integral (consistent
            with standard definite integrals).
        funct (int): Integrand function provided by the caller (described in the
            original source as "integrand function"). Although the signature
            indicates type int, the implementation expects an object that can be
            called with a single float argument (a callable such as a Python
            function or a callable object) and which returns a numeric value
            convertible to float. In GPAW this callable typically evaluates a
            scalar integrand arising from mesh, basis, or radial-function
            evaluations. If a non-callable is passed, a TypeError (or other
            exception during evaluation) will be raised at runtime.
        ng (int): Gauss integration order (number of nodes/weights to use). Default
            is 10. The value passed is clamped to the allowed range indexed by the
            module-level constants _NGMIN and _NGMAX: ng = max(min(ng, _NGMAX), _NGMIN).
            The function then selects nodes and weights from the precomputed tables
            _nodes[ng-1] and _weights[ng-1]. Typical GPAW usage supplies ng to
            control integration accuracy and cost; larger ng increases accuracy and
            computational work approximately linearly in ng.
    
    Returns:
        float: Numerical approximation to the integral of funct over [xmin, xmax]
        using Gauss (Legendre) quadrature with the chosen order ng. The value is
        computed as 0.5 * dx * sum(funct(x_i) * w_i) where x_i are the mapped nodes
        in [xmin, xmax], w_i are the corresponding weights, and dx = xmax - xmin.
        There are no side effects (no global state is modified). Possible failure
        modes include runtime exceptions when funct is not callable or when the
        callable raises exceptions for given sample points; supplying extremely
        large or small floating-point endpoints may lead to usual floating-point
        round-off inaccuracies. The function relies on the presence of the module
        arrays _nodes and _weights; improper initialization of these arrays outside
        the documented GPAW package may lead to IndexError or other exceptions.
    """
    from gpaw.utilities.gl_quadrature import gauss
    return gauss(xmin, xmax, funct, ng)


################################################################################
# Source: gpaw.utilities.hardware.hms_string
# File: gpaw/utilities/hardware.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_hardware_hms_string(secs: float):
    """Return a human-readable hours:minutes:seconds string for a duration given in seconds.
    
    This utility is used throughout GPAW's timing and logging utilities to present elapsed wall-clock or CPU time in a compact, human-readable form (for example in progress output, log files, and test diagnostics). The function converts a duration expressed in seconds into integer hours, minutes and seconds using the internal helper hms(secs) and then formats each component as a two-digit field when appropriate.
    
    Args:
        secs (float): Duration in seconds to format. This value is interpreted as a floating-point number of seconds (elapsed time). The caller in GPAW typically supplies wall-clock or CPU elapsed time measured by timers. The function relies on the internal hms(secs) helper to compute integer (hours, minutes, seconds) from this input; if secs is not a valid float suitable for hms, the underlying hms or comparisons will raise an exception which will propagate to the caller.
    
    Returns:
        str: A string representing the input duration in the form "HH:MM:SS". Each of the three fields is formatted with a leading zero when its value is less than 10 (for example, 2 hours, 0 minutes, and 5 seconds becomes "02:00:05"). The hours field is not truncated if it contains more than two digits (e.g. very large durations may yield "100:00:00"). There are no side effects; the function only returns the formatted string.
    """
    from gpaw.utilities.hardware import hms_string
    return hms_string(secs)


################################################################################
# Source: gpaw.utilities.hilbert.analytic_transforms
# File: gpaw/utilities/hilbert.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_hilbert_analytic_transforms(x: numpy.ndarray):
    """gpaw.utilities.hilbert.analytic_transforms returns a pair of analytic example functions and their Hilbert transforms evaluated elementwise on a real-valued numpy array of sample points. This utility is intended for use in the GPAW code base (e.g., for testing and validating numerical Hilbert-transform routines used in DFT-related frequency-domain analyses and Kramers–Kronig relations) by providing known, closed-form transforms.
    
    The function evaluates four analytic functions at every entry of the input array x and returns two lists of numpy.ndarray: the first list contains the function values and the second list contains the corresponding Hilbert transforms in the same order. The four function/Hilbert-transform pairs (in order) are:
    - sin(x) and cos(x)
    - cos(x) and -sin(x)
    - sinc(x) = sin(x)/x (with the analytic limit 1 at x == 0) and (cos(x) - 1)/x (with the analytic limit 0 at x == 0)
    - 1/(1 + x**2) and -x/(1 + x**2)
    
    Args:
        x (numpy.ndarray): Real-valued sample points at which the analytic functions and their Hilbert transforms are evaluated. The input is used elementwise and the returned arrays have the same shape as x. The implementation uses numpy ufuncs and numpy.where to handle the x == 0 special cases for the sinc and its transform to avoid division by zero by substituting the analytic limits (1 and 0 respectively). The function expects a numpy.ndarray; passing other types is not guaranteed to behave identically and may raise an exception or produce unexpected results.
    
    Returns:
        tuple: A pair (func_l, hfunc_l) where func_l is a list of four numpy.ndarray objects containing the elementwise evaluations of the analytic functions listed above, and hfunc_l is a list of four numpy.ndarray objects containing their corresponding Hilbert transforms in the same index order. Each returned array has the same shape as the input x and elementwise numeric dtype determined by numpy operations. There are no side effects: the input array x is not modified. Failure modes include propagation of NaN or Inf values in x (these appear in the outputs according to numpy semantics) and potential exceptions if x is not a numpy.ndarray or does not support the required numpy operations.
    """
    from gpaw.utilities.hilbert import analytic_transforms
    return analytic_transforms(x)


################################################################################
# Source: gpaw.utilities.hilbert.hilbert_kernel_simple
# File: gpaw/utilities/hilbert.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_hilbert_hilbert_kernel_simple(n: int):
    """gpaw.utilities.hilbert.hilbert_kernel_simple constructs the discrete Hilbert-transform kernel in Fourier space for a grid of n points. It returns the array that represents the discrete Fourier transform of 1/x on a uniform grid and is intended for use in GPAW utilities that perform Hilbert transforms or analytic-signal operations via FFTs on real-space or reciprocal-space grids.
    
    Args:
        n (int): Number of grid points in the discrete transform. In the GPAW/FFT context this is the length of the one-dimensional uniform grid (number of Fourier frequencies). This integer determines the length of the returned kernel array and the placement of positive- and negative-frequency components: indices 1..(n/2 - 1) are set to +1j (positive-frequency quadrature), index 0 (the DC component) and, when n is even, index n/2 (the Nyquist component) remain zero, and indices (n/2 + 1)..(n - 1) are set to -1j (negative-frequency quadrature). The caller must provide an integer number of points appropriate for the FFT-based transform; supplying a non-integer type will raise a TypeError when creating the array and supplying a negative integer will raise a ValueError from numpy for invalid array size.
    
    Returns:
        numpy.ndarray: A complex-valued one-dimensional array of length n (dtype complex) containing the Hilbert kernel in Fourier-space. Practical significance: when multiplied with the Fourier transform of a real signal and inverse-transformed, this kernel implements the discrete Hilbert transform (shifting phases by +/−90 degrees for positive/negative frequencies). The function has no side effects and does not modify global state. For small n (for example n < 3) the kernel will be mostly zeros except for any indices that fall into the positive/negative-frequency ranges described above.
    """
    from gpaw.utilities.hilbert import hilbert_kernel_simple
    return hilbert_kernel_simple(n)


################################################################################
# Source: gpaw.utilities.hardware.hms
# File: gpaw/utilities/hardware.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_hardware_hms(secs: float):
    """gpaw.utilities.hardware.hms converts a time interval given in seconds into a three-component list representing hours, minutes and seconds, intended for human-readable timing and logging within the GPAW hardware/timing utilities.
    
    This utility computes hours by floor-dividing the input seconds by 3600, computes remaining whole minutes from the remainder, and computes seconds by taking the remaining fractional seconds and rounding to the nearest integer using the int(s + 0.5) rule. The function is pure (no side effects) and returns a short list of integers that callers can format for display in GPAW logs, test output, or timing summaries.
    
    Args:
        secs (float): Elapsed time in seconds as a floating-point value. This represents a total time interval (wall-clock or CPU seconds) produced by GPAW timing code and should normally be non-negative for conventional hour:minute:second semantics. The function performs arithmetic using Python's floor-division (//) and modulo (%) operators; if a non-numeric object is passed, those operators will raise a TypeError. There is no default value; secs must be supplied.
    
    Returns:
        list[int]: A list of three integers [hours, minutes, seconds].
            hours is computed as int(secs // 3600) and counts whole hours in the input.
            minutes is computed as int((secs % 3600) // 60) and counts whole minutes remaining after removing hours.
            seconds is computed as int((secs % 60) + 0.5), i.e., the remaining seconds rounded to the nearest integer.
            Note: rounding can produce 60 for the seconds component (for example when the fractional seconds are >= 59.5) and this function does not carry that overflow into minutes or hours; callers that require strictly normalized ranges (0 <= seconds <= 59 and 0 <= minutes <= 59) should perform additional normalization.
    
    Raises:
        TypeError: If secs does not support numeric floor-division and modulo operations (for example if a non-numeric object is provided), the underlying // and % operations will raise a TypeError.
    """
    from gpaw.utilities.hardware import hms
    return hms(secs)


################################################################################
# Source: gpaw.utilities.hilbert.hilbert_kernel_interpolate
# File: gpaw/utilities/hilbert.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_hilbert_hilbert_kernel_interpolate(n: int):
    """gpaw.utilities.hilbert.hilbert_kernel_interpolate constructs the discrete Hilbert transform kernel on a periodic grid of n points. The kernel produced is the discrete Hilbert transform of the linear interpolation kernel L(s) = (1 - |s|) Heaviside(1 - |s|), and is returned in the Fourier/spectral representation used by GPAW utilities for Hilbert-transform-based interpolation and convolution operations in DFT-related real-space grid routines.
    
    This function is used within the GPAW code base to generate a spectral operator that implements the Hilbert transform corresponding to a linear interpolation kernel. In practical terms, the returned array can be multiplied with the FFT of a sampled function on an n-point grid to apply the Hilbert-transform interpolation operator in spectral space. The implementation builds a compact finite-difference-like representation on the real-space grid, computes its discrete Fourier transform, and returns the Fourier-domain kernel scaled by -1/pi, consistent with the continuous Hilbert transform normalization used in GPAW utilities.
    
    Args:
        n (int): Number of grid points used to construct the discrete kernel. This integer specifies the length of the returned kernel array and determines the discrete sampling of the linear interpolation kernel L(s). n must be an integer scalar consistent with the grid size used in downstream FFT operations; passing non-integer types or values that are not valid grid sizes (for example, non-positive integers) will lead to errors in array construction or slicing.
    
    Returns:
        numpy.ndarray: A 1-D NumPy array of length n containing the spectral (Fourier-domain) representation of the discrete Hilbert kernel. The array elements are the discrete Fourier transform of the constructed real-space kernel scaled by -1/pi, so they are typically complex-valued and suitable for elementwise multiplication with FFTs of real-space data to perform the Hilbert transform. The function has no side effects (it does not modify global state or input arguments). If invalid input is provided (for example, n not an integer or n too small for the internal indexing), the function may raise built-in exceptions such as TypeError or IndexError during array construction or slicing.
    """
    from gpaw.utilities.hilbert import hilbert_kernel_interpolate
    return hilbert_kernel_interpolate(n)


################################################################################
# Source: gpaw.utilities.hilbert.hilbert
# File: gpaw/utilities/hilbert.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_hilbert_hilbert(
    f: numpy.ndarray,
    ker: numpy.ndarray = None,
    nfft: int = None,
    axis: int = 0,
    kerneltype: str = "interpolate",
    translate: float = 0
):
    """Compute the Hilbert transform of an array along a specified axis by
    performing a convolution with a Hilbert kernel in Fourier space.
    
    This utility is part of the gpaw.utilities package used within the GPAW
    density-functional-theory codebase for array-level operations that arise in
    DFT post-processing (for example, Fourier-domain convolutions of frequency-
    or grid-dependent response functions). The function computes the convolution
    via FFTs, optionally generating a Hilbert kernel appropriate for the chosen
    kerneltype, applying an optional (possibly non-integer) translation of the
    input along the transform axis, and returning the transformed array truncated
    to the original grid length along that axis.
    
    Args:
        f (numpy.ndarray): Input array to be transformed. The Hilbert transform is
            applied along the axis specified by the axis parameter. In GPAW this
            array typically represents a grid- or frequency-dependent quantity
            (e.g., a response function) that must be convolved with the Hilbert
            kernel. The input is passed to numpy.fft.fft, so it must be compatible
            with NumPy FFT routines; invalid types or an out-of-range axis will
            raise the corresponding NumPy exception (TypeError/IndexError).
        ker (numpy.ndarray): Precomputed Hilbert kernel sampled on the FFT grid.
            If provided, this array is used directly (after being reshaped in
            place to match the FFT grid length along the transform axis). The
            kernel must contain nfft elements along the transform axis; if its
            size is incompatible with the computed FFT grid shape, assigning
            ker.shape will raise a ValueError. If ker is None the function will
            generate a kernel by calling hilbert_kernel_<kerneltype>(nfft) using
            Python eval (e.g., hilbert_kernel_interpolate for kerneltype='interpolate'),
            so an invalid kerneltype or missing kernel factory function will raise
            a NameError or AttributeError.
        nfft (int): Number of grid points used for the FFT convolution. If nfft
            is larger than the length of f along the transform axis, f is zero-
            padded to length nfft along that axis before the FFT; if nfft is
            smaller, the first nfft elements along the axis are used (truncation,
            which can introduce aliasing). If None (the default), nfft is set to
            two times the length of f along the transform axis (2 * n), which is
            a common choice to reduce wrap-around from the circular convolution
            implied by FFTs.
        axis (int): Axis of f along which to perform the Hilbert transform.
            Passed directly to the FFT and IFFT calls. The axis index follows
            NumPy conventions (negative indices allowed). Providing an axis that
            is out of range for f will raise an IndexError from NumPy.
        kerneltype (str): Name of the kernel factory to use when ker is None.
            Must be one of the kernel implementations available in this module,
            currently expected values are 'interpolate' or 'simple' as used in
            the package. The function constructs the kernel by evaluating
            'hilbert_kernel_' + kerneltype and calling it with nfft. An unknown
            kerneltype or missing kernel factory will result in a NameError or
            AttributeError from the eval/call.
        translate (float): Number of grid points by which the input f should be
            shifted prior to convolution. This parameter can be non-integer; the
            shift is implemented in Fourier space by multiplying the kernel with
            exp(i * translate * 2*pi/nfft * k) factors (k is the centered discrete
            frequency index). translate=10 means the function transforms f(x + 10)
            instead of f(x). A translate of 0 applies no additional phase shift.
            Units are grid points on the FFT grid (not physical distance unless
            the caller maps grid indices to physical units).
    
    Returns:
        numpy.ndarray: Complex-valued array containing the Hilbert transform of f
        along the specified axis. The returned array has the same number of
        dimensions as f and the same shape except along the transform axis, where
        its length equals the original length n = f.shape[axis] (the function
        truncates the inverse FFT result to the first n elements along that axis).
        The dtype is determined by the FFT operations (typically a complex dtype).
        No in-place modification of f is performed, but if a ker array is provided
        it will be reshaped in place to match the internal FFT grid shape; callers
        that reuse ker should be aware of this side effect.
    
    Raises/Failure modes:
        TypeError: If argument types are incompatible with NumPy FFT routines or
            if nfft is not an integer when provided.
        IndexError: If axis is out of range for f.
        ValueError: If a provided ker cannot be reshaped to the required FFT grid
            shape (ker must have nfft elements along the transform axis).
        NameError/AttributeError: If kerneltype is invalid or the expected kernel
            factory function hilbert_kernel_<kerneltype> is not defined.
        MemoryError: For very large nfft, FFT arrays and temporary arrays may
            consume significant memory; callers should choose nfft mindful of
            computational and memory cost.
    
    Notes:
        The implementation performs the convolution by multiplication in Fourier
        space using numpy FFTs, which corresponds to a circular convolution with
        period nfft. To avoid wrap-around artifacts, choose nfft sufficiently
        large (the default 2*n helps reduce such artifacts). The translation is
        performed as a phase factor in Fourier space and is periodic on the FFT
        grid. This routine is intended for numerical Fourier-domain operations
        commonly encountered in GPAW post-processing and should be used with the
        same care regarding sampling, padding, and aliasing as any FFT-based
        convolution.
    """
    from gpaw.utilities.hilbert import hilbert
    return hilbert(f, ker, nfft, axis, kerneltype, translate)


################################################################################
# Source: gpaw.utilities.gl_quadrature.gaussLog
# File: gpaw/utilities/gl_quadrature.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_gl_quadrature_gaussLog(
    xmin: float,
    xmax: float,
    funct: int,
    ng: int = 10
):
    """Gauss quadrature integration on [xmin, xmax] tailored for integrands with a logarithmic singularity at x = xmin, used in GPAW for numerical integration tasks where a log singularity occurs at the lower integration boundary.
    
    This function evaluates a Gauss-type quadrature that accounts for a log singularity at the left endpoint of the integration interval. It maps precomputed logarithm-aware quadrature nodes and weights from module-level arrays (_nodesLog and _weightsLog) to the interval [xmin, xmax], calls the provided integrand at each mapped node, and returns the weighted sum multiplied by the interval length. It is used in GPAW numerical routines where integrals contain log(x - xmin)-type singular behavior and where accurate, fixed-order quadrature is required.
    
    Args:
        xmin (float): Left boundary of the integration domain. This is the location of the logarithmic singularity that the specialized quadrature is designed to handle. In typical GPAW use, xmin is the lower limit of an integral over a radial or energy-like variable. The function expects xmin to represent the actual lower endpoint; supplying xmin equal to xmax yields a zero-length interval (result effectively zero), and supplying xmin > xmax will produce a result scaled by the negative interval length (dx = xmax - xmin).
        xmax (float): Right boundary of the integration domain. This is the upper limit of integration. The integration interval is [xmin, xmax] and the returned value scales with dx = xmax - xmin. For meaningful quadrature results in GPAW contexts, xmax is normally greater than xmin.
        funct (int): Integrand function. The original signature annotates this parameter as int, and that annotation is preserved here; however, the implementation expects a callable: at runtime funct will be invoked as funct(x) for each quadrature node x and must return a numeric value (float or compatible numeric type). In GPAW usage, funct typically implements the integrand (for example, a radial or kernel function) that may have a logarithmic singularity at xmin. If a non-callable object is provided (including a bare integer), a TypeError will be raised when the code attempts to call it; if the callable returns non-numeric values, downstream numeric errors (TypeError or ValueError) may occur.
        ng (int): Gauss integration order (optional, default 10). This integer selects the quadrature order and therefore the number of nodes/weights used. The implementation clamps ng to the valid range defined by module-level constants _NGMIN and _NGMAX: ng = max(min(ng, _NGMAX), _NGMIN). The clamping ensures safe indexing into the precomputed arrays _nodesLog and _weightsLog. Typical GPAW use selects ng to balance accuracy and cost; increasing ng increases the number of calls to funct and thus computational cost roughly linearly in ng.
    
    Returns:
        float: The scalar numerical approximation of the integral over [xmin, xmax] of the provided integrand with the logarithmic singularity at xmin accounted for. Concretely, the function computes dx * sum(funct(x_i) * w_i) where dx = xmax - xmin, x_i are the mapped nodes taken from _nodesLog[ng-1] scaled to [xmin, xmax], and w_i are the corresponding weights from _weightsLog[ng-1]. The return value is a plain Python float (or a numeric type returned by the underlying operations) suitable for use in GPAW numerical workflows.
    
    Behavior and failure modes:
        - No persistent side effects: this function does not modify module-level arrays; it only reads _nodesLog and _weightsLog and calls the provided funct.
        - Performance cost is proportional to the effective quadrature order after clamping; the function makes one call to funct per node.
        - If the module-level constants or arrays (_NGMIN, _NGMAX, _nodesLog, _weightsLog) are missing or improperly sized, the function may raise NameError or IndexError. The clamping of ng is intended to prevent out-of-range indexing when the arrays are present with the expected sizes.
        - If funct is not callable or returns non-numeric values, the function will raise a TypeError or allow numeric operations to raise appropriate exceptions.
        - The function assumes the integrand's singular behavior is log-like at xmin; it is not a general-purpose singularity handler for other singularity types.
    """
    from gpaw.utilities.gl_quadrature import gaussLog
    return gaussLog(xmin, xmax, funct, ng)


################################################################################
# Source: gpaw.utilities.scalapack.pblas_symm
# File: gpaw/utilities/scalapack.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_scalapack_pblas_symm(
    alpha: float,
    a_MM: numpy.ndarray,
    b_MN: numpy.ndarray,
    beta: float,
    c_MN: numpy.ndarray,
    desca: tuple,
    descb: tuple,
    descc: tuple,
    side: str = "L",
    uplo: str = "L"
):
    """gpaw.utilities.scalapack.pblas_symm performs a distributed symmetric matrix–matrix product using the PBLAS/ScaLAPACK interface used in GPAW for parallel linear algebra. It wraps the corresponding PBLAS routines (pzsymm for complex matrices and pdsymm for real matrices) and applies the operation C <- alpha*A*B + beta*C when side == 'L', or C <- alpha*B*A + beta*C when side == 'R'. Only the lower or upper triangle of the symmetric matrix a_MM is read, as controlled by the uplo argument. This function is intended for use in GPAW workflows that rely on ScaLAPACK/BLACS distributed matrices and descriptors for parallel DFT/linear-algebra computations.
    
    Args:
        alpha (float): Scalar multiplier for the product term. In the mathematical operation C <- alpha*A*B + beta*C (or its right-side variant), alpha scales the matrix product. Typical use in GPAW is to scale contributions from matrix products when assembling or updating distributed matrices during parallel calculations.
        a_MM (numpy.ndarray): Distributed square symmetric matrix A with dimensions M x M stored in ScaLAPACK block-cyclic layout. Only the triangle specified by uplo ('L' or 'U') is referenced; the other triangle is ignored. This ndarray represents local blocks of the global distributed matrix as required by ScaLAPACK/BLACS conventions used in GPAW.
        b_MN (numpy.ndarray): Distributed general matrix B with dimensions M x N (if side == 'L') or N x M (if side == 'R'), stored in ScaLAPACK block-cyclic layout. This ndarray supplies the second operand of the matrix product; its local block layout must be compatible with the descriptors provided in descb.
        beta (float): Scalar multiplier for the existing C matrix. In the update C <- alpha*A*B + beta*C (or its right-side variant), beta scales the previous contents of C. Use 0.0 to overwrite C with the product, or 1.0 to accumulate into C.
        c_MN (numpy.ndarray): Distributed result matrix C with dimensions M x N, stored in ScaLAPACK block-cyclic layout. This ndarray is updated by the operation: its contents are overwritten or scaled and accumulated according to alpha and beta. The local layout must match the descriptor descc.
        desca (tuple): ScaLAPACK descriptor for a_MM. This descriptor tuple encodes the block-cyclic distribution, global dimensions, local leading dimension, BLACS context, block sizes, and other ScaLAPACK metadata required to interpret the local blocks of a_MM. It must be a valid descriptor compatible with the ScaLAPACK routines used by GPAW.
        descb (tuple): ScaLAPACK descriptor for b_MN. This descriptor must describe the block-cyclic distribution and layout of b_MN and be compatible with desca/descc and the BLACS context expected by the underlying PBLAS call.
        descc (tuple): ScaLAPACK descriptor for c_MN. This descriptor must describe the block-cyclic distribution and layout of c_MN and be consistent with the other descriptors and BLACS context used for the computation.
        side (str): Which side the symmetric matrix a_MM multiplies from. Must be 'L' to compute C <- alpha*A*B + beta*C where A is MxM and multiplies B on the left, or 'R' to compute C <- alpha*B*A + beta*C where A multiplies from the right. Default is 'L'. This parameter controls the order of multiplication and therefore the required shapes of a_MM and b_MN relative to c_MN.
        uplo (str): Which triangle of the symmetric matrix a_MM is referenced. Must be 'L' to use the lower triangle of a_MM, or 'U' to use the upper triangle. Default is 'L'. Only the specified triangular part is read; the other part may contain arbitrary data and is ignored.
    
    Returns:
        numpy.ndarray: The updated distributed result matrix c_MN. The function returns the ndarray object corresponding to the distributed matrix C (typically the same object passed in as c_MN, whose local blocks have been modified in-place by the operation). This return value provides the updated distributed matrix in the ScaLAPACK block-cyclic layout described by descc.
    
    Behavior, side effects, and failure modes:
        This function delegates to the appropriate PBLAS routine depending on the element type of the provided numpy ndarrays: pzsymm is used for complex dtypes and pdsymm for real dtypes, matching ScaLAPACK/PBLAS conventions used in GPAW. The operation updates c_MN in-place (local blocks are modified), and the returned ndarray refers to the updated distributed matrix. All descriptor tuples (desca, descb, descc) must be valid ScaLAPACK descriptors describing the same BLACS context and compatible global dimensions and block sizes; inconsistent descriptors, incompatible array shapes, mismatched data types between inputs, or an uninitialized BLACS/ScaLAPACK context will typically result in an error (for example, ValueError or a lower-level error propagated from the ScaLAPACK/PBLAS layer). The function only reads the triangular part of a_MM specified by uplo; supplying inconsistent data in the unused triangle will not affect the result. Use this routine when performing parallel symmetric matrix multiplications within GPAW workflows that rely on ScaLAPACK for distributed dense linear algebra.
    """
    from gpaw.utilities.scalapack import pblas_symm
    return pblas_symm(alpha, a_MM, b_MN, beta, c_MN, desca, descb, descc, side, uplo)


################################################################################
# Source: gpaw.utilities.blas.gpu_gemm
# File: gpaw/utilities/blas.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_blas_gpu_gemm(
    alpha: float,
    a: numpy.ndarray,
    b: numpy.ndarray,
    beta: float,
    c: numpy.ndarray,
    transa: str = "n"
):
    """General Matrix Multiply executed on GPU for GPAW internal linear algebra.
    
    Performs the blocked/general matrix multiplication and accumulation used throughout GPAW's linear-algebra kernels and DFT routines. The operation performed is
    c <- alpha * (b.a) + beta * c
    where the binary operation (b.a) depends on the value of transa (see below). This function is a thin Python wrapper that forwards raw array pointers to the low-level cgpaw.gemm_gpu routine; it is intended to accelerate BLAS-level GEMM operations on GPU hardware within GPAW's numerical workflows (for example, updates of block matrices or application of operators in plane-wave/real-space representations).
    
    Behavior and practical significance:
    This function multiplies and accumulates multi-dimensional arrays used in GPAW's matrix algebra. The layout conventions and contiguity requirements are important for correct and efficient GPU execution: the arrays are expected to expose C-contiguous memory and a .data.ptr pointer (used by the underlying cgpaw.gemm_gpu call). When used with debug checks enabled in the GPAW build (global debug flag True), a number of assertions verify dtype, contiguity, and shape compatibility and will raise AssertionError on mismatch. On success the result is written in-place into c; the function does not return a new array.
    
    Index definitions of b.a:
    If transa == 'n', b.a denotes the matrix multiplication with implicit summation over index p:
    (b.a)_{ijkl...} = sum_p b_{ip} * a_{pjkl...}
    This corresponds to multiplying a 2-D matrix b on the left of a possibly higher-rank array a when a is treated with its first axis as the contracted dimension.
    
    If transa == 't' or transa == 'c', b.a denotes the multiplication
    (b.a)_{ij} = sum_{klm...} b_{iklm...} * a_{jklm...}
    and if transa == 'c' the complex conjugate of a is taken before contraction. This mode is used when b and a share trailing dimensions and the contraction is over those trailing dimensions.
    
    Args:
        alpha (float): Scalar multiplier applied to the product (b.a). In GPAW workflows this typically scales the contribution coming from a matrix product before accumulation into c. When arrays have float dtype, alpha is required to be a Python float (this is asserted in debug builds).
        a (numpy.ndarray): Left or right operand array for the contraction. Must be a numpy.ndarray exposing a .data.ptr pointer used by the GPU backend. Required C-contiguity: a.flags.c_contiguous must be True. Its shape is constrained relative to b and c (see shape and contiguity rules below). In GPAW this array often represents a block of coefficients, wave-function components or operator blocks.
        b (numpy.ndarray): The other operand array for the contraction; treated as a 2-D matrix when transa == 'n' or as an array sharing trailing dimensions with a when transa == 't' or 'c'. Must be a numpy.ndarray exposing .data.ptr. For transa == 'n' b is required to be 2-D and have contiguous columns (b.strides[1] == b.itemsize). For transa != 'n' either b.size == 0 or each b[0] must be C-contiguous (this follows the debug-time assertions).
        beta (float): Scalar multiplier applied to the existing contents of c before accumulation. Used to scale the prior contents of c as in the standard BLAS GEMM semantics. When arrays have float dtype, beta is required to be a Python float (this is asserted in debug builds).
        c (numpy.ndarray): Output array overwritten in-place with the result of the operation. The array must be a numpy.ndarray exposing .data.ptr. The function updates c to alpha*(b.a) + beta*c; no new array is allocated. Contiguity and stride requirements depend on transa (see shape and contiguity rules below). In GPAW this array typically stores updated blocks of matrices or density-related tensors.
        transa (str): Specifies the contraction mode and interpretation of a in the product. Allowed values are:
            'n' (default): interpret b as a 2-D matrix on the left and contract b's second axis with a's first axis.
            't': contract over trailing dimensions of a and b as described above (no complex conjugation of a).
            'c': same as 't' but take the complex conjugate of a before contraction.
          The default value is 'n'. The choice controls both the index pattern used for multiplication and contiguity/shape expectations.
    
    Shape and contiguity rules (enforced in debug builds):
        When transa == 'n':
            - a.flags.c_contiguous must be True.
            - b must be 2-D and have contiguous columns: b.ndim == 2 and b.strides[1] == b.itemsize.
            - c must be C-contiguous or have 2 dimensions with contiguous columns: c.flags.c_contiguous or (c.ndim == 2 and c.strides[1] == c.itemsize).
            - Shapes must satisfy a.shape[0] == b.shape[1].
            - The output shape must satisfy c.shape == b.shape[0:1] + a.shape[1:].
        When transa == 't' or transa == 'c':
            - Either b.size == 0 or b[0].flags.c_contiguous must be True.
            - c must have contiguous columns: c.strides[1] == c.itemsize.
            - Trailing dimensions of a and b must match: a.shape[1:] == b.shape[1:].
            - Shapes must satisfy c.shape == (b.shape[0], a.shape[0]).
        Dtype compatibility:
            - Either all of a, b, c have dtype float (in which case alpha and beta are expected to be Python floats in debug builds) or all of a, b, c have dtype complex. These dtype combinations are asserted when the global debug flag is enabled.
    
    Side effects and implementation details:
        - The result is written in-place into c; no array is returned.
        - The function forwards raw data pointers (a.data.ptr, b.data.ptr, c.data.ptr), shapes, and dtype to the low-level cgpaw.gemm_gpu implementation which performs the GPU-accelerated computation.
        - If the global GPAW debug flag is True, input validation is performed and AssertionError will be raised on dtype/shape/contiguity mismatches. If debug is False, these checks are skipped and malformed inputs may produce incorrect results or cause errors in the underlying cgpaw library.
        - Errors originating from the underlying cgpaw.gemm_gpu call (for example, GPU execution failures, memory errors, or bindings errors) propagate as exceptions raised by that native layer.
    
    Returns:
        None: The function does not return a value. The computed result replaces the contents of the provided c array in-place (c is mutated to contain alpha*(b.a) + beta*c).
    """
    from gpaw.utilities.blas import gpu_gemm
    return gpu_gemm(alpha, a, b, beta, c, transa)


################################################################################
# Source: gpaw.utilities.scalapack.scalapack_tri2full
# File: gpaw/utilities/scalapack.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_scalapack_scalapack_tri2full(
    desc: tuple,
    array: numpy.ndarray,
    conj: bool = True
):
    """Write the lower triangular part of a ScaLAPACK-distributed matrix into its upper triangular part so that the full matrix becomes symmetric or Hermitian.
    
    This function is used in GPAW's ScaLAPACK utilities when a distributed routine produces only the lower-triangular half of a matrix (common in parallel linear-algebra workflows such as distributed eigenvalue or density-matrix construction) and the full matrix (symmetric or Hermitian) is required. The implementation is an explicit three-step procedure: zero the current upper triangle, copy the local array, clear the diagonal in the copy, and then transpose-add the copy into the original array. This produces A := A + transpose_or_conjtranspose(A_with_zero_diag) so that the lower-triangular data are reflected into the upper triangle.
    
    Args:
        desc (tuple): ScaLAPACK descriptor tuple that describes the distributed matrix layout. This descriptor is passed unchanged to the underlying ScaLAPACK helper routines (scalapack_zero, scalapack_set, pblas_tran) and therefore must follow the ScaLAPACK descriptor conventions expected by those routines in GPAW. The descriptor controls how the global matrix is distributed across MPI processes and is essential for correct communication and indexing when copying and transposing blocks.
        array (numpy.ndarray): Local portion of the distributed matrix stored on the current process. This NumPy array is modified in place: its original upper triangle is first zeroed and then the transposed (or conjugate-transposed) lower-triangular data are added into it so that the full matrix is reconstructed. The array must be compatible with the provided desc and with the ScaLAPACK helper routines; mismatches between desc and array layout can cause underlying library errors.
        conj (bool): If True (default), the lower triangular part is added into the upper triangular part using the complex conjugate transpose (Hermitian completion). If False, a plain transpose is used (symmetric completion). Use True when the original matrix is Hermitian and lower-triangular entries represent conjugate pairs; use False for real symmetric matrices or when conjugation is not wanted.
    
    Returns:
        None: The function does not return a value. Instead, it modifies the provided array in place so that its upper triangle contains the reflected lower-triangular data (with or without conjugation as controlled by conj). Side effects include allocation of a temporary copy of the local array (buf) and calls to the ScaLAPACK/BLACS helper routines scalapack_zero, scalapack_set, and pblas_tran, which may perform inter-process communication in a parallel run.
    
    Behavior, side effects and failure modes:
        The function performs these concrete steps in order: (1) zero the matrix upper triangle in place via scalapack_zero(desc, array, 'U'); (2) make a local copy of array into buf; (3) set the diagonal of buf to zero via scalapack_set(desc, buf, alpha=0.0, beta=0.0, uplo='U'); (4) call pblas_tran to add the (conjugate-)transpose of buf into array. Because of the copy and the explicit transpose-add, this implementation may allocate additional temporary memory and incur extra communication compared to a specialized ScaLAPACK routine that directly fills the full matrix.
        The function relies on the underlying ScaLAPACK helper routines to validate desc and array. Errors raised by those routines (for example, due to an invalid descriptor tuple, incompatible local array shape, or missing ScaLAPACK/BLACS/ScaLAPACK libraries when running in a parallel environment) are propagated to the caller. If array is not a numpy.ndarray or desc is not a tuple, the function may raise a TypeError or a related error from the underlying helpers. Use this function only when the matrix distribution and local array layout conform to the ScaLAPACK conventions used in GPAW.
    """
    from gpaw.utilities.scalapack import scalapack_tri2full
    return scalapack_tri2full(desc, array, conj)


################################################################################
# Source: gpaw.utilities.tools.dagger
# File: gpaw/utilities/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_tools_dagger(a: numpy.ndarray, copy: bool = True):
    """gpaw.utilities.tools.dagger — Return Hermitian conjugate of input array
    
    Compute the Hermitian conjugate (conjugate transpose) of a NumPy array. In the GPAW codebase (a DFT/PAW/ASE-based electronic-structure package), this operation is commonly used in linear-algebra manipulations such as forming bra/kets, overlap matrices, and conjugate-transpose operations on coefficient or operator matrices. By default the function returns a new NumPy array containing the conjugated transpose. For performance-sensitive internal code paths, an in-place variant is available that may overwrite the original array memory (use with care).
    
    Args:
        a (numpy.ndarray): Input array whose Hermitian conjugate is desired. This should be a NumPy ndarray (commonly a 2-D matrix representing coefficients or operators in GPAW workflows). The function uses a.T to transpose the array and applies complex conjugation to produce the Hermitian conjugate. The array's dtype determines whether an in-place negation of the imaginary part is performed when copy is False: if the dtype compares equal to the Python complex type (e.g., complex64/complex128), the imaginary part is negated in-place; otherwise no element-wise conjugation is applied in-place.
        copy (bool, optional): If True (default), return a new array containing the Hermitian conjugate computed as numpy.conj(a.T). This allocates and returns a separate ndarray and leaves the original array unmodified. If False, attempt to avoid allocation by returning the transpose view a.T and, when a.dtype == complex, negating the view's imaginary part in-place (a.imag *= -1). Using copy=False is faster and reduces memory usage but may overwrite the original array data and can raise exceptions if the array is not writable or if the memory layout prevents an in-place modification.
    
    Returns:
        numpy.ndarray: The Hermitian conjugate of the input. If copy is True, this is a newly allocated ndarray equal to numpy.conj(a.T) and the original array is unchanged. If copy is False, this is the transposed view of the original array (a.T); for complex dtypes the imaginary parts have been negated in-place so the returned view represents the conjugate transpose but the underlying original array memory may have been modified. Possible side effects include modification of the original array and allocation avoidance; possible failure modes include exceptions raised when attempting in-place modification on read-only or non-writable arrays or when the input is not a NumPy ndarray.
    """
    from gpaw.utilities.tools import dagger
    return dagger(a, copy)


################################################################################
# Source: gpaw.utilities.tools.cutoff2gridspacing
# File: gpaw/utilities/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_tools_cutoff2gridspacing(E: float):
    """gpaw.utilities.tools.cutoff2gridspacing converts a plane-wave kinetic energy cutoff to the equivalent real-space uniform grid spacing used in GPAW real-space calculations.
    
    Args:
        E (float): Plane-wave kinetic energy cutoff expressed in electronvolts (eV). In GPAW and ASE units, energies are given in eV (for example, PW(300) corresponds to E = 300.0). This scalar controls the maximum plane-wave kinetic energy included in a plane-wave expansion and therefore determines the shortest wavelength (largest reciprocal-space vector) that must be resolved on the real-space grid.
    
    Returns:
        float: Real-space grid spacing (distance) in Ångström (Å). The returned value is computed from the relation grid_spacing = pi / G_max with G_max = sqrt(2 * E / Hartree) in atomic units, and then converted to Å by multiplying with the Bohr radius constant. This spacing is the recommended uniform grid spacing for representing wave functions or densities in real-space when using a plane-wave cutoff E in GPAW.
    
    Notes:
        - Practical significance: This function is used when converting a plane-wave cutoff energy (commonly specified for PW mode or for comparing plane-wave and real-space resolutions) into a compatible real-space mesh spacing for GPAW calculations, grid convergence tests, or preparing real-space operators.
        - Behavior and formula: The implementation evaluates numpy.pi / numpy.sqrt(2 * E / Hartree) * Bohr, where Hartree and Bohr are GPAW constants used to convert between eV and atomic units and between atomic length units and Å respectively.
        - Input requirements and failure modes: E must be a positive, finite float. If E == 0.0 the function yields an infinite grid spacing (division by zero in the mathematical expression); if E < 0.0 the square root becomes imaginary and the computation yields NaN (with a runtime warning). Passing a non-float or non-scalar value that does not behave like a float may raise a TypeError or produce undefined results; the function signature documents E as a float.
        - Side effects: None. The function is pure and does not modify global state or I/O.
        - Defaults: There is no default value; E must be provided.
    """
    from gpaw.utilities.tools import cutoff2gridspacing
    return cutoff2gridspacing(E)


################################################################################
# Source: gpaw.utilities.tools.gram_schmidt
# File: gpaw/utilities/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_tools_gram_schmidt(U: numpy.ndarray):
    """gpaw.utilities.tools.gram_schmidt: Orthonormalize the columns of a matrix U in-place using the classical Gram-Schmidt procedure.
    
    This function implements the classical Gram-Schmidt algorithm to produce a set of orthonormal column vectors from the columns of the input array U. In the context of GPAW (a density-functional theory code that works with wavefunction coefficient matrices, basis-function coefficients, and real-space discretizations), this routine is used to convert a collection of (possibly non-orthogonal) vectors into an orthonormal basis suitable for subsequent linear-algebra operations such as projections, subspace diagonalization, or construction of orthonormalized wavefunctions. The implementation uses the complex-conjugate inner product (numpy.dot(col2.conj(), col)) and normalizes with numpy.linalg.norm, so it supports real or complex-valued arrays.
    
    Args:
        U (numpy.ndarray): A writable NumPy array whose columns are the vectors to be orthonormalized. The function expects U to be a two-dimensional array with shape (n, m) where each column 0..m-1 is a length-n vector. The function operates in-place: the columns of U are modified so that after the call they are orthonormal with respect to the standard complex inner product (conjugate on the first argument). The array must be mutable and have a numeric dtype (real or complex). No new array is returned.
    
    Behavior and side effects:
        The algorithm iterates over columns from left to right. For each column i it subtracts its projections onto all previously processed (and already orthonormalized) columns 0..i-1, and then divides by its Euclidean norm to enforce unit length. Because the routine modifies U in-place, any references to the original array will observe the orthonormalized columns after the call. The routine uses classical Gram-Schmidt (not the numerically more stable modified Gram-Schmidt or a QR factorization), so in cases of nearly linearly dependent columns numerical orthogonality may be lost due to round-off error.
    
    Failure modes and warnings:
        If a column becomes or is (near) the zero vector after projection, the division by its norm will involve zero and will produce infinities or NaNs and/or raise a runtime warning; the function does not explicitly check for zero norms or raise exceptions. For highly ill-conditioned or nearly linearly dependent sets of vectors, consider applying a numerically stable alternative (for example, QR decomposition using numpy.linalg.qr) outside this function. The function assumes U is two-dimensional and writable; passing arrays that violate these assumptions may lead to errors from NumPy.
    
    Returns:
        None: The function returns None and communicates its result via an in-place modification of the input array U. After the call, the columns of U are intended to be mutually orthogonal and of unit norm with respect to the complex inner product, subject to the numerical limitations described above.
    """
    from gpaw.utilities.tools import gram_schmidt
    return gram_schmidt(U)


################################################################################
# Source: gpaw.utilities.tools.normalize
# File: gpaw/utilities/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_tools_normalize(U: numpy.ndarray):
    """Normalize columns of U.
    
    This function normalizes each column vector of the input array U in place using the Euclidean (L2) norm. In the GPAW DFT codebase (which represents physical quantities such as wavefunction coefficient matrices, basis-function coefficients, or other column-wise vector sets as NumPy arrays), this utility ensures each column has unit length, which is often required before or after linear-algebra operations (for example, when preparing coefficient matrices for orthonormalization, projection, or numerical stabilization in plane-wave, atom-centered, or real-space grid representations).
    
    Args:
        U (numpy.ndarray): Array whose columns are treated as vectors to normalize. For a typical 2-D array of shape (M, N), each of the N column vectors of length M is divided in place by its Euclidean norm computed with numpy.linalg.norm. The function operates by iterating over U.T and performing in-place division on each column view, so U is modified directly; no copy is returned. It is intended for floating-point arrays representing collections of column vectors (e.g., wavefunction coefficient matrices). If U has integer dtype, in-place true division by a float norm will raise a NumPy casting error. For arrays with nonstandard shapes (e.g., 1-D arrays, higher-rank arrays), behavior follows NumPy iteration semantics but may not correspond to column-wise normalization and should be used with care.
    
    Returns:
        None: The function does not return a new array. Instead, it has the side effect of normalizing the columns of U in place. After the call, each column that had a nonzero Euclidean norm will have unit L2 norm. Columns with zero norm will cause division by zero, producing Inf or NaN entries (and possibly runtime warnings); callers should check for and handle zero-norm columns before calling this function when such cases are possible.
    """
    from gpaw.utilities.tools import normalize
    return normalize(U)


################################################################################
# Source: gpaw.utilities.timelimit.time_to_seconds
# File: gpaw/utilities/timelimit.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_timelimit_time_to_seconds(timestr: str):
    """Convert gpaw.utilities.timelimit.time_to_seconds input to a number of seconds.
    
    This function is used in GPAW (a DFT/PAW code) to normalize user-specified time limits or timeout specifications into a single floating-point value representing seconds. It accepts either a numeric value (interpreted directly as seconds) or a formatted time string and returns the total elapsed time in seconds as a float so that other parts of the GPAW code (for example job scheduling, timeouts for calculations, or logging) can perform numeric comparisons and arithmetic.
    
    Args:
        timestr (float or string): Time specified either as a numeric value (e.g. 3600 or "3600.5") which is interpreted directly as seconds, or as a formatted string in one of the supported patterns: 'DD-HH:MM:SS', 'HH:MM:SS', 'MM:SS', or 'SS'. When a numeric value or a numeric string is provided, the function returns its float conversion (preserving fractional seconds). When a formatted string is provided, the function splits days from the remainder using a single '-' (days must be an integer) and splits hours/minutes/seconds by ':'; each component in the colon-separated part is parsed with int(), so only integer components are accepted in those fields. Examples: '1-00:00:30' => 86430.0, '02:30' => 150.0, '45' => 45.0. The function does not modify the input argument.
    
    Returns:
        float: Total time in seconds as a floating-point number. If the input was a numeric value or a numeric string, the returned float preserves any fractional seconds. If the input was a colon/dash-formatted string, the returned value is computed by converting day, hour, minute, and second components to seconds and summing them (days*86400 + hours*3600 + minutes*60 + seconds). There are no side effects; the function is pure.
    
    Raises:
        ValueError: If the input is a non-numeric string that cannot be parsed as a float and contains non-integer components in the colon-separated fields (for example '1-00:00:3.5' or non-digit characters in components), or if integer conversion of components fails.
        AssertionError: If the string contains more than one '-' segment (the code expects at most one day separator).
        TypeError: If the input type cannot be handled by float() (for example None); this propagates because only ValueError is explicitly caught when attempting float conversion.
    
    Notes:
        - Fractional seconds are supported only when the entire input is a numeric value or a numeric string that float() accepts. The parsed 'DD-HH:MM:SS' / 'HH:MM:SS' / 'MM:SS' formats require integer components.
        - The allowed formats and strict parsing behavior are intended to provide unambiguous time limits for job-control and timeout logic in GPAW, which may be used in parallel or batch execution contexts described in the GPAW README.
    """
    from gpaw.utilities.timelimit import time_to_seconds
    return time_to_seconds(timestr)


################################################################################
# Source: gpaw.utilities.tools.symmetrize
# File: gpaw/utilities/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_tools_symmetrize(matrix: numpy.ndarray):
    """Symmetrize input matrix by replacing it with its Hermitian (conjugate-transpose) average.
    
    This function is used in GPAW (a DFT code) to enforce the physical requirement that many operator matrices
    (e.g., Hamiltonian, density matrix, overlap) are Hermitian (for complex-valued arrays) or symmetric
    (for real-valued arrays). It performs the operation matrix <- (matrix + matrix^†) / 2 in-place, where
    matrix^† is the conjugate transpose of matrix (computed by dagger(matrix) in the source). The implementation
    uses NumPy in-place operations (numpy.add and numpy.multiply) to avoid extra allocations, which is important
    for large matrices common in plane-wave, real-space, or atom-centered basis computations in GPAW.
    
    Args:
        matrix (numpy.ndarray): The input array to be symmetrized. This should be a square 2-D NumPy array
            representing a matrix stored in GPAW as an operator or similar quantity. The function treats the
            array as a matrix A and replaces its contents with (A + A^†)/2, where A^† is the conjugate
            transpose. The operation is performed in-place: the original array object is overwritten and no
            separate copy is returned. The dtype and shape of the array are preserved by the in-place operations.
            Passing a non-square array will generally lead to a NumPy error due to shape mismatch when computing
            the conjugate transpose. Passing a non-NumPy object or an array-like structure that does not support
            the required NumPy ufuncs may raise TypeError or produce undefined behavior.
    
    Returns:
        numpy.ndarray: The same array object passed in as matrix, now containing the symmetrized result
        (A_sym = (A + A^†)/2). Returning the same object allows callers in GPAW to continue using the original
        reference without an additional assignment. The primary side effect is the in-place modification of the
        provided array; no new array is allocated for the result.
    
    Raises:
        ValueError: If the conjugate-transpose of matrix has a shape that is incompatible with matrix
            (for example, if matrix is not 2-D square), NumPy operations will raise a ValueError.
        TypeError: If matrix is not a NumPy ndarray or does not support the in-place NumPy ufuncs used,
            a TypeError or similar exception may be raised.
    """
    from gpaw.utilities.tools import symmetrize
    return symmetrize(matrix)


################################################################################
# Source: gpaw.utilities.tools.split_formula
# File: gpaw/utilities/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_tools_split_formula(formula: str):
    """gpaw.utilities.tools.split_formula: Expand a chemical formula string into a flat list of element symbols by repeating each element according to its numeric count. This function is used in GPAW utilities to translate simple chemical formulas (used e.g. in tests, quick input parsing, or stoichiometry checks) into an explicit list of atom symbols that can be passed to ASE/GPAW routines that expect per-atom entries.
    
    Args:
        formula (str): Chemical formula to parse, expressed as a contiguous string of element symbols and counts. Element symbols must begin with an uppercase ASCII letter and may include one or more lowercase ASCII letters immediately following (e.g. 'C', 'Mg', 'He'). Counts are represented by non-letter characters encountered after an element symbol; the character is evaluated with Python's eval() and interpreted as the total multiplicity for the immediately preceding element. Because the implementation appends the element once when its symbol is first parsed, a numeric count n will result in n total occurrences of that element (the code performs an extend with (eval(c) - 1) additional copies). The function processes the input left-to-right without permitting separators or whitespace; any characters that are not ASCII letters are passed to eval() and therefore must be valid Python expressions that evaluate to integers. Example valid input: 'C2H3Mg' -> expands to two 'C', three 'H', and one 'Mg'.
    
    Returns:
        list[str]: A flat list of element symbols (strings) in the order they appear in the formula, with each symbol repeated according to its multiplicity. For example, split_formula('C2H3Mg') returns ['C', 'C', 'H', 'H', 'H', 'Mg'].
    
    Behavior, defaults, and failure modes:
        - The function has no side effects and does not modify external state.
        - It treats any uppercase letter as the start of a new element symbol and appends following lowercase letters to that symbol.
        - Counts are applied per non-letter character encountered; the implementation expects counts to be single-character expressions (for multi-character numbers like '10' each character is processed separately and will not yield the intended result).
        - If the formula begins with a lowercase letter or a count (so there is no previous element), accessing the previous element will raise an IndexError.
        - If a non-letter character is not a valid Python expression that evaluates to an integer, eval() will raise a SyntaxError, NameError, ValueError, or another exception; such exceptions are propagated to the caller.
        - Because the function uses eval() on characters from the input string, passing untrusted input can be a security risk; do not call this function on untrusted data without sanitization or replacing eval() with a safe numeric parser.
        - The function assumes ASCII letters for element parsing and does not perform chemical validation (it does not verify that parsed symbols correspond to real elements).
    """
    from gpaw.utilities.tools import split_formula
    return split_formula(formula)


################################################################################
# Source: gpaw.utilities.tools.lowdin
# File: gpaw/utilities/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_tools_lowdin(U: numpy.ndarray, S: numpy.ndarray = None):
    """gpaw.utilities.tools.lowdin orthonormalizes the columns of a coefficient matrix U using the Löwdin (symmetric) orthogonalization procedure. In the GPAW density-functional-theory (DFT) context this is used to convert a set of non-orthogonal basis-function coefficient vectors or molecular-orbital coefficient columns into a symmetric orthonormal set suitable for subsequent linear-algebra operations (for example, when working with PAW projector/basis representations or overlap-corrected coefficient sets).
    
    If an overlap matrix S is provided it is used directly; otherwise the overlap is formed from U as S = dagger(U) @ U, where dagger denotes the conjugate-transpose used elsewhere in GPAW. The implementation computes the Hermitian eigen-decomposition of S, forms the symmetric inverse square root of S from the eigenvectors and eigenvalues, and left-multiplies U by that inverse square root so that the columns of U become orthonormal with respect to the standard inner product.
    
    Args:
        U (numpy.ndarray): 2-D array whose columns represent the vectors to be orthonormalized. This array is modified in-place: after the call the columns of U are Löwdin-orthonormalized. In GPAW workflows U typically contains basis-function coefficients or orbital expansion coefficients; the function operates directly on these coefficient matrices so no copy is returned.
        S (numpy.ndarray): Overlap matrix corresponding to the columns of U. If provided, S is used as the Hermitian overlap matrix in the Löwdin procedure. Default: None, in which case S is computed internally as dagger(U) @ U (the conjugate-transpose of U multiplied by U). S must be a Hermitian (symmetric) matrix consistent with U for correct results.
    
    Returns:
        None: The function does not return a value. Instead, it has the side effect of overwriting the contents of U with its Löwdin-orthonormalized columns. This in-place update is used in GPAW to avoid extra memory allocation when preparing orthonormal coefficient sets.
    
    Raises:
        numpy.linalg.LinAlgError: Raised by numpy.linalg.eigh if the provided or computed S is not valid for eigen-decomposition.
        RuntimeWarning or numerical errors: If S is singular or has zero or negative eigenvalues, forming the inverse square root involves division by zero or by the square root of non-positive eigenvalues and will produce NaNs or infinities; callers should ensure S is positive definite (or regularize small eigenvalues) before calling in numerical workflows.
    """
    from gpaw.utilities.tools import lowdin
    return lowdin(U, S)


################################################################################
# Source: gpaw.utilities.tools.pick
# File: gpaw/utilities/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_tools_pick(a_ix: numpy.ndarray, i: numpy.ndarray):
    """gpaw.utilities.tools.pick selects either a single entry along the first axis of a NumPy array or computes a linear combination of the slices along the first axis. This utility is used in GPAW's data-manipulation code to extract per-index data (for example, a specific band, projector, or grid component) or to form weighted sums over that axis (for example, applying coefficients or projections to combine contributions from several indices).
    
    Args:
        a_ix (numpy.ndarray): Input array whose first dimension indexes a set of vectors or blocks. In GPAW this commonly corresponds to an indexable collection such as per-index quantities (bands, projectors, etc.). The function treats a_ix as having shape (N, ...), where N = a_ix.shape[0]. The returned value is assembled from the elements along this first axis without modifying a_ix (no in-place changes are performed).
        i (numpy.ndarray): 1-D array of numeric coefficients with length N used to form a linear combination of the N elements along the first axis of a_ix. Alternatively, i may be an int (scalar) as handled by the implementation: if i is an int, it is interpreted as an index into the first axis and the corresponding element a_ix[i] is returned. When i is a numpy.ndarray, it must be broadcast-compatible so that the dot product with a_ix reshaped to (N, -1) is valid; in practice i should have exactly length N.
    
    Returns:
        numpy.ndarray: If i is an int, returns the slice a_ix[i], which has shape equal to a_ix.shape[1:]. If i is a 1-D numpy.ndarray of coefficients of length N, returns the weighted linear combination sum_k i[k] * a_ix[k] with shape a_ix.shape[1:]. The returned array is a new NumPy array view or copy produced by the dot and reshape operations; callers should not rely on it being a view of the original a_ix.
    
    Behavior, defaults, and failure modes:
        - The function treats the first axis of a_ix as the index axis (length N) and operates on the remaining axes as the data block to return or combine.
        - No in-place modification of a_ix or i is performed.
        - If i is an int that is out of bounds for the first axis, indexing will raise IndexError.
        - If i is not an int and not a 1-D sequence of numeric coefficients compatible with the first axis length N, NumPy operations (for example, numpy.dot or reshape) will raise ValueError or TypeError (e.g., shape mismatch or non-numeric types).
        - The function relies on NumPy semantics for dot and reshape; any NumPy-supported numeric type for a_ix and numeric-coercible types for i are acceptable as long as the shapes are compatible.
    """
    from gpaw.utilities.tools import pick
    return pick(a_ix, i)


################################################################################
# Source: gpaw.utilities.tools.project
# File: gpaw/utilities/tools.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_utilities_tools_project(a: numpy.ndarray, b: numpy.ndarray):
    """gpaw.utilities.tools.project computes the component of the numpy array b along the direction of the numpy array a as implemented in GPAW utilities for operations such as projecting one wavefunction or coefficient vector onto another in density-functional-theory (DFT) workflows.
    
    Args:
        a (numpy.ndarray): Reference vector onto which b is projected. In GPAW this typically represents a wavefunction, orbital coefficient vector, or other complex/real vector in the same finite-dimensional vector space; the function uses a.conj() so a may be complex-valued. The shape of a should match the shape of b (commonly 1-D arrays of the same length). If a is the zero vector (norm zero) the result is undefined (see Failure modes). This argument is not modified by the function.
        b (numpy.ndarray): Vector being projected onto a. In GPAW contexts b often represents another wavefunction, state, or coefficient vector whose component along a is required (for overlaps, projections, or component extraction). The shape must be compatible with a for numpy.dot(a.conj(), b) to produce a scalar; mismatched shapes will cause a numpy error. This argument is not modified by the function.
    
    Returns:
        numpy.ndarray: The resulting numpy array equal to a * (numpy.dot(a.conj(), b) / numpy.linalg.norm(a)). This is the vector in the direction of a whose magnitude equals the inner product of a.conj() with b divided by the Euclidean norm of a. Note that this is proportional to the standard orthogonal projection of b onto the span of a: the standard orthogonal projection is a * (numpy.dot(a.conj(), b) / numpy.dot(a.conj(), a)) = a * (numpy.dot(a.conj(), b) / (numpy.linalg.norm(a)**2)), so the value returned by this function is the standard projection multiplied by numpy.linalg.norm(a). No in-place modification of a or b occurs; a new numpy.ndarray is returned.
    
    Behavior, significance, and failure modes:
        The function computes the complex (or real) inner product between a and b using a.conj() to handle complex conjugation appropriate for quantum-mechanical objects (e.g., wavefunctions) used throughout GPAW. It then divides that scalar by numpy.linalg.norm(a) and scales a by the result. Computational cost is O(N) for length-N vectors dominated by the dot product and norm computation. If a has zero Euclidean norm, division by zero will occur: NumPy will typically emit a RuntimeWarning and produce inf or NaN values, so the output is undefined in this case. If a and b have incompatible shapes for numpy.dot, NumPy will raise an error (ValueError or a broadcasting-related exception). The function relies on NumPy semantics and does not perform additional validation or broadcasting beyond what NumPy provides.
    """
    from gpaw.utilities.tools import project
    return project(a, b)


################################################################################
# Source: gpaw.xc.xc_string_to_dict
# File: gpaw/xc/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_xc_xc_string_to_dict(string: str):
    """Parse an exchange–correlation (XC) specification string used by GPAW into a dictionary.
    
    This function is used within the GPAW DFT codebase to interpret the xc argument (exchange–correlation functional specification) supplied when configuring a GPAW calculator (for example, the common usage xc='PBE' or xc='B3LYP:alpha=0.2'). It converts a compact, colon-separated specification of the form 'name:key1=value1:key2=value2:...' into a Python dictionary that downstream GPAW code (and LibXC/backends) can consume to select the functional and its numeric parameters.
    
    Args:
        string (str): The XC specification string. The first token (substring before the first ':') is interpreted as the functional name and stored under the 'name' key in the returned dictionary. Subsequent tokens must have the form 'key=value' (exactly one '=' per token). Values are interpreted as integers if int(...) succeeds, otherwise as floats if float(...) succeeds, and otherwise left as the original string. Note that this function does not strip whitespace from tokens or validate key names; any leading or trailing whitespace in tokens will be preserved. Example valid inputs include 'PBE', 'PBE:beta=1', or 'MYFUNC:mix=0.25:order=2'. An empty input string yields {'name': ''}. Tokens that do not follow the 'key=value' pattern (including empty tokens produced by consecutive or trailing colons) will cause a ValueError due to the required split/unpack step.
    
    Returns:
        dict: A dictionary mapping strings to values describing the XC specification. The dictionary always contains a 'name' key whose value is the functional name as a str (the first token). Additional keys are the parameter names (str) from the subsequent tokens and their values are either int, float, or str depending on the conversion attempt order (int attempted first, then float, otherwise left as str). This return value is intended to be used directly by GPAW code that configures exchange–correlation functionals. There are no side effects; the function only parses and returns the dictionary.
    """
    from gpaw.xc import xc_string_to_dict
    return xc_string_to_dict(string)


################################################################################
# Source: gpaw.xc.ri.spherical_hse_kernel.Phi
# File: gpaw/xc/ri/spherical_hse_kernel.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_xc_ri_spherical_hse_kernel_Phi(
    n: int,
    mu: float,
    R: numpy.ndarray,
    r: numpy.ndarray
):
    """Compute the official spherical kernel expansion used by GPAW's resolution-of-identity (ri)
    spherical HSE kernel implementation.
    
    This function implements the spherical-kernel expansion for range-separated hybrid (HSE)
    exchange integrals as used in gpaw.xc.ri.spherical_hse_kernel. It evaluates the radial
    part of the spherical expansion (see the comments referring to "Scaling as given by Eq. 16"
    and "Eq. 21" in the source) by combining the helper functions Fn, Hn and Phinj and applying
    a small-xi threshold replacement. The result is multiplied by the screening parameter mu
    so that the returned array is the mu-scaled spherical kernel contribution for pairs of
    radial distances R and r. This routine is intended for use inside GPAW's real-space RI
    evaluation of screened exchange kernels in density-functional calculations.
    
    Args:
        n (int): Order of the spherical expansion (non-negative integer). In the source
            implementation this value is used as an index into an internal threshold table
            of length 6; therefore n must be a non-negative integer in the supported range
            (0 through 5) to avoid an IndexError. Practically, n selects the angular-momentum
            channel of the spherical kernel expansion and determines how many terms are summed
            in Eq. 21 of the implementation.
        mu (float): Screening (range-separation) parameter with units of inverse length
            used to scale radial distances (mu * R, mu * r). In the HSE context this
            parameter controls the short- vs long-range separation of the Coulomb kernel.
            mu is multiplied into the final result (scaling behavior indicated by the code).
            Passing mu <= 0 is allowed by the numeric operations but is physically meaningless
            for typical HSE use; callers should supply the physically relevant positive mu.
        R (numpy.ndarray): Array of radial distances corresponding to one set of points
            (outer radial coordinate). This numpy.ndarray is combined elementwise with r;
            the code computes Rg = maximum(R, r) and Rl = minimum(R, r) using numpy
            broadcasting rules. R must be a numpy.ndarray (or convertible to one) and its
            shape must be broadcast-compatible with r; otherwise numpy will raise a
            broadcasting-related exception. R represents the radial distance values used
            to form the spherical-kernel arguments Xi = mu * Rg and xi = mu * Rl.
        r (numpy.ndarray): Array of radial distances for the other set of points
            (inner radial coordinate). Like R, r must be a numpy.ndarray and broadcastable
            with R. The pair (R, r) defines the two radii for which the spherical kernel
            expansion is evaluated; the function uses the elementwise maximum and minimum
            of these arrays to produce Xi and xi for use in Fn, Hn and the small-xi replacement.
    
    Returns:
        numpy.ndarray: Elementwise mu-scaled spherical kernel expansion evaluated for the
        provided inputs R and r. The returned array has the shape given by numpy broadcasting
        of R and r and contains the radial contribution to the HSE spherical kernel for the
        requested expansion order n. No in-place modification of the input arrays occurs;
        the function is pure (no side effects). Possible failure modes include:
        IndexError if n is outside the supported index range used by the internal threshold
        table (the implementation expects 0 <= n <= 5), TypeError if R or r are not array-like
        objects convertible to numpy.ndarray, and numpy broadcasting or arithmetic errors if R
        and r have incompatible shapes or contain values that cause invalid operations. The
        function falls back to the Phinj(n, 2, Xi, xi) branch for very small xi values as
        specified by the internal threshold table to avoid numerical instability (see the
        xi < thresholds check in the source).
    """
    from gpaw.xc.ri.spherical_hse_kernel import Phi
    return Phi(n, mu, R, r)


################################################################################
# Source: gpaw.xc.ri.spherical_hse_kernel.Hn
# File: gpaw/xc/ri/spherical_hse_kernel.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_xc_ri_spherical_hse_kernel_Hn(n: int, Xi: numpy.ndarray, xi: numpy.ndarray):
    """Compute the H_n function used in the spherical HSE (Heyd–Scuseria–Ernzerhof) screened-exchange kernel (Eq. 24 in the implementation). This helper implements the closed-form combination of powers and complementary error functions used by the spherical HSE kernel in gpaw.xc.ri.spherical_hse_kernel. In the GPAW DFT codebase this function appears as an inner radial integrand evaluator for constructing the short-range screened exchange kernel on spherical coordinates; it therefore plays the practical role of producing elementwise numerical values of H_n for arrays of radial or transformed variables used in spherical integration.
    
    Args:
        n (int): Integer order of the H_n function. In the spherical HSE kernel this selects the power of Xi and xi that appear in the numerator (powers 2*n+1) and the exponent of the denominator factor (xi*Xi)^(n+1). In practice n is used as a non-negative integer index when expanding spherical contributions to the screened-exchange kernel; passing values outside the expected integer range may produce mathematically valid results but is uncommon in the HSE context.
        Xi (numpy.ndarray): Array of Xi arguments for the H_n expression. Xi corresponds to one of the radial or transformed variables used in the spherical HSE kernel evaluation and is used elementwise in powers Xi**(2*n+1) and in the complementary error function arguments safeerfc(Xi +/- xi). Xi must be a numpy.ndarray; its shape must be broadcast-compatible with xi. The function performs elementwise operations and returns an array shaped according to numpy broadcasting rules applied to Xi and xi.
        xi (numpy.ndarray): Array of xi arguments for the H_n expression. xi corresponds to the other radial or transformed variable in the spherical HSE integrand and appears both in powers xi**(2*n+1) and in the denominator factor (xi*Xi)**(n+1) as well as in the safeerfc(Xi +/- xi) arguments. xi must be a numpy.ndarray; its shape must be broadcast-compatible with Xi. In the physical context of spherical radial integration xi is typically a non-negative radial variable, but the function accepts any numeric values representable in the provided numpy arrays.
    
    Behavior and side effects:
        The computation is performed elementwise using numpy broadcasting between Xi and xi. Internally the implementation uses a numerically safer complementary error function wrapper (safeerfc) applied to Xi + xi and Xi - xi to reduce overflow/underflow issues when evaluating erfc for large arguments. The function is pure (no side effects) and returns a new numpy.ndarray; it does not modify its inputs.
        The expression contains a denominator (2 * (xi * Xi)**(n + 1)). If any element of the product xi * Xi is zero, the corresponding denominator element is zero, which will produce divide-by-zero behavior and yield infinities or NaNs in the output according to numpy semantics. Similarly, extremely small magnitudes of xi or Xi can produce very large values due to this power law, so callers should ensure input arrays are appropriate for stable numerical evaluation.
        The routine relies on elementwise exponentiation and subtraction of potentially large powers Xi**(2*n+1) and xi**(2*n+1); for very large absolute input values and/or large n this may lead to overflow to infinities even if safeerfc guards the erfc evaluations.
    
    Returns:
        numpy.ndarray: Elementwise values of H_n evaluated for the broadcasted combination of Xi and xi. The returned array shape equals numpy.broadcast(Xi, xi).shape and contains the numerical result of the expression
        1 / (2 * (xi * Xi)**(n + 1)) * ((Xi**(2 * n + 1) + xi**(2 * n + 1)) * safeerfc(Xi + xi) - (Xi**(2 * n + 1) - xi**(2 * n + 1)) * safeerfc(Xi - xi)),
        computed using numpy arithmetic and the module's safeerfc wrapper. Nan or Inf values may appear in the output if inputs lead to division by zero or overflow according to numpy rules.
    """
    from gpaw.xc.ri.spherical_hse_kernel import Hn
    return Hn(n, Xi, xi)


################################################################################
# Source: gpaw.zero_field_splitting.convert_tensor
# File: gpaw/zero_field_splitting.py
# Category: fix_docstring
# Reason: Schema parsing failed: Cannot generate JSON schema for convert_tensor because the docstring has no description for the argument 'D_vv'
################################################################################

def gpaw_zero_field_splitting_convert_tensor(D_vv: numpy.ndarray, unit: str = "eV"):
    """gpaw.zero_field_splitting.convert_tensor converts a 3x3 zero‑field‑splitting (ZFS) tensor (given in electronvolts) into the scalar D and E ZFS parameters, the principal "easy" axis (unit eigenvector), and the full tensor expressed in a requested output unit. This function is used in GPAW DFT workflows to extract the common spin-Hamiltonian parameters (D and E) and the principal axis from the computed ZFS tensor for reporting or comparison with experiment. The input tensor must represent a real symmetric 3x3 ZFS tensor in eV; the function diagonalizes the tensor, selects the principal eigenvalue by largest absolute magnitude, and computes D and E from the ordered eigenvalues. Supported output units are "eV", "ueV" (microelectronvolt), "MHz" (megahertz), and "1/cm" (wavenumbers); conversion to MHz and 1/cm uses the electron charge, Planck's constant and the speed of light as implemented in the module.
    
    Args:
        D_vv (numpy.ndarray): The input zero‑field‑splitting tensor as a 3x3 NumPy array. This array must contain the tensor components in electronvolts (eV) and is expected to be real and symmetric; it will be multiplied by a unit conversion scale before diagonalization. The function calls numpy.linalg.eigh on the scaled tensor, so an input of incorrect shape or a non‑Hermitian array will cause numpy.linalg.eigh to raise an exception (for example numpy.linalg.LinAlgError) or produce undefined results.
        unit (str): Output unit for D, E, and the returned scaled tensor. Must be one of "eV", "ueV", "MHz", or "1/cm". Default is "eV". The mapping implemented is: "eV" -> no scaling; "ueV" -> scale by 1e6; "MHz" -> convert using the module constants (electron charge divided by Planck's constant) with a factor to produce MHz; "1/cm" -> convert using electron charge, Planck's constant and the speed of light to produce inverse centimeters. If unit is not one of the supported strings, the function raises ValueError("Unknown unit: {unit}").
    
    Behavior and details:
        The function first determines a multiplicative scale factor according to unit and multiplies the input D_vv by this scale to obtain the tensor expressed in the requested unit. It then diagonalizes the scaled tensor with numpy.linalg.eigh, which returns real eigenvalues (e1 <= e2 <= e3) and an orthonormal matrix U whose columns are the corresponding eigenvectors. The function compares the absolute values of the smallest and largest eigenvalues to decide which eigenvalue is "principal" (largest magnitude). If abs(e1) > abs(e3), the principal eigenvalue is e1 and the function sets D = 1.5 * e1, E = 0.5 * (e2 - e3), and axis = U[:, 0] (the eigenvector for e1). Otherwise the principal eigenvalue is e3 and the function sets D = 1.5 * e3, E = 0.5 * (e2 - e1), and axis = U[:, 2] (the eigenvector for e3). The returned axis is taken directly from the eigenvector matrix U and is therefore an orthonormal unit vector by construction. In cases of exact or near degeneracy of eigenvalues, the choice of axis may be numerically arbitrary (determined by the diagonalization routine). No in‑place modification of the caller's D_vv array is performed; the function returns a separately scaled tensor.
    
    Failure modes and side effects:
        If unit is not one of the supported strings a ValueError is raised. If D_vv has a shape other than (3, 3) or is not suitable for Hermitian diagonalization, numpy.linalg.eigh will raise an appropriate NumPy linear algebra exception (for example numpy.linalg.LinAlgError). The function has no other side effects (it does not modify global state or the input array).
    
    Returns:
        Tuple[float, float, numpy.ndarray, numpy.ndarray]: A 4-tuple containing:
            D (float): The axial zero‑field‑splitting parameter D, returned as a Python float and expressed in the requested unit (same unit as specified by the unit argument). D is computed as 1.5 times the principal eigenvalue of the scaled tensor.
            E (float): The rhombic zero‑field‑splitting parameter E, returned as a Python float and expressed in the requested unit. E is computed as half the difference between the two non‑principal eigenvalues after ordering by eigenvalue.
            axis (numpy.ndarray): The 3 element NumPy array (shape (3,)) giving the "easy" axis (the eigenvector associated with the principal eigenvalue). This vector is an orthonormal unit vector as produced by numpy.linalg.eigh and corresponds to the column of the eigenvector matrix U chosen by the principal eigenvalue rule described above.
            numpy.ndarray: The full 3x3 ZFS tensor after conversion to the requested unit (i.e., D_vv multiplied by the unit conversion scale). This array has shape (3, 3) and is returned for completeness and further analysis.
    
    Example (behavioral):
        Given a diagonal input tensor numpy.diag([1.0, 2.0, 3.0]) in eV and the default unit="eV", the function diagonalizes the tensor (trivially), identifies the principal eigenvalue (3.0), computes D = 1.5 * 3.0 = 4.5 and E = 0.5 * (2.0 - 1.0) = 0.5, returns the corresponding axis [0., 0., 1.], and the scaled tensor equal to the original tensor (since unit is "eV").
    """
    from gpaw.zero_field_splitting import convert_tensor
    return convert_tensor(D_vv, unit)


################################################################################
# Source: gpaw.xc.ri.spherical_hse_kernel.Fn
# File: gpaw/xc/ri/spherical_hse_kernel.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_xc_ri_spherical_hse_kernel_Fn(n: int, Xi: numpy.ndarray, xi: numpy.ndarray):
    """gpaw.xc.ri.spherical_hse_kernel.Fn computes the radial helper function used in the spherical HSE kernel evaluation (referenced as Eq. 22 in the implementation notes of the module). This function is a low-level numerical routine used inside GPAW's exchange-correlation (XC) range-separated integrals machinery to evaluate a contribution that depends on an integer order n and two radial variables Xi and xi. It implements the finite summation form (with the summation corrected to start at p = 0 for correct results) and switches to a Taylor-series approximation for numerical stability when the product Xi * xi is very small.
    
    Args:
        n (int): Non-negative integer order of the function. In the context of the spherical HSE kernel, n selects the angular/radial order of the term being evaluated (corresponding to the index in Eq. 22). The implementation assumes n >= 0; negative values will typically lead to ValueError or incorrect factorial operations raised by the underlying factorial routines.
        Xi (numpy.ndarray): Array of radial values for the first argument (capital Xi). Xi participates multiplicatively with xi inside exponentials and power factors; it must be a numeric NumPy array (or an object that NumPy can broadcast with xi). Xi is used directly in the computation of the prefactor, the finite summation, and the Taylor expansion. Typical usage within GPAW supplies Xi as a grid or radial coordinate array produced during real-space integration of the HSE kernel.
        xi (numpy.ndarray): Array of radial values for the second argument (lowercase xi). xi has the same role as Xi but represents the second radial coordinate of the integrand. xi must be a numeric NumPy array broadcastable with Xi. In the GPAW XC/RI context, xi often represents the radial distance variable from another grid point or basis function center.
    
    Detailed behavior:
        The function evaluates the expression given by Eq. 22 as implemented in the source: it computes a prefactor prefactor = 2 / sqrt(pi) and a finite summation over p from 0 to n inclusive. Each term uses factorial and double-factorial functions and contains exponential factors exp(-(xi +/- Xi)**2). Because the algebraic summation contains powers of 1/(4*Xi*xi), direct evaluation may be numerically unstable or singular when Xi*xi is very small or zero. To avoid loss of precision and division-by-zero issues, the function also computes an analytic Taylor-series approximation (named taylor in the code) valid for small Xi*xi. The implementation then selects between the full summation result (prefactor * result) and the Taylor approximation using NumPy's where with the criterion (Xi * xi)**(2 * n + 1) < 1e-6. The threshold 1e-6 is a hard-coded stability/accuracy threshold in the implementation.
    
    Side effects and defaults:
        This is a pure numeric function with no observable side effects (it does not modify its inputs or any global state). The small-product threshold 1e-6 and the choice to start the summation at p = 0 (correcting a typographical error in the referenced article) are implementation defaults encoded in the function. The function relies on NumPy and the factorial/factorial2 routines; it uses broadcasting rules from NumPy to combine Xi and xi.
    
    Failure modes and errors:
        If n is not an integer or is negative, the factorial calls will raise exceptions (e.g., ValueError). If Xi or xi contain non-finite values (NaN or Inf) or are of types that cannot be used in NumPy arithmetic, NumPy will raise exceptions. Division-by-zero within the summation is avoided by switching to the Taylor approximation for sufficiently small Xi*xi; however, if inputs are exactly zero and the threshold test does not trigger due to unusual dtype behavior, downstream arithmetic errors may occur. The function relies on standard NumPy broadcasting: Xi and xi must be broadcastable to a common shape.
    
    Returns:
        numpy.ndarray: Array containing the evaluated helper function values. The returned array has the shape resulting from NumPy broadcasting of Xi and xi and a floating-point dtype determined by the inputs. In the GPAW context this array supplies the radial contribution used when assembling the spherical component of the HSE exchange kernel; it is intended to be combined with other terms in the real-space/radial integration routines.
    """
    from gpaw.xc.ri.spherical_hse_kernel import Fn
    return Fn(n, Xi, xi)


################################################################################
# Source: gpaw.xc.gga.add_gradient_correction
# File: gpaw/xc/gga.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_xc_gga_add_gradient_correction(
    grad_v: list,
    gradn_svg: numpy.ndarray,
    sigma_xg: list,
    dedsigma_xg: numpy.ndarray,
    v_sg: list
):
    """gpaw.xc.gga.add_gradient_correction: Add the gradient-dependent part of the exchange-correlation (XC) potential to spin-resolved potential arrays used in GPAW's generalized gradient approximation (GGA) machinery. This routine implements the operation shown in the original code comment, updating the spin potentials v_sg in-place by applying gradient operators (provided in grad_v) weighted by derivatives of the XC energy density with respect to the density gradient invariant sigma. It is used inside GPAW's XC evaluation to accumulate the -2 * divergence(d e / d sigma * grad n) contribution to the XC potential on real-space grids or equivalent buffers.
    
    Args:
        grad_v (list): A list of three gradient-evaluation callables (one per Cartesian component). Each element grad_v[v] is invoked as grad_v[v](scalar_field_array, output_buffer) in the implementation: the callable should take a scalar field (a numpy array-like multiplier for the stored gradient of the density) and an output buffer array (used to store the computed gradient component contribution). The practical role of grad_v is to perform the discrete gradient/derivative operation along one Cartesian direction on the provided field; these callables must be compatible with the buffer objects supplied in sigma_xg and v_sg so that the computed result can be written into the provided output buffer. If these callables have incompatible argument types or shapes, the function will raise runtime exceptions from the underlying gradient implementation.
    
        gradn_svg (numpy.ndarray): Array containing precomputed gradients of the density for each spin channel and Cartesian direction. In the code this array is indexed as gradn_svg[s, v], so it must support that indexing for s in range(nspins) and v in range(3). In the GPAW/GGA context gradn_svg holds the gradient of the density for each spin channel (practical significance: it supplies grad n(r) that, multiplied by d e / d sigma, gives the field whose divergence contributes to the XC potential). Supplying an array with incompatible shape or dtype will cause indexing or arithmetic errors.
    
        sigma_xg (list): A list of arrays used as intermediate/working storage for sigma-dependent fields; sigma_xg[0] is reused inside this function as a temporary calculation buffer (named vv_g in the code) and will be overwritten/corrupted by the routine. The function also "adds arbitrary data to sigma_xg" as noted in the original implementation: callers that need to preserve the original contents of sigma_xg must pass a copy. In GPAW's domain, sigma_xg holds sigma-related grid data per grid/processor and is used as a place to assemble contributions before accumulating them into spin potentials.
    
        dedsigma_xg (numpy.ndarray): Array (or array-like) holding the pointwise derivative(s) of the XC energy density with respect to sigma for the available spin channels. The implementation indexes this array as dedsigma_xg[2 * s] for the same spin channel and, when two spin channels are present (nspins == 2), it also uses dedsigma_xg[1] for the opposite-spin cross term. Thus dedsigma_xg must be organized consistently with the calling code so that element 2*s corresponds to the derivative needed for spin s and element 1 supplies the cross-spin derivative when two spin channels are present. dedsigma_xg provides the weighting factor multiplying gradn_svg in the expression whose gradient is taken by grad_v.
    
        v_sg (list): List of spin-resolved potential arrays to be modified in-place: v_sg[s] is the potential for spin channel s and will be decremented by the computed gradient-correction contribution for that spin. The function computes contributions into the temporary buffer (sigma_xg[0]) and then subtracts (in-place) those contributions from v_sg entries. The practical significance is that v_sg is the target XC potential array used later in the DFT self-consistency and must be updated by this routine to include gradient-correction terms.
    
    Returns:
        None: This function does not return a value. Instead it has the following side effects: it mutates v_sg by subtracting the computed gradient-correction contributions for each spin channel, and it modifies sigma_xg (in particular sigma_xg[0] is used as a temporary buffer and will be corrupted). Callers who must retain the original sigma_xg contents must pass a copy. Typical failure modes include mismatched array shapes or incompatible types between grad_v callables, gradn_svg, dedsigma_xg, sigma_xg, and v_sg, which will raise exceptions at runtime; the function also assumes there are exactly three Cartesian gradient components (the grad_v list length is used as 3 in the implementation) and that len(v_sg) gives the number of spin channels (nspins).
    """
    from gpaw.xc.gga import add_gradient_correction
    return add_gradient_correction(grad_v, gradn_svg, sigma_xg, dedsigma_xg, v_sg)


################################################################################
# Source: gpaw.xc.vdw.hRPS
# File: gpaw/xc/vdw.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_xc_vdw_hRPS(x: numpy.ndarray, xc: float = 1.0):
    """Cutoff function from the Román-Pérez–Soler (RPS) paper used in the gpaw.xc.vdw implementation of nonlocal van der Waals correlation. This function evaluates a pair of array-valued quantities derived from the dimensionless argument x/xc: a cutoff-modified kernel value and an auxiliary weight. In the GPAW DFT/van-der-Waals context (see gpaw.xc.vdw), these arrays are used when constructing the RPS convolution kernel for efficient evaluation of the nonlocal correlation energy; xc acts as the characteristic length (scaling) parameter that controls the position of the cutoff in the dimensionless argument.
    
    Args:
        x (numpy.ndarray): Input array of dimensionless (or physical) distances or arguments to the RPS cutoff. In practice, x is the array of values at which the RPS cutoff and auxiliary weight are evaluated inside the gpaw.xc.vdw kernel construction. The function treats x elementwise and returns arrays with the same shape and dtype-compatible numeric type. x must be a NumPy array; values that are NaN or infinite will propagate through the computation and may produce NaNs/infs in the outputs.
        xc (float): Positive scalar scaling parameter (default 1.0) that rescales x before evaluating the RPS series. The code computes x1 = x/xc and then evaluates polynomial and logarithmic series in x1 described by the Román-Pérez–Soler cutoff. In GPAW this parameter controls the effective range of the cutoff: larger xc shifts the cutoff to larger x values. If xc == 0.0 a division-by-zero will occur (leading to infinities and runtime warnings); xc should therefore be a nonzero float in normal use.
    
    Detailed behavior:
        The implementation follows the RPS formulae by computing x1 = x/xc, then forming two intermediate arrays:
        y = -x1 - x1**2/2 - x1**3/3 - ... - x1**12/12 (a truncated negative series up to order 12),
        z = 1 + x1 + x1**2 + ... + x1**11 (a geometric-like sum up to power 11).
        The code clips y elementwise to the range [-1e10, 1e10] prior to exponentiation to reduce overflow risk, then computes y = exp(y). Finally it returns the pair (xc*(1.0 - y), z*y).
        The first returned array, xc*(1.0 - y), is the cutoff-modified kernel value (the RPS cutoff function scaled by xc) used to attenuate long-range contributions in the nonlocal vdW kernel. The second returned array, z*y, is an auxiliary weight factor that appears in the algebraic manipulation of the RPS convolution kernel.
        Computation is vectorized over the elements of x using NumPy operations. The implementation uses a fixed polynomial truncation (terms up to power 12 in y and up to power 11 in z) as specified in the RPS approach used in gpaw.xc.vdw.
    
    Numerical and failure modes:
        The function attempts to mitigate overflow by clipping the pre-exponential y to [-1e10, 1e10]; despite this, extreme inputs or inappropriate xc values can still lead to underflow/overflow or loss of precision. If xc is zero, a division-by-zero occurs and the outputs will contain Infs or NaNs and NumPy runtime warnings may be raised. Inputs containing NaNs or Infs propagate to the outputs. The function does not modify its input array x in-place.
    
    Returns:
        tuple of numpy.ndarray: A pair (h, w) of NumPy arrays with the same shape as x.
            h: numpy.ndarray containing xc * (1.0 - exp(y)), the cutoff-modified kernel value used in the RPS vdW kernel construction.
            w: numpy.ndarray containing z * exp(y), the auxiliary weight factor used together with h in the algebraic formulation of the RPS convolution kernel.
        Both arrays have dtype determined by NumPy broadcasting and arithmetic (input dtype will typically be promoted to a floating dtype).
    """
    from gpaw.xc.vdw import hRPS
    return hRPS(x, xc)


################################################################################
# Source: gpaw.xc.vdw.phi
# File: gpaw/xc/vdw.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_xc_vdw_phi(d: float, dp: float):
    """vdW-DF kernel used by GPAW for non-local van der Waals correlation calculations.
    
    This function evaluates the scalar kernel value phi(d, dp) for the
    vdW-DF (van der Waals density functional) non-local correlation term by
    performing a nested two-dimensional numerical integration of a module-level
    integrand function f. The implementation is written for use inside the GPAW
    DFT codebase (see README) where phi(d, dp) appears as a building block when
    assembling the nonlocal correlation energy and potential in vdW-DF type
    functionals. The integrand f must be defined in the same module and is called
    with the signature f(x, y, d, dp) by the integrator. The nested integration
    uses scipy.integrate.quad with hard-coded tolerances and integration bounds
    appropriate for typical vdW-DF kernel evaluations inside GPAW.
    
    Args:
        d (float): First kernel parameter representing a scaled separation or
            dimensionless distance variable for the vdW-DF kernel. In the GPAW
            domain this value parametrizes one of the relative-distance arguments
            of the non-local correlation kernel and must be provided as a Python
            float. It is passed unchanged to the integrand f as its third
            argument (f(x, y, d, dp)). Providing d outside physically meaningful
            ranges may lead to slow convergence or inaccurate integrals but the
            function does not itself enforce a particular value range.
        dp (float): Second kernel parameter representing another scaled
            separation or dimensionless distance variable (often denoted d'
            in vdW-DF literature). In GPAW usage dp parametrizes the second
            relative-distance argument of the non-local correlation kernel and
            must be a Python float. It is passed unchanged to the integrand f as
            its fourth argument (f(x, y, d, dp)). Like d, dp is not range-checked
            by this function.
    
    Returns:
        float: The numerically integrated kernel value phi(d, dp). This scalar is
        computed as the double integral over x and y from 0 to a hard-coded cut
        value (cut = 35) using scipy.integrate.quad with absolute and relative
        error tolerances epsabs = 1.0e-6 and epsrel = 1.0e-6 and a maximum
        subdivision limit of 400. The returned value is suitable for use in the
        non-local correlation energy and potential assembly within GPAW.
    
    Behavior, side effects, defaults, and failure modes:
        - The function performs a nested numerical integration: the inner integral
          evaluates quad(f, 0, cut, (y, d, dp), **kwargs) treating x as the
          integration variable and passing (y, d, dp) as additional arguments to
          f; the outer integral integrates the inner integral's result over y
          from 0 to cut.
        - Integration parameters are hard-coded: cut = 35, epsabs = 1.0e-6,
          epsrel = 1.0e-6, limit = 400. These defaults were chosen for typical
          vdW-DF kernel convergence behavior in GPAW; changing them requires
          modifying the source code.
        - Requires SciPy (scipy.integrate.quad). If SciPy is not available an
          ImportError will occur when this function is executed.
        - The integrand function f must exist in the module and accept the call
          signature f(x, y, d, dp). If f is undefined a NameError will be raised.
        - If the integrand is highly singular or oscillatory for the supplied d
          and dp, quad may issue warnings about roundoff or accuracy or may fail
          to converge within the provided limit; the function will then return the
          best estimate from quad (the first element of its return tuple) but the
          caller should treat such results with caution.
        - Passing non-float types for d or dp may lead to TypeError or to
          incorrect integration results depending on how f handles those types.
        - This function has no other side effects (it does not modify global
          state aside from relying on f) and returns only the computed float.
    """
    from gpaw.xc.vdw import phi
    return phi(d, dp)


################################################################################
# Source: gpaw.xc.vdw.phi_asymptotic
# File: gpaw/xc/vdw.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_xc_vdw_phi_asymptotic(d: numpy.ndarray, dp: numpy.ndarray):
    """gpaw.xc.vdw.phi_asymptotic computes the asymptotic form of the van der Waals density-functional (vdW-DF) kernel used in GPAW's vdW-DF implementation. This function evaluates the algebraic large-separation limit of the kernel as implemented in gpaw.xc.vdw, returning the scalar kernel value computed elementwise from the provided NumPy arrays. It is used internally in vdW-DF energy and potential evaluations where the asymptotic tail of the kernel is required for long-range correlation contributions in density-functional theory (DFT) calculations performed with GPAW.
    
    Args:
        d (numpy.ndarray): Input array of first kernel argument. In the context of the vdW-DF kernel, this array represents one of the separation/argument variables for which the asymptotic kernel is evaluated. The function treats d as a NumPy ndarray and performs elementwise arithmetic; typical usage supplies real-valued arrays of separation-like quantities from GPAW's vdW routines.
        dp (numpy.ndarray): Input array of second kernel argument. Analogous to d, this array represents the other separation/argument variable for the asymptotic kernel evaluation. It must be a NumPy ndarray and will be combined elementwise with d following NumPy broadcasting rules.
    
    Behavior and side effects:
        The function computes d2 = d**2 and dp2 = dp**2 and returns the elementwise value -C / (d2 * dp2 * (d2 + dp2)), where C is a module-level constant defined elsewhere in gpaw.xc.vdw that sets the overall amplitude of the asymptotic kernel. The computation is fully vectorized using NumPy operations and has no side effects on inputs or global state beyond reading the constant C.
        NumPy broadcasting rules apply if d and dp have different, but broadcast-compatible, shapes. No input validation is performed by the function; invalid inputs (for example non-numeric arrays) will raise standard NumPy errors.
        Failure modes: because the formula divides by powers of d and dp, inputs containing zeros or values that make d2 + dp2 equal to zero will produce division-by-zero results, leading to Inf or NaN in the output and possibly NumPy RuntimeWarnings. If NumPy is configured to raise FloatingPointError for invalid floating-point operations, such errors may be raised. Users should ensure inputs avoid singular combinations when calling this function or handle resulting infinities/NaNs appropriately.
    
    Returns:
        numpy.ndarray: The elementwise asymptotic vdW-DF kernel values computed as -C / (d**2 * dp**2 * (d**2 + dp**2)). The returned object is a NumPy ndarray produced by the vectorized arithmetic; its shape and broadcasting behavior follow NumPy rules based on the input arrays.
    """
    from gpaw.xc.vdw import phi_asymptotic
    return phi_asymptotic(d, dp)


################################################################################
# Source: gpaw.xc.sic.ortho
# File: gpaw/xc/sic.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_xc_sic_ortho(W_nn: numpy.ndarray, maxerr: float = 1e-10):
    """gpaw.xc.sic.ortho: Orthogonalize column vectors of a matrix using the symmetric Löwdin procedure.
    
    Performs Symmetric-Löwdin orthogonalization of the column vectors contained in a square numpy.ndarray. This function is intended for use within GPAW's self-interaction-correction (gpaw.xc.sic) code paths where a set of (typically localized) orbital-like column vectors must be transformed into an orthonormal set before further processing. The routine computes the Hermitian overlap matrix O = W_nn @ W_nn.T.conj() and either applies a second-order perturbative approximation of O^{-1/2} when O is already close to the identity (faster, avoids diagonalization), or computes the exact inverse square root via diagonalization of O (stable, more expensive). The returned matrix has the same shape as W_nn and its columns are orthonormal within numerical tolerance: the overlap of the returned columns with their Hermitian conjugates is (approximately) the identity.
    
    Args:
        W_nn (numpy.ndarray): Square input array whose column vectors are to be orthogonalized. In the source code this array is treated as having ndim = W_nn.shape[1] and the Hermitian overlap is computed as O_nn = W_nn @ W_nn.T.conj(), so W_nn must be laid out such that this product yields an (ndim x ndim) Hermitian matrix. The practical significance in GPAW is that W_nn typically contains orbital or projector coefficients that must be orthonormalized for stable self-interaction-correction or related operations.
        maxerr (float): Threshold for choosing the perturbative (approximate) orthogonalization instead of explicit diagonalization of the overlap. If the L1 deviation from identity of the overlap matrix, computed as sum(abs(O_nn - I)), is strictly less than maxerr, the routine uses the perturbative Symmetric-Löwdin approximation X = 1.5*I - 0.5*O_nn to obtain an approximate O^{-1/2} and avoid diagonalization. If the deviation is greater than or equal to maxerr, the routine diagonalizes O_nn with a Hermitian eigensolver (eigh), forms nsqrt_n = diag(1/sqrt(eigenvalues)), and constructs X = U @ nsqrt_n @ U.T.conj() to obtain the exact inverse square root. The default value 1e-10 is chosen to balance performance and numerical stability in typical GPAW calculations; set this parameter smaller to force diagonalization more often, or larger to favor the perturbative shortcut.
    
    Returns:
        numpy.ndarray: An array with the same shape as W_nn whose columns are orthonormal within numerical tolerance. Internally this is the product O_nn = X_nn @ W_nn where X_nn is either the perturbative approximation to O^{-1/2} or the exact inverse square root obtained by diagonalization. No in-place modification of the input W_nn is performed; the function returns a new array.
    
    Behavior, side effects, and failure modes:
        - The routine computes the Hermitian overlap O_nn = W_nn @ W_nn.T.conj() and measures its deviation from the identity with err = sum(abs(O_nn - I)). If err < maxerr the perturbative formula X = 1.5*I - 0.5*O_nn is used; otherwise the code diagonalizes O_nn using a Hermitian eigensolver (numpy.linalg.eigh in the source) to obtain eigenvalues and eigenvectors and constructs the exact inverse square root O^{-1/2} = U @ diag(1/sqrt(eigs)) @ U.T.conj().
        - The perturbative branch is cheaper (no diagonalization) and suitable when the input columns are already nearly orthonormal; it yields an approximation to the true Löwdin orthogonalization and therefore should be used only when the overlap is sufficiently close to identity as governed by maxerr.
        - The diagonalization branch has cubic cost in the matrix dimension (O(n^3)) and is numerically robust when all eigenvalues are strictly positive.
        - If O_nn has zero or negative eigenvalues (for example due to linear dependence or large numerical error), forming 1/sqrt(eigenvalue) will produce infinities or NaNs and can raise runtime warnings or exceptions; such cases indicate that the columns of W_nn are (nearly) linearly dependent or that numerical precision is insufficient. Users should inspect eigenvalues or regularize the input in such situations.
        - The function assumes standard complex-conjugate Hermitian transpose behavior via .T.conj(); it does not perform explicit checks on input dimensionality beyond relying on numpy operations and will raise numpy errors if W_nn has incompatible shape.
    """
    from gpaw.xc.sic import ortho
    return ortho(W_nn, maxerr)


################################################################################
# Source: gpaw.xc.sic.matrix_exponential
# File: gpaw/xc/sic.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def gpaw_xc_sic_matrix_exponential(G_nn: numpy.ndarray, dlt: float):
    """gpaw.xc.sic.matrix_exponential computes the matrix exponential U = exp(i * dlt * G)
    for an anti-Hermitian generator G used in GPAW's self-interaction-correction (sic)
    code path. In the GPAW DFT/PAW context this routine is used to construct a unitary
    rotation operator from an anti-Hermitian generator matrix G_nn (for example to
    rotate orbitals or apply small unitary updates in SIC procedures). The routine
    diagonalizes a Hermitian matrix derived from G_nn, forms phase factors exp(i*dlt*w)
    from the real eigenvalues w, and reconstructs the exponential by back-transforming
    the diagonal phase matrix with the eigenvectors.
    
    Args:
        G_nn (numpy.ndarray): Anti-Hermitian (skew-Hermitian) matrix representing the
            generator G in the expression U = exp(i * dlt * G). The function expects
            a two-dimensional square array with shape (n, n) where n = G_nn.shape[1].
            The implementation treats complex and real dtypes differently: when
            G_nn.dtype == complex the code uses both real and imaginary parts to form
            a Hermitian matrix for diagonalization; when G_nn.dtype is not complex the
            code uses only the real part. For mathematically correct/unitary results,
            G_nn should satisfy G_nn.conj().T == -G_nn (anti-Hermitian). If G_nn is not
            square, contains non-finite values (NaN or Inf), or strongly violates the
            anti-Hermitian property the numerical result may be invalid or the linear
            algebra routines may raise errors (for example numpy.linalg.LinAlgError).
        dlt (float): Scalar scaling factor that multiplies the generator inside the
            exponential. Physically this can represent a small rotation angle or a
            timestep-like parameter controlling the magnitude of the unitary update.
            The value is used exactly as provided in exp(i * dlt * w) where w are the
            real eigenvalues obtained from diagonalizing the Hermitian matrix derived
            from G_nn. Very large magnitudes of dlt can produce rapidly oscillatory
            phases and increase numerical sensitivity.
    
    Returns:
        numpy.ndarray: The matrix U_nn = exp(i * dlt * G_nn) with shape (n, n). If the
        input G_nn had complex dtype the returned array will be complex and contain the
        full unitary (complex) exponential. If the input G_nn had a non-complex dtype
        the implementation returns the real part of the reconstructed exponential (a
        floating-point ndarray) as produced by the algorithm. The returned matrix is
        constructed by forming a Hermitian matrix V from G_nn, computing its real
        eigenvalues w_n and eigenvectors V_nn (via a Hermitian eigendecomposition),
        building the diagonal phase matrix O_nn = diag(exp(i * dlt * w_n)), and
        reconstructing U_nn = V_nn @ O_nn @ V_nn.conj().T. There are no side effects;
        the input array is not modified. Error conditions include non-square input,
        invalid numerical values in G_nn, or failures in the underlying eigensolver,
        which will raise the corresponding numpy / SciPy linear-algebra exceptions.
    """
    from gpaw.xc.sic import matrix_exponential
    return matrix_exponential(G_nn, dlt)


from typing import Dict, Any


def get_tools() -> Dict[str, Dict[str, Any]]:
    """Extract JSON schemas for all functions in this module."""
    import sys
    import os
    
    # Add project root to path to import our json_schema module
    # Try multiple possible paths
    possible_paths = [
        os.path.join(os.path.dirname(__file__), '..', '..', 'utils'),
        '/app/utils',
        '/app/project/utils',
    ]
    
    json_schema_path = None
    for path in possible_paths:
        abs_path = os.path.abspath(path)
        if os.path.exists(os.path.join(abs_path, 'json_schema.py')):
            if abs_path not in sys.path:
                sys.path.insert(0, abs_path)
            json_schema_path = abs_path
            break
    
    if json_schema_path:
        from json_schema import get_json_schema
    else:
        # Fallback to transformers if our module not found
        from transformers.utils import get_json_schema
    
    tools = {}
    failed_count = 0
    
    for name, func in get_lib().items():
        try:
            tools[name] = get_json_schema(func)
        except Exception as e:
            failed_count += 1
            # Only print first few errors to avoid spam
            if failed_count <= 3:
                print(f"Failed to get schema for {name}: {type(e).__name__}: {e}", file=sys.stderr)
            continue
    
    if failed_count > 0:
        print(f"Warning: Failed to extract schemas for {failed_count} out of {len(get_lib())} functions", file=sys.stderr)
    
    return tools


def get_lib():
    """Get all functions defined in this module."""
    import inspect
    global_vars = inspect.currentframe().f_globals
    
    functions = {
        name: obj for name, obj in global_vars.items()
        if inspect.isfunction(obj) and obj.__module__ == __name__
    }
    functions.pop("get_lib", None)
    functions.pop("get_tools", None)
    return functions
