"""
Regenerated Google-style docstrings for module 'pyscf'.
README source: others/readme/pyscf/README.md
Generated at: 2025-12-02T06:40:44.490803Z

Total functions: 449
"""


import numpy
from typing import List

################################################################################
# Source: pyscf.agf2._agf2.build_mats_dfragf2_lowmem
# File: pyscf/agf2/_agf2.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_agf2__agf2_build_mats_dfragf2_lowmem(
    qxi: numpy.ndarray,
    qja: numpy.ndarray,
    e_occ: numpy.ndarray,
    e_vir: numpy.ndarray,
    os_factor: float = 1.0,
    ss_factor: float = 1.0
):
    """build_mats_dfragf2_lowmem builds two molecular-orbital (MO) matrices used by the AGF2 density-fitted (df-AGF2) low-memory driver. This function is a Python wrapper around the compiled routine libagf2.AGF2df_vv_vev_islice_lowmem and prepares inputs, invokes the driver with C-contiguous arrays and MPI slicing, and performs an MPI all-reduce so the returned matrices are the globally assembled results used in subsequent AGF2 self-energy and correlation-energy construction.
    
    Args:
        qxi (numpy.ndarray): Auxiliary-interaction array for occupied orbitals. The driver expects an array whose leading axis length equals the number of auxiliaries naux and whose total size equals naux * nmo * nocc (where nmo is inferred as qxi.size // (naux*nocc) and nocc is e_occ.size). qxi is converted to a C-contiguous numpy array inside the function. Practically, qxi holds the density-fitted integrals (or their contraction) that couple auxiliary basis functions to MO occupied indices for the df-AGF2 matrix assembly.
        qja (numpy.ndarray): Auxiliary-interaction array for virtual orbitals. The driver expects qja.size == naux * nocc * nvir (nvir is e_vir.size) and a leading axis length equal to naux. qja is converted to a C-contiguous numpy array inside the function. In df-AGF2 this array provides the density-fitted integrals coupling auxiliaries to MO virtual indices needed to assemble the vv and vev matrices.
        e_occ (numpy.ndarray): Occupied orbital energies as a one-dimensional numpy array of length nocc. e_occ is converted to a C-contiguous array and is used by the underlying driver to form energy-dependent contractions (energy denominators) that enter the vev matrix and related AGF2 constructs.
        e_vir (numpy.ndarray): Virtual orbital energies as a one-dimensional numpy array of length nvir. e_vir is converted to a C-contiguous array and is used by the underlying driver to form energy-dependent contractions that contribute to vev and related AGF2 quantities.
        os_factor (float): Opposite-spin scaling factor. Passed through to the compiled driver (default 1.0). In practical AGF2/MP2-like spin-scaling workflows this factor scales opposite-spin contributions to the assembled matrices; changing it modifies the relative weight of opposite-spin correlation terms used downstream in self-energy and energy evaluations.
        ss_factor (float): Same-spin scaling factor. Passed through to the compiled driver (default 1.0). In practical AGF2/MP2-like spin-scaling workflows this factor scales same-spin contributions to the assembled matrices; changing it modifies the relative weight of same-spin correlation terms used downstream in self-energy and energy evaluations.
    
    Behavior and side effects:
        The function queries the compiled library symbol AGF2df_vv_vev_islice_lowmem from libagf2 and will raise AttributeError if that symbol is not available. It infers naux, nocc, nvir, and nmo from the provided arrays and enforces consistency with assertions: qxi.size must equal naux * nmo * nocc and qja.size must equal naux * nocc * nvir; an AssertionError is raised if these conditions fail. Input arrays are converted to C-contiguous numpy arrays; the compiled driver expects data compatible with C double precision memory layout, so passing arrays with incompatible dtypes or non-contiguous memory may lead to low-level errors or segmentation faults. The function distributes work over MPI ranks by computing a start and end index slice (based on mpi_helper.rank and mpi_helper.size) and calls the driver with these slice bounds; after the driver returns, the function performs mpi_helper.barrier() and mpi_helper.allreduce_safe_inplace on the two assembled matrices so the outputs are globally reduced across all MPI ranks. Because the function invokes a compiled routine via ctypes, it may raise low-level exceptions (e.g., from ctypes) if the driver fails during execution.
    
    Defaults:
        os_factor and ss_factor default to 1.0 meaning no spin scaling by default, which corresponds to standard AGF2/MP2 scaling. The MPI behavior uses the globally configured mpi_helper (rank and size) from the PySCF environment.
    
    Failure modes:
        AssertionError if input array sizes do not match the required naux/nmo/nocc/nvir relationships.
        AttributeError if libagf2 does not expose AGF2df_vv_vev_islice_lowmem.
        Low-level ctypes/segmentation faults if inputs are not compatible with the driver (e.g., wrong dtype, non-C layout despite conversion, or incompatible memory).
        MPI-related errors if mpi_helper is not initialized correctly or if ranks disagree on array dimensions.
    
    Returns:
        vv (numpy.ndarray): A two-dimensional numpy array of shape (nmo, nmo) containing the assembled MO-space "vv" matrix produced by the AGF2df_vv_vev_islice_lowmem driver. In the df-AGF2 algorithm this matrix aggregates auxiliary-mediated two-electron contributions in MO basis and is used in constructing correlation and self-energy terms.
        vev (numpy.ndarray): A two-dimensional numpy array of shape (nmo, nmo) containing the assembled MO-space "vev" matrix produced by the driver. This matrix is the energy-weighted counterpart (depends on e_occ and e_vir) used by df-AGF2 to form energy-denominator-weighted contributions to the self-energy and related quantities.
    
    Note:
        The returned matrices have been reduced across MPI ranks before being returned; callers on all ranks receive the full, globally assembled vv and vev. This function is intended for use within the PySCF AGF2 density-fitted workflow where memory-efficient, slice-based assembly of intermediate matrices is required.
    """
    from pyscf.agf2._agf2 import build_mats_dfragf2_lowmem
    return build_mats_dfragf2_lowmem(qxi, qja, e_occ, e_vir, os_factor, ss_factor)


################################################################################
# Source: pyscf.agf2._agf2.build_mats_dfragf2_outcore
# File: pyscf/agf2/_agf2.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_agf2__agf2_build_mats_dfragf2_outcore(
    qxi: numpy.ndarray,
    qja: numpy.ndarray,
    e_occ: numpy.ndarray,
    e_vir: numpy.ndarray,
    os_factor: float = 1.0,
    ss_factor: float = 1.0
):
    """build_mats_dfragf2_outcore(qxi, qja, e_occ, e_vir, os_factor=1.0, ss_factor=1.0)
    
    Constructs the VV and VEV intermediate matrices used by the AGF2 density-fitted fragment GF2 out-of-core kernel.
    This Python implementation corresponds to the Fortran routine AGF2df_vv_vev_islice and is intended for use inside PySCF's agf2._agf2 module to accumulate energy-weighted and unweighted two-index intermediates from density-fitted three-index tensors while slicing over occupied orbitals (out-of-core style). The routine performs local BLAS operations (via lib.dot), iterates over occupied orbital slices to limit peak memory use, applies opposite-spin and same-spin scalar weighting factors, and finally synchronizes and reduces the results across MPI ranks using mpi_helper.barrier and mpi_helper.allreduce_safe_inplace.
    
    Args:
        qxi (numpy.ndarray): Three-index density-fitted tensor data arranged so that qxi.size == naux * nmo * nocc. In the implementation qxi is reshaped as (naux, nmo, nocc) and each occupied slice qx = qxi.reshape(naux, nmo, nocc)[:,:,i] is used in the i-th iteration. This array supplies the "x-i" (auxiliary x, molecular orbital, occupied) components required to build the VV and VEV intermediates for the AGF2 density-fitted fragment algorithm. The function asserts the size relationship and will raise AssertionError if qxi.size does not match naux * nmo * nocc as deduced from qxi.shape[0] and the inferred nmo and nocc.
        qja (numpy.ndarray): Three-index density-fitted tensor data with dimensions implied by qja.size == naux * nocc * nvir. In the routine qja is accessed both as the full array and in per-occupied-column slices qja[:, i*nvir:(i+1)*nvir] to form j-a blocks. This array supplies the "q-j-a" (auxiliary, occupied, virtual) components used together with qxi to form the intermediate contractions. The function asserts qja.size matches the expected naux * nocc * nvir and will raise AssertionError on mismatch.
        e_occ (numpy.ndarray): One-dimensional array of occupied orbital energies with length nocc. The code uses e_occ both to derive nocc and to form energy-denominator-like combinations (through lib.direct_sum) that weight contributions into the energy-weighted VEV matrix. These energies are typically those produced by the Hartree–Fock or mean-field step used upstream in AGF2 and must match the occupied dimension implied by qxi and qja; mismatched lengths will lead to assertion failures or incorrect results.
        e_vir (numpy.ndarray): One-dimensional array of virtual orbital energies with length nvir. e_vir is used to form the composite energy array eija = e_occ[j] - e_vir[a] (via lib.direct_sum('j,a->ja', e_occ, -e_vir)) that enters the weighted contractions for VEV. The length must match the virtual dimension implied by qja; mismatches will produce assertion failures or incorrect numerical results.
        os_factor (float): Scalar multiplier for opposite-spin contributions. Defaults to 1.0. In the implementation the combination fpos = os_factor + ss_factor and fneg = -ss_factor are used to scale the positive (fpos) and negative (fneg) contributions added to the unweighted (VV) and energy-weighted (VEV) accumulation matrices. This parameter controls the relative weighting of opposite-spin correlation in the constructed intermediates and should be provided as a floating-point scalar consistent with the AGF2 spin-scaling convention used elsewhere in the AGF2 implementation.
        ss_factor (float): Scalar multiplier for same-spin contributions. Defaults to 1.0. See os_factor description: ss_factor contributes to fpos and to fneg (with fneg = -ss_factor) and therefore alters both the summed and subtracted parts of the VV and VEV accumulations, reflecting same-spin correlation scaling in the AGF2 fragment algorithm.
    
    Returns:
        tuple[numpy.ndarray, numpy.ndarray]: A pair (vv, vev) of two-dimensional numpy.ndarray objects, each shaped (nmo, nmo) as produced by the routine (nmo is inferred as qxi.size // (naux * nocc)). vv is the accumulated unweighted intermediate matrix formed by contracted three-index tensors and spin-scaling factors; vev is the corresponding energy-weighted intermediate where contributions have been multiplied by the composite orbital-energy combinations (e_occ - e_vir) as implemented in the loop. Both arrays are reduced across MPI ranks via mpi_helper.allreduce_safe_inplace before being returned, so the returned matrices represent the global (all-rank) sums suitable for subsequent AGF2 self-energy construction.
    
    Behavior and side effects:
        The function derives naux from qxi.shape[0], nocc from e_occ.size, nvir from e_vir.size, and nmo from integer division qxi.size // (naux * nocc). It asserts that qxi.size == naux * nmo * nocc and qja.size == naux * nocc * nvir; assertion failures indicate inconsistent input tensor dimensions and will raise AssertionError. The routine iterates over occupied orbital indices (range nocc) and for each i performs BLAS-accelerated contractions using lib.dot into preallocated temporary buffers to limit memory usage (out-of-core style). The local vv and vev accumulators are updated with alpha/beta-scaled dot products; intermediate arrays are used but input arrays qxi and qja are not modified. After the loop the function calls mpi_helper.barrier() and mpi_helper.allreduce_safe_inplace(vv/vev) to synchronize and sum the accumulators across MPI ranks; these MPI calls are side effects and require an MPI-capable environment consistent with the rest of the PySCF MPI helper utilities. No file I/O is performed by this routine. Because the algorithm accumulates dense (nmo x nmo) matrices, memory consumption may be significant for large problems; users should ensure available memory and appropriate MPI configuration.
    
    Failure modes and errors:
        The function will raise AssertionError if the input array sizes do not satisfy the expected relationships documented above. Passing arrays of incompatible types or shapes may raise downstream exceptions from lib.dot or numpy operations. Incorrect os_factor/ss_factor values will change the numerical results but will not be type-checked beyond normal Python float behavior. MPI synchronization calls assume the mpi_helper utilities are available and properly initialized; failure of MPI initialization may produce runtime errors outside this routine.
    """
    from pyscf.agf2._agf2 import build_mats_dfragf2_outcore
    return build_mats_dfragf2_outcore(qxi, qja, e_occ, e_vir, os_factor, ss_factor)


################################################################################
# Source: pyscf.agf2._agf2.cholesky_build
# File: pyscf/agf2/_agf2.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_agf2__agf2_cholesky_build(
    vv: numpy.ndarray,
    vev: numpy.ndarray,
    eps: float = 1e-16
):
    """Constructs truncated auxiliary tensors (auxiliaries) from the metric-like
    matrices vv and vev used in the AGF2 self-energy construction.
    
    This function is part of the AGF2 implementation in PySCF and is used by
    build_se_part to produce a compact representation of the auxiliary basis that
    parameterizes the frequency-dependent self-energy for occupied or virtual
    spaces. In practice, vv is expected to be a Hermitian, positive-definite or
    positive-semidefinite metric (for example when gf_occ.naux < gf_occ.nphys or
    gf_vir.naux < gf_vir.nphys the matrix can be positive-semidefinite). The
    function performs a Cholesky decomposition of vv to obtain a factor b, falls
    back to an eigenvalue regularization when vv is not strictly positive-definite,
    and then diagonalizes a transformed vev to produce eigenvalues and transformed
    eigenvectors that define the truncated auxiliaries. This numerical procedure
    stabilizes the auxiliary representation used in correlated Green's function
    (Self-Energy) computations within the PySCF AGF2 module.
    
    Args:
        vv (numpy.ndarray): Square Hermitian matrix defining the metric for the
            auxiliary space. In AGF2 this matrix arises in build_se_part and
            represents overlaps or coupling weights of auxiliary functions; its
            shape and leading dimension determine nmo (the number of molecular
            orbitals or the physical dimension for which auxiliaries are formed).
            The function attempts a Cholesky decomposition of vv. If numpy.linalg.cholesky
            raises a LinAlgError (vv not strictly positive-definite), the code
            performs an eigenvalue decomposition, replaces eigenvalues smaller than
            eps with eps to enforce positive-definiteness (numerical regularization),
            reconstructs a positive-definite vv, and proceeds with the Cholesky
            decomposition. This regularization removes exact null-space (zero
            eigenvalues) by elevating them to eps and thereby enables stable
            factorization.
        vev (numpy.ndarray): Hermitian matrix in the same auxiliary/physical basis
            as vv that is transformed into the Cholesky-normalized space and
            diagonalized to obtain auxiliary energies and coefficients. In AGF2
            usage vev encodes energy-weighted couplings of auxiliaries (for
            occupied/virtual self-energy parts) produced by build_se_part. The
            function forms m = b_inv.T @ vev @ b_inv (with b from the Cholesky
            factor of vv) and diagonalizes m to obtain eigenvalues and eigenvectors.
        eps (float): Threshold for numerical regularization of vv eigenvalues;
            eigenvalues smaller than eps are replaced by eps when vv is
            not strictly positive-definite. Default is 1e-16. This parameter
            controls how small or near-zero eigenvalues are treated: too-large
            eps may artificially inflate a null space, while too-small eps may
            fail to stabilize the Cholesky decomposition in the presence of
            numerical noise. A LinAlgError during the initial Cholesky triggers
            the eigen-regularization using eps. No other side effects or global
            state are modified by changing eps.
    
    Returns:
        e (numpy.ndarray): Real eigenvalues obtained by diagonalizing the
            transformed matrix m = b_inv.T @ vev @ b_inv. These values act as the
            auxiliary energy (or weight) spectrum in the Cholesky-normalized
            auxiliary basis. They are used downstream in AGF2 to form frequency-
            dependent self-energy contributions and to truncate or rank auxiliaries.
        c (numpy.ndarray): Complex- or real-valued matrix of transformed eigenvectors
            (coefficients) corresponding to e. The returned c is formed by mapping
            the eigenvectors of m back through the Cholesky factor (c = b.T @ eigvecs_subset)
            to produce coefficients in the original physical/auxiliary basis. These
            columns constitute the truncated auxiliary vectors used by build_se_part
            / AGF2 to represent the self-energy. The array shape and organization
            align with vv and vev such that contracting c with e (and with orbital
            quantities) yields the intended auxiliary contributions.
    
    Raises/Failure modes:
        If vv is not Hermitian or has invalid shape, numpy.linalg.cholesky or
        numpy.linalg.eigh may raise exceptions (LinAlgError or ValueError). The
        function catches a LinAlgError from the initial Cholesky and attempts
        eigenvalue-regularization; if eigen-decomposition or reconstruction fails
        or inputs have incompatible shapes, the original exception from NumPy will
        propagate to the caller. No in-place modification of the inputs is performed.
    """
    from pyscf.agf2._agf2 import cholesky_build
    return cholesky_build(vv, vev, eps)


################################################################################
# Source: pyscf.agf2._agf2.get_blksize
# File: pyscf/agf2/_agf2.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_agf2__agf2_get_blksize(max_memory_total: float, *sizes):
    """Gets a block size (integer) such that the total memory required by the blocks
    does not exceed the available memory. This utility is used in AGF2 routines
    within the PySCF project to pick a number of elements per block when forming
    or processing large arrays/tensors so that the sum over block contributions
    (sum(sizes) * blksize or max over tuple-sums when tuples are supplied) fits
    within the remaining memory budget.
    
    This function reads the current memory usage via lib.current_memory()[0] and
    subtracts it from the provided max_memory_total (interpreted as megabytes).
    It then converts the available memory and element-size estimate into bits
    (using 8e6 bits per MB and 64 bits per element) and returns the integer
    quotient mem_avail / (sum_of_sizes * 64 bits) as the block size. The routine
    supports either a list of integer sizes provided as separate varargs or one
    or more tuples of integer sizes (in which case the maximum tuple-sum is used).
    
    Args:
        max_memory_total (float): The total allowed memory target for the process,
            expressed in megabytes (MB). In AGF2/ PySCF workflows this represents
            the upper memory budget the caller does not want to exceed. The
            function computes the usable memory as max_memory_total minus the
            current memory usage reported by lib.current_memory()[0] (also in MB).
            The caller must supply this value in MB because the function multiplies
            the result by 8e6 to convert MB to bits. Providing a value in other
            units will yield incorrect block-size estimates.
        sizes (int or tuple of int): One or more integers (as varargs) representing
            the per-element size contributions to memory for a single block, or
            one or more tuples of integers. Each integer is interpreted as a
            count of scalar elements contributed by one component of the block.
            If the first vararg is a tuple, the function expects one or more
            tuples and uses the maximum of the sums of those tuples as the
            per-block element count estimate. If plain integers are supplied,
            their sum is used as the per-block element count estimate. These
            values are multiplied by the computed blksize to estimate total
            element count per operation and then converted assuming 64 bits
            per element.
    
    Returns:
        int: An integer block size (number of elements per block) computed as
        floor(mem_avail_bits / (sum_of_sizes * 64)), where mem_avail_bits is
        (max_memory_total - current_memory_in_MB) * 8e6. This returned value is
        intended to be used to partition large arrays/tensors in AGF2 routines so
        that the memory footprint of one block fits within the remaining memory
        budget. The function does not allocate memory itself; it only returns a
        computed size.
    
    Behavior, side effects, defaults, and failure modes:
        - The function calls lib.current_memory()[0] to obtain current memory usage
          in MB; this is a read-only side effect (no writes or global state
          changes).
        - The conversion constants are fixed: MB -> bits uses 8e6 (8 * 10^6) and
          each element is assumed to occupy 64 bits (8 bytes). These assumptions
          reflect typical floating-point element sizes in PySCF/AGF2 code; callers
          must provide sizes consistent with those assumptions.
        - If sizes is empty, the function will raise an IndexError when accessing
          sizes[0]. Callers must supply at least one size argument.
        - If sum_of_sizes evaluates to zero (for example, all provided sizes are
          zero), a ZeroDivisionError may be raised; callers must ensure sizes
          represent positive element counts.
        - If the computed available memory (max_memory_total - current usage) is
          negative or smaller than required for a single element, the function may
          return 0 or a negative integer (after truncation). Callers should check
          the returned value and handle non-positive block sizes (e.g., by lowering
          memory targets, reducing problem size, or falling back to conservative
          defaults).
        - If sizes contain non-numeric types, TypeError may be raised when attempting
          to sum them. Callers should pass integers (or tuples of integers).
        - The function is intended for use in memory planning for tensor/block
          operations in PySCF's AGF2 implementation; it is not a general-purpose
          memory allocator.
    """
    from pyscf.agf2._agf2 import get_blksize
    return get_blksize(max_memory_total, *sizes)


################################################################################
# Source: pyscf.agf2._agf2.build_mats_ragf2_incore
# File: pyscf/agf2/_agf2.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_agf2__agf2_build_mats_ragf2_incore(
    qeri: numpy.ndarray,
    e_occ: numpy.ndarray,
    e_vir: numpy.ndarray,
    os_factor: float = 1.0,
    ss_factor: float = 1.0
):
    """build_mats_ragf2_incore builds two frequency-independent matrices (vv and vev) used by the restricted AGF2 (rAGF2) implementation by wrapping the compiled driver libagf2.AG F2ee_vv_vev_islice. This function is part of the PySCF agf2 module (Python-based Simulations of Chemistry Framework) and is used in electronic-structure workflows to convert a four-index two-electron integral tensor and orbital energy arrays into condensed matrices that enter the AGF2 self-energy construction and subsequent algebraic Green's function procedures.
    
    Args:
        qeri (numpy.ndarray): A contiguous, C-ordered 4-dimensional array of two-electron repulsion integrals in the molecular orbital basis. The code asserts qeri.ndim == 4 and uses qeri.shape[0] as the number of molecular orbitals nmo. In practical AGF2/rAGF2 usage this tensor supplies the electron-electron interaction integrals needed by the C driver to form the vv and vev contributions; providing an array with incorrect dimensionality or non-C-ordering may raise an AssertionError or cause the underlying C driver to fail.
        e_occ (numpy.ndarray): A 1-dimensional, C-ordered array of occupied orbital energies. The length of this array is taken as nocc (number of occupied orbitals) and determines the portion of occupied-space indices processed on each MPI rank. These orbital energies are used by the native C routine to evaluate energy denominators and weighting factors when constructing the matrices; supplying arrays of incorrect length or dtype may lead to incorrect results or a segfault in the C driver.
        e_vir (numpy.ndarray): A 1-dimensional, C-ordered array of virtual (unoccupied) orbital energies. The length of this array is taken as nvir (number of virtual orbitals) and is required by the C driver to compute denominators and intermediate quantities for the vv and vev matrices. As with e_occ, wrong sizing or non-contiguous memory can cause runtime failures in the wrapped routine.
        os_factor (float): Opposite-spin scaling factor (default 1.0). This scalar multiplies the opposite-spin contribution inside the AGF2 matrix construction performed by the C driver and is provided to allow spin-component-scaled variants of AGF2. Typical values are 1.0 (no scaling) or empirically tuned values used in SCS/OS schemes; passing a non-finite value will propagate to the C driver and may produce NaNs or raise errors.
        ss_factor (float): Same-spin scaling factor (default 1.0). This scalar multiplies the same-spin contribution inside the AGF2 matrix construction performed by the C driver. As with os_factor, use 1.0 for the unscaled method or other positive floats for spin-scaled variants. Non-finite or extreme values can produce invalid numerical results or failures.
    
    Returns:
        tuple: Two numpy.ndarray objects (vv, vev), each of shape (nmo, nmo) and dtype float64. Both arrays are constructed as flattened C-order arrays inside the function, filled by the wrapped C driver, and then reshaped to (nmo, nmo) before being returned. These matrices represent condensed two-electron contributions assembled from qeri and the orbital energies and are used downstream in the rAGF2 implementation to build self-energies and effective Hamiltonian terms.
    
    Behavior, side effects, and failure modes:
        The function wraps the compiled driver libagf2.AG F2ee_vv_vev_islice and therefore performs an out-of-Python call via ctypes. It enforces qeri.ndim == 4 and creates C-contiguous copies of qeri, e_occ, and e_vir (np.asarray(..., order='C')) to satisfy the C interface. It allocates temporary flattened buffers for vv and vev with length nmo*nmo and passes pointers and integer parameters (nmo, nocc, nvir, istart, iend) to the driver. The occupied-index slice (istart,iend) is chosen from mpi_helper.rank and mpi_helper.size so the routine performs a distributed workload across MPI ranks; after the driver call the function executes mpi_helper.barrier() and mpi_helper.allreduce_safe_inplace(...) to combine per-rank contributions into final global vv and vev arrays. Because of these MPI operations, calling this function requires an MPI-aware execution environment consistent with pyscf.agf2.mpi_helper; incorrect MPI setup can cause hangs or synchronization failures. The C driver symbol must be present in libagf2; if AGF2ee_vv_vev_islice is missing an AttributeError will be raised when attempting to get the function. Mis-sized inputs, non-contiguous arrays, or mismatched dimensions between qeri and the orbital-energy arrays can lead to AssertionError, exceptions from numpy, or segmentation faults inside the native driver. The function returns newly allocated numpy arrays and does not modify the caller-provided qeri, e_occ, or e_vir objects.
    """
    from pyscf.agf2._agf2 import build_mats_ragf2_incore
    return build_mats_ragf2_incore(qeri, e_occ, e_vir, os_factor, ss_factor)


################################################################################
# Source: pyscf.agf2._agf2.build_mats_uagf2_incore
# File: pyscf/agf2/_agf2.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_agf2__agf2_build_mats_uagf2_incore(
    qeri: tuple,
    e_occ: tuple,
    e_vir: tuple,
    os_factor: float = 1.0,
    ss_factor: float = 1.0
):
    """Builds two unrestricted AGF2 intermediate matrices (vv and vev) in-core by calling the compiled C driver AGF2uee_vv_vev_islice from libagf2 and reducing partial results across MPI ranks.
    
    Args:
        qeri (tuple): A 2-tuple of 4-dimensional numpy arrays holding spin-resolved two-electron repulsion integrals used by unrestricted AGF2 (uAGF2). qeri[0] and qeri[1] correspond to the alpha- and beta-spin integral tensors respectively. Each array must have ndim == 4 and the first dimension size defines the number of molecular orbitals nmo used to size the output matrices. These integrals are the fundamental electron-electron interaction inputs from which frequency-independent AGF2 intermediates are constructed.
        e_occ (tuple): A 2-tuple of 1-dimensional numpy arrays containing occupied orbital energies for the alpha and beta spin channels. e_occ[0] has length noa (number of alpha occupied orbitals) and e_occ[1] has length nob (number of beta occupied orbitals). These orbital energies are used by the C driver to form energy denominators in the unrestricted AGF2 intermediate construction.
        e_vir (tuple): A 2-tuple of 1-dimensional numpy arrays containing virtual orbital energies for the alpha and beta spin channels. e_vir[0] has length nva and e_vir[1] has length nvb. These virtual energies are combined with e_occ and the two-electron integrals by the C driver to produce the vv and vev matrices.
        os_factor (float): Opposite-spin scaling factor applied inside the AGF2 C driver. Defaults to 1.0. In practical AGF2 calculations this scalar multiplies contributions arising from opposite-spin electron pair channels to enable empirical scaling or spin-component-scaled variants of the method. The value is passed to the C routine as a double and must be finite.
        ss_factor (float): Same-spin scaling factor applied inside the AGF2 C driver. Defaults to 1.0. In practical AGF2 calculations this scalar multiplies same-spin contributions and is used analogously to os_factor to control same-spin correlation weight. The value is passed to the C routine as a double and must be finite.
    
    Behavior and side effects:
        The function converts inputs to C-contiguous numpy arrays and obtains their raw data pointers to call the libagf2 C driver AGF2uee_vv_vev_islice. It allocates two flat double arrays of length nmo*nmo for the outputs, calls the driver with MPI work slicing determined from mpi_helper.rank and mpi_helper.size (istart and iend partition the alpha-occupied index range), and reshapes the computed flat arrays to (nmo, nmo) numpy arrays named vv and vev. After the local driver call, the function performs an MPI barrier and then reduces (all-reduces) vv and vev in-place across ranks using mpi_helper.allreduce_safe_inplace, returning the globally aggregated results. The function therefore has MPI side effects: it participates in collective synchronization and reduction operations and will block until the barrier and reductions complete.
    
    Defaults:
        os_factor and ss_factor default to 1.0, producing the unscaled uAGF2 intermediates. The function assumes the libagf2 driver AGF2uee_vv_vev_islice is available and properly linked.
    
    Failure modes and errors:
        An AssertionError is raised if qeri[0].ndim or qeri[1].ndim is not 4. The function will also raise typical numpy/type errors if the provided tuples do not contain array-like objects of compatible sizes (for example mismatched lengths of e_occ/e_vir entries relative to the integral tensor shapes). The underlying C driver may raise or abort on invalid memory or incompatible array shapes; such failures will manifest as Python exceptions or process termination. MPI-related misconfiguration (incorrect mpi_helper.rank/size or unmatched communicators) can cause deadlock in the barrier/allreduce calls.
    
    Returns:
        tuple: A pair of numpy.ndarray objects (vv, vev) each with shape (nmo, nmo), where nmo is the number of molecular orbitals inferred from qeri[0]. These arrays are the frequency-independent unrestricted AGF2 intermediate matrices produced by contracting the input two-electron integrals with occupied and virtual orbital energies and scaling factors. They are returned in global (post-allreduce) form suitable for subsequent uAGF2 self-energy construction or other correlated post-processing steps.
    """
    from pyscf.agf2._agf2 import build_mats_uagf2_incore
    return build_mats_uagf2_incore(qeri, e_occ, e_vir, os_factor, ss_factor)


################################################################################
# Source: pyscf.agf2._agf2.build_mats_dfuagf2_lowmem
# File: pyscf/agf2/_agf2.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_agf2__agf2_build_mats_dfuagf2_lowmem(
    qxi: tuple,
    qja: tuple,
    e_occ: tuple,
    e_vir: tuple,
    os_factor: float = 1.0,
    ss_factor: float = 1.0
):
    """Build low-memory DF-U-AGF2 intermediate matrices vv and vev by calling the C driver AGF2udf_vv_vev_islice_lowmem, producing two real square matrices used by the density-fitted unrestricted AGF2 (DF-U-AGF2) algorithm in PySCF. This wrapper prepares Python-side inputs (spin-resolved auxiliary tensors and orbital energies), partitions the work across MPI ranks by slicing occupied-index blocks, calls the libagf2 C routine via ctypes, and then performs MPI reductions to produce the global vv and vev matrices. In the PySCF/AGF2 domain these matrices are energy-weighted auxiliary contractions used as intermediate building blocks for constructing the frequency-independent parts of the AGF2 self-energy in a low-memory workflow.
    
    Args:
        qxi (tuple): A length-2 tuple (qxi_a, qxi_b) of numpy arrays representing the occupied-auxiliary coupling tensors for alpha and beta spin channels respectively. Each array is expected to be a flat/packed 1-D array with total size equal to naux * nmo * no, where naux is the number of auxiliary functions, nmo is the number of molecular orbitals inferred from the input, and no is the number of occupied orbitals for the corresponding spin. qxi supplies the C driver with the auxiliary–occupied coupling (xi) data required to contract over auxiliaries and occupied indices in the DF-U-AGF2 low-memory slice routine.
        qja (tuple): A length-2 tuple (qja_a, qja_b) of numpy arrays representing the occupied-virtual-auxiliary coupling tensors for alpha and beta spins respectively. qja_a is expected to have size naux * noa * nva and qja_b size naux * nob * nvb (flattened); these arrays supply the C driver with the ja coupling data that connects occupied and virtual orbitals through auxiliary functions and are necessary to form the vv and vev intermediates.
        e_occ (tuple): A length-2 tuple (e_i, e_I) of 1-D numpy arrays containing occupied orbital energies for the alpha and beta spin manifolds respectively. The arrays must have lengths noa and nob (number of occupied alpha and beta orbitals). These orbital energies are used inside the C driver to form energy denominators and energy-weighted contractions that define the vev intermediate and spin-dependent contributions.
        e_vir (tuple): A length-2 tuple (e_a, e_A) of 1-D numpy arrays containing virtual orbital energies for the alpha and beta spin manifolds respectively. The arrays must have lengths nva and nvb (number of virtual alpha and beta orbitals). Virtual energies are used by the C driver to compute energy-weighted contractions that enter the vev intermediate.
        os_factor (float, optional): Scaling factor applied to opposite-spin contributions. Default 1.0. In the AGF2 correlation construction this scales terms arising from opposite-spin electron pairs; changing it modifies the relative weight of opposite-spin channels computed by the C driver.
        ss_factor (float, optional): Scaling factor applied to same-spin contributions. Default 1.0. In AGF2 this scales terms arising from same-spin electron pairs; the C driver receives this value to weight same-spin contributions appropriately.
    
    Returns:
        tuple: Two numpy.ndarray objects (vv, vev) of dtype float64 and shape (nmo, nmo) where nmo is inferred from the input qxi arrays. vv is the auxiliary–auxiliary contracted matrix (conceptually a v·v type contraction) and vev is an energy-weighted auxiliary contraction (v·e·v) used as intermediate matrices in the DF-U-AGF2 low-memory algorithm. Both arrays are constructed in a distributed fashion: each MPI rank computes a slice determined by mpi_helper.rank/mpi_helper.size (start and end indices computed from noa and nob), the C driver writes into local buffers, and mpi_helper.allreduce_safe_inplace is used to collect and sum contributions across ranks before the final arrays are returned.
    
    Behavior and side effects:
        This function converts inputs to C-contiguous numpy arrays (np.asarray(..., order='C')) and allocates temporary 1-D buffers for vv and vev of length nmo*nmo before reshaping them to (nmo, nmo) after the C call. It calls the libagf2 C symbol AGF2udf_vv_vev_islice_lowmem via ctypes, passing raw pointers to the data and several integer and double parameters (nmo, noa, nob, nva, nvb, naux, start, end, os_factor, ss_factor). After the C driver returns, an MPI barrier is issued and the local vv and vev arrays are reduced in place across all ranks using mpi_helper.allreduce_safe_inplace. The returned arrays are the globally reduced results.
    
    Defaults:
        os_factor and ss_factor default to 1.0, producing the standard unscaled opposite- and same-spin contributions used in DF-U-AGF2.
    
    Failure modes and preconditions:
        The function asserts that array sizes match the expected flattened sizes; if the provided qxi or qja arrays do not have the expected total lengths (naux * nmo * no or naux * no * nv) an AssertionError is raised. The C driver requires that the libagf2 shared library expose AGF2udf_vv_vev_islice_lowmem; if it is missing or the ctypes call is provided incompatible data, the process may raise an OSError or crash (segmentation fault). MPI must be available and mpi_helper.rank/size must be set; if MPI is not initialized or mpi_helper is not configured, the partitioning and reduction behavior will fail. Inputs should be convertible to contiguous numpy arrays of float64; np.asarray(..., order='C') is used but insufficient memory or incorrect dtypes at the C boundary may still cause errors.
    """
    from pyscf.agf2._agf2 import build_mats_dfuagf2_lowmem
    return build_mats_dfuagf2_lowmem(qxi, qja, e_occ, e_vir, os_factor, ss_factor)


################################################################################
# Source: pyscf.agf2._agf2.build_mats_dfuagf2_incore
# File: pyscf/agf2/_agf2.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_agf2__agf2_build_mats_dfuagf2_incore(
    qxi: tuple,
    qja: tuple,
    e_occ: tuple,
    e_vir: tuple,
    os_factor: float = 1.0,
    ss_factor: float = 1.0
):
    """Builds the in-core vv and vev intermediate matrices for the density-fitted,
    unrestricted AGF2 implementation by calling the compiled driver
    AGF2udf_vv_vev_islice. This wrapper is used in PySCF's agf2 module to
    assemble two intermediate nmo-by-nmo matrices (vv and vev) that are required
    by the density-fitted unrestricted AGF2 (df-uAGF2) correlation/self-energy
    routines. The function partitions work over MPI ranks using mpi_helper, invokes
    the C driver with contiguous arrays, and then reduces partial results from all
    ranks into the final full matrices.
    
    Args:
        qxi (tuple): Tuple of two arrays corresponding to the "qxi" DF contraction
            data for alpha and beta spins, in that order: (qxi_alpha, qxi_beta).
            Each element is expected to be an array-like object that can be
            converted with numpy.asarray(order='C'). The function computes
            naux = qxi[0].shape[0], noa from e_occ[0].size and nmo from
            qxi[0].size // (naux * noa), and asserts that qxi[0].size ==
            (naux * nmo * noa). These arrays provide the density-fitting tensor
            slices required by the underlying C driver AGF2udf_vv_vev_islice and
            therefore must have the same flattened layout and lengths implied by
            the occupied/virtual counts provided in e_occ and e_vir.
        qja (tuple): Tuple of two arrays corresponding to the "qja" DF contraction
            data for alpha and beta spins, in that order: (qja_alpha, qja_beta).
            Each element is expected to be an array-like object convertible to a
            contiguous numpy array. The function asserts qja[0].size ==
            (naux * noa * nva) and qja[1].size == (naux * nob * nvb) where naux,
            noa, nob, nva, nvb are derived from qxi, e_occ, and e_vir as in the
            code. These arrays supply the other density-fitted tensor slices that
            the C driver consumes.
        e_occ (tuple): Tuple of two one-dimensional arrays of occupied orbital
            energies for alpha and beta spins, in that order: (e_occ_alpha,
            e_occ_beta). Each element must be indexable and convertible to a
            contiguous numpy array (the code uses numpy.asarray(order='C')) and
            defines noa = e_occ[0].size and nob = e_occ[1].size. These energies
            are passed to the C driver and determine the occupied-space dimensions
            used to slice/contract the DF tensors.
        e_vir (tuple): Tuple of two one-dimensional arrays of virtual orbital
            energies for alpha and beta spins, in that order: (e_vir_alpha,
            e_vir_beta). Each element must be convertible to a contiguous numpy
            array (numpy.asarray(order='C')) and defines nva = e_vir[0].size and
            nvb = e_vir[1].size. These energies are passed to the C driver and
            determine the virtual-space dimensions used by the DF contractions.
        os_factor (float): Opposite-spin scaling factor applied inside the C
            driver. Default is 1.0. The float is forwarded to the compiled
            routine as a C double (ctypes.c_double) and scales the opposite-spin
            contribution to the constructed vv and vev intermediates. Use this to
            modify the relative weight of opposite-spin contributions consistent
            with the df-uAGF2 formulation.
        ss_factor (float): Same-spin scaling factor applied inside the C driver.
            Default is 1.0. The float is forwarded to the compiled routine as a
            C double (ctypes.c_double) and scales the same-spin contribution to
            the constructed vv and vev intermediates.
    
    Behavior and side effects:
        The function converts the provided tuple elements to contiguous numpy
        arrays with order='C' and performs several internal consistency checks
        (assertions) on flattened sizes to recover the number of auxiliaries
        (naux), occupied orbitals per spin (noa, nob), virtual orbitals per spin
        (nva, nvb), and molecular orbitals (nmo). It allocates two flat double
        arrays of length nmo*nmo (vv and vev), calls the compiled driver
        AGF2udf_vv_vev_islice through ctypes with pointers to the contiguous
        buffers, and passes MPI slice indices (istart, iend) derived from
        mpi_helper.rank and mpi_helper.size so each MPI rank computes a disjoint
        slice of the work. After the C driver returns, the flat results are
        reshaped to (nmo, nmo). The function calls mpi_helper.barrier() and then
        mpi_helper.allreduce_safe_inplace(...) to sum partial contributions from
        all ranks into the final vv and vev matrices. The function therefore has
        the side effect of performing MPI synchronization and reduction; it
        requires an mpi_helper object with attributes rank, size, barrier and
        allreduce_safe_inplace available in the module scope.
    
    Failure modes and requirements:
        The function will raise AssertionError if the flattened array sizes do not
        match the expectations derived from qxi, qja, e_occ and e_vir. An
        AttributeError will occur if the compiled driver AGF2udf_vv_vev_islice is
        not present in libagf2. The C driver may raise segmentation faults or
        other low-level errors if the provided buffers, dimensions, or MPI slicing
        are inconsistent; therefore inputs must match the layout and lengths the
        df-uAGF2 compiled routine expects. The function assumes availability of
        numpy, ctypes, libagf2.AGF2udf_vv_vev_islice, and a functional mpi_helper
        in the module namespace.
    
    Returns:
        tuple: A pair (vv, vev) where both vv and vev are numpy.ndarray objects
        with shape (nmo, nmo). These matrices are the assembled in-core
        df-uAGF2 intermediates produced by AGF2udf_vv_vev_islice, after MPI
        reduction. They are the objects returned to the caller for use in
        subsequent unrestricted AGF2 correlation and self-energy calculations.
    """
    from pyscf.agf2._agf2 import build_mats_dfuagf2_incore
    return build_mats_dfuagf2_incore(qxi, qja, e_occ, e_vir, os_factor, ss_factor)


################################################################################
# Source: pyscf.agf2._agf2.build_mats_dfragf2_incore
# File: pyscf/agf2/_agf2.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_agf2__agf2_build_mats_dfragf2_incore(
    qxi: numpy.ndarray,
    qja: numpy.ndarray,
    e_occ: numpy.ndarray,
    e_vir: numpy.ndarray,
    os_factor: float = 1.0,
    ss_factor: float = 1.0
):
    """build_mats_dfragf2_incore(qxi, qja, e_occ, e_vir, os_factor=1.0, ss_factor=1.0)
    Build nmo-by-nmo intermediate matrices for the density-fitted fragment AGF2 procedure using the in-core C driver AGF2df_vv_vev_islice and MPI slicing over occupied orbitals.
    
    This function is a thin Python wrapper around the compiled libagf2 routine AGF2df_vv_vev_islice. It prepares inputs, determines array sizes (number of auxiliary functions, occupied and virtual orbitals, and molecular orbitals), slices the occupied-orbital index range for the current MPI rank, calls the C driver with C-contiguous buffers via ctypes, then performs an MPI all-reduce to sum the per-rank contributions. The outputs vv and vev are the two nmo-by-nmo intermediate matrices produced by the C routine; these matrices are used inside the AGF2 (second-order Green's function) implementation in PySCF for assembling correlation/self-energy contributions in the density-fitted fragment variant (dfragf2).
    
    Args:
        qxi (numpy.ndarray): Array holding density-fitted integrals or intermediate tensors arranged so that qxi.size == naux * nmo * nocc where naux is the number of auxiliary basis functions, nmo is the number of molecular orbitals, and nocc is the number of occupied orbitals (nocc == e_occ.size). The code treats qxi as C-contiguous memory and calls np.asarray(qxi, order='C') internally; therefore qxi must be convertible to a C-order contiguous numpy array. The practical role of qxi is to supply the C driver with the auxiliary-occupied-molecular orbital data needed to build the vv and vev intermediates for AGF2 density-fitted fragment calculations.
        qja (numpy.ndarray): Array holding density-fitted integrals or intermediate tensors arranged so that qja.size == naux * nocc * nvir where nvir is the number of virtual orbitals (nvir == e_vir.size). Like qxi, qja is converted to C-order inside the function. qja provides the auxiliary-occupied-virtual data consumed by the C driver to construct the same intermediates used by the AGF2 algorithm.
        e_occ (numpy.ndarray): One-dimensional array of occupied orbital energies with length nocc. The function uses e_occ to form denominators or energy-dependent factors inside the C driver; it is converted to a C-order numpy array named e_i internally. The practical significance is that these orbital energies define the occupied-space spectral positions used by AGF2 correlation integrals.
        e_vir (numpy.ndarray): One-dimensional array of virtual orbital energies with length nvir. The function uses e_vir as the virtual-space energies (converted internally to a C-order numpy array named e_a) required by the C driver to evaluate energy-dependent contributions to the vv and vev intermediates in AGF2.
        os_factor (float): Scalar multiplicative factor applied to opposite-spin contributions inside the AGF2df_vv_vev_islice driver. Defaults to 1.0. In practice this parameter lets callers scale the opposite-spin part of the two-body contributions (for example, to implement spin-scaling variants of correlation treatments) before the intermediates are accumulated.
        ss_factor (float): Scalar multiplicative factor applied to same-spin contributions inside the AGF2df_vv_vev_islice driver. Defaults to 1.0. This parameter lets callers scale the same-spin part of the two-body contributions analogously to os_factor.
    
    Behavior, side effects, defaults, and failure modes:
        - The function infers naux from qxi.shape[0], nocc from e_occ.size, nvir from e_vir.size, and computes nmo from qxi.size // (naux*nocc). It asserts that qxi.size == (naux * nmo * nocc) and that qja.size == (naux * nocc * nvir). If these size assertions fail, an AssertionError is raised.
        - The function converts qxi, qja, e_occ, and e_vir to C-contiguous numpy arrays (np.asarray(..., order='C')) before passing pointers to the C driver via ctypes. Inputs must therefore be convertible to C-order arrays; otherwise the conversion may allocate copies but the shape/size constraints still apply.
        - The implementation uses mpi_helper.rank and mpi_helper.size to compute a per-rank occupied index slice [start:end) and calls the C driver with these start/end indices so that work is distributed across MPI ranks. It then calls mpi_helper.barrier() and mpi_helper.allreduce_safe_inplace(...) on the vv and vev arrays to produce final globally summed results. These MPI operations are side effects: they synchronize processes and perform in-place global reductions of the intermediate matrices.
        - The C driver invoked is libagf2.AGF2df_vv_vev_islice; AttributeError will occur if libagf2 or that symbol is not present. The function relies on correct runtime linkage of the compiled driver and on mpi_helper being available and correctly configured.
        - The arrays vv and vev are created inside the function as flat numpy.zeros buffers of length nmo*nmo, passed to the C driver and reshaped to (nmo, nmo) on return. Their dtype will be the default numpy float type for zeros() (typically float64) unless the environment or caller modifies numpy defaults.
        - No input arrays are modified in-place by this function; qxi, qja, e_occ, and e_vir are converted to C-order copies if necessary, but the provided objects are not overwritten.
    
    Returns:
        tuple(numpy.ndarray, numpy.ndarray): A pair (vv, vev). Each element is a numpy.ndarray of shape (nmo, nmo) containing the intermediate matrices produced by the AGF2df_vv_vev_islice driver and then summed across MPI ranks. These matrices are the assembled two-index intermediates used by the AGF2 density-fitted fragment implementation in PySCF to build correlation/self-energy contributions.
    """
    from pyscf.agf2._agf2 import build_mats_dfragf2_incore
    return build_mats_dfragf2_incore(qxi, qja, e_occ, e_vir, os_factor, ss_factor)


################################################################################
# Source: pyscf.agf2._agf2.build_mats_dfuagf2_outcore
# File: pyscf/agf2/_agf2.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_agf2__agf2_build_mats_dfuagf2_outcore(
    qxi: tuple,
    qja: tuple,
    e_occ: tuple,
    e_vir: tuple,
    os_factor: float = 1.0,
    ss_factor: float = 1.0
):
    """Builds the vv and vev matrices for the density-fitted, unrestricted AGF2 (DF-UAGF2)
    out-of-core slice implementation used in PySCF's AGF2 module.
    
    This Python implementation corresponds to the lower-level routine AGF2udf_vv_vev_islice and is used to accumulate two related matrices required by the AGF2 self-energy construction: vv, a spin-weighted coupling matrix accumulated from auxiliary integral slices, and vev, the same coupling matrix weighted by excitation energy denominators. The function is designed to operate on flattened / sliced density-fitting auxiliary arrays (qxi, qja) so that large datasets can be processed "outcore" (slice-by-slice) and then globally reduced across MPI ranks. It performs local contractions with BLAS (lib.dot), applies same-spin and opposite-spin prefactors, and synchronizes the final results using mpi_helper.barrier() and mpi_helper.allreduce_safe_inplace().
    
    Args:
        qxi (tuple): Two-element tuple (qxi_a, qxi_b) of 1-D numpy arrays containing the density-fitting auxiliary integrals contracted with orbital/virtual bases for the alpha and beta spins. The routine expects qxi[0].shape[0] to be the number of auxiliaries (naux). For the alpha block, qxi_a is interpreted as a flattened array with logical shape (naux, nmo, noa) so that qxi_a.size == naux * nmo * noa; the code computes nmo = qxi_a.size // (naux * noa). The beta block qxi_b is the corresponding data for beta spin. These arrays supply the sliced auxiliary-to-orbital coupling used in the dot products that form vv and vev.
    
        qja (tuple): Two-element tuple (qja_a, qja_b) of 1-D numpy arrays containing the density-fitting auxiliary integrals contracted with occupied and virtual index combinations for alpha and beta spins. The routine expects qja_a.size == naux * noa * nva and qja_b.size == naux * nob * nvb where noa/nob are numbers of occupied orbitals and nva/nvb are numbers of virtual orbitals (derived from e_occ and e_vir). qja arrays provide the auxiliary-to-(occupied,virtual) blocks used to form xija and xjia intermediates in the contractions.
    
        e_occ (tuple): Two-element tuple (e_occ_a, e_occ_b) of 1-D arrays of occupied orbital energies for alpha and beta spins. The lengths define noa and nob used throughout the routine (noa = e_occ[0].size, nob = e_occ[1].size). These energies enter the construction of excitation denominators (added to -e_vir) and are used to compute the energy-weighted vev matrix.
    
        e_vir (tuple): Two-element tuple (e_vir_a, e_vir_b) of 1-D arrays of virtual orbital energies for alpha and beta spins. The lengths define nva and nvb (nva = e_vir[0].size, nvb = e_vir[1].size). e_vir is used together with e_occ to form the excitation energies e_ja = e_occ[:,None] - e_vir[None,:] (flattened) which weight contributions to vev.
    
        os_factor (float): Scalar prefactor applied to opposite-spin (alpha-beta) contributions. Default is 1.0. In the accumulation, terms involving cross-spin (alpha vs beta) contractions are multiplied by this factor. Changing this value scales the opposite-spin part of the resulting vv and vev matrices.
    
        ss_factor (float): Scalar prefactor applied to same-spin (alpha-alpha) contributions. Default is 1.0. The code uses ss_factor with both positive and negative signs (fposa = ss_factor; fnega = -ss_factor) to implement the same-spin direct and exchange sign structure; altering ss_factor rescales same-spin contributions (including exchange sign via fnega).
    
    Behavior and side effects:
        The routine infers internal dimensions (naux, noa, nob, nva, nvb, nmo) from array sizes and asserts consistency between expected flattened sizes and the provided arrays. If these shape/size assertions fail an AssertionError will be raised. The function iterates over alpha occupied indices (range(noa)), forms intermediate contractions using lib.dot, and accumulates into local vv and vev numpy arrays of shape (nmo, nmo) using the spin prefactors described above. The vev matrix is the energy-weighted analogue computed by multiplying appropriate intermediates by the excitation denominators before accumulation.
    
        This function performs MPI synchronization and global reduction: it calls mpi_helper.barrier() and mpi_helper.allreduce_safe_inplace() to reduce the local vv and vev across MPI ranks into final global matrices. As a result, calling processes should have a functioning mpi_helper and a communicator setting compatible with mpi_helper operations; MPI-related failures or misconfiguration will cause communication errors.
    
        Numerical/implementation notes: the routine relies on PySCF's lib.direct_sum and lib.dot for vectorized energy-sum construction and BLAS-backed contractions. Input arrays must be compatible with these routines (typically numpy arrays of floating dtype). The routine uses in-place accumulation (lib.dot with c=...) and returns the final accumulated arrays.
    
    Failure modes:
        AssertionError when input array sizes do not match the expected flattened shapes derived from naux, nmo, noa, nva, nob, nvb.
        Exceptions raised by lib.dot or lib.direct_sum for incompatible dtypes/shapes.
        MPI communication errors or deadlock if mpi_helper is misconfigured or the calling environment does not provide matching ranks for the allreduce operations.
    
    Returns:
        tuple: A pair (vv, vev) of numpy.ndarray objects, both shaped (nmo, nmo). vv is the spin-weighted coupling matrix accumulated from contracted auxiliary slices and spin prefactors; vev is the energy-weighted version where each contribution is multiplied by the corresponding excitation energy denominator (constructed from e_occ and e_vir). Both arrays are globally reduced across MPI ranks before being returned.
    """
    from pyscf.agf2._agf2 import build_mats_dfuagf2_outcore
    return build_mats_dfuagf2_outcore(qxi, qja, e_occ, e_vir, os_factor, ss_factor)


################################################################################
# Source: pyscf.agf2._agf2.build_mats_uagf2_outcore
# File: pyscf/agf2/_agf2.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_agf2__agf2_build_mats_uagf2_outcore(
    qeri: list,
    e_occ: list,
    e_vir: list,
    os_factor: float = 1.0,
    ss_factor: float = 1.0
):
    """Build vv and vev matrices for unrestricted AGF2 (uAGF2) using out-of-core,
    slice-by-slice two-electron integral factors.
    
    This function is the Python reimplementation of the routine named
    AGF2uee_vv_vev_islice used in the PySCF AGF2 machinery. It is intended for
    use in unrestricted (spin-separated) AGF2 calculations within the PySCF
    framework and supports out-of-core evaluation by iterating over slices of the
    factorized two-electron integrals (qeri). The computed matrices vv and vev
    represent accumulated bilinear forms of integral-factor slices and energy
    denominator-weighted slices respectively; in practice these objects are used
    inside AGF2 self-energy construction and related post-Hartree–Fock routines
    where contributions from same-spin and opposite-spin channels are combined.
    
    Args:
        qeri (list): A list containing two factorized two-electron-integral
            containers (one per spin channel). Each entry must be a 4-dimensional
            array-like object (asserted in the implementation) that can be indexed
            and reshaped as in the source code. The first dimension size nmo is
            taken as the number of molecular orbitals (nmo = qeri[0].shape[0]).
            qeri is consumed slice-by-slice in the occupied index to support
            out-of-core workflows: the function expects to be able to read
            qeri[spin][:, i] and qeri[spin][:, :, i] for occupied-index i while
            avoiding construction of a full in-memory 4-index tensor.
        e_occ (list): A list of two one-dimensional arrays (alpha, beta) of
            occupied orbital energies. The implementation uses e_occ[0].size to
            determine the number of alpha occupied orbitals (noa) and accesses
            e_occ[0][i] inside the loop. These energies are used to build energy
            denominators that weight contributions to the vev matrix and to
            compute combined excitation energies used in the intermediate
            multiplications.
        e_vir (list): A list of two one-dimensional arrays (alpha, beta) of
            virtual orbital energies. e_vir is paired with e_occ to form
            excitation-denominator arrays (direct sums of occupied and virtual
            energies) which are ravelled and added to per-slice occupied energies
            to obtain the eija arrays used when forming energy-weighted slices.
        os_factor (float): Scaling factor applied to opposite-spin (alpha-beta)
            contributions when accumulating the vv and vev matrices. The code
            multiplies alpha-beta slice contributions by this factor; set to 1.0
            by default to include full opposite-spin contributions or to other
            values to scale/approximate correlation contributions.
        ss_factor (float): Scaling factor applied to same-spin (alpha-alpha)
            contributions. Internally this value is used both with positive sign
            for x(i,j)·x(i,j)^T terms and with negative sign for the x(i,j)·x(j,i)^T
            mirror terms (fposa = ss_factor, fnega = -ss_factor). The default 1.0
            reproduces the standard same-spin weighting used in the original
            routine.
    
    Behavior and side effects:
        The function allocates local numpy arrays vv and vev of shape (nmo, nmo)
        and accumulates contributions by looping over occupied alpha slices
        (range determined from e_occ[0].size). For each slice i it extracts three
        slice views from qeri (xija_aa, xija_ab, xjia_aa), forms BLAS-friendly
        2D arrays via reshape, and updates vv and vev through a sequence of
        matrix-matrix products (lib.dot) and elementwise multiplications with
        energy-denominator vectors. The same-spin alpha-alpha blocks are weighted
        by ss_factor (with the mirror term negated) and the opposite-spin
        alpha-beta blocks are weighted by os_factor, matching the logic of the
        AGF2 implementation this function mirrors.
        After the local accumulation completes the function invokes mpi_helper.barrier()
        and mpi_helper.allreduce_safe_inplace on both vv and vev, performing an
        MPI-aware global reduction so the returned matrices are summed across MPI
        ranks. Consequently the function has network/parallel side effects and
        requires the mpi_helper utilities accessible in the running PySCF
        environment.
    
    Defaults and performance notes:
        The default os_factor=1.0 and ss_factor=1.0 produce the standard
        spin-summed contributions. The implementation is BLAS-heavy (uses
        lib.dot) and is designed to be efficient when linked to optimized BLAS
        libraries. By iterating over occupied slices it reduces memory pressure
        and supports out-of-core integral representations, but overall runtime
        scales with the number of occupied orbitals and the sizes of the factorized
        qeri slices.
    
    Failure modes and preconditions:
        The function asserts that qeri[0].ndim == qeri[1].ndim == 4 and will raise
        AssertionError if that condition fails. The function also assumes that
        qeri, e_occ, and e_vir are indexable as lists with two entries (alpha and
        beta); missing entries or mismatched lengths will raise IndexError or
        other runtime errors. If the mpi_helper utilities are not available or not
        configured correctly, the barrier/allreduce calls may raise exceptions or
        cause incorrect behavior; correct parallel operation depends on the
        environment provided by PySCF's mpi_helper.
    
    Returns:
        tuple: A pair (vv, vev) where each element is a numpy.ndarray of shape
        (nmo, nmo) (nmo taken from qeri[0].shape[0]). vv is the accumulated
        bilinear (integral-factor · integral-factor^T) contribution with spin
        scalings applied; vev is the corresponding energy-weighted accumulation
        (integral-factor multiplied by excitation-energy denominators before
        accumulation). Both arrays have been globally summed across MPI ranks via
        mpi_helper.allreduce_safe_inplace before being returned and are ready for
        downstream use in AGF2 self-energy construction and related PySCF routines.
    """
    from pyscf.agf2._agf2 import build_mats_uagf2_outcore
    return build_mats_uagf2_outcore(qeri, e_occ, e_vir, os_factor, ss_factor)


################################################################################
# Source: pyscf.agf2.chkfile.load
# File: pyscf/agf2/chkfile.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_agf2_chkfile_load(chkfile: str, key: str):
    """pyscf.agf2.chkfile.load: Load array(s) stored under a given key from a PySCF checkpoint file and distribute the loaded object to all MPI ranks.
    
    This function is used by AGF2 and other PySCF workflows to read persistent intermediate data (arrays, scalars, or Python objects) from a checkpoint file created by PySCF I/O utilities and to ensure every MPI process receives the same object without every rank performing file I/O. It delegates the actual file read to pyscf.lib.chkfile (via chkutil.load) on MPI rank 0 only, then synchronizes and broadcasts the result to all ranks using mpi_helper.barrier and mpi_helper.bcast_dict. Consult pyscf.lib.chkfile for the precise storage format and semantics of stored keys.
    
    Args:
        chkfile (str): Filesystem path to the PySCF checkpoint file to read. This is the same kind of checkpoint file used throughout PySCF to store persistent computation state and intermediate arrays; providing the correct path is required for successful load. Only MPI rank 0 performs file I/O on this path.
        key (str): The string identifier used inside the checkpoint file to index the stored object(s). This must match the key used when the data were written (for example by pyscf.lib.chkfile write utilities). The function returns the object associated with this key.
    
    Returns:
        object: The Python object loaded from the checkpoint for the given key, exactly as returned by pyscf.lib.chkfile loader (for example a NumPy array, scalar, or a nested dict of arrays). The returned object is the same on every MPI rank after the broadcast.
    
    Behavior, side effects, defaults, and failure modes:
        On MPI rank 0 the function calls chkutil.load(chkfile, key) to perform file I/O and obtain the value(s). All other ranks set vals to None. The function then calls mpi_helper.barrier() to synchronize ranks and mpi_helper.bcast_dict(vals) to broadcast the loaded object from rank 0 to all ranks. As a side effect, rank 0 performs disk I/O and only rank 0 reads the checkpoint file to reduce redundant concurrent file access in parallel runs. If chkutil.load raises an exception on rank 0 (for example file not found, permission error, or missing key), that exception occurs before the barrier; other ranks will not reach the barrier and the program may deadlock or terminate depending on the MPI runtime. Broadcast and barrier operations rely on the mpi_helper implementation; in serial or single-process use mpi_helper is a no-op and the function simply returns the loaded object.
    """
    from pyscf.agf2.chkfile import load
    return load(chkfile, key)


################################################################################
# Source: pyscf.agf2._agf2.build_mats_ragf2_outcore
# File: pyscf/agf2/_agf2.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_agf2__agf2_build_mats_ragf2_outcore(
    qeri: numpy.ndarray,
    e_occ: numpy.ndarray,
    e_vir: numpy.ndarray,
    os_factor: float = 1.0,
    ss_factor: float = 1.0
):
    """Build two intermediate two-index matrices used by the restricted AGF2 (RAGF2) out-of-core
    implementation: vv and vev. This function is the Python implementation of the
    AGF2ee_vv_vev_islice routine and is intended to be used within PySCF's
    AGF2 workflow to accumulate contributions from a 4-dimensional slice of
    electron-repulsion integrals (ERIs) together with occupied and virtual
    orbital energies. The resulting matrices are used downstream in RAGF2
    self-energy and energy evaluations as compact two-index intermediates
    that collect spin-weighted ERI contractions and their energy-weighted
    counterparts.
    
    Args:
        qeri (numpy.ndarray): A four-dimensional array of precomputed ERI slices
            supplied to support out-of-core processing. The function asserts
            qeri.ndim == 4 and uses qeri.shape[0] as the number of molecular
            orbitals nmo and e_occ.size as the number of occupied orbitals nocc.
            The implementation accesses qeri[:, i] and qeri[:, :, i] inside the
            loop over occupied indices i and reshapes those slices to (nmo, -1)
            for the internal contractions. The caller must therefore provide qeri
            arranged so that selecting the second or third index by an occupied
            index i yields a contiguous slice that can be reshaped into (nmo, -1).
            This array encodes the two-electron integral information required by
            the outcore RAGF2 contraction; no additional file I/O is performed by
            this function itself.
        e_occ (numpy.ndarray): One-dimensional array of occupied orbital energies.
            Its length determines the number of occupied orbitals nocc used by the
            routine (nocc = e_occ.size). These energies are used to build the
            energy combination e_i + e_j - e_a that weights the vev contraction.
        e_vir (numpy.ndarray): One-dimensional array of virtual orbital energies.
            This array is combined with e_occ via a direct sum to form the term
            e_j - e_a (then shifted by e_i inside the loop) used to weight the
            energy-dependent contraction for vev. The shape and length must be
            consistent with the slices encoded in qeri so that the direct-sum and
            subsequent indexing produce a vector of length nocc * nvir.
        os_factor (float): Opposite-spin prefactor. Default is 1.0. This scalar
            multiplies the contributions that combine opposite-spin coupling in the
            accumulation. The code computes fpos = os_factor + ss_factor and uses
            fpos as the positive weighting factor in the dot-product updates.
        ss_factor (float): Same-spin prefactor. Default is 1.0. This scalar
            contributes to both the positive and negative spin-weighted updates;
            the code uses fneg = -ss_factor as the negative weighting factor for
            one set of contractions. Together with os_factor, ss_factor controls
            the relative weighting of same- and opposite-spin contributions in the
            vv and vev intermediates.
    
    Behavior and side effects:
        The function allocates and returns two dense numpy arrays vv and vev,
        each of shape (nmo, nmo) where nmo = qeri.shape[0]. Internally, vv and
        vev are initialized to zeros and updated by accumulating matrix products
        of reshaped ERI slices. The vev accumulation includes an elementwise
        multiplication by the energy-combination vector e_i + e_j - e_a for each
        occupied index i. The implementation uses lib.dot with alpha/beta scalings
        to update matrices in-place for numerical efficiency.
        The routine uses pyscf's mpi_helper to distribute the loop over occupied
        indices (mpi_helper.nrange) and to synchronize and reduce partial results
        across MPI ranks (mpi_helper.barrier and mpi_helper.allreduce_safe_inplace).
        As a consequence, this function performs MPI collective operations and
        returns globally reduced vv and vev matrices on every rank. The caller
        must ensure the pyscf MPI helper is configured appropriately when running
        in parallel; the function does not initialize or finalize MPI itself.
    
    Defaults:
        os_factor and ss_factor default to 1.0, which corresponds to the standard
        spin-summed weighting used in many RAGF2 implementations. Adjust these
        factors to change the relative contributions of opposite- and same-spin
        channels according to the desired variant of the AGF2 algorithm.
    
    Failure modes and exceptions:
        The function will raise an AssertionError if qeri.ndim != 4. If the shapes
        of qeri, e_occ, and e_vir are inconsistent (for example, if the size of
        e_occ does not match the occupied index range implied by qeri), numpy
        indexing, reshape, or broadcasting operations will raise IndexError,
        ValueError, or related exceptions. Large molecular systems may cause high
        memory usage when forming intermediate reshaped views and the full (nmo,
        nmo) vv/vev matrices and may raise MemoryError. MPI misconfiguration
        (e.g., performing reductions without initializing the MPI environment
        expected by mpi_helper) can result in runtime errors or deadlocks.
    
    Returns:
        tuple: A pair (vv, vev) of numpy.ndarray objects, both with shape
            (nmo, nmo), where nmo = qeri.shape[0].
            vv: The spin-weighted two-index coupling matrix accumulated from the
                ERI slices using positive and negative spin prefactors derived
                from os_factor and ss_factor. This matrix collects the pure
                ERI-contraction contributions used as an intermediate in RAGF2
                self-energy and energy expressions.
            vev: The energy-weighted counterpart of vv in which each ERI slice
                contribution is multiplied by the energy combination e_i + e_j - e_a
                (constructed from e_occ and e_vir). vev is used in RAGF2 to form
                energy-dependent parts of intermediate quantities and ultimately
                contributes to frequency-dependent self-energy building.
    """
    from pyscf.agf2._agf2 import build_mats_ragf2_outcore
    return build_mats_ragf2_outcore(qeri, e_occ, e_vir, os_factor, ss_factor)


################################################################################
# Source: pyscf.agf2.chempot.binsearch_chempot
# File: pyscf/agf2/chempot.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_agf2_chempot_binsearch_chempot(
    fock: tuple,
    nphys: int,
    nelec: int,
    occupancy: int = 2
):
    """Finds a chemical potential that best matches a target number of physical electrons by inspecting the eigenvalues and eigenvectors of a Fock matrix and enforcing the Aufbau principle.
    
    This routine is used in the AGF2 chemical-potential determination within PySCF: given a Fock matrix describing either a physical fragment or an extended (physical + auxiliary) system, it identifies the highest-occupied and lowest-unoccupied molecular orbitals (HOMO/LUMO) with respect to the physical subspace and returns the midpoint eigenvalue as the chemical potential. If the caller supplies a pre-diagonalised Fock (eigenvalues and eigenvectors), the function uses them directly; otherwise it diagonalises the supplied Fock matrix with numpy.linalg.eigh. The function computes the occupation contributed by each molecular orbital to the first nphys rows (the physical degrees of freedom) via the projection n = occupancy * v[:nphys,i].conj().T @ v[:nphys,i] and accumulates this until the accumulated physical electron count brackets the requested nelec. The returned error is the signed difference between the requested nelec and the chosen accumulated electron count (positive means the chosen state has fewer electrons than requested).
    
    Args:
        fock (2D array or tuple of arrays): Fock matrix to diagonalise, or a precomputed eigen-decomposition. In practical AGF2 usage this is either the physical Fock matrix or an extended Fock matrix that includes auxiliary degrees of freedom. If a tuple is provided it must follow the output convention of numpy.linalg.eigh: (w, v) where w is a 1D array of eigenvalues and v is a 2D array whose columns are the corresponding eigenvectors. When a 2D array is provided the function will call numpy.linalg.eigh(fock) internally. The eigenvectors v are expected to have at least nphys rows so that v[:nphys, i] projects the i-th molecular orbital onto the physical subspace.
        nphys (int): Number of physical degrees of freedom. In AGF2 this is the dimension of the physical fragment (for example, the number of physical atomic orbitals or orbitals retained as "physical" in the extended problem). The function uses nphys to restrict population counting to the physical subspace: only the first nphys components of each eigenvector are included when computing how much each molecular orbital contributes to the physical electron count.
        nelec (int): Number of physical electrons to match. This is the target electron count in the physical subspace for which the chemical potential is being determined (for example, the number of electrons in the molecule or fragment). The routine attempts to choose a chemical potential so that, when orbitals are filled according to increasing eigenvalue and weighted by their projection into the physical subspace, the resulting physical electron count is as close as possible to nelec.
        occupancy (int): Occupancy of each spatial orbital when fully occupied: 2 for restricted (RHF) spin-paired occupancy and 1 for unrestricted (UHF) spin-resolved occupancy. Default 2. This factor multiplies the projected MO population and therefore scales the maximum possible physical electron count (maximum = occupancy * nphys). Provide the occupancy that matches how the rest of the AGF2 calculation counts electrons.
    
    Returns:
        tuple: A pair (chempot, error).
            chempot: Scalar chemical potential chosen as 0.5*(epsilon_HOMO + epsilon_LUMO), i.e. the midpoint between the eigenvalues identified as HOMO and LUMO after projecting orbitals onto the physical subspace. This value is intended to be used in shifting orbital energies or in self-consistent procedures that require a chemical potential consistent with the physical electron count.
            error: Signed scalar equal to (nelec - assigned_electrons), where assigned_electrons is the accumulated number of physical electrons used to decide whether the HOMO or LUMO bracketed the target. A value of zero indicates an exact match; a positive value means the chosen accumulated electron count was smaller than requested, a negative value means it was larger.
    
    Behavioral notes, side effects and failure modes:
        - The function is pure with respect to its inputs (it does not modify fock, w, or v). If fock is not pre-diagonalised, the function calls numpy.linalg.eigh(fock) which may be the dominant cost.
        - The algorithm enumerates molecular orbitals in ascending eigenvalue order and accumulates their contributions to the physical electron count until the target nelec lies between two successive cumulative sums, thereby implementing an Aufbau-style filling rule in the physical subspace. It then selects HOMO/LUMO indices from that bracket and returns the midpoint eigenvalue as the chemical potential.
        - The caller must ensure that v has shape consistent with the description above (v.shape[-1] is the number of molecular orbitals nmo and v must have at least nphys rows). If nphys > nmo, or if shapes are inconsistent, numpy indexing operations will raise an IndexError.
        - If nelec lies outside the physically possible range [0, occupancy * nphys], the routine will still return a chemical potential derived from the available eigenvalues but the returned error will reflect the mismatch; callers should validate nelec where strict bounds are required.
        - Degenerate eigenvalues or near-degenerate HOMO/LUMO pairs are handled by selecting the first bracket encountered when scanning eigenvalues; the chemical potential is still the arithmetic midpoint of the chosen pair but may not be unique for exact degeneracies.
        - Numerical rounding in the projection and accumulation may produce small residual errors; the error return value quantifies the difference between requested and achieved physical electron count so callers can decide whether further adjustments (e.g., shifting eigenvalues or performing a more sophisticated root-finding) are necessary.
    """
    from pyscf.agf2.chempot import binsearch_chempot
    return binsearch_chempot(fock, nphys, nelec, occupancy)


################################################################################
# Source: pyscf.agf2.chkfile.load_mol
# File: pyscf/agf2/chkfile.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_agf2_chkfile_load_mol(chkfile: str):
    """pyscf.agf2.chkfile.load_mol loads a PySCF molecular object from a checkpoint file and reconstructs the same pyscf.gto.Mole on all MPI ranks for distributed PySCF workflows.
    
    This function reads a checkpoint file produced by PySCF's chkfile utilities and returns a gto.Mole that contains the molecular geometry, basis, and other molecule metadata required for subsequent quantum-chemistry computations (for example, SCF, correlated methods, or AGF2 runs). To minimize filesystem activity in MPI-parallel runs, only MPI rank 0 performs the file I/O using chkutil.load_mol and serializes the molecule with mol.dumps(); the serialized data are then synchronized to all ranks via mpi_helper.barrier() and mpi_helper.bcast_dict(), and each rank reconstructs an identical molecule locally with gto.loads().
    
    Args:
        chkfile (str): Path to the checkpoint file produced and supported by pyscf.lib.chkfile utilities. This file path is interpreted on MPI rank 0 only; the function expects chkfile to reference a valid, readable checkpoint file that contains a serialized PySCF molecule. The string must be a filesystem path accessible to the process running on rank 0 in a parallel environment.
    
    Returns:
        pyscf.gto.Mole: A pyscf.gto.Mole instance reconstructed from the checkpoint. The returned Mole contains atomic coordinates, basis set definitions, symmetry and other molecule attributes as stored in the chkfile, and is suitable for use in subsequent PySCF calculations on the local MPI rank.
    
    Behavior and side effects:
    - Only MPI rank 0 calls chkutil.load_mol(chkfile) and calls mol.dumps() to produce a serialized representation. Other ranks set dumps = None.
    - The function then calls mpi_helper.barrier() to synchronize ranks and uses mpi_helper.bcast_dict(dumps) to broadcast the serialized data so every rank receives the same serialized molecule.
    - Each rank calls gto.loads(dumps) to reconstruct an equivalent pyscf.gto.Mole locally.
    - Side effects include file I/O on rank 0 and MPI synchronization (barrier and broadcast) across all ranks.
    
    Failure modes and exceptions:
    - If the checkpoint file does not exist or is unreadable on rank 0, chkutil.load_mol will raise an exception (e.g., OSError or parsing error). If such an exception occurs before the mpi_helper.barrier() call, other MPI ranks may block at the barrier and the program can deadlock; therefore, ensure the file is available and readable to rank 0.
    - If the serialized data are corrupted or incompatible with gto.loads, gto.loads will raise a parsing/deserialization exception on each rank.
    - Network, MPI, or serialization failures during mpi_helper.bcast_dict may raise MPI-related exceptions or cause the call to hang, depending on the MPI implementation.
    
    Notes:
    - This function is intended for use in PySCF workflows that require the same molecule object on multiple MPI ranks (for example, distributed correlation methods or parallel post-SCF workflows).
    - The function relies on chkutil.load_mol, mol.dumps(), mpi_helper.barrier, mpi_helper.bcast_dict, and gto.loads to perform its operations and preserve molecular data consistency across ranks.
    """
    from pyscf.agf2.chkfile import load_mol
    return load_mol(chkfile)


################################################################################
# Source: pyscf.agf2.chkfile.load_agf2
# File: pyscf/agf2/chkfile.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_agf2_chkfile_load_agf2(chkfile: str):
    """Load the AGF2 data stored under the "agf2" checkpoint group in a PySCF
    checkpoint file and reconstruct Python objects used by AGF2 code paths.
    
    Args:
        chkfile (str): Path to a PySCF checkpoint file (checkpoint filename string)
            that was previously written by PySCF/AGF2 routines. This function reads
            the checkpoint group named 'agf2' from the file using chkutil.load.
            The path must be accessible from the current process; when running under
            MPI only the rank 0 process reads the file and the data are then
            broadcast to all ranks. If the file is missing, unreadable, or does
            not contain an 'agf2' group, chkutil.load or load_mol may raise an
            exception propagated to the caller.
    
    Returns:
        tuple: A two-item tuple (mol, dic) where:
            mol: The molecular object returned by load_mol(chkfile). This is the
                PySCF molecule/state object reconstructed from the same checkpoint
                file; it represents the molecular geometry, basis, and other
                metadata required to continue or analyze the AGF2 calculation.
            dic (dict): A dictionary of AGF2 runtime data loaded from the
                'agf2' checkpoint group and post-processed for immediate use by
                AGF2 routines. Practical contents and post-processing performed by
                this function:
                - The raw dictionary returned by chkutil.load(chkfile, 'agf2')
                  is broadcast to all MPI ranks (mpi_helper.bcast_dict) after an
                  initial read only on mpi_helper.rank == 0, so all ranks receive
                  the same processed dictionary.
                - If dic contains the key 'gf', it is expected to be a mapping
                  with keys 'energy', 'coupling', and 'chempot'; this mapping is
                  replaced by a GreensFunction object constructed as
                  GreensFunction(gf['energy'], gf['coupling'], chempot=gf['chempot']).
                  This reconstructed object represents the frequency-domain
                  Green's function used by AGF2 for spectral and correlation data.
                - If dic contains spin-separated keys 'gfa' and 'gfb' (each a
                  mapping with 'energy', 'coupling', 'chempot'), they are replaced
                  by a two-tuple (GreensFunction_alpha, GreensFunction_beta) of
                  GreensFunction objects and the original 'gfa'/'gfb' keys are
                  deleted. This preserves spin-dependent Green's functions for
                  unrestricted calculations.
                - Analogously, if dic contains 'se' it is expected to be a mapping
                  with 'energy', 'coupling', and 'chempot' and is replaced by a
                  SelfEnergy object constructed as
                  SelfEnergy(se['energy'], se['coupling'], chempot=se['chempot']).
                  If 'sea' and 'seb' are present, they are converted to a two-tuple
                  of SelfEnergy objects for alpha/beta spins and the original keys
                  are deleted.
                - If 'ngf' and/or 'nse' are present, they are combined into a
                  single tuple stored under the key 'nmom' as (ngf, nse) and the
                  original 'ngf' and 'nse' keys are removed. This records the
                  number of moments used to represent Green's function and
                  self-energy.
                - If spin-frozen orbital information is saved under 'frozena' and
                  'frozenb', they are combined into a single 'frozen' key as a
                  two-tuple (frozena, frozenb) and the original keys are removed.
                - No new keys beyond those in the original checkpoint are added
                  except for the canonical 'gf'/'se' replacements, 'nmom', and
                  'frozen' as described; other keys from the checkpoint are left
                  intact.
                - The function performs in-place key replacements and deletions on
                  the returned dictionary; callers should not rely on the presence
                  of the original keys ('gfa', 'gfb', 'sea', 'seb', 'ngf',
                  'nse', 'frozena', 'frozenb') after this call.
    
    Failure modes and side effects:
        - If chkutil.load raises an exception (file missing, corrupted, or no
          'agf2' group), that exception will propagate to the caller.
        - If load_mol(chkfile) fails to reconstruct the molecular object, that
          exception is propagated.
        - Under MPI, only the rank 0 process performs the file read; all ranks
          wait at mpi_helper.barrier() and then receive the processed dictionary
          via mpi_helper.bcast_dict. The function thus has the side effect of
          synchronizing MPI ranks.
        - The function mutates and returns the dictionary from the checkpoint:
          original serialized sub-structures (e.g., 'gfa', 'gfb', 'sea', 'seb',
          'ngf', 'nse', 'frozena', 'frozenb') are removed and replaced as noted,
          so callers desiring the raw serialized layout should reload the file
          separately before calling this function.
    
    Usage significance:
        This function is intended to restore the state of an AGF2 calculation
        saved in a PySCF checkpoint file for restarting calculations, post-
        processing, or analysis. The reconstructed GreensFunction and SelfEnergy
        objects make the returned dictionary directly consumable by AGF2 routines
        that expect those runtime objects rather than raw serialized arrays.
    """
    from pyscf.agf2.chkfile import load_agf2
    return load_agf2(chkfile)


################################################################################
# Source: pyscf.agf2.mpi_helper.prange
# File: pyscf/agf2/mpi_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_agf2_mpi_helper_prange(start: int, stop: int, step: int):
    """pyscf.agf2.mpi_helper.prange: Produce the sub-range(s) of an integer index interval that the current MPI rank should process. This function is used inside the AGF2 (auxiliary Green’s function, second-order) parallel workflow in PySCF to distribute a global loop range across MPI ranks by delegating to lib.prange for the local per-rank iteration. It returns the sequence of (start, stop) index pairs that a single MPI rank should iterate over when executing distributed work (for example, partitioning index ranges for blocks of an integral or frequency loop).
    
    This function either delegates directly to lib.prange when there is one MPI process, or partitions the total interval length (stop - start) into size roughly-even pieces and yields the piece assigned to the current rank. When SIZE > 1 and the module-level flag SCALE_PRANGE_STEP is true, the function reduces the requested step granularity by integer-dividing step by size (step //= size) before calling lib.prange on the per-rank subinterval. The subinterval boundaries are computed with integer division using the local lambda split = lambda x: x * (stop - start) // size; the per-rank start and stop values are then passed to lib.prange to produce the final sequence of (p0, p1) pairs for that rank. The function relies on the mpi_helper module globals size (number of MPI ranks), rank (this process rank), SCALE_PRANGE_STEP, and the lib.prange implementation; these must be available in the executing environment.
    
    Args:
        start (int): Inclusive start index of the global interval to be partitioned. This is the same start parameter that would be passed to lib.prange when running without MPI; the function partitions the interval of length (stop - start) among MPI ranks and produces the subrange(s) for the local rank.
        stop (int): Exclusive stop index of the global interval to be partitioned. The global interval is [start, stop). The function ensures that the last MPI rank covers up to this stop value so the whole global interval is covered across ranks.
        step (int): Chunk size requested for lib.prange on the local subinterval. If the module-level flag SCALE_PRANGE_STEP is True and more than one MPI rank is present, step is integer-divided by the number of ranks (step //= size) before use; otherwise it is passed unchanged to lib.prange. step should be an integer appropriate for lib.prange.
    
    Returns:
        generator: A generator that yields tuples (p0, p1) of two ints. Each yielded tuple is a start (inclusive), stop (exclusive) pair that describes a subinterval assigned to the current MPI rank and is suitable to pass to the same lib.prange-based inner iteration used in non-MPI code. When size == 1 the yielded sequence is exactly the sequence produced by lib.prange(start, stop, step). When size > 1 the yielded sequence covers only the portion of the original interval assigned to this rank, computed by integer partitioning of (stop - start) among ranks and, for the last rank, extending to the original stop value.
    
    Behavioral notes, side effects, and failure modes:
        - The function depends on module-level MPI context variables: size (number of ranks), rank (index of this rank), and SCALE_PRANGE_STEP. These must be defined and have sensible integer values for correct behavior.
        - If size == 1 the function simply yields the ranges produced by lib.prange(start, stop, step) with no additional partitioning.
        - If SCALE_PRANGE_STEP is true and size > 1, step is modified locally by integer division (floor division) to reduce granularity; this change is local to this function call and does not mutate external state.
        - The partitioning uses integer division and therefore yields contiguous, non-overlapping integer subintervals whose lengths differ by at most one element due to truncation.
        - The last MPI rank is forced to use stop as its upper bound to ensure complete coverage of the original interval.
        - The caller should supply integer start, stop, and step values appropriate for lib.prange. If size < 1, rank is out of range, step is non-positive, or lib.prange enforces additional constraints, the function may raise errors propagated from integer operations or from lib.prange; such exceptions are not caught inside this function.
    """
    from pyscf.agf2.mpi_helper import prange
    return prange(start, stop, step)


################################################################################
# Source: pyscf.ao2mo.incore.general
# File: pyscf/ao2mo/incore.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_ao2mo_incore_general(
    eri_ao: numpy.ndarray,
    mo_coeffs: list,
    verbose: int = 0,
    compact: bool = True,
    **kwargs
):
    """pyscf.ao2mo.incore.general transforms two-electron integrals expressed in the atomic-orbital (AO) basis into molecular-orbital (MO) integrals for four (possibly different) sets of orbitals. This function is used in PySCF to produce the MO representation of electron repulsion integrals (ERIs) required by post-Hartree–Fock methods and other electronic-structure routines that operate in an MO basis. The implementation accepts either a fully expanded 4-index AO tensor (nao**4 elements) or AO integrals stored with permutation symmetry (4-fold or 8-fold) and will choose a dense einsum contraction for fully expanded input or a symmetry-aware transformation routine for packed input. When the four orbital sets contain identical columns or repeated pairs, setting compact=True returns MO integrals in a packed (permutation-symmetric) 2D representation, reducing memory and computational costs; when compact=False the function returns the "plain" uncompressed MO integrals without exploiting permutation symmetry.
    
    Args:
        eri_ao (numpy.ndarray): AO integrals provided as a one-dimensional or multi-dimensional array. Accepted formats are either a fully expanded 4-index array with eri_ao.size == nao**4 (where nao is the number of atomic orbitals derived from mo_coeffs[0].shape[0]) or a packed AO integral representation with 4-fold/8-fold permutation symmetry (typical output of molecular integral routines with aosym='s4' or 's8'). This argument is the input electron repulsion integrals in the AO basis that will be transformed to the MO basis.
        mo_coeffs (list): 4-item list of numpy.ndarray. Each item is a two-dimensional orbital coefficient matrix (shape (nao, nmoX)) corresponding to the coefficient vectors for one index of the chemists' notation (ij|kl). The first element supplies coefficients for index i, the second for j, the third for k, and the fourth for l. The number of rows of mo_coeffs[0] defines nao (nao = mo_coeffs[0].shape[0]) used to interpret fully expanded eri_ao; mismatched row counts among the provided coefficient matrices or an eri_ao incompatible with nao will lead to array-shape errors. If any coefficient array has dtype numpy.complex128, the function raises NotImplementedError because complex-orbital transformations are not implemented in this routine.
        verbose (int): Print level (default 0). Provided for API compatibility with other PySCF routines and to allow integration into code paths that expect a verbose keyword. This function does not print detailed transformation logs by default; higher values are reserved for callers or future extensions. Supplying non-integer types may affect downstream code that inspects verbose but does not alter the core transformation behavior.
        compact (bool): If True (default), the function will exploit permutation symmetry among pairs (i,j) and/or (k,l) when possible and return MO integrals in a packed 2D representation that encodes unique (pair) indices (reducing dimensionality up to 4-fold when orbital sets are identical). For example, when the third and fourth orbital sets are identical, the number of unique (k,l) pairs is reduced and the returned array's second dimension is the number of unique pairs (not the simple product of their column counts). If compact is False, all pair permutations are retained and the function returns the full (uncompressed) set of MO integrals corresponding to the direct product of the supplied MO spaces. Use compact=True to save memory and exploit symmetry when the calling code understands packed pair indexing; use compact=False when the calling code requires the plain (i.e., non-packed) rectangular representation.
        kwargs (dict): Additional keyword arguments. Present for API compatibility; this function does not document or require any further keyword options and currently ignores unknown kwargs. Callers should not rely on kwargs having any effect for transformation behavior in this version of the function.
    
    Returns:
        numpy.ndarray: The transformed MO integrals. For packed/symmetry-aware input (the common case when eri_ao is supplied with aosym='s4' or 's8') the function returns a 2D array whose first dimension indexes unique (i,j) pairs and whose second dimension indexes unique (k,l) pairs; the sizes of these dimensions depend on the column counts of the corresponding mo_coeffs and on whether compact=True compresses equivalent pairs. If eri_ao is a fully expanded 4-index array (eri_ao.size == nao**4), the function returns a 4-dimensional numpy.ndarray with shape (nmo1, nmo2, nmo3, nmo4) produced by an explicit einsum contraction (where nmoX are the number of columns in the corresponding mo_coeffs). If the transformed intermediate arrays have zero size in a BLAS-sensitive path, the function returns an explicit zero-filled 2D array with shape (nrows, ncols) to avoid BLAS errors; callers should expect either a 2D packed result (typical) or a 4D dense result (when passing a fully expanded eri_ao). The dtype of the return array follows from input dtype and mo_coeffs; mixed or complex dtypes are not supported (complex mo_coeffs raise NotImplementedError).
    
    Behavior, side effects, defaults, and failure modes:
        - The function determines nao from mo_coeffs[0].shape[0]; inconsistent coefficient matrix row counts may trigger shape errors during array reshaping or contraction.
        - If eri_ao.size == nao**4, the function performs a direct dense transformation via einsum and returns a 4D array of shape (nmo1, nmo2, nmo3, nmo4). This branch bypasses symmetry-aware packing and is appropriate when the caller supplies a fully expanded AO tensor.
        - For packed/symmetric eri_ao (aosym='s4' or 's8'), the function uses an intermediate half-transform (half_e1) followed by symmetry-aware transformations (_ao2mo.nr_e2) to produce a 2D packed MO integral matrix. This path is more memory- and time-efficient for typical molecular integral representations.
        - If any mo_coeffs entries have dtype numpy.complex128, the function raises NotImplementedError('Integral transformation for complex orbitals') because complex-valued orbital transformations are not implemented here.
        - When compact=True, repeated orbital sets (e.g., mo_coeffs[2] is mo_coeffs[3]) cause the function to compress the corresponding pair index dimension using permutation symmetry (e.g., k<=l packing), reducing the returned array dimension; when compact=False, no compression is applied.
        - kwargs are accepted for API compatibility but are currently ignored; do not rely on side effects from kwargs in this routine.
        - If intermediate results are empty (zero-length in a dimension), the function returns a zero-filled numpy.ndarray with a shape compatible with the expected packed indexing to avoid errors in low-level BLAS routines.
        - The caller is responsible for interpreting the packed 2D indexing when compact=True (i.e., mapping pair indices back to (i,j) or (k,l) orbital indices); this mapping follows the standard PySCF packed-pair ordering used throughout ao2mo routines.
    """
    from pyscf.ao2mo.incore import general
    return general(eri_ao, mo_coeffs, verbose, compact, **kwargs)


################################################################################
# Source: pyscf.ao2mo.incore.full
# File: pyscf/ao2mo/incore.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_ao2mo_incore_full(
    eri_ao: numpy.ndarray,
    mo_coeff: numpy.ndarray,
    verbose: int = 0,
    compact: bool = True,
    **kwargs
):
    """pyscf.ao2mo.incore.full transforms atomic-orbital (AO) electron repulsion integrals (ERI) into molecular-orbital (MO) representation using the same set of molecular orbitals for all four indices. This function is part of the PySCF ao2mo.incore module and is used in quantum chemistry post-Hartree–Fock workflows (for example MP2, CC, and other correlated methods) that require MO-basis two-electron integrals.
    
    Args:
        eri_ao (numpy.ndarray): AO integrals. This is the electron repulsion integral tensor in the atomic-orbital basis. It may be provided with 8-fold (full s8) or 4-fold permutation symmetry (s4) as produced by PySCF integral engines (e.g., mol.intor('int2e_sph', aosym='s8')). The array is the primary input that will be transformed to the MO basis; its layout and symmetry determine how the underlying transformation routine interprets and reads integrals. Supplying an array with incompatible shape or symmetry will raise an error propagated from the underlying transformation routine.
        mo_coeff (numpy.ndarray): Molecular orbital coefficients. A 2D array whose columns are the MO coefficients used to transform AO integrals to the MO basis. This function applies the same mo_coeff array to all four orbital indices, i.e., it transforms (ij|kl) -> (pq|rs) with p,q,r,s from the same MO set. The number of molecular orbitals nmo is mo_coeff.shape[1]; returned MO integral array dimensions depend on nmo and the compact flag.
        verbose (int): Print level. Integer verbosity control (default 0). This controls informational and debugging output emitted by the underlying transformation routine. Higher values produce more diagnostic output. The value is forwarded to the underlying implementation; invalid verbosity values may be ignored or cause the underlying routine to report an error.
        compact (bool): When True (default), return the MO integrals using 4-fold permutation symmetry (compact packed representation). In this mode the returned 2D array has dimension nmo*(nmo+1)/2 by nmo*(nmo+1)/2 (for nmo = number of columns in mo_coeff), enabling storage and algorithms that exploit (pq|rs) = (qp|rs) = (pq|sr) = (rs|pq). When False, return the "plain" MO integrals as an nmo**2 by nmo**2 2D array without exploiting that 4-fold symmetry. Choice of compact affects memory usage and the expected layout of integrals for downstream correlated-method routines.
        kwargs (dict): Additional keyword arguments forwarded to the underlying general transformation routine invoked internally. These may control implementation details of the transformation (for example threading, memory handling, or integral ordering) as supported by the lower-level function. Unknown or unsupported keywords may raise TypeError or be ignored by the underlying routine.
    
    Returns:
        numpy.ndarray: A 2D array containing the transformed MO electron repulsion integrals. If compact is True, the array uses the 4-fold symmetry packed ordering and has shape (nmo*(nmo+1)//2, nmo*(nmo+1)//2). If compact is False, the array is in the plain, unpacked ordering with shape (nmo**2, nmo**2). The returned integrals are suitable as input to MO-based correlated electronic-structure methods (MP2, CC, etc.). No in-place modification of eri_ao or mo_coeff is performed; errors arise if input shapes or symmetries are incompatible or if the forwarded kwargs are invalid.
    """
    from pyscf.ao2mo.incore import full
    return full(eri_ao, mo_coeff, verbose, compact, **kwargs)


################################################################################
# Source: pyscf.ao2mo.incore.half_e1
# File: pyscf/ao2mo/incore.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_ao2mo_incore_half_e1(eri_ao: numpy.ndarray, mo_coeffs: list, compact: bool = True):
    """pyscf.ao2mo.incore.half_e1: Perform a half transformation of atomic-orbital (AO) two-electron integrals (ij|kl) to the molecular-orbital (MO) basis by transforming the pair of AO indices corresponding to i and j, producing an array of MO integrals used in post-Hartree–Fock methods (e.g., MP2, CC) within the PySCF electronic structure framework.
    
    This function implements the first (half) step of an AO->MO integral transformation: it contracts two sets of MO coefficient matrices with the AO two-electron integrals to transform the AO indices i and j to the MO basis while leaving the k,l AO pair untransformed. It accepts AO integrals provided with either 4-fold (s4) or 8-fold (s8) permutation symmetry and produces a 2D array whose first dimension indexes the combined i-j MO pairs and whose second dimension indexes the AO pair basis (the remaining AO pair indices). The routine is implemented with performance-critical C backends and is intended for double-precision real integrals in typical quantum chemistry workflows within PySCF.
    
    Args:
        eri_ao (ndarray): AO two-electron integrals in packed form. Must be a NumPy array containing either 4-fold symmetric integrals (size == nao_pair**2) or 8-fold symmetric integrals (size == nao_pair*(nao_pair+1)//2), where nao_pair = nao*(nao+1)//2 and nao is the number of atomic orbitals inferred from mo_coeffs[0]. The function requires eri_ao.dtype == numpy.double (double precision); otherwise a TypeError is raised. If eri_ao has 4-fold symmetry, the implementation transposes the stored integrals internally to make the ij indices contiguous before the half transformation.
        mo_coeffs (list): A list of two NumPy arrays [C_i, C_j], each of shape (nao, nmo_i) and (nao, nmo_j) respectively, containing real-valued MO coefficient matrices for the i and j orbital indices of (ij|kl). These matrices define which MO combinations are formed for the transformed i-j pair. If any coefficient array has dtype numpy.complex128 the function raises NotImplementedError('Integral transformation for complex orbitals') because complex orbital support is not implemented. The number of atomic orbitals (nao) is taken from mo_coeffs[0]. The routine internally concatenates or maps the provided MO sets and determines the number of resulting combined i-j MO pairs (nij_pair) and the symmetry type used for storing the transformed integrals.
        compact (bool): When True (default), the returned MO integrals exploit the highest permutation symmetry possible for the provided pair of MO coefficient sets and packing format, reducing storage by using symmetry-adapted indexing for the i-j MO pairs. When False, the function abandons permutation symmetry and returns the "plain" MO integrals for the i-j pairs in full packed AO-pair order. This flag controls how mo_coeffs are combined and how the output array indexes correspond to MO-pair permutations.
    
    Returns:
        ndarray: A 2D NumPy array of transformed MO integrals with shape (nij_pair, nao_pair), where nij_pair is the number of combined i-j MO pairs determined from mo_coeffs and the compact setting, and nao_pair = nao*(nao+1)//2 is the number of unique AO pairs. The array contains the half-transformed integrals <ij|kl> with indices i,j expressed in the given MO bases and k,l remaining in the AO-pair basis. The returned integrals may be stored with permutation symmetry (if compact=True and the MO sets allow it) or without permutation symmetry (if compact=False). If nij_pair == 0 the function returns an empty array of shape (0, nao_pair).
    
    Behavior, side effects, defaults, and failure modes:
        - The function only supports real, double-precision AO integrals (eri_ao.dtype must be numpy.double). Passing other dtypes raises TypeError.
        - Complex-valued MO coefficients are not supported; if any array in mo_coeffs has dtype numpy.complex128 a NotImplementedError is raised with message 'Integral transformation for complex orbitals'.
        - eri_ao must be provided in either 4-fold (s4) or 8-fold (s8) packed symmetry formats. If eri_ao.size does not match either expected packed size based on nao (derived from mo_coeffs[0]), the function raises NotImplementedError.
        - For 4-fold symmetric input, the implementation performs an internal transposition of eri_ao (via a C helper) to make ij the contiguous indices before calling the C-level half-transform kernel; callers should not rely on eri_ao retaining its original memory layout after the call (the input is converted to a contiguous NumPy array internally).
        - The function allocates internal buffers (including a temporary buffer sized around a BLOCK-by-nij_pair tile) and an output array eri1 of shape (nij_pair, nao_pair). Memory consumption scales with the number of AO pairs and the number of requested i-j MO pairs; large systems can require significant memory and may be limited by available RAM.
        - The routine delegates heavy computation to PySCF C backends (_ao2mo.libao2mo functions). Errors or crashes in those compiled routines may raise lower-level exceptions or propagate as fatal errors; typical Python-level error checks (dtype, symmetry size, complex orbitals) are performed before invoking the C drivers.
        - Default behavior is compact=True. Use compact=False to obtain non-symmetry-packed ("plain") MO integrals when explicit uncontracted ordering is required by downstream code.
        - If the number of combined MO pairs (nij_pair) is zero due to the provided mo_coeffs, the function returns an empty result with shape (0, nao_pair) without invoking the heavy C drivers.
    
    Practical significance:
        - This function is used in electronic-structure workflows in PySCF to obtain partially transformed two-electron integrals needed by correlated methods (MP2, CC, CI) where one typically transforms two indices at a time to manage computational cost. The output is a compact representation suitable for further full AO->MO transformations or for algorithms that consume half-transformed integrals. The behavior and error conditions align with PySCF conventions for performance-critical integral transformations in quantum chemistry applications.
    """
    from pyscf.ao2mo.incore import half_e1
    return half_e1(eri_ao, mo_coeffs, compact)


################################################################################
# Source: pyscf.cc.bccd.get_mo_ovlp
# File: pyscf/cc/bccd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_cc_bccd_get_mo_ovlp(mo1: numpy.ndarray, mo2: numpy.ndarray, ovlp: numpy.ndarray):
    """Get MO overlap matrix C_1.conj().T ovlp C_2 used in BCCD and other correlated-method routines in PySCF.
    
    Args:
        mo1 (numpy.ndarray): Molecular-orbital coefficient array for the first set of MOs, representing C_1 in the expression C_1.conj().T @ ovlp @ C_2. In the context of PySCF and the BCCD module, this is the coefficient matrix that expands molecular orbitals in the atomic-orbital (AO) basis used to compute overlaps and projections between orbital sets. mo1 may be either a 2-D array with shape (nao, nmo1) for a single (spin-independent) MO block, or a 3-D array with shape (spin, nao, nmo1) when separate spin blocks are provided (spin is typically 2 for unrestricted/spinor treatments). The function converts this input to a numpy.ndarray via np.asarray and accepts complex-valued coefficients; the conjugate transpose of mo1 is used in the overlap computation.
    
        mo2 (numpy.ndarray): Molecular-orbital coefficient array for the second set of MOs, representing C_2 in the expression C_1.conj().T @ ovlp @ C_2. mo2 follows the same shape conventions as mo1: either 2-D (nao, nmo2) or 3-D (spin, nao, nmo2). When mo1 is 3-D, mo2 must have the same spin dimension (the code asserts mo1.shape[0] == mo2.shape[0]). mo2 is converted to a numpy.ndarray with np.asarray before use. This array provides the target orbital coefficients whose overlap with mo1 is being measured, a common operation when projecting orbitals between bases or comparing occupied/virtual subspaces in correlated calculations.
    
        ovlp (numpy.ndarray): AO overlap matrix S (often named ovlp) with shape (nao, nao) that defines the inner product in the AO basis. This matrix is the same overlap S used throughout PySCF to convert between AO and MO representations. ovlp is converted to a numpy.ndarray with np.asarray prior to use. The function computes C_1.conj().T @ ovlp @ C_2, so ovlp must be square with its dimension matching the first axis (nao) of mo1 and mo2.
    
    Returns:
        numpy.ndarray: The overlap matrix between the MO sets. If mo1 and mo2 are 2-D, returns an array of shape (nmo1, nmo2) containing the overlap elements <MO1_i|MO2_j> = (C_1.conj().T @ ovlp @ C_2)_{ij}. If mo1 and mo2 are 3-D with a leading spin index, returns an array of shape (spin, nmo1, nmo2) containing the per-spin-block overlaps. The dtype of the returned array is determined by numpy.result_type(mo1, mo2) and will preserve complex types when inputs are complex. The function does not modify the input arrays in place; it converts inputs with np.asarray and constructs and returns a new numpy.ndarray.
    
    Behavior, side effects, and failure modes:
        This function implements the standard MO overlap/projection used in PySCF BCCD workflows and similar modules to compare or project orbital sets. It uses numpy.dot via reduce to perform matrix multiplications and handles both single-block (2-D) and per-spin-block (3-D) MO coefficient arrays. Side effects are limited to converting inputs to numpy arrays (np.asarray) and allocating a new result array; mo1, mo2, and ovlp are not modified in place. Failure modes include an AssertionError when mo1 and mo2 have mismatched spin dimensions in the 3-D case (the code asserts mo1.shape[0] == mo2.shape[0]), and numpy/linalg-related errors (e.g., ValueError) if the array dimensions are incompatible for matrix multiplication (for example, if the nao dimension of mo1/mo2 does not match the dimensions of ovlp). TypeErrors may arise if inputs are not array-like. This function is deterministic and relies on numpy's arithmetic semantics (including complex conjugation) for physically meaningful MO overlap calculations used in correlated-electron methods.
    """
    from pyscf.cc.bccd import get_mo_ovlp
    return get_mo_ovlp(mo1, mo2, ovlp)


################################################################################
# Source: pyscf.cc.ccsd.get_t1_diagnostic
# File: pyscf/cc/ccsd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_cc_ccsd_get_t1_diagnostic(t1: numpy.ndarray):
    """Returns the t1 amplitude norm normalized by the number of correlated electrons, commonly called the T1 diagnostic in coupled-cluster singles and doubles (CCSD) calculations. In the PySCF quantum-chemistry framework this function is used to quantify the overall magnitude of single-excitation amplitudes produced by a CCSD calculation and to provide a compact, dimensionless measure that helps assess the degree to which a system departs from a single-reference description.
    
    Args:
        t1 (numpy.ndarray): Array of CCSD single-excitation amplitudes (t_i^a) as produced/used by PySCF CCSD routines. The function infers the number of correlated occupied orbitals from t1.shape[0] and therefore treats the first array dimension as the occupied-orbital index count. Practically, t1 contains complex or real numerical amplitude values; entries are squared and summed by numpy.linalg.norm to compute the amplitude magnitude. The implementation assumes closed-shell pairing when estimating total correlated electrons via nelectron = 2 * t1.shape[0]; if t1 has an unexpected shape or zero size this will lead to errors (IndexError or ZeroDivisionError) or meaningless results.
    
    Returns:
        float: Dimensionless T1 diagnostic computed as sqrt(sum(|t1|^2) / nelectron), where nelectron = 2 * t1.shape[0]. This value is the root-mean-square of the t1 amplitudes per correlated electron. There are no side effects. Failure modes include exceptions from numpy (e.g., if t1 contains non-numeric entries) and division-by-zero if the inferred number of correlated occupied orbitals is zero.
    """
    from pyscf.cc.ccsd import get_t1_diagnostic
    return get_t1_diagnostic(t1)


################################################################################
# Source: pyscf.cc.ccsd.get_d1_diagnostic
# File: pyscf/cc/ccsd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_cc_ccsd_get_d1_diagnostic(t1: numpy.ndarray):
    """Compute the D1 diagnostic for CCSD single-excitation amplitudes as defined in Janssen et al., Chem. Phys. Lett. 290 (1998) 423. This diagnostic extracts a single non-negative scalar that quantifies the magnitude of single-excitation amplitudes and is used within the PySCF coupled-cluster (CCSD) context to assess the importance of single excitations and, indirectly, the potential multireference character of a wavefunction.
    
    Args:
        t1 (numpy.ndarray): A NumPy array containing CCSD single-excitation amplitudes. In the typical CCSD convention used in PySCF, t1 is a 2-D array t1[i,a] with occupied-index i and virtual-index a (shape commonly (nocc, nvir)). The function treats the array as numeric real (or complex) amplitude data and computes two symmetric matrices by contracting t1 with itself: one in the occupied index space (einsum 'ia,ja->ij') and one in the virtual index space (einsum 'ia,ib->ab'). These matrices are then diagonalized and their largest eigenvalue magnitudes are converted to the diagnostic value. The parameter has no default; the function will raise NumPy errors if t1 is not a compatible ndarray (for example, wrong number of dimensions or non-numeric entries will propagate exceptions from numpy.einsum or numpy.linalg.eigh).
    
    Returns:
        float: The D1 diagnostic value (non-negative scalar). Concretely, the implementation forms the occupied-occupied matrix M_ij = sum_a t1[i,a] * t1[j,a] and the virtual-virtual matrix N_ab = sum_i t1[i,a] * t1[i,b], computes their eigenvalues, takes the square root of the largest absolute eigenvalue from each matrix, and returns the larger of the two results: max( sqrt(max|eig(M)|), sqrt(max|eig(N)|) ). There are no side effects; the function does not modify the input array. The function may raise exceptions from NumPy linear algebra routines if the input is ill-formed, non-finite, or has incompatible dimensions.
    """
    from pyscf.cc.ccsd import get_d1_diagnostic
    return get_d1_diagnostic(t1)


################################################################################
# Source: pyscf.ao2mo.semi_incore.general
# File: pyscf/ao2mo/semi_incore.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_ao2mo_semi_incore_general(
    eri: numpy.ndarray,
    mo_coeffs: list,
    erifile: str,
    dataname: str = "eri_mo",
    ioblk_size: float = 128,
    compact: bool = True,
    verbose: int = 3
):
    """pyscf.ao2mo.semi_incore.general: Transform spherical atomic-orbital (AO) electron repulsion integrals (ERIs) to molecular-orbital (MO) ERIs on disk for four arbitrary sets of orbitals used in PySCF quantum-chemistry workflows. This routine performs a two-step "half-transform" (mu,nu -> ij and lambda,sigma -> kl) and writes the final ij|kl MO integrals to an HDF5 dataset, enabling out-of-core handling of large integral tensors that would not fit in RAM.
    
    This function is used in PySCF to convert an input AO ERI representation (either 4-fold or 8-fold symmetry as produced by PySCF integral routines) into MO-basis ERIs for four potentially distinct sets of molecular orbital coefficient matrices. The produced dataset is intended for downstream correlated-electron methods (MP2, CC, multireference methods) that consume ij|kl integrals. The implementation minimizes peak memory usage by chunking and by writing an intermediate "half-transformed" array to a temporary HDF5 swap file and then completing the transformation to the final HDF5 dataset.
    
    Args:
        eri (numpy.ndarray): 8-fold reduced AO ERI vector or 4-fold reduced AO ERI array as produced by PySCF integral routines. The function detects whether eri encodes 4-fold symmetry (size == nao_pair**2) or 8-fold symmetry (size == nao_pair*(nao_pair+1)//2) and dispatches the appropriate C-accelerated transform. eri must be in C-contiguous order (the code converts via numpy.asarray(eri, order='C')). The practical significance is that eri is the starting compact representation of two-electron integrals in the atomic-orbital basis; its symmetry/reduction dictates which optimized low-level kernel is used and whether lib.unpack_row/unpack_tril are invoked.
        mo_coeffs (list): 4-item list of numpy.ndarray, each array is an orbital-coefficient matrix for one index of the ERI quadruple (i, j, k, l). The first two entries correspond to the orbitals used for the (ij) composite index, and the last two correspond to the (kl) composite index. Each ndarray has shape (nao, nmo) where nao is the number of atomic orbitals and nmo is the number of molecular orbitals in that set. The function concatenates/packages these coefficient arrays (via internal helper _conc_mos) and uses them to perform the two half-transforms by contracting AO integrals with MO coefficients. The practical significance is that mo_coeffs specify the target MO spaces for which the transformed ij|kl integrals are computed; using different sets allows nonorthogonal or different active spaces for each index.
        erifile (str or h5py.File or h5py.Group): Destination for the transformed integrals, expressed either as a filesystem path to an HDF5 file (str) or an already opened h5py File/Group object. If a filename (str) is provided, the function opens/creates the HDF5 file and writes the dataset; if an h5py Group/File is provided, the dataset is created inside that group. The function may delete an existing dataset with the same dataname inside the file (overwrite behavior). The practical significance is persistent storage of large MO ERI tensors in HDF5 format so that downstream modules can read them without keeping the full tensor in memory.
        dataname (str): Name of the dataset inside the HDF5 file (default "eri_mo"). This is the HDF5 dataset key under which the final MO integrals (indexed by composite indices ij x kl) are stored. Assigning different dataname values allows multiple transformed integral datasets to coexist in the same HDF5 file or to reuse the same file for different transformations. If the dataset already exists in erifile and a filename is used, the existing dataset is deleted and replaced, so caller should ensure this overwrite semantics is acceptable.
        ioblk_size (float): I/O block size in megabytes (MB) used to guide chunking of read/write buffers and the internal temporary array chunk dimensions (default 128.0). The function translates ioblk_size into an integer chunk size for the temporary half-transformed array and balances memory vs I/O throughput. Larger ioblk_size increases RAM used by IO buffers and may reduce the number of read/write operations but does not always improve performance; excessively small ioblk_size can force pathological 1x1 chunking and poor performance. The user should choose ioblk_size proportional to available RAM and disk throughput; the code logs estimated memory and disk usage to help tune this parameter.
        compact (bool): If True (default), try to exploit permutation symmetry that may exist between the four orbital sets so that the returned/packed MO integrals preserve up to 4-fold permutation symmetry and are stored in packed (tril/8-fold) format when applicable. If False, the function abandons permutation symmetry and writes the "plain" (unpacked) MO integrals. The practical significance is storage and compute savings: compact=True yields smaller on-disk storage and fewer arithmetic operations when symmetry applies, but the dataset layout will be packed and consumers must unpack accordingly.
        verbose (int): Verbosity level controlling internal logging (default 3). The function creates a logger via logger.new_logger(None, verbose) and emits informational and debug messages about chunk sizes, memory estimates, transform timings, and file operations. Higher verbosity produces more detailed timing and memory output useful for performance tuning; lower verbosity suppresses these messages.
    
    Returns:
        str or h5py.Group or numpy.ndarray: If erifile was a filename (str) or an h5py File/Group was supplied, the function returns the same object used to store the integrals: the filename string (when a string path was supplied) or the provided h5py.Group/File object. The HDF5 dataset named dataname is created inside this file/group and contains the final MO integrals arranged as a two-dimensional array indexed by composite indices (ij, kl) where ij runs over the packed ij-pairs and kl runs over the packed kl-pairs. If no MO pairs exist for the (ij) side (nij_pair == 0), the function returns a numpy.empty array of shape (0, nkl_pair) immediately (this is an early-exit behavior used by callers to handle degenerate cases). The returned value is primarily the handle to the on-disk storage holding the transformed integrals for downstream PySCF routines.
    
    Behavior, side effects, defaults, and failure modes:
        This routine performs an out-of-core two-step transform: first it contracts AO ERIs with the first two MO coefficient sets to form a half-transformed tensor (indexed by ij x lo) which is written to a temporary HDF5 swap file; second it reads this half-transformed data in chunks and contracts with the last two MO coefficient sets to form the final ij|kl dataset written to erifile[dataname]. The function automatically detects whether the input eri uses 4-fold or 8-fold reduction and selects optimized low-level C drivers accordingly. It uses a temporary HDF5 file (internal feri_swap) for intermediate storage and will create or overwrite the dataset dataname in the destination file/group. If erifile is a string and points to an existing HDF5 file containing dataname, the existing dataset is removed before writing the new data. The function logs memory estimates and timings controlled by the verbose argument to aid debugging and tuning.
        The default ioblk_size is in MB and is used to derive chunk_size = min(nao_pair, max(4, int(ioblk_size*1e6/8/nao_pair))). If chunk_size is too small relative to nao_pair, the internal chunking can degrade to 1x1 tiles and performance will suffer; the caller can increase ioblk_size to mitigate this. The function assumes eri encodes either 4-fold or 8-fold reduced integrals; if eri size does not match either pattern the function raises NotImplementedError. File I/O errors, insufficient disk space, or missing h5py support will surface as exceptions from the underlying I/O operations. The routine may use significant temporary disk space for the half-transformed array (logged before the transform); callers should ensure adequate disk capacity for feri_swap.
        The function preserves dtype of the computation from the input eri and MO coefficients (float/double or complex); the low-level code paths differentiate double vs complex execution. If compact symmetry is used, the final dataset may be stored in packed tril form and consumers must unpack with the corresponding helper routines (consistent with PySCF packed conventions).
        Intended usage context: this routine is part of PySCF's ao2mo utilities and is intended for transforming large AO ERI datasets to MO representations for post-Hartree-Fock correlated methods; it is not a general-purpose linear algebra routine but is optimized for the specific symmetry and storage patterns used in quantum-chemistry integrals.
    """
    from pyscf.ao2mo.semi_incore import general
    return general(eri, mo_coeffs, erifile, dataname, ioblk_size, compact, verbose)


################################################################################
# Source: pyscf.cc.bccd.get_umat_from_t1
# File: pyscf/cc/bccd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_cc_bccd_get_umat_from_t1(t1: numpy.ndarray):
    """pyscf.cc.bccd.get_umat_from_t1: Construct a unitary orbital rotation matrix (or matrices) from CC singles amplitudes t1.
    
    This function is used in the bccd (Brueckner coupled-cluster doubles) workflow of the PySCF electronic structure package to convert t1 singles-amplitude information into a unitary rotation matrix U that can be applied to molecular-orbital coefficients. For restricted-reference (RHF) input, a single square unitary matrix of size nmo x nmo is returned. For unrestricted-reference (UHF) input (multiple spin components), a stack of unitary matrices is returned, one per spin. The routine assembles an anti-Hermitian generator A from the t1 amplitudes with the block structure
      A = [ 0    -t1
            t1^H  0 ]
    and then computes U = expm(A) (matrix exponential) to obtain a unitary rotation. This implements the standard mapping from singles amplitudes to an orbital rotation operator used when performing orbital rotations or orbital optimization driven by singles in coupled-cluster contexts.
    
    Args:
        t1 (numpy.ndarray): Singles-amplitude array containing t1 amplitudes with the occupied-virtual block layout, or for unrestricted-reference calculations a sequence-like container of such 2-D arrays for each spin. For a restricted/reference (RHF) calculation, t1 must be a 2-D numpy.ndarray with shape (nocc, nvir), where nocc is the number of occupied orbitals and nvir is the number of virtual orbitals; the function constructs an (nocc + nvir) x (nocc + nvir) anti-Hermitian generator using the conventions amat[:nocc, -nvir:] = -t1 and amat[-nvir:, :nocc] = t1.conj().T and returns a numpy.ndarray of shape (nmo, nmo) with nmo = nocc + nvir. For an unrestricted/reference (UHF) case, t1 is expected to be an indexable collection (e.g., list or tuple) whose elements are 2-D numpy.ndarray objects each of shape (nocc, nvir) for that spin; the function determines spin = len(t1), computes nmo = nocc + nvir from the first spin component, builds one anti-Hermitian generator per spin, and returns a numpy.ndarray of shape (spin, nmo, nmo). The dtype of the returned array follows the input dtypes (RHF returns the dtype of t1, UHF uses numpy.result_type on the spin components). This argument is central in orbital-rotation-based updates: t1 represents singles amplitudes that, through this mapping, become the generator of a unitary rotation applied to orbital coefficients.
    
    Returns:
        numpy.ndarray: The unitary rotation matrix U obtained by exponentiating the assembled anti-Hermitian generator(s). For RHF-style 2-D t1 input, returns an array of shape (nmo, nmo) representing a single unitary rotation in the occupied+virtual orbital basis. For UHF-style input (a sequence of per-spin 2-D arrays), returns an array of shape (spin, nmo, nmo) containing one unitary matrix per spin. The returned matrix/matrices are suitable for directly rotating molecular-orbital coefficient arrays in subsequent coupled-cluster orbital updates or transformations.
    
    Raises and failure modes:
        The function will raise typical numpy exceptions if the provided t1 has incompatible shape or is not indexable in the UHF branch (for example, AttributeError, IndexError, or ValueError when shapes do not match nocc + nvir). scipy.linalg.expm (referenced as la.expm in the source) may raise a linear-algebra-related exception if the assembled generator contains invalid or non-finite values. Users must ensure t1 contains finite numeric entries and follows the (nocc, nvir) convention for each spin; otherwise the resulting umat is undefined and the call will fail. No in-place modification of the input t1 occurs; the function constructs intermediate arrays and returns a new numpy.ndarray (or array of arrays) with the computed unitary rotation.
    """
    from pyscf.cc.bccd import get_umat_from_t1
    return get_umat_from_t1(t1)


################################################################################
# Source: pyscf.cc.addons.spatial2spin
# File: pyscf/cc/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_cc_addons_spatial2spin(tx: tuple, orbspin: numpy.ndarray = None):
    """pyscf.cc.addons.spatial2spin converts coupled-cluster T1/T2 amplitude tensors from a spatial-orbital (spin-summed or spatial-indexed) representation into the spin-orbital representation used by PySCF's coupled-cluster routines. This function is used in PySCF to map restricted/ spatial-formatted amplitudes (RCCSD-style single-array T1 or T2, or separated alpha/beta blocks) into full spin-orbital amplitude arrays suitable for spin-orbital CC code paths and for interoperation between restricted and unrestricted amplitude formats.
    
    Args:
        tx (tuple or numpy.ndarray): Input T amplitudes in spatial-orbital form. Acceptable shapes and interpretations (in the context of PySCF coupled-cluster amplitudes) are:
            - A 2-D numpy.ndarray with ndim==2 interpreted as RCCSD T1 amplitudes of shape (nocc, nvir). In this case the function treats tx as identical alpha and beta T1 blocks and processes it as (tx, tx).
            - A 4-D numpy.ndarray with ndim==4 interpreted as RCCSD T2 amplitudes of shape (nocc, nocc, nvir, nvir). In this case the function forms the antisymmetrized same-spin block t2aa = tx - tx.transpose(1,0,2,3) and processes it as (t2aa, tx, t2aa).
            - A tuple of length 2 interpreted as separate T1 blocks (t1a, t1b) where t1a has shape (nocc_a, nvir_a) and t1b has shape (nocc_b, nvir_b). These are alpha and beta single excitation amplitudes in spatial-orbital indexing.
            - A tuple of length 3 interpreted as T2 blocks (t2aa, t2ab, t2bb) with shapes t2aa: (nocc_a, nocc_a, nvir_a, nvir_a), t2ab: (nocc_a, nocc_b, nvir_a, nvir_b), t2bb: (nocc_b, nocc_b, nvir_b, nvir_b). These correspond to alpha-alpha, alpha-beta, and beta-beta double excitation amplitudes in spatial indexing.
            The function preserves the dtype of the input arrays when constructing the spin-orbital output. If tx is not one of the above shapes/structures, the function raises RuntimeError('Unknown T amplitudes').
        orbspin (numpy.ndarray, optional): 1-D integer array that encodes the spin label for each spin-orbital used to build the spin-orbital mapping. The array length must equal the total number of spin-orbitals (nocc + nvir) where nocc = nocc_a + nocc_b and nvir = nvir_a + nvir_b as inferred from tx. Elements should be 0 for alpha and 1 for beta; the first nocc entries correspond to occupied spin-orbitals and the remaining nvir entries correspond to virtual spin-orbitals. If orbspin is None (default), the function constructs the canonical alternating spin ordering [0,1,0,1,...] for each spatial orbital assuming nocc_a == nocc_b (an assertion is performed). Providing an orbspin with an incorrect length or with labels other than 0/1 may lead to incorrect indexing or an IndexError during conversion.
    
    Behavior and side effects:
        - The function accepts both spatial-format numpy arrays and tuples of separated spin blocks and returns a spin-orbital numpy array suitable for spin-orbital CC code paths in PySCF.
        - For T1 input the returned array has shape (nocc, nvir) where nocc and nvir are the total numbers of occupied and virtual spin-orbitals computed from the input blocks (nocc = nocc_a + nocc_b, nvir = nvir_a + nvir_b).
        - For T2 input the returned array has shape (nocc, nocc, nvir, nvir) with spin-orbital ordering. Internally the function lays out a 2-D temporary (nocc**2, nvir**2) buffer and fills it by mapping the separated spin blocks into the combined spin-orbital indexing, including the required sign changes for exchange-related blocks (e.g., ab/ba combinations).
        - The function tags the returned array with an orbspin attribute using lib.tag_array(…, orbspin=orbspin) so downstream PySCF code can access the spin mapping metadata.
        - The function preserves input dtypes when creating the output arrays and uses lib.takebak_2d for indexed block placement; these are internal array operations and do not modify external state beyond returning the tagged array.
    
    Returns:
        numpy.ndarray: The converted amplitude array in spin-orbital representation. For T1 inputs this is a 2-D numpy array of shape (nocc, nvir) (total spin-orbitals) and for T2 inputs this is a 4-D numpy array of shape (nocc, nocc, nvir, nvir). The returned array dtype matches the input dtype and carries an orbspin attribute (tagged via lib.tag_array) describing the spin label of each spin-orbital. Errors are raised if the input structure cannot be recognized (RuntimeError('Unknown T amplitudes')) or if required assumptions fail (for example, an assertion when orbspin is None requires nocc_a == nocc_b).
    """
    from pyscf.cc.addons import spatial2spin
    return spatial2spin(tx, orbspin)


################################################################################
# Source: pyscf.cc.addons.spin2spatial
# File: pyscf/cc/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_cc_addons_spin2spatial(tx: numpy.ndarray, orbspin: numpy.ndarray):
    """Convert T1/T2 amplitudes from spin-orbital basis to spatial-orbital spin-separated basis used in PySCF coupled-cluster (CC) workflows.
    
    This function is used in the PySCF CC addons to transform CC single (T1) and double (T2) excitation amplitude tensors that are expressed in a spin-orbital indexing (interleaved alpha/beta spin-orbitals) into spatial-orbital amplitude tensors separated by spin (alpha and beta). This conversion is required when downstream CC code or post-processing routines expect amplitudes grouped by spatial orbitals and spin blocks (alpha-alpha, alpha-beta, beta-beta) rather than a single spin-orbital tensor. The implementation assumes the convention used elsewhere in PySCF: the first nocc entries of the spin-orbital index correspond to occupied spin-orbitals and the remaining entries correspond to virtual spin-orbitals; orbspin labels each spin-orbital as 0 (alpha) or 1 (beta).
    
    Args:
        tx (numpy.ndarray): Input T amplitudes in the spin-orbital basis. For T1 amplitudes this must be a 2-D array with shape (nocc, nvir) where nocc and nvir are numbers of occupied and virtual spin-orbitals respectively. For T2 amplitudes this must be a 4-D array with shape (nocc, nocc, nvir, nvir) where the first two indices are occupied spin-orbitals and the last two are virtual spin-orbitals. The function inspects tx.ndim to determine whether tx encodes T1 (ndim == 2) or T2 (ndim == 4) amplitudes. If tx has any other dimensionality, the function raises RuntimeError('Unknown T amplitudes').
        orbspin (numpy.ndarray): One-dimensional array that assigns a spin label to each spin-orbital index used by tx. Its length is expected to be at least nocc + nvir (the total number of spin-orbitals referenced by tx). Entries must be 0 for alpha spin and 1 for beta spin. The function uses orbspin[:nocc] to classify occupied spin-orbitals and orbspin[nocc:] to classify virtual spin-orbitals and then partitions indices into alpha and beta subsets for both occupied and virtual spaces. If orbspin contains values other than 0 or 1, some spin blocks may be empty; if orbspin is shorter than required, standard indexing errors (e.g., IndexError) may occur.
    
    Returns:
        tuple:
            If tx.ndim == 2 (T1 case): returns (t1a, t1b)
                t1a (numpy.ndarray): Alpha-spin single excitation amplitudes with shape (nocc_a, nvir_a). nocc_a is the number of alpha occupied spatial orbitals (count of zeros in orbspin[:nocc]), and nvir_a is the number of alpha virtual spatial orbitals (count of zeros in orbspin[nocc:]). Elements map occupied-alpha -> virtual-alpha amplitudes extracted from tx.
                t1b (numpy.ndarray): Beta-spin single excitation amplitudes with shape (nocc_b, nvir_b). nocc_b is the number of beta occupied spin-orbitals and nvir_b is the number of beta virtual spin-orbitals. Elements map occupied-beta -> virtual-beta amplitudes extracted from tx.
            If tx.ndim == 4 (T2 case): returns (t2aa, t2ab, t2bb)
                t2aa (numpy.ndarray): Alpha-alpha double excitation amplitudes with shape (nocc_a, nocc_a, nvir_a, nvir_a). The index order is (occ1_alpha, occ2_alpha, vir1_alpha, vir2_alpha). These amplitudes correspond to excitations from two alpha occupied spin-orbitals to two alpha virtual spin-orbitals extracted from the spin-orbital tensor tx.
                t2ab (numpy.ndarray): Alpha-beta double excitation amplitudes with shape (nocc_a, nocc_b, nvir_a, nvir_b). The index order is (occ_alpha, occ_beta, vir_alpha, vir_beta). These amplitudes correspond to excitations from one alpha and one beta occupied spin-orbital to one alpha and one beta virtual spin-orbital.
                t2bb (numpy.ndarray): Beta-beta double excitation amplitudes with shape (nocc_b, nocc_b, nvir_b, nvir_b). The index order is (occ1_beta, occ2_beta, vir1_beta, vir2_beta). These amplitudes correspond to excitations from two beta occupied spin-orbitals to two beta virtual spin-orbitals.
    
    Behavior and side effects:
        - The function inspects tx.ndim to decide whether it is handling T1 (2-D) or T2 (4-D) amplitudes. It raises RuntimeError('Unknown T amplitudes') for other dimensionalities.
        - The function partitions orbital indices into occupied/virtual and alpha/beta using orbspin and then extracts the corresponding blocks using index selection. The returned objects are numpy.ndarray instances containing the converted amplitude blocks for use in spatial-orbital, spin-separated CC routines.
        - No global state or module-level data are modified; the function has no side effects beyond allocating and returning the resulting numpy arrays.
        - If an expected spin block is empty (for example, all occupied spin-orbitals are alpha), the corresponding returned array will have a zero length along the appropriate dimensions.
        - If orbspin does not contain only 0 and 1 or does not have sufficient length to cover the indices implied by tx, the function may produce empty blocks or raise standard indexing errors (IndexError). These conditions are not explicitly validated beyond using numpy.where and slicing.
    
    Failure modes:
        - RuntimeError('Unknown T amplitudes') is raised when tx.ndim is neither 2 nor 4.
        - IndexError or other numpy indexing errors may occur if orbspin is shorter than nocc + nvir.
        - Logical misuse (for example, passing orbspin with unexpected labels) can yield empty or incorrect spin blocks; the function does not validate that orbspin contains only 0/1 beyond using equality comparisons.
    
    Practical significance in PySCF:
        - This conversion is commonly required in PySCF's coupled-cluster post-processing and addons where spin-orbital amplitude tensors produced by some routines must be reshaped into spin-separated spatial-orbital tensors for constructing energies, intermediates, or for interfacing with spin-adapted algorithms. The returned t1a/t1b and t2aa/t2ab/t2bb blocks are the standard inputs expected by many spatial-orbital CC helper functions in the pyscf.cc namespace.
    """
    from pyscf.cc.addons import spin2spatial
    return spin2spatial(tx, orbspin)


################################################################################
# Source: pyscf.cc.ccsd.get_d2_diagnostic
# File: pyscf/cc/ccsd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_cc_ccsd_get_d2_diagnostic(t2: numpy.ndarray):
    """Compute the D2 diagnostic for CCSD T2 amplitudes.
    
    This function implements the D2 diagnostic defined in Nielsen et al., Chem. Phys. Lett. 310 (1999) 568. It is intended for use in the PySCF coupled-cluster (ccsd) workflow to quantify the magnitude of double-excitation amplitudes (T2) coming from a restricted closed-shell CCSD calculation. The diagnostic is computed as the maximum of two norms derived from the largest eigenvalues of Hermitian matrices formed by contracting the supplied T2 tensor with itself over occupied or virtual index pairs. Larger values of the D2 diagnostic indicate stronger double-excitation character and can signal increasing nondynamic (multireference) correlation where single-reference CCSD may become unreliable. Note: this diagnostic is currently only defined in the literature and in this implementation for restricted closed-shell systems; it should not be used for unrestricted or general open-shell T2 tensors.
    
    Args:
        t2 (numpy.ndarray): T2 amplitude tensor from a restricted closed-shell CCSD calculation. The array is expected to have the standard occupied-occupied-virtual-virtual ordering with shape (nocc, nocc, nvir, nvir), corresponding to indices (i, j, a, b) where i and j label occupied orbitals and a and b label virtual orbitals. The function uses numpy.einsum contractions "ikab,jkab->ij" and "ijac,ijbc->ab" to build two Hermitian matrices from t2 and then computes their eigenvalues with numpy.linalg.eigh. If t2 is not a numpy.ndarray, has incompatible shape, contains non-finite values (NaN or infinite), or does not follow the expected index ordering, the underlying einsum or eigh calls will raise a ValueError or produce unreliable results.
    
    Returns:
        float: Scalar D2 diagnostic value (dimensionless). The returned value is computed as follows: form two Hermitian matrices M_ij = sum_{k,a,b} t2[i,k,a,b] * t2[j,k,a,b] and M_ab = sum_{i,j,c} t2[i,j,a,c] * t2[i,j,b,c]; obtain their eigenvalues using numpy.linalg.eigh; take the square root of the largest absolute eigenvalue for each matrix; and return the maximum of these two square-rooted largest eigenvalues. This is a pure, side-effect-free computation; it does not modify the input array. Numerical issues may arise if the matrices are ill-conditioned or t2 contains noisy values; absolute values of eigenvalues are used before taking the square root to mitigate small negative eigenvalues from numerical noise.
    """
    from pyscf.cc.ccsd import get_d2_diagnostic
    return get_d2_diagnostic(t2)


################################################################################
# Source: pyscf.cc.bccd.transform_l1_to_bo
# File: pyscf/cc/bccd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_cc_bccd_transform_l1_to_bo(t1: numpy.ndarray, umat: numpy.ndarray):
    """pyscf.cc.bccd.transform_l1_to_bo transforms single-excitation amplitudes (t1) into the Brueckner orbital (BO) basis used in Brueckner coupled-cluster doubles (BCCD) procedures. This function is used in the BCCD orbital-rotation and amplitude-transformation steps to express t1 amplitudes in the rotated (Brueckner) molecular-orbital basis defined by the orbital rotation matrix umat, which is required when checking or enforcing the Brueckner condition (vanishing singles) or when converting amplitudes between orbital representations.
    
    Args:
        t1 (numpy.ndarray or sequence of numpy.ndarray): The single-excitation amplitude(s) in the original molecular-orbital basis. For a restricted/HF-like case supply a 2-D numpy.ndarray with shape (nocc, nvir), where nocc is the number of occupied orbitals and nvir is the number of virtual orbitals; the function treats this as a single block of amplitudes and returns a single transformed 2-D array. For an unrestricted (UHF) calculation supply a sequence (e.g., list or tuple) of per-spin 2-D numpy.ndarray objects (one entry per spin), and the function will return a list of transformed arrays, applying the per-spin umat matrices. The t1 amplitudes represent the practical quantum-chemistry quantity of single excitation cluster amplitudes used by the coupled-cluster solver and by BCCD orbital-update logic.
    
        umat (numpy.ndarray): The orbital rotation (unitary) matrix that carries molecular orbitals from the original basis into the Brueckner orbital basis. In the restricted/2-D-t1 case, umat must be a square numpy.ndarray whose first nocc rows/columns correspond to the occupied space and whose remaining nvir rows/columns correspond to the virtual space; the code slices umat as umat[:nocc,:nocc] for the occupied block and umat[nocc:,nocc:] for the virtual block. In the unrestricted/UHF case, umat is expected to be a sequence (e.g., list or tuple) of per-spin square numpy.ndarray matrices with the same occupied/virtual block layout for each spin. The umat matrix encodes the orbital rotations computed by BCCD orbital optimization and is practically required to change the representation of amplitudes between orbital bases.
    
    Returns:
        numpy.ndarray or list of numpy.ndarray: If the input t1 is a 2-D numpy.ndarray (restricted/HF-like case), returns a 2-D numpy.ndarray of the same shape (nocc, nvir) containing the t1 amplitudes transformed to the Brueckner orbital basis according to the operation umat_occ.conj().T @ t1 @ umat_vir, where umat_occ = umat[:nocc,:nocc] and umat_vir = umat[nocc:,nocc:]. If the input t1 is a sequence for an unrestricted (UHF) case, returns a list of transformed 2-D numpy.ndarray objects, one per spin, each obtained by applying the corresponding per-spin umat. The returned arrays are new objects; the function does not modify the input arrays in place.
    
    Behavior and side effects:
        For a 2-D t1 input the function extracts the occupied and virtual blocks from umat and computes the matrix product reduce(np.dot, (umat_occ.conj().T, t1, umat_vir)), i.e., the occupied-block conjugate-transpose premultiplication and the virtual-block postmultiplication. For UHF (spin-dependent) inputs the function dispatches to per-spin transforms and returns a list of per-spin results. There are no side effects: inputs are not modified in place and a new numpy.ndarray (or list of arrays) is returned.
    
    Failure modes and error conditions:
        If t1 is a 2-D numpy.ndarray but umat does not have at least nocc + nvir rows and columns or is not indexable as assumed, slicing umat[:nocc,:nocc] or umat[nocc:,nocc:] will raise an IndexError or produce an incorrectly shaped block; subsequent matrix multiplication will raise a ValueError for incompatible shapes. If t1 is neither a 2-D numpy.ndarray nor a sequence of 2-D numpy.ndarray objects, the function will raise a TypeError or a downstream error when attempting indexing or dot products. For UHF inputs, umat should be provided as a sequence of per-spin matrices matching the structure expected by the t1 spin blocks; mismatched sequence lengths or incompatible per-spin shapes will result in IndexError/ValueError. The function does not perform explicit validation of unitary properties of umat; such physical correctness checks must be performed by caller code if required.
    """
    from pyscf.cc.bccd import transform_l1_to_bo
    return transform_l1_to_bo(t1, umat)


################################################################################
# Source: pyscf.cc.eom_uccsd.vector_to_amplitudes_ip
# File: pyscf/cc/eom_uccsd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_cc_eom_uccsd_vector_to_amplitudes_ip(
    vector: numpy.ndarray,
    nmo: tuple,
    nocc: tuple
):
    """Convert a flat optimization vector into spin-orbital ionization-potential (IP) EOM-UCCSD singles and doubles amplitude tensors used by PySCF. This function is used in the EOM-UCCSD (equation-of-motion coupled-cluster with single and double excitations) IP module to reconstruct the per-spin singles (r1) and doubles (r2) amplitude arrays from a one-dimensional parameter vector that typically appears in iterative solvers and linear-response routines. The reconstruction follows the layout implemented in the source: packed lower-triangular storage for same-spin double excitations and full storage for mixed-spin doubles; same-spin doubles are expanded to antisymmetric 2-index tensors.
    
    Args:
        vector (numpy.ndarray): One-dimensional numpy array containing concatenated amplitude parameters in the specific ordering expected by the IP EOM-UCCSD routines. The vector must contain segments in the following order and sizes (computed inside the function): nocca, noccb, nocca*(nocca-1)//2*nvira, noccb*nocca*nvira, nocca*noccb*nvirb, noccb*(noccb-1)//2*nvirb, where nocca and noccb are the alpha and beta occupied orbital counts and nvira = nmoa - nocca, nvirb = nmob - noccb (see nmo and nocc). The dtype of the returned arrays is preserved from vector.dtype. If the length of vector does not match the expected total size, numpy.split will raise a ValueError.
    
        nmo (tuple): Tuple of two integers (nmoa, nmob) giving the total number of molecular orbitals for alpha (spin-up) and beta (spin-down) electrons, respectively. These values are used to compute the number of virtual orbitals per spin as nvira = nmoa - nocca and nvirb = nmob - noccb. Supplying inconsistent or non-integer values will lead to invalid shapes or errors when splitting/reshaping the vector.
    
        nocc (tuple): Tuple of two integers (nocca, noccb) giving the number of occupied molecular orbitals for alpha and beta spins, respectively. These counts determine the sizes of the singles and doubles amplitude blocks. Negative or non-integer occupation numbers are invalid and will produce shape/resize errors.
    
    Returns:
        tuple: A pair (r1, r2) where:
            r1 (tuple): Two one-dimensional numpy arrays (r1a, r1b) containing the reconstructed singles (IP) amplitudes for alpha and beta spins. Their shapes are (nocca,) and (noccb,), respectively. These arrays are copies of the corresponding segments from the input vector and are suitable for use in PySCF's EOM-UCCSD IP algorithms that expect per-spin singles amplitudes.
    
            r2 (tuple): Four numpy arrays (r2aaa, r2baa, r2abb, r2bbb) containing the reconstructed doubles amplitudes arranged by spin block:
                r2aaa has shape (nocca, nocca, nvira) and represents same-spin alpha-alpha-alpha doubles; it is antisymmetric in the first two occupied indices and is assembled from the packed lower-triangular block in the input vector (the function fills the lower-triangular part and enforces antisymmetry by sign).
                r2baa has shape (noccb, nocca, nvira) and represents beta-alpha-alpha mixed-spin doubles; it is taken from the corresponding contiguous block in the vector and returned as a copy (shape consistent with code: noccb x nocca x nvira).
                r2abb has shape (nocca, noccb, nvirb) and represents alpha-beta-beta mixed-spin doubles; it is taken from the corresponding contiguous block in the vector and returned as a copy (shape: nocca x noccb x nvirb).
                r2bbb has shape (noccb, noccb, nvirb) and represents same-spin beta-beta-beta doubles; it is antisymmetric in its first two occupied indices and reconstructed from the packed lower-triangular block in the input vector.
    
        The returned arrays preserve the dtype of the input vector and are ready for use in downstream PySCF EOM-UCCSD IP computations that require structured per-spin amplitude tensors.
    
    Raises / failure modes:
        ValueError: If the one-dimensional input vector length does not equal the sum of the expected block sizes, numpy.split or subsequent reshape calls will raise a ValueError. This indicates a mismatch between the provided vector and the (nmo, nocc) specification.
        TypeError or IndexError: If nmo or nocc are not two-element tuples of integers, or if the computed virtual dimensions are negative, reshape and indexing operations will fail.
    Side effects and implementation notes:
        The function makes explicit copies for some returned arrays (r1a, r1b via copy; r2baa and r2abb via reshape().copy()) to avoid giving views into the original vector; r2aaa and r2bbb are newly allocated arrays populated from the packed-storage components. The routine assumes the particular packing/order convention used throughout PySCF's EOM-UCCSD IP implementation for spin-orbital amplitudes.
    """
    from pyscf.cc.eom_uccsd import vector_to_amplitudes_ip
    return vector_to_amplitudes_ip(vector, nmo, nocc)


################################################################################
# Source: pyscf.cc.eom_uccsd.spatial2spin_ea
# File: pyscf/cc/eom_uccsd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_cc_eom_uccsd_spatial2spin_ea(rx: list, orbspin: numpy.ndarray = None):
    """pyscf.cc.eom_uccsd.spatial2spin_ea converts electron-attached (EOMEA) excitation amplitudes expressed in spatial-orbital blocks into a spin-orbital representation required by spin-orbital EOM-UCCSD operations in the PySCF quantum chemistry framework. This function is used in the EOM-UCCSD module to take spatial-only R1 or R2 amplitude components (separate alpha/beta blocks) and assemble them into a single spin-orbital array where spin labels are encoded by an orbspin mask (0 for alpha, 1 for beta). The conversion preserves the input numeric dtype and arranges virtual and occupied indices according to the provided or implicit orbital-spin ordering so downstream spin-orbital Hamiltonian routines can consume the amplitudes.
    
    Args:
        rx (list): Spatial-orbital EOMEA amplitude components. Two distinct valid forms are accepted and distinguished by the list length.
            If len(rx) == 2: rx must contain two 1D numpy arrays [r1a, r1b] representing the R1 (single-particle) amplitudes for alpha and beta spatial virtual orbitals respectively. r1a.shape == (nvir_a,) and r1b.shape == (nvir_b,). The function returns a single 1D spin-orbital R1 array of length nvir_a + nvir_b where entries are placed according to orbspin (see orbspin description). When orbspin is None, an interleaved alpha/beta ordering is assumed and requires nvir_a == nvir_b; an AssertionError is raised otherwise.
            If len(rx) != 2: rx must contain four arrays [r2aaa, r2aba, r2bab, r2bbb] corresponding to the spatial R2 (two-particle, occupied->virtual->virtual) amplitude blocks for different spin combinations. Expected shapes are r2aaa.shape == (nocc_a, nvir_a, nvir_a), r2aba.shape == (nocc_a, nvir_b, nvir_a), r2bab.shape == (nocc_b, nvir_a, nvir_b), and r2bbb.shape == (nocc_b, nvir_b, nvir_b). The function assembles these four spatial blocks into a single spin-orbital R2 array of shape (nocc, nvir, nvir) where nocc = nocc_a + nocc_b and nvir = nvir_a + nvir_b. When orbspin is None, the code asserts nvir_a == nvir_b and constructs a default alternating spin ordering; an AssertionError is raised if this equality does not hold.
        orbspin (numpy.ndarray): 1D integer array encoding spin labels for each orbital in the combined occupied+virtual orbital list using 0 for alpha and 1 for beta. The array length must equal the total number of spatial occupied plus spatial virtual orbitals (nocc + nvir) when provided. For the R1 case, only the last nvir entries orbspin[-nvir:] are used to place virtual amplitudes into the spin-orbital R1 vector. For the R2 case, orbspin is used to locate occupied and virtual indices of each spin (idxoa, idxob, idxva, idxvb) and route the four spatial blocks into the corresponding spin-orbital subblocks. If orbspin is None, the function constructs a default orbspin of length (nocc_a + nvir_a)*2 with alternating 0,1 (alpha,beta) entries and requires equal numbers of alpha and beta virtuals (nvir_a == nvir_b). orbspin must contain only 0 and 1 values; mismatched lengths or invalid contents will lead to indexing errors or incorrect placement.
    
    Behavior, defaults, and failure modes:
        The function is pure (no outside side effects) and returns a new numpy.ndarray holding the spin-orbital amplitudes; it does not modify the input arrays. The returned array dtype is the same as the dtype of the provided spatial blocks (r1a / r2aaa etc.). When rx encodes R1 amplitudes (len(rx) == 2), the function builds a 1D spin-orbital R1 vector by interleaving or selecting entries from r1a and r1b according to orbspin. When rx encodes R2 amplitudes (len(rx) == 4), the function flattens and places spatial subblocks into a flattened (nocc, nvir**2) working array using index maps derived from orbspin, applies sign conventions present in the code (two mixed-spin blocks are negated as r2aab = -r2aba and r2bba = -r2bab), and finally reshapes the result to (nocc, nvir, nvir). If orbspin is None a default alternating alpha/beta ordering is assumed; this default requires equal numbers of alpha and beta virtual orbitals (an assertion enforces equality). AssertionError is raised if required equalities do not hold, and IndexError or ValueError may be raised for inconsistent array shapes. The function uses numpy and an internal lib.takebak_2d helper for block placements; if those routines raise exceptions (e.g., due to shape mismatches), they propagate to the caller.
    
    Returns:
        numpy.ndarray: For the R1 case (len(rx) == 2) returns a 1D numpy array r1 of length nvir = nvir_a + nvir_b containing spin-orbital virtual amplitudes arranged by orbspin. For the R2 case (len(rx) == 4) returns a 3D numpy array r2 with shape (nocc, nvir, nvir), where nocc = nocc_a + nocc_b and nvir = nvir_a + nvir_b; r2[io, va, vb] indexes the amplitude for occupied spin-orbital io and virtual spin-orbitals (va, vb). The dtype of the returned array matches the dtype of the input amplitude blocks. Exceptions are raised for inconsistent shapes or invalid orbspin values as described above.
    """
    from pyscf.cc.eom_uccsd import spatial2spin_ea
    return spatial2spin_ea(rx, orbspin)


################################################################################
# Source: pyscf.cc.eom_uccsd.spin2spatial_eomsf
# File: pyscf/cc/eom_uccsd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_cc_eom_uccsd_spin2spatial_eomsf(rx: numpy.ndarray, orbspin: numpy.ndarray):
    """Convert EOMEE spin-orbital R1/R2 amplitudes into spin-flip EOMEE spatial-orbital R1/R2 blocks.
    
    This function is used in the EOM-UCCSD code path of the PySCF quantum chemistry package to transform excitation (R1) or double-excitation (R2) amplitudes that are expressed in a spin-orbital basis into spatial-orbital blocks arranged for spin-flip EOM calculations. The conversion groups amplitude elements according to the spin (alpha/beta) of the occupied and virtual orbitals defined by orbspin, returning only the spin-flip relevant blocks. It is a pure transformation with no side effects on inputs.
    
    Args:
        rx (numpy.ndarray): The input excitation amplitudes in spin-orbital representation. For single-excitation amplitudes (R1) rx must be a 2-dimensional array with shape (nocc, nvir) where nocc is the number of occupied spin-orbitals and nvir the number of virtual spin-orbitals. For double-excitation amplitudes (R2) rx must be an array whose middle two dimensions are (nocc, nvir) so that the code reshapes it to a 2D array of shape (nocc**2, nvir**2); in typical use R2 is provided as a 4-dimensional array with shape (nocc, nocc, nvir, nvir). The function slices rx and reshapes blocks; if rx has unexpected dimensionality or incompatible shape a ValueError or IndexError may be raised during reshaping or indexing.
        orbspin (numpy.ndarray): 1-dimensional array labeling the spin of each spatial orbital. Elements are integer codes where 0 denotes an alpha (↑) spin orbital and 1 denotes a beta (↓) spin orbital. The array must have at least nocc + nvir entries, where nocc and nvir are derived from rx as described above. The first nocc entries are interpreted as the spins of occupied orbitals and the remaining entries as the spins of virtual orbitals. If orbspin does not follow this convention (wrong length or values other than 0/1), the returned blocks will be incorrect or indexing will fail.
    
    Returns:
        tuple or numpy.ndarray: If rx is 2-dimensional (R1 case), returns a tuple (r1ab, r1ba) of numpy.ndarray objects:
            r1ab has shape (nocca, nvirb) and contains the single-excitation amplitudes that remove an electron from an occupied alpha orbital and create one in a virtual beta orbital. nocca is the number of occupied alpha orbitals and nvirb the number of virtual beta orbitals determined from orbspin.
            r1ba has shape (noccb, nvira) and contains the amplitudes that remove an electron from an occupied beta orbital and create one in a virtual alpha orbital. noccb is the number of occupied beta orbitals and nvira the number of virtual alpha orbitals.
        If rx has higher dimensionality (R2 case), returns a 4-tuple (r2baaa, r2aaba, r2abbb, r2bbab) of numpy.ndarray objects corresponding to different occupied/virtual spin combinations relevant for spin-flip EOM:
            r2baaa is shaped (noccb, nocca, nvira, nvira) and the element r2baaa[i_b, j_a, a_a, b_a] corresponds to the amplitude that annihilates an electron in occupied beta orbital i_b and occupied alpha orbital j_a and creates electrons in virtual alpha orbitals a_a and b_a.
            r2aaba is shaped (nocca, nocca, nvirb, nvira) and the element r2aaba[i_a, j_a, a_b, b_a] corresponds to annihilating two occupied alpha electrons (i_a, j_a) and creating one beta virtual (a_b) and one alpha virtual (b_a).
            r2abbb is shaped (nocca, noccb, nvirb, nvirb) corresponding to annihilating an occupied alpha and an occupied beta electron and creating two virtual beta electrons.
            r2bbab is shaped (noccb, noccb, nvira, nvirb) corresponding to annihilating two occupied beta electrons and creating one virtual alpha and one virtual beta electron.
        All returned objects are new numpy.ndarray instances; the input arrays are not modified.
    
    Behavior, defaults, and failure modes:
        - The function infers nocc and nvir from the shape of rx: for 2D rx these are rx.shape; for higher-dimensional rx it uses rx.shape[1:3] and then reshapes to (nocc**2, nvir**2). Calling code should supply rx in the expected shapes (commonly (nocc, nvir) for R1 or (nocc, nocc, nvir, nvir) for R2).
        - orbspin must index occupied and virtual orbitals as described; orbspin values outside {0,1} are not handled and will lead to incorrect indexing.
        - If rx and orbspin are incompatible (orbspin too short, indices out of range, or rx not having the expected product dimensions), NumPy indexing or reshape operations will raise IndexError or ValueError.
        - This routine performs only slicing and reshaping to produce physically meaningful spin-flip blocks for downstream spin-flip EOM-EOM/UCCSD routines in PySCF; it does not validate electron counts, spin multiplicities, or other physical consistency checks beyond the array shape and orbspin convention.
    """
    from pyscf.cc.eom_uccsd import spin2spatial_eomsf
    return spin2spatial_eomsf(rx, orbspin)


################################################################################
# Source: pyscf.cc.eom_uccsd.spatial2spin_eomsf
# File: pyscf/cc/eom_uccsd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_cc_eom_uccsd_spatial2spin_eomsf(rx: list, orbspin: numpy.ndarray = None):
    """Convert spin-flip EOM-EE spatial-orbital excitation amplitudes (R1/R2) to spin-orbital excitation amplitudes used in spin-orbital EOM-SF code paths.
    
    Args:
        rx (list): Input spin-flip excitation amplitudes in spatial-orbital block form. Must be either:
            - A length-2 list [r1ab, r1ba] for single-excitation (R1) amplitudes where
              r1ab is a numpy.ndarray of shape (nocca, nvirb) and r1ba is a numpy.ndarray of shape (noccb, nvira).
              Here nocca is the number of occupied alpha spatial orbitals, noccb the number of occupied beta spatial orbitals,
              nvira the number of virtual alpha spatial orbitals, and nvirb the number of virtual beta spatial orbitals.
              The function combines these two spatial spin-flip R1 blocks into a single spin-orbital R1 array of shape
              (nocc, nvir) with nocc = nocca + noccb and nvir = nvira + nvirb.
            - A length-4 list [r2baaa, r2aaba, r2abbb, r2bbab] for double-excitation (R2) amplitudes where the expected
              array shapes are
                r2baaa: (noccb, nocca, nvira, nvira)
                r2aaba: (nocca, nocca, nvirb, nvira)
                r2abbb: (nocca, noccb, nvirb, nvirb)
                r2bbab: (noccb, noccb, nvira, nvirb)
              These four spatial spin-flip R2 blocks are mapped and interleaved into a single spin-orbital R2 array of shape
              (nocc, nocc, nvir, nvir) with nocc = nocca + noccb and nvir = nvira + nvirb.
            The list elements must be numpy.ndarray objects whose dtypes are preserved in the output. The function will
            raise a Python unpacking error if rx has a length other than 2 or 4, and downstream shape/indexing errors
            (ValueError, IndexError) if individual array shapes do not match the expected block dimensions.
        orbspin (numpy.ndarray, optional): 1D integer array of length (nocc + nvir) that labels the spin of each spatial
            orbital in the combined occupied+virtual ordering. Elements must be 0 for alpha and 1 for beta. The first nocc
            entries correspond to occupied spatial orbitals and the remaining nvir entries correspond to virtual spatial
            orbitals. If provided, orbspin controls how spatial alpha/beta blocks from rx are interleaved into the
            spin-orbital output; orbspin is not modified by the function. If orbspin is None (default), the function
            assumes equal numbers of occupied alpha and beta spatial orbitals (nocca == noccb) and constructs a default
            alternating spin pattern [0,1,0,1,...] across the combined occupied+virtual orbital list. If this assumption
            does not hold, an AssertionError is raised when orbspin is None.
    
    Behavior and practical significance:
        This routine is intended for use in PySCF EOM-CCSD spin-flip (EOM-SF) workflows to convert amplitude tensors expressed
        in a spatial-orbital spin-block representation (separate alpha/beta spatial blocks) into a single spin-orbital
        representation where each spatial orbital appears once and a separate spin label is encoded implicitly by position.
        The conversion rearranges and inserts the provided spatial-block amplitudes into the correct spin-orbital locations
        (occupied and virtual spaces concatenated) according to orbspin. For R1 inputs, the two spatial blocks r1ab and r1ba
        are placed into the corresponding spin-orbital positions. For R2 inputs, the four spatial blocks are reshaped and
        placed into the four corresponding spin-orbital block positions with both direct and transposed placements to
        produce the full antisymmetric spin-orbital R2 array expected by spin-orbital solvers.
        The dtype of the returned arrays matches the dtype of the input blocks. The routine allocates new numpy arrays for
        the spin-orbital outputs and does not modify the input rx list or the provided orbspin array.
    
    Defaults and side effects:
        If orbspin is None, a default even-odd alternating spin pattern is created (alpha=0 on even indices, beta=1 on
        odd indices) across the concatenated occupied+virtual index range. This default is appropriate for the common
        closed-shell assumption where the number of occupied alpha and beta spatial orbitals are equal. No external state
        is mutated; all outputs are newly allocated numpy arrays returned to the caller.
    
    Failure modes and errors:
        - If rx is not length 2 or 4, the function will fail when attempting to unpack rx (TypeError/ValueError).
        - If the spatial-block arrays in rx do not have the expected shapes described above, numpy reshape/indexing will
          raise ValueError or IndexError.
        - If orbspin is None and nocca != noccb, an AssertionError is raised because the default alternating-spin pattern
          cannot be inferred consistently.
        - If orbspin is provided but does not have length equal to nocc + nvir or contains values other than 0 and 1,
          the function may produce empty index sets and subsequently raise IndexError or produce incorrect placement.
        Users should validate shapes and orbspin contents before calling this function in production workflows.
    
    Returns:
        numpy.ndarray: For R1 input (rx length 2), returns a 2D numpy.ndarray of shape (nocc, nvir) containing the
        spin-orbital single-excitation amplitudes. For R2 input (rx length 4), returns a 4D numpy.ndarray of shape
        (nocc, nocc, nvir, nvir) containing the spin-orbital double-excitation amplitudes. In both cases nocc = nocca + noccb
        and nvir = nvira + nvirb as inferred from the shapes of the input spatial blocks. The returned arrays are newly
        allocated and preserve the dtype of the corresponding input blocks.
    """
    from pyscf.cc.eom_uccsd import spatial2spin_eomsf
    return spatial2spin_eomsf(rx, orbspin)


################################################################################
# Source: pyscf.cc.eom_uccsd.spin2spatial_ea
# File: pyscf/cc/eom_uccsd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_cc_eom_uccsd_spin2spatial_ea(rx: numpy.ndarray, orbspin: numpy.ndarray):
    """Convert EOMEA spin-orbital amplitudes (R1 or R2) into spatial-orbital blocks for UCCSD EOM-EA procedures.
    
    This function is used in the PySCF coupled-cluster EOM electron-affinity (EOMEA) workflow to separate spin-orbital amplitude arrays into spatial-orbital components grouped by spin (alpha/beta). In EOM-EA calculations built on unrestricted CCSD (UCCSD), excitation/attachment amplitude vectors are often stored in spin-orbital form (one entry per spin-orbital). Many post-processing routines and tensor contractions operate on spatial-orbital blocks (alpha/beta subblocks). This routine accepts either a 1-D R1 spin-orbital vector or a 2-D R2 spin-orbital amplitude array and returns the corresponding spatial-orbital blocks used downstream in EOMEA amplitude manipulation, screening, or contraction.
    
    Args:
        rx (numpy.ndarray): Spin-orbital amplitude data for an EOMEA calculation. Two formats are accepted and distinguished by rx.ndim:
            - If rx.ndim == 1: rx is a spin-orbital R1 vector with length equal to the total number of virtual spin-orbitals (nvir_total). In this case the function extracts and returns the spatial alpha and beta components of the R1 vector. The function indexes the last nvir entries of orbspin to determine which virtual spin-orbitals are alpha (orbspin value 0) or beta (orbspin value 1) and returns two 1-D numpy.ndarray objects r1a and r1b containing the amplitudes for alpha and beta virtual spatial orbitals respectively.
            - If rx.ndim != 1: rx is interpreted as a spin-orbital R2 amplitude array whose first two shape entries are (nocc, nvir**2). Concretely, the function reads nocc, nvir = rx.shape[:2] and expects rx.size == nocc * (nvir**2). In this case the function reshapes and selects subblocks to produce four spatial blocks of the R2 amplitudes partitioned by occupied/virtual spins.
          The rx array must be a numpy.ndarray consistent with one of the two formats above; incompatible shapes (for example, a 2-D array whose total size does not equal nocc*nvir**2 after choosing nocc,nvir from rx.shape[:2]) will raise a numpy indexing/reshape error.
        orbspin (numpy.ndarray): 1-D integer array that encodes the spin label for each spatial orbital in the combined occupied+virtual ordering used by rx. Entries must be exactly 0 for alpha spin and 1 for beta spin (the implementation tests equality to 0 or 1). When rx is 1-D, orbspin is indexed with its last nvir entries to classify the virtual spin-orbitals. When rx is 2-D, orbspin is indexed as orbspin[:nocc] for occupied-spin classification and orbspin[nocc:] for virtual-spin classification; therefore orbspin must have length equal to nocc + nvir in that case. Mismatch between orbspin length and the expected nocc/nvir values will produce an IndexError or incorrect slicing.
    
    Returns:
        If rx.ndim == 1:
            (numpy.ndarray, numpy.ndarray): A tuple (r1a, r1b). r1a is a 1-D numpy.ndarray containing the R1 amplitudes corresponding to alpha spatial virtual orbitals (orbspin == 0). r1b is a 1-D numpy.ndarray containing the R1 amplitudes corresponding to beta spatial virtual orbitals (orbspin == 1). These arrays are intended for use in spatial-orbital EOMEA code paths that expect separate alpha/beta R1 vectors.
        If rx.ndim != 1:
            (numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray): A tuple (r2aaa, r2aba, r2bab, r2bbb). Each returned element is a 3-D numpy.ndarray representing a spatial-orbital block of the R2 amplitudes with shapes determined by the counts of occupied/virtual orbitals of each spin:
            - r2aaa has shape (nocc_a, nvir_a, nvir_a) and contains amplitudes with an alpha occupied index and two alpha virtual indices.
            - r2aba has shape (nocc_a, nvir_b, nvir_a) and contains amplitudes with an alpha occupied index, a beta first virtual index, and an alpha second virtual index.
            - r2bab has shape (nocc_b, nvir_a, nvir_b) and contains amplitudes with a beta occupied index, an alpha first virtual index, and a beta second virtual index.
            - r2bbb has shape (nocc_b, nvir_b, nvir_b) and contains amplitudes with a beta occupied index and two beta virtual indices.
          Here nocc_a, nocc_b are the numbers of alpha and beta occupied spatial orbitals determined from orbspin[:nocc], and nvir_a, nvir_b are the numbers of alpha and beta virtual spatial orbitals determined from orbspin[nocc:].
          These blocks are returned in the order commonly used in UCCSD EOM-EA implementations so they can be directly used for spatial-orbital tensor contractions and subsequent EOM algebra.
    
    Behavior and failure modes:
        - No in-place modification of rx or orbspin is performed; the function returns new numpy arrays referencing or copying data as determined by numpy indexing and reshape semantics.
        - orbspin must contain only 0 and 1 values that consistently label alpha and beta spins. Non-0/1 values will not match the expected conditions and will likely produce empty selections or incorrect output.
        - For 1-D rx input, orbspin must have at least nvir entries at its end; for 2-D rx input orbspin must have length exactly nocc + nvir. If these conditions are violated, numpy indexing or reshape operations will raise IndexError or ValueError.
        - rx must be provided in the spin-orbital ordering convention assumed by the calling code (occupied indices first, then virtual indices for the orbspin split used in this routine). Providing rx in a different ordering will produce incorrect spatial blocks.
        - This function does not validate numeric types beyond numpy.ndarray; supplying non-numeric or non-array objects will raise typical numpy attribute or indexing errors.
    
    Side effects:
        - None beyond allocation of the returned numpy.ndarray objects used to hold the spatial blocks.
    """
    from pyscf.cc.eom_uccsd import spin2spatial_ea
    return spin2spatial_ea(rx, orbspin)


################################################################################
# Source: pyscf.cc.eom_uccsd.spin2spatial_ip
# File: pyscf/cc/eom_uccsd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_cc_eom_uccsd_spin2spatial_ip(rx: numpy.ndarray, orbspin: numpy.ndarray):
    """Convert EOM-IP spin-orbital R1/R2 amplitudes to spatial-orbital R1/R2 blocks used in EOM-UCCSD.
    
    This function is used within the pyscf.cc.eom_uccsd module of the PySCF quantum chemistry framework to translate amplitude tensors expressed in a spin-orbital basis (where alpha/beta spin are interleaved) into spatial-orbital blocks separated by spin (alpha/beta). The conversion is required when working with unrestricted coupled-cluster EOM for ionization potentials (EOM-IP) where intermediate code or algorithms expect spatial-orbital block structures: for a 1-D input it extracts spatial occupied single-hole (R1) amplitudes for alpha and beta spins; for a higher-dimensional input it reshapes and partitions two-hole/one-particle (R2) spin-orbital amplitudes into the four spin blocks (alpha-alpha, beta-alpha, alpha-beta, beta-beta) for occupied-occupied -> virtual mapping. The function does not modify its inputs and returns newly allocated numpy arrays.
    
    Args:
        rx (numpy.ndarray): Spin-orbital amplitudes to be converted. If rx.ndim == 1, rx is interpreted as a 1-D R1 vector of length equal to the total number of occupied spin-orbitals (nocc_total), and the function returns the spatial R1 blocks for alpha and beta occupied orbitals. If rx.ndim != 1, the function expects rx to be an array whose second and third dimensions are (nocc_total, nvir_total) so that nocc, nvir = rx.shape[1:] are used; in this case rx is treated as spin-orbital R2 amplitudes packed as a 2-D (nocc_total**2, nvir_total) block after a reshape. The caller is responsible for providing rx in the spin-orbital ordering consistent with orbspin (occupied indices first, then virtual indices). The function returns newly created numpy arrays and does not alter rx in place.
    
        orbspin (numpy.ndarray): 1-D integer array that encodes the spin label for each spatial orbital in the ordering expected by rx. The array must contain entries 0 for alpha and 1 for beta and must be ordered so that the first nocc entries correspond to the nocc occupied spin-orbitals and the remaining entries correspond to the nvir virtual spin-orbitals (i.e., orbspin[:nocc] are occupied spins and orbspin[nocc:] are virtual spins, where nocc and nvir are inferred from rx when rx.ndim != 1). orbspin is used to partition indices into alpha and beta sets for occupied and virtual spaces. If orbspin length or contents do not match the shapes and conventions expected from rx, indexing or reshape operations will raise an error (e.g., IndexError or ValueError).
    
    Returns:
        If rx.ndim == 1:
            tuple(numpy.ndarray, numpy.ndarray): (r1a, r1b) where r1a contains the spatial R1 amplitudes for alpha-occupied orbitals and r1b contains the spatial R1 amplitudes for beta-occupied orbitals. The lengths of r1a and r1b equal the number of alpha and beta occupied spatial orbitals (nocc_a and nocc_b) determined from orbspin[:nocc_total].
        Otherwise:
            tuple(numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray): (r2aaa, r2baa, r2abb, r2bbb). These are the spatial-orbital R2 blocks extracted from the spin-orbital R2 input after reshaping rx to shape (nocc_total**2, nvir_total) and selecting index pairs according to orbspin. Their shapes are:
            r2aaa: (nocc_a, nocc_a, nvir_a)
            r2baa: (nocc_b, nocc_a, nvir_a)
            r2abb: (nocc_a, nocc_b, nvir_b)
            r2bbb: (nocc_b, nocc_b, nvir_b)
            where nocc_a/nocc_b are the counts of alpha/beta occupied spatial orbitals from orbspin[:nocc], and nvir_a/nvir_b are the counts of alpha/beta virtual spatial orbitals from orbspin[nocc:].
    
    Notes and failure modes:
        - The function assumes the spin-orbital ordering used by rx is consistent with orbspin: occupied spin-orbitals are indexed first and virtual spin-orbitals follow. orbspin must therefore have length equal to nocc + nvir when rx.ndim != 1 and must use 0/1 to indicate alpha/beta.
        - If orbspin contains values other than 0 or 1, or its length does not match the expected nocc + nvir, indexing operations (np.where, reshapes, or lib.take_2d calls) may raise IndexError or ValueError.
        - If one spin channel is absent (e.g., no alpha or no beta orbitals), the corresponding returned arrays may be empty with zero size in the respective dimension.
        - There are no side effects: inputs are not modified and all outputs are new numpy arrays allocated by the function.
    """
    from pyscf.cc.eom_uccsd import spin2spatial_ip
    return spin2spatial_ip(rx, orbspin)


################################################################################
# Source: pyscf.cc.eom_uccsd.spatial2spin_ip
# File: pyscf/cc/eom_uccsd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_cc_eom_uccsd_spatial2spin_ip(rx: tuple, orbspin: numpy.ndarray = None):
    """pyscf.cc.eom_uccsd.spatial2spin_ip: Convert EOM-IP spatial-orbital R1/R2 amplitude blocks to a unified spin-orbital representation used in UCCSD EOM-IP calculations in the PySCF quantum-chemistry framework. This function is used when downstream linear-algebra routines (solvers, matrix-vector products, and response routines) require amplitudes arranged in a spin-orbital basis rather than separate alpha/beta spatial blocks.
    
    Args:
        rx (tuple): Input EOM-IP amplitude blocks in spatial-orbital form. The function accepts two alternative layouts determined by the length of this tuple:
            - If len(rx) == 2: rx is (r1a, r1b) where r1a and r1b are 1D numpy.ndarray objects containing occupied-space R1 amplitudes for alpha and beta spins, respectively. r1a.size and r1b.size are the number of occupied spatial orbitals for alpha (nocc_a) and beta (nocc_b).
            - If len(rx) == 4: rx is (r2aaa, r2baa, r2abb, r2bbb) where each element is a 3D numpy.ndarray holding spatial-orbital R2 amplitudes for different spin blocks. The code expects r2aaa.shape == (nocc_a, nocc_a, nvir_a), r2baa.shape == (nocc_b, nocc_a, nvir_a), r2abb.shape == (nocc_a, nocc_b, nvir_b), and r2bbb.shape == (nocc_b, nocc_b, nvir_b). Here nocc_a/nocc_b are the numbers of occupied alpha/beta spatial orbitals and nvir_a/nvir_b are the numbers of virtual alpha/beta spatial orbitals. These shapes are used to reshape and place blocks into the full spin-orbital tensor.
        orbspin (numpy.ndarray = None): Optional 1D integer array that maps spin-orbital indices to spin labels. Entries equal to 0 denote alpha spin and entries equal to 1 denote beta spin. When provided, the function uses orbspin[:nocc] to identify which occupied spin-orbital indices correspond to alpha/beta and orbspin[nocc:] to identify virtual spin-orbital indices; nocc and nvir are inferred from the shapes of the rx blocks. If orbspin is None, the function constructs a default alternating spin pattern (alpha, beta, alpha, beta, ...) of length 2*(nocc_a+nvir_a) in the R2 branch, or in the R1 branch it asserts nocc_a == nocc_b and interleaves r1a and r1b into the returned array. The orbspin array must be a numpy.ndarray of integer type and must be at least as long as the number of spin-orbitals implied by the input amplitude blocks.
    
    Behavior and practical significance:
        - For the R1 case (rx length 2), the function produces a 1D spin-orbital R1 array by interleaving or placing alpha (r1a) and beta (r1b) occupied amplitudes into a single vector ordered by spin-orbital index. This representation is required for matrix-vector products and eigenvalue problems formulated in the full spin-orbital basis in EOM-IP calculations.
        - For the R2 case (rx length 4), the function assembles a full (nocc, nocc, nvir) spin-orbital R2 array from the four spatial spin blocks. It reshapes the spatial blocks, fills the appropriate rows/columns using orbspin to map spatial alpha/beta indices to spin-orbital indices, and enforces the sign conventions used in the UCCSD EOM-IP implementation (certain off-diagonal blocks are negated as in r2aba = -r2baa and r2bab = -r2abb). The returned 3D array is suitable for subsequent spin-orbital algebra in PySCF EOM-UCCSD routines.
        - No global state is modified; the function allocates and returns new numpy arrays for the spin-orbital amplitudes.
    
    Defaults:
        - orbspin defaults to None. In the R1 branch this requires equal numbers of occupied alpha and beta spatial orbitals (nocc_a == nocc_b) and results in simple interleaving with pattern [alpha0, beta0, alpha1, beta1, ...]. In the R2 branch orbspin is generated as an alternating pattern of length 2*(nocc_a+nvir_a) when not provided, which corresponds to the common ordering where spin-orbitals are arranged as (alpha0, beta0, alpha1, beta1, ...).
    
    Failure modes and exceptions:
        - AssertionError is raised when orbspin is None in the R1 branch and nocc_a != nocc_b (the function asserts equal occupied counts before interleaving).
        - If rx does not have length 2 or 4, the function will fail when attempting to unpack or reshape the inputs (typically raising ValueError or IndexError during unpacking or numpy reshape operations).
        - If orbspin has insufficient length or contains values other than 0 or 1, indexing operations such as orbspin[:nocc] == 0 may produce incorrect results or IndexError; the caller must ensure orbspin is a 1D numpy.ndarray of integers with appropriate length.
        - Shape mismatches between the declared spatial blocks in rx and the inferred nocc/nvir will cause numpy reshape or take operations to raise errors.
    
    Returns:
        numpy.ndarray: If rx length is 2, returns a 1D numpy.ndarray of length nocc (nocc_a + nocc_b) containing the spin-orbital R1 amplitudes arranged by spin-orbital index. If rx length is 4, returns a 3D numpy.ndarray with shape (nocc, nocc, nvir) containing the assembled spin-orbital R2 amplitudes suitable for subsequent EOM-IP/UCCSD operations. The returned arrays are newly allocated; the function does not modify the input arrays in-place.
    """
    from pyscf.cc.eom_uccsd import spatial2spin_ip
    return spatial2spin_ip(rx, orbspin)


################################################################################
# Source: pyscf.cc.eom_uccsd.amplitudes_to_vector_ip
# File: pyscf/cc/eom_uccsd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_cc_eom_uccsd_amplitudes_to_vector_ip(r1: tuple, r2: tuple):
    """Convert unrestricted spin-orbital EOM-UCCSD ionization amplitudes into a single packed 1-D vector suitable for iterative solvers (for example Davidson) used in PySCF's equation-of-motion ionization-potential (IP) UCCSD routines. This function is used to take the separate alpha/beta singles and the four spin-block double-amplitude tensors produced in IP-EOM-UCCSD calculations and produce a contiguous 1-D representation expected by linear-algebra and diagonalization routines in the pyscf.cc.eom_uccsd module.
    
    Args:
        r1 (tuple): A length-2 tuple (r1a, r1b) containing the spin-orbital single-ionization amplitude arrays for alpha and beta spin channels, respectively. Each element is expected to be a one-dimensional array-like object (e.g., numpy.ndarray) of length equal to the number of occupied orbitals for that spin (nocc_alpha for r1a, nocc_beta for r1b). These singles represent the 1h (one-hole) part of the IP excitation operator and are placed first in the packed vector in the order r1a then r1b.
        r2 (tuple): A length-4 tuple (r2aaa, r2baa, r2abb, r2bbb) containing the spin-blocked two-electron ionization amplitude tensors used in IP-EOM-UCCSD. Each element is a 3-dimensional array-like object where the first two indices enumerate occupied orbitals (for the first two spin labels) and the third index enumerates virtual orbitals (for the remaining spin label). The four blocks follow the spin patterns: r2aaa (alpha-alpha-alpha), r2baa (beta-alpha-alpha), r2abb (alpha-beta-beta), and r2bbb (beta-beta-beta). The function expects r2abb to have a shape that can be unpacked as (nocca, noccb, nvirb) because its first two dimensions define nocca and noccb used to generate triangular index masks for r2aaa and r2bbb. In practice these tensors are the 2h-1p amplitude blocks (two holes, one particle) for different spin combinations and are flattened and concatenated after the singles to form the final vector.
    
    Returns:
        numpy.ndarray: A one-dimensional numpy array that concatenates the input amplitudes in the following precise order: r1a, r1b, lower-triangular entries of r2aaa (first two occupied indices), all entries of r2baa, all entries of r2abb, and lower-triangular entries of r2bbb (first two occupied indices). The lower-triangular selection for r2aaa and r2bbb uses numpy.tril_indices with k = -1 (excluding diagonal) to avoid double counting antisymmetric occupied-index pairs; r2baa and r2abb are included in full. This packed ordering and selection is required by downstream IP-EOM-UCCSD routines and solvers in PySCF.
    
    Behavior and failure modes:
        The function performs no in-place modification of its inputs and returns a new contiguous 1-D numpy array. It relies on numpy indexing and ravel/flatten semantics: each input element must therefore be array-like and support numpy-style indexing and ravel(). The function will raise standard numpy exceptions (IndexError, ValueError, or TypeError) if:
        - r2 does not contain four elements or r1 does not contain two elements,
        - r2abb is not a 3-dimensional array whose shape can be unpacked to (nocca, noccb, nvirb),
        - r2aaa and r2bbb do not have first two dimensions matching nocca and noccb respectively (mismatched occupied-index sizes),
        - any input arrays are not convertible to numpy arrays or do not support the used indexing operations.
        If nocca or noccb are small such that the lower-triangular selection with k = -1 yields zero elements, the corresponding triangular slices contribute an empty segment to the returned vector (this is the intended behavior to preserve the packing convention).
    """
    from pyscf.cc.eom_uccsd import amplitudes_to_vector_ip
    return amplitudes_to_vector_ip(r1, r2)


################################################################################
# Source: pyscf.cc.momgfccsd.build_block_tridiagonal
# File: pyscf/cc/momgfccsd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_cc_momgfccsd_build_block_tridiagonal(a: list, b: list, c: list = None):
    """Construct a block tridiagonal matrix from supplied on-diagonal and off-diagonal block lists.
    
    This function assembles a full 2D block matrix H whose only non-zero blocks are the diagonal blocks a[i], the subdiagonal blocks b[i] placed at block position (i+1, i), and the superdiagonal blocks c[i] placed at block position (i, i+1). If c is not provided, it is created as the conjugate transpose of b (c[i] = b[i].T.conj()), which is the common choice when assembling a Hermitian block tridiagonal matrix as used in moment-constrained Green's function coupled-cluster (MOMGF-CCSD) routines and block-Lanczos style algorithms in PySCF. The assembled matrix is returned as a NumPy ndarray created via numpy.block. The function does not modify its inputs.
    
    Args:
        a (list): List of 2-D array-like objects (typically numpy.ndarray) containing the diagonal blocks a[0], a[1], ..., a[N-1]. Each element a[i] represents the block on the main diagonal for block row/column i; its shape determines the row and column size of that block row/column in the final assembled matrix. In practical use within pyscf.cc.momgfccsd, these blocks are often square matrices representing block pieces of an effective Hamiltonian or response matrix arising in CCSD/MOMGF calculations. The list must be non-empty; the first element a[0] is used to infer a placeholder block shape for off-diagonal zero blocks.
        b (list): List of 2-D array-like objects for the subdiagonal (below-diagonal) blocks b[0], b[1], ..., b[N-2]. The element b[j] is placed at block position (j+1, j) in the assembled matrix. For correct assembly, b[j] must have a shape compatible with the adjacent diagonal blocks: its number of rows must match the number of rows of a[j+1] and its number of columns must match the number of columns of a[j]. In the MOMGF-CCSD context, these blocks represent coupling between adjacent block subspaces.
        c (list, optional): List of 2-D array-like objects for the superdiagonal (above-diagonal) blocks c[0], c[1], ..., c[N-2]. The element c[i] is placed at block position (i, i+1). If c is None (the default), it will be created internally as the conjugate transpose of b via [x.T.conj() for x in b], which yields the common Hermitian partner to b in many quantum-chemistry applications. If provided, each c[i] must have a shape compatible with the adjacent diagonal blocks: its number of rows must match the number of rows of a[i] and its number of columns must match the number of columns of a[i+1].
    
    Returns:
        numpy.ndarray: The assembled full block matrix H constructed with numpy.block. The block structure follows the input lists such that H contains a[i] on its diagonal, b[j] on the subdiagonal positions (j+1, j), c[i] on the superdiagonal positions (i, i+1), and zeros elsewhere. The dtype of zero-fill blocks is taken from a[0].dtype. The returned array is a newly allocated object; no in-place modification of the inputs occurs.
    
    Raises:
        IndexError: If the input list a is empty (a[0] is accessed) or if indexing assumptions fail due to incorrect list lengths.
        ValueError: If block shapes are incompatible for numpy.block assembly (for example, mismatched dimensions between adjacent blocks or incorrect lengths of b/c relative to a).
        TypeError: If elements of a, b, or c are not array-like objects accepted by numpy.block or numpy.zeros_like.
    
    Notes:
        - The function is commonly used in PySCF's coupled-cluster MOMGF implementations and other block-Lanczos or block-tridiagonalization procedures where an explicit block matrix representation is required.
        - To produce a Hermitian block tridiagonal matrix, provide b and leave c as None so that c is set to the conjugate transpose of b.
    """
    from pyscf.cc.momgfccsd import build_block_tridiagonal
    return build_block_tridiagonal(a, b, c)


################################################################################
# Source: pyscf.cc.gccsd.amplitudes_from_rccsd
# File: pyscf/cc/gccsd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_cc_gccsd_amplitudes_from_rccsd(
    t1: numpy.ndarray,
    t2: numpy.ndarray,
    orbspin: int = None
):
    """pyscf.cc.gccsd.amplitudes_from_rccsd converts restricted (spatial-orbital) coupled-cluster singles and doubles (RCCSD) amplitudes into spin-orbital amplitudes suitable for generalized/ spin-orbital CCSD routines in PySCF (for example, to provide input amplitudes to pyscf.cc.gccsd routines). This function is a thin wrapper that calls spatial2spin on each amplitude array and returns the corresponding spin-orbital T1 and T2 arrays used by downstream spin-orbital correlated-wavefunction code.
    
    Args:
        t1 (numpy.ndarray): Spatial-orbital single-excitation amplitude array (RCCSD T1). In the context of PySCF and coupled-cluster theory, this array encodes the amplitudes for single excitations between spatial occupied and virtual orbitals produced by an RCCSD calculation. This function treats t1 as read-only and does not modify it in place; it is converted into a spin-orbital representation by calling spatial2spin(t1, orbspin).
        t2 (numpy.ndarray): Spatial-orbital double-excitation amplitude array (RCCSD T2). This array encodes the amplitudes for double excitations in the spatial-orbital RCCSD formalism. As with t1, t2 is treated as read-only by this routine and is converted to the spin-orbital representation by calling spatial2spin(t2, orbspin).
        orbspin (int): Optional integer parameter passed through to spatial2spin that controls how spatial orbitals are mapped to spin-orbital indices (spin ordering / interleaving convention). The annotation is int and the default value is None in the function signature; when orbspin is None the function relies on spatial2spin's default mapping behavior. The exact meaning and allowed integer values for orbspin (if any) are determined by spatial2spin; supplying an incompatible value will cause spatial2spin to raise an error.
    
    Returns:
        tuple: A pair of numpy.ndarray objects (t1_spin, t2_spin). t1_spin is the spin-orbital representation of the input spatial t1 amplitude, and t2_spin is the spin-orbital representation of the input spatial t2 amplitude. These returned arrays are newly created by the conversion and are intended for use by spin-orbital CCSD/GCCSD code paths within PySCF.
    
    Behavior and failure modes:
        This function performs a pure conversion and has no side effects on the input arrays. It delegates the detailed mapping rules and any validation to spatial2spin; therefore, errors raised by spatial2spin (for example, due to incorrect input array dimensionality or incompatible orbspin values) will propagate to the caller. Callers should pass numpy.ndarray objects for t1 and t2 consistent with spatial-orbital RCCSD output from PySCF; otherwise a TypeError or ValueError may be raised by spatial2spin or NumPy operations.
    """
    from pyscf.cc.gccsd import amplitudes_from_rccsd
    return amplitudes_from_rccsd(t1, t2, orbspin)


################################################################################
# Source: pyscf.cc.momgfccsd.mat_isqrt
# File: pyscf/cc/momgfccsd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_cc_momgfccsd_mat_isqrt(m: numpy.ndarray, tol: float = 1e-16, hermi: bool = False):
    """pyscf.cc.momgfccsd.mat_isqrt returns the inverse square root of a square matrix using an eigendecomposition. This routine is used in the PySCF correlated-electron (coupled-cluster) code paths (pyscf.cc.*), for example to form inverse-square-root metric or overlap operators that arise in MOMGF/CCSD transformations and orthonormalizations. The implementation chooses an algorithm depending on whether the input is known or assumed Hermitian: for Hermitian matrices it uses a real symmetric eigendecomposition (np.linalg.eigh) and forms v diag(w**-1/2) v^H; for general (possibly non-Hermitian) matrices it uses a full eigendecomposition (np.linalg.eig) and forms v diag(w**-1/2) v^{-1}.
    
    Args:
        m (numpy.ndarray): Square input matrix whose inverse square root is requested. In the context of PySCF this is typically a metric, overlap, or other operator matrix produced by coupled-cluster or related modules. The function expects a 2-D square numpy.ndarray; the output will have the same shape. If hermi is True the routine assumes m is Hermitian (or symmetric real) and uses a numerically stable Hermitian eigendecomposition; if hermi is False m may be non-Hermitian and a general eigendecomposition is used.
        tol (float = 1e-16): Numerical eigenvalue cutoff threshold. Eigenvalues with magnitude below this threshold are treated as numerically zero and are removed from the reconstruction of the inverse square root to avoid division by (near-)zero. The default 1e-16 is a very small tolerance appropriate for well-conditioned matrices in double precision; callers should increase tol for matrices known to contain very small or noisy eigenvalues. Behavior: when hermi is True the function keeps eigenvalues w that satisfy w > tol; when hermi is False it keeps eigenvalues satisfying abs(w) >= tol. If no eigenvalues survive the function returns a matrix of the same shape filled with zeros (i.e., the projection is empty). Choosing tol too large will discard meaningful eigencomponents and produce a rank-deficient result; choosing tol too small may lead to very large numerical values or overflow when forming w**(-0.5).
        hermi (bool = False): Flag indicating whether the input matrix m should be treated as Hermitian/symmetric. If True the code uses np.linalg.eigh which returns real eigenvalues and orthonormal eigenvectors and is numerically stable for Hermitian matrices; the inverse square root is formed as v * w**(-1/2) @ v.T.conj(). If False the code uses np.linalg.eig (general eigendecomposition) and forms v * w**(-1/2) @ inv(v). For non-Hermitian matrices the eigenvector matrix v must be invertible; the call to np.linalg.inv(v) may raise numpy.linalg.LinAlgError if v is singular.
    
    Returns:
        numpy.ndarray: A numpy.ndarray of the same shape as m containing the computed inverse square root matrix. For Hermitian input this corresponds to v diag(w**-1/2) v^H with only eigenpairs having eigenvalues > tol included. For non-Hermitian input this corresponds to v diag(w**-1/2) v^{-1} with only eigenpairs having abs(eigenvalue) >= tol included. If no eigenvalues meet the cutoff, an all-zero matrix of shape m.shape is returned. Exceptions and failure modes: np.linalg.eigh / np.linalg.eig may raise numpy.linalg.LinAlgError for ill-conditioned inputs; in the non-Hermitian branch np.linalg.inv(v) can raise numpy.linalg.LinAlgError if the eigenvector matrix is singular. No other side effects occur.
    """
    from pyscf.cc.momgfccsd import mat_isqrt
    return mat_isqrt(m, tol, hermi)


################################################################################
# Source: pyscf.cc.momgfccsd.mat_sqrt
# File: pyscf/cc/momgfccsd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_cc_momgfccsd_mat_sqrt(m: numpy.ndarray, hermi: bool = False):
    """Compute the matrix square root used by pyscf.cc.momgfccsd routines in PySCF's electronic-structure calculations, returning a matrix X such that X @ X approximates the input matrix m within numerical limits and algorithmic caveats described below. This function is typically used in coupled-cluster / moment-Green's-function (momgfccsd) workflows in PySCF where square roots of Hermitian or general matrices (e.g., metric, density-like, or similarity-transformed matrices) are required for further linear-algebra manipulations.
    
    Args:
        m (numpy.ndarray): A square 2-D numpy.ndarray representing the matrix to take the square root of. In the context of PySCF/CCSD moment-GF code, m is expected to be a finite, numeric matrix (real or complex) whose eigen-decomposition is used to form a square root. The function requires m to be square because it calls numpy.linalg.eigh (for Hermitian inputs) or numpy.linalg.eig (for general inputs). Supplying a non-square array will cause NumPy linear-algebra routines to raise an exception.
        hermi (bool): If True, treat m as Hermitian (conjugate-symmetric) and compute the square root via a Hermitian eigen-decomposition (numpy.linalg.eigh). In this Hermitian branch the implementation selects eigenvalues w >= 0 (exact non-negativity test) and discards negative eigenvalues by masking them out; the returned matrix is reconstructed from the remaining eigenpairs as v * sqrt(w) * v^H. This is appropriate when m should be positive semidefinite in physical applications (for example, metrics or overlap-like matrices) but note that small negative eigenvalues from numerical noise are also removed. If hermi is False (default), treat m as a general (possibly non-Hermitian) matrix and compute a square root via the eigen-decomposition numpy.linalg.eig and matrix inversion: out = v * sqrt(w) * inv(v). The default False is suitable when m may be non-Hermitian (complex asymmetric) as occasionally encountered in similarity-transformed coupled-cluster intermediates.
    
    Returns:
        numpy.ndarray: A numpy.ndarray representing the computed matrix square root. For hermi=True the returned array is constructed from the non-negative eigenvalues and their eigenvectors and therefore may have reduced rank if any eigenvalues were negative; in that case out @ out reproduces the projection of m onto the subspace spanned by retained eigenvectors rather than the original m. For hermi=False the function returns the matrix built from the eigen-decomposition and matrix inverse; this yields a principal-like square root when m is diagonalizable, but for defective (non-diagonalizable) matrices or when eigenvector matrix v is nearly singular the result may be inaccurate or numpy.linalg.inv(v) may raise a numpy.linalg.LinAlgError.
    
    Behavior and failure modes:
        The function performs no in-place modification of the input m and always returns a new array. Numerical issues can arise: when hermi=True small negative eigenvalues produced by finite-precision arithmetic are removed (mask w >= 0), which can silently reduce rank and discard components; when hermi=False the eigenvector matrix v must be invertible to form inv(v), and inv(v) will raise numpy.linalg.LinAlgError if v is singular or ill-conditioned. Both branches rely on NumPy eigen solvers and may raise numpy.linalg.LinAlgError or other NumPy exceptions if eigen-decomposition fails to converge or if inputs contain NaNs/Infs. The square root returned satisfies out @ out ≈ m only under the method's assumptions (Hermitian positive-semidefinite or diagonalizable general matrix) and within floating-point tolerance. Use hermi=True when m is known or intended to be Hermitian and positive-semidefinite in the physical problem to avoid unpredictable branch cuts of complex square roots.
    """
    from pyscf.cc.momgfccsd import mat_sqrt
    return mat_sqrt(m, hermi)


################################################################################
# Source: pyscf.ci.cisd.t1strs
# File: pyscf/ci/cisd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_ci_cisd_t1strs(norb: int, nelec: int):
    """pyscf.ci.cisd.t1strs: Compute the FCI string addresses and fermionic sign factors needed for CIS single-excitation amplitudes and for converting CI coefficients between the physics vacuum and the Hartree–Fock (HF) vacuum.
    
    Args:
        norb (int): Number of orbitals used to construct the full configuration-interaction (FCI) string space. In the context of PySCF CI/CIS routines, norb defines the size of the single-particle basis from which occupation bit-strings (determinants) are formed; it therefore controls the combinatorial size of the FCI string list that this routine enumerates. The argument must be an integer; non-integer types will propagate a TypeError from internal routines.
        nelec (int): Number of electrons in the reference determinant used to define occupied and virtual orbitals. In CIS and related CI modules, nelec determines which determinants are considered as single excitations relative to the HF reference. This argument must be an integer; invalid or inconsistent electron counts (for example, values that cannot be accommodated by the underlying tn_addrs_signs implementation) will result in an exception being raised.
    
    Returns:
        tuple: A pair (addrs, signs) produced by the internal helper tn_addrs_signs(norb, nelec, 1). addrs encodes the addresses (indices) of the FCI strings corresponding to single excitations from the chosen reference; signs encodes the associated fermionic sign factors that must be applied when transferring CI coefficients between the physics vacuum representation and the HF vacuum representation (these signs account for parity changes due to moving creation/annihilation operators). The exact container types and layout are returned as provided by tn_addrs_signs; callers should treat addrs and signs as indexable collections aligned elementwise so that addrs[i] and signs[i] together describe the i-th single excitation. No external state is modified by this function.
    
    Behavior and failure modes:
        This routine is a thin wrapper that calls tn_addrs_signs(norb, nelec, 1) and returns its outputs. It performs no additional validation beyond that performed by the internal routine. Because the number of FCI strings grows combinatorially with norb and nelec, invoking this function with large norb/nelec can consume large amounts of memory and CPU time; callers should be prepared for MemoryError or long runtimes in such cases. Any errors raised by tn_addrs_signs (for example, ValueError for inconsistent inputs or TypeError for wrong types) will propagate to the caller.
    """
    from pyscf.ci.cisd import t1strs
    return t1strs(norb, nelec)


################################################################################
# Source: pyscf.ci.cisd.tn_addrs_signs
# File: pyscf/ci/cisd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_ci_cisd_tn_addrs_signs(norb: int, nelec: int, n_excite: int):
    """Compute addresses and sign factors for CIS n-excitation amplitudes relative to a Hartree–Fock (HF) reference.
    
    This function is used in the PySCF correlated-electron code path that constructs Configuration Interaction Singles/Doubles (CIS/CISD) style excitation amplitudes expressed as Full CI (FCI) string addresses. For a given number of orbitals (norb), electrons (nelec) and an excitation level (n_excite), it enumerates all determinants reachable by exciting n_excite electrons from the occupied (hole) orbital subspace to the virtual (particle) subspace of the HF reference, returns the integer FCI addresses for those determinants, and computes the sign (+1 or -1) required to convert coefficients defined with the "physics" vacuum ordering into the HF vacuum ordering used by downstream PySCF routines. The implementation uses cistring.gen_strings4orblist to generate hole and particle bit-strings and cistring.strs2addr to convert combined bit-strings into FCI addresses.
    
    Args:
        norb (int): Total number of spatial orbitals in the electronic basis. In the domain of quantum chemistry and PySCF, norb determines the size of the single-particle basis and partitions into occupied (0..nocc-1) and virtual (nocc..norb-1) orbitals for a given HF reference. Expect norb to be a non-negative integer; values outside the normal domain (e.g., negative or non-integer) will cause lower-level helpers to raise errors.
        nelec (int): Total number of electrons (occupied orbitals) in the HF reference, denoted nocc in the code. nelec defines the occupied subspace size and therefore the number of possible holes when forming excitations. In practice, 0 <= nelec <= norb is expected; passing nelec outside this range may produce incorrect results or errors from cistring utilities.
        n_excite (int): Excitation level (number of electrons to promote from occupied to virtual orbitals) for CIS amplitudes. This function enumerates determinants with exactly n_excite particle-hole replacements. Valid values are integers with 0 <= n_excite <= min(nelec, norb - nelec). If n_excite exceeds the available number of electrons or holes, the function returns two empty lists (see Returns). Negative or non-integer n_excite may lead to errors from the underlying cistring routines.
    
    Returns:
        tuple: A pair (addrs, signs) describing the enumerated FCI determinants and their associated sign factors, with the following practical meanings used by PySCF CI/CIS routines.
        addrs (numpy.ndarray of int): One-dimensional integer array of FCI addresses (indices into the Full CI determinant list) for all determinants reachable by promoting n_excite electrons from occupied to virtual orbitals relative to the HF reference. The ordering reflects iteration over hole strings (occupied-space selections) and particle strings (virtual-space selections) as produced by the cistring utilities: hole strings are generated for the occupied orbital indices and reversed to account for the HF vacuum ordering, particle strings are generated for the virtual orbital indices, and the combined bit-strings (hole XOR particle) are converted to addresses via cistring.strs2addr. The array length equals the number of hole combinations times the number of particle combinations, i.e., binomial(nelec, n_excite) * binomial(norb - nelec, n_excite), when n_excite is within the valid range.
        signs (numpy.ndarray of int): One-dimensional integer array of the same length as addrs. Each element is either +1 or -1 and encodes the fermionic sign arising from reordering creation/annihilation operators when translating coefficient phases from the "physics" vacuum ordering to the HF vacuum ordering used by PySCF. The sign is computed as (-1)**(n_excite * nocc - n_excite*(n_excite+1)//2 - hole_sum) where hole_sum is the per-hole contribution accumulated from the bit-string positions of occupied orbitals chosen as holes; this formula matches the ordering convention and is critical for correct antisymmetry of CI amplitudes in subsequent tensor contractions.
    
    Behavior, side effects, and failure modes:
        - If n_excite > min(nelec, norb - nelec), there are not enough electrons or holes to form the requested excitations; the function returns two empty Python lists ([], []) as a clear signal that no valid excitations exist for the provided inputs.
        - No mutable global state or I/O side effects are performed; the function is pure with respect to program state and only returns computed arrays (or empty lists for the incompatible-excitation case).
        - The computational cost and memory footprint grow combinatorially with norb and n_excite (specifically with the product of binomial coefficients described above); callers should avoid very large values to prevent excessive runtime or memory use.
        - The function relies on cistring utilities and numpy; invalid types (non-integers) or out-of-range values for norb/nelec/n_excite will typically result in exceptions raised by those lower-level libraries rather than by explicit checks here.
        - The returned addrs and signs must be interpreted according to PySCF's FCI address and HF-vacuum ordering conventions; misuse (for example, combining these outputs with a different vacuum convention) will produce incorrect CI amplitudes.
    
    Practical significance:
        - This routine is intended for use in constructing CIS or low-rank CI amplitude tensors inside PySCF modules that convert between occupation-string representations and compact address-based arrays used in tensor contractions and diagonalizations.
        - The sign array ensures that amplitude phases are consistent with PySCF's HF vacuum operator ordering, which is essential for correct antisymmetric wavefunction assembly and energy/gradient computations downstream.
    """
    from pyscf.ci.cisd import tn_addrs_signs
    return tn_addrs_signs(norb, nelec, n_excite)


################################################################################
# Source: pyscf.ci.cisd.from_fcivec
# File: pyscf/ci/cisd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_ci_cisd_from_fcivec(ci0: numpy.ndarray, norb: int, nelec: int, frozen: int = None):
    """Extract CISD amplitudes from a full configuration interaction (FCI) vector.
    
    This function converts a PySCF FCI representation (ci0) into the compact set of
    CISD amplitudes used by PySCF CISD routines. It reads the reference (scalar)
    coefficient, the single-excitation block, and the double-excitation block from
    the FCI matrix form and assembles them into the CISD vector ordering produced
    by amplitudes_to_cisdvec. This conversion is used in workflows where one wants
    to initialize or compare CISD calculations from a full-CI result in the PySCF
    quantum chemistry framework (see PySCF README and CI modules).
    
    Args:
        ci0 (numpy.ndarray): FCI coefficient array in PySCF's matrix form. The
            function expects ci0 to be indexable as ci0[0,0] for the reference
            (reference alpha and beta occupations) and to contain the single- and
            double-excitation blocks at indices addressed by the internal single-
            excitation index arrays (t1addr and t1sign). Typical PySCF FCI storage
            is a 2-D array whose first row/column hold the reference and excitations
            relative to that reference. Passing an array with incompatible shape or
            indexing will raise IndexError.
        norb (int): Total number of spatial orbitals in the system. This integer is
            used to determine the number of virtual orbitals after the occupied
            count is derived from nelec. If norb is smaller than the number of
            occupied orbitals implied by nelec, a ValueError (or negative nvir)
            results because the number of virtual orbitals would be invalid.
        nelec (int or tuple): Number of electrons. If an int is provided, the code
            splits it into alpha and beta counts assuming near-closed-shell packing
            (nelecb = nelec//2, neleca = nelec - nelecb) and then uses neleca as the
            number of occupied spatial orbitals (nocc). The function also accepts a
            pair-like input (neleca, nelecb) to specify alpha and beta electrons
            explicitly; in that case the first element is taken as the number of
            alpha electrons and used to define nocc. The alpha-electron count
            determines nocc and thus the number of virtual orbitals nvir = norb -
            nocc used to reshape extracted single and double amplitudes.
        frozen (int or None): Number of frozen core orbitals or a flag for frozen
            orbitals. Currently only None or 0 (no frozen orbitals) is supported.
            If frozen is not None and not equal to 0 the function raises
            NotImplementedError because frozen-orbital handling is not implemented
            in this conversion routine.
    
    Returns:
        numpy.ndarray: CISD amplitude vector assembled from FCI coefficients using
        amplitudes_to_cisdvec. The returned array encodes the CISD ansatz in the
        same ordering used by PySCF CISD routines: the scalar reference amplitude
        c0 (extracted from ci0[0,0]), the single-excitation amplitudes c1 with
        shape (nocc, nvir) (extracted and reshaped from the FCI single-excitation
        block), and the double-excitation amplitudes c2 with shape
        (nocc, nocc, nvir, nvir) (constructed from the appropriate FCI submatrix).
        The function performs no in-place modification of ci0; it returns a new
        NumPy array suitable for passing into PySCF CISD functions.
    
    Raises:
        NotImplementedError: If frozen is not None and not equal to 0 because frozen
            orbital support is not implemented.
        IndexError: If ci0 does not have the expected indexing layout (for example
            missing rows/columns for reference or excitation blocks).
        ValueError: If norb and nelec imply an invalid number of virtual orbitals
            (nvir < 0) or otherwise inconsistent orbital/electron counts.
    
    Behavior notes:
        The function infers the number of occupied orbitals (nocc) from the alpha
        electron count and sets nvir = norb - nocc. It constructs c1 and c2 by
        applying precomputed single-excitation indexing and sign arrays (t1addr,
        t1sign) to select and sign the FCI matrix entries, reshaping them to the
        CISD single and double amplitude tensor shapes, and then delegates to
        amplitudes_to_cisdvec to produce the final packed CISD vector. There are no
        side effects on the input ci0 array.
    """
    from pyscf.ci.cisd import from_fcivec
    return from_fcivec(ci0, norb, nelec, frozen)


################################################################################
# Source: pyscf.ci.cisd.overlap
# File: pyscf/ci/cisd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_ci_cisd_overlap(
    cibra: numpy.ndarray,
    ciket: numpy.ndarray,
    nmo: int,
    nocc: int,
    s: numpy.ndarray = None
):
    """pyscf.ci.cisd.overlap computes the scalar overlap ⟨Ψ_bra | Ψ_ket⟩ between two CISD (Configuration Interaction with Single and Double excitations) wavefunctions represented as CISD vectors. In the PySCF quantum-chemistry framework this routine is used to evaluate the inner product of two CISD wavefunctions either in an orthonormal one-particle basis (fast path) or in a non-orthogonal one-particle basis by explicitly building many-body transformation matrices from determinants of orbital-overlap minors. The returned overlap is a single floating-point number used, for example, in state-overlap assessments, non-orthogonal CI analyses, and post-processing of CISD calculations.
    
    Args:
        cibra (numpy.ndarray): CISD state vector for the bra wavefunction. This is the packed CISD coefficient vector expected by PySCF CISD utilities. The function converts this vector into reference (0), single (1), and double (2) excitation amplitude blocks via cisdvec_to_amplitudes(cibra, nmo, nocc, copy=False). The practical role of cibra is to provide the bra-side amplitudes whose contractions with transformed ket amplitudes produce the many-body overlap. The routine does not modify the caller's cibra array contents.
        ciket (numpy.ndarray): CISD state vector for the ket wavefunction in the same packed format as cibra. ciket is unpacked into reference, single, and double excitation amplitude blocks with cisdvec_to_amplitudes(ciket, nmo, nocc, copy=False). These ket amplitudes are combined with determinants of one-particle overlap minors to form the overlap contributions in the non-orthogonal basis. The function does not modify the caller's ciket array contents.
        nmo (int): Number of molecular orbitals (spin-orbitals per spin block as used by this CISD implementation) in the one-particle basis used to define the CISD vectors. nmo is used to infer the number of virtual orbitals nvir = nmo - nocc and to reshape and index amplitude blocks consistently with PySCF CISD internal ordering. Passing an incorrect nmo will lead to shape mismatches and ValueError from NumPy operations.
        nocc (int): Number of occupied orbitals (per spin block) in the reference determinant used by the CISD vectors. nocc defines the occupied/virtual partition and determines the dimensions of singles and doubles amplitude blocks. An inconsistent or incorrect nocc causes incorrect indexing and will raise errors when computing minors or reshaping amplitude arrays.
        s (numpy.ndarray, optional): Overlap matrix of the non-orthogonal one-particle basis. When provided, s is a 2D NumPy array whose (i,j) entries are the overlaps between one-particle basis functions in the bra and ket orbital sets (shape should be (nmo, nmo) consistent with nmo and nocc). The practical significance of s is that it defines the change-of-basis between the two Slater determinants; the routine computes determinants of submatrices (minors) of s corresponding to occupied/virtual excitation patterns to build the many-body transformation. If s is None (the default), the function assumes an orthonormal one-particle basis and takes a fast path by calling dot(cibra, ciket, nmo, nocc) to return the overlap of the packed CISD vectors. If s is supplied but has block structure very close to identity (determinants of s[:nocc,:nocc] and s[nocc:,nocc:] within 1e-2 of 1.0), the routine may use simplified approximate formulas for some double-excitation contributions to reduce cost. The function treats s as read-only; internally it creates views and temporary copies (for example s_sub = s[idx].T.copy()) when computing minors and determinants. Supplying an s with incompatible shape will raise errors from NumPy routines.
    
    Behavior, approximations, and side effects:
        The implementation unpacks CISD vectors into reference, single, and antisymmetrized double-amplitude tensors and constructs lists of occupied/virtual index patterns to enumerate contributions to the full many-body overlap. For non-orthogonal bases (s provided), it computes determinants of selected minors of s to form elements of a transformation matrix (trans) that maps CISD amplitude sectors between orbital bases. The final scalar overlap is built from contractions of bra and ket amplitude blocks with these transformation matrices and determinants using efficient NumPy einsum and dot calls.
        The routine includes practical approximations to reduce cost: if the product of norms of antisymmetrized double-amplitude tensors (bra2aa and ket2aa) is below 1e-4, the code skips the explicit expensive double-excitation overlap contributions. If the occupied and virtual block determinants of s are within 1e-2 of unity, the code uses the orthogonal-basis double-overlap approximation (simple dot of double amplitudes scaled by the reference overlap) for the corresponding term.
        For large double-excitation spaces, the code may compute parts of the required transformed ket-vector components in parallel using Python multiprocessing. This involves allocating a shared RawArray buffer and spawning worker Process objects and therefore has side effects visible to the hosting Python interpreter: additional OS-level processes may be created and synchronized, and shared memory buffers are allocated. The number of worker processes is controlled internally via lib.num_threads(). On environments that disallow multiprocessing (for example some restricted compute nodes or when running under certain interactive debuggers), process creation may fail and raise an exception.
        All numerical linear-algebra work uses NumPy routines (einsum, dot, linalg.det) and PySCF utility functions (lib.einsum, lib.take_2d). Numerical tolerances described above are hard-coded in the routine (1e-2 for determinant-to-identity checks; 1e-4 for skipping double overlaps) and affect whether approximate shortcuts are taken.
    
    Failure modes and exceptions:
        The function will raise standard NumPy exceptions when input shapes are inconsistent (for example ValueError on reshaping or indexing) or when determinant/minor extraction is called with invalid indices. Multiprocessing-related failures (OSError, RuntimeError) may occur if the platform disallows spawning subprocesses or if system resources are exhausted. Numerical instability is possible for extremely ill-conditioned overlap matrices s; in such cases determinants may be numerically zero or underflow, which affects the computed overlap but does not raise an explicit exception from NumPy beyond potential floating-point warnings.
    
    Returns:
        float: A scalar floating-point number (typically numpy.float64) equal to the overlap ⟨Ψ_bra | Ψ_ket⟩ of the two CISD wavefunctions. When s is None this is computed by the fast dot(cibra, ciket, nmo, nocc) path (equivalent to the overlap in an orthonormal basis). When s is provided, this scalar is the many-body overlap assembled from reference, single-, and double-excitation contributions transformed by determinants of s submatrices and possible approximations as described above. The function returns the computed overlap value; it does not modify the input CISD vectors cibra or ciket, though it may allocate temporary arrays and (when s is provided and the full transformation is required) spawn child processes and allocate shared memory for intermediate results.
    """
    from pyscf.ci.cisd import overlap
    return overlap(cibra, ciket, nmo, nocc, s)


################################################################################
# Source: pyscf.ci.gcisd.to_ucisdvec
# File: pyscf/ci/gcisd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_ci_gcisd_to_ucisdvec(civec: numpy.ndarray, nmo: int, nocc: int, orbspin: list):
    """Convert a GCISD coefficient vector to a UCISD coefficient vector.
    
    This function is part of the PySCF quantum chemistry library and is used to transform a CI (configuration interaction) wavefunction represented in a generalized CI single-and-double (GCISD) spin-orbital basis into the unrestricted CISD (UCISD) spatial-orbital representation used by the ucisd module. The conversion proceeds by decomposing the input GCISD coefficient vector into reference, single, and double excitation amplitudes (c0, c1, c2) using cisdvec_to_amplitudes, mapping spin-orbital amplitudes to spatial-orbital amplitudes with spin2spatial according to orbspin, and recombining the spatial amplitudes into a UCISD coefficient vector via ucisd.amplitudes_to_cisdvec. The routine checks the norm of the resulting UCISD vector to detect spin-flip excitations: if the UCISD norm is extremely small, the function raises RuntimeError; if the norm is significantly reduced (< 0.99) a warning is emitted and spin-flip components are ignored in the returned UCISD vector.
    
    Args:
        civec (numpy.ndarray): GCISD coefficient vector in the spin-orbital representation. This is the input wavefunction vector that cisdvec_to_amplitudes expects and from which the reference amplitude (c0), single (c1) and double (c2) excitation amplitudes are extracted. The function calls cisdvec_to_amplitudes(civec, nmo, nocc, copy=False), so the implementation may return views into this array rather than a deep copy; callers should avoid mutating civec while this function is running.
        nmo (int): Number of molecular orbitals used by cisdvec_to_amplitudes to interpret civec. This integer determines how the input coefficient vector is partitioned into reference, single, and double amplitudes in the context of GCISD for a system described with nmo orbitals.
        nocc (int): Number of occupied orbitals used by cisdvec_to_amplitudes to interpret civec. Together with nmo, nocc determines the excitation space (occupied/virtual partitioning) for decomposing the GCISD vector into amplitudes.
        orbspin (list): Mapping used by spin2spatial to convert spin-orbital amplitude arrays (c1, c2) into spatial-orbital amplitude arrays. This list encodes the spin labeling for the spin-orbital indices and must match the convention expected by spin2spatial; it controls how spin degrees of freedom are collapsed when forming the UCISD spatial-amplitude representation.
    
    Returns:
        numpy.ndarray: The UCISD coefficient vector constructed from the spatial reference, single, and double amplitudes. This vector is suitable for use with the ucisd module and represents the input GCISD wavefunction with spin-flip components removed or ignored as necessary.
    
    Raises:
        RuntimeError: If the norm of the computed UCISD vector is below 1e-2, indicating that the input GCISD vector corresponds predominantly to spin-flip excitations and cannot be meaningfully represented as a UCISD wavefunction. The function aborts and does not return a UCISD vector in this case.
        Warning (via warnings.warn): If the norm of the computed UCISD vector is below 0.99 but not below 1e-2, indicating that the input GCISD vector contains non-negligible spin-flip components. The function will proceed, but spin-flip excitations are ignored in the returned UCISD vector; a runtime warning is emitted to inform the caller.
    
    Side effects:
        The function calls cisdvec_to_amplitudes(civec, nmo, nocc, copy=False), spin2spatial, and ucisd.amplitudes_to_cisdvec. Because copy=False is passed to cisdvec_to_amplitudes, the returned amplitude arrays may share memory with the input civec; avoid modifying civec while the conversion is in progress. The function may emit a Python warning when spin-flip components are present and may raise a RuntimeError when the UCISD norm is vanishingly small.
    """
    from pyscf.ci.gcisd import to_ucisdvec
    return to_ucisdvec(civec, nmo, nocc, orbspin)


################################################################################
# Source: pyscf.ci.cisd.to_fcivec
# File: pyscf/ci/cisd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_ci_cisd_to_fcivec(
    cisdvec: numpy.ndarray,
    norb: int,
    nelec: int,
    frozen: list = None
):
    """Convert CISD amplitudes (c0, c1, c2) into an FCI coefficient matrix suitable for FCI-based routines.
    
    This function is used in PySCF's configuration interaction utilities to map a restricted CISD wavefunction (a closed-shell CISD amplitude vector) into an FCI representation on a determinant/string basis. The input cisdvec is interpreted as the packed CISD coefficient vector that encodes the reference coefficient (c0), single excitations (c1) and double excitations (c2) for a closed-shell system. The output is a dense square numpy.ndarray whose rows and columns index alpha- and beta-string occupations (FCI basis). If frozen orbitals are provided, the function expands the active-space CISD amplitudes to the full orbital space, applying the required parity (phase) corrections so the resulting FCI coefficients correspond to the full norb orbital ordering used elsewhere in PySCF.
    
    Args:
        cisdvec (numpy.ndarray): 1-D array containing packed CISD coefficients in the standard PySCF CISD packing (c0, c1, c2). This is the amplitude vector produced by CISD solvers and by cisdvec_to_amplitudes; it is read but not modified by to_fcivec. The practical significance is that these amplitudes describe the closed-shell CISD wavefunction in the active (unfrozen) orbital space and are transformed here into the full FCI coefficient matrix for downstream FCI routines or diagnostics.
        norb (int): Total number of spatial molecular orbitals in the target FCI representation (including frozen orbitals if any). This integer determines the FCI basis size when frozen orbitals are expanded back into the full space. It must match the orbital indexing convention used to build or interpret the final FCI matrix.
        nelec (int): Total number of electrons in the system. When provided as a single integer, the function assumes a closed-shell distribution and splits electrons equally between alpha and beta spins (neleca = ceil/half, nelecb = floor/half as performed in the code). The function also supports specifying spin occupations as a 2-tuple (neleca, nelecb) in which case the code expects equal numbers for closed-shell CISD and will assert if they differ; this behavior is intentional because CISD here targets restricted closed-shell amplitudes. The electron count controls how many occupied orbitals are considered for alpha/beta strings and therefore the dimension of the FCI basis.
        frozen (list): Optional descriptor of frozen orbitals in the input CISD amplitudes. If None (default), no orbitals are frozen and the function returns the FCI matrix for the active space directly. If an integer is provided (or a numpy.integer), it is interpreted as the number of frozen orbitals at the beginning of the orbital list (i.e., orbitals 0..frozen-1 are treated as frozen). If a list-like of orbital indices is provided, those orbital indices are treated as frozen. Frozen orbitals are removed from the CISD active-space amplitudes and then reintroduced when constructing the full-space FCI coefficients; the function also enforces that frozen occupied orbitals are occupied in the final determinants and frozen virtual orbitals are unoccupied. The frozen argument controls expansion logic and parity (phase) corrections applied to map the active-space coefficients into the full norb space.
    
    Returns:
        numpy.ndarray: A two-dimensional square array (fcivec or fcivec1) representing the FCI coefficients in the determinant/string basis used by PySCF. If no frozen orbitals are specified, the returned array has shape (na, na) where na is the number of alpha (or beta) occupation strings for the active-space orbital count (nmo) and active electron count (nocc); the matrix encodes coefficients between alpha- and beta-string pairs: fcivec[alpha_addr, beta_addr]. If frozen orbitals are present, the function returns the FCI matrix expanded to the full orbital space (norb) and full alpha-occupation count (neleca), with parity signs applied so the returned matrix corresponds to the original orbital ordering. The returned array is a new numpy.ndarray; the input cisdvec is not modified.
    
    Raises and failure modes:
        AssertionError: If nelec is provided as a 2-tuple and the two spin occupations differ (the code asserts neleca == nelecb because this routine is intended for restricted/closed-shell CISD amplitudes).
        AssertionError: If frozen is not None and norb >= 63 the function asserts (norb < 63) because the implementation uses integer bit masks for string generation and parity computations that rely on native integer widths.
        ValueError / IndexError (implicit): If cisdvec does not have the expected length/packing for the implied nmo and nocc derived from norb, nelec and frozen, downstream unpacking (cisdvec_to_amplitudes and index computations) will raise errors; callers must ensure cisdvec matches the CISD packing for the active space implied by norb and frozen.
        Notes on behavior and side effects: The function does not modify global state and returns a fresh numpy.ndarray. It internally calls cisdvec_to_amplitudes and tn_addrs_signs and applies sign conventions consistent with PySCF's CISD/FCI indexing. When frozen is provided, the routine constructs occupation bitstrings for the full norb and enforces frozen-occupied and frozen-virtual conditions while computing parity flips required by moving frozen orbitals to the beginning of the orbital list.
    """
    from pyscf.ci.cisd import to_fcivec
    return to_fcivec(cisdvec, norb, nelec, frozen)


################################################################################
# Source: pyscf.data.nucprop.g_factor_to_gyromagnetic_ratio
# File: pyscf/data/nucprop.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_data_nucprop_g_factor_to_gyromagnetic_ratio(g: float):
    """pyscf.data.nucprop.g_factor_to_gyromagnetic_ratio converts a nuclear g-factor to the gyromagnetic ratio expressed as a Larmor precession frequency per unit magnetic field (Hz per Tesla). This utility is used in the PySCF properties and NMR-related code paths to translate a dimensionless nuclear g-factor into a physically meaningful frequency-per-field quantity for spectroscopy and magnetic-response calculations.
    
    Args:
        g (float): Dimensionless nuclear g-factor. In the domain of nuclear magnetic resonance (NMR) and related magnetic properties calculations, the g-factor characterizes the magnetic moment of a nucleus relative to the nuclear magneton. The function expects a Python float representing this dimensionless quantity; passing a non-float value may raise a TypeError at runtime.
    
    Returns:
        float: The gyromagnetic ratio computed as nist.NUC_MAGNETON / nist.PLANCK * g, with SI units of hertz per tesla (Hz/T). Practically, this value is the Larmor precession frequency per unit magnetic field: to obtain the Larmor frequency in Hz for a given static magnetic field B (in tesla), multiply the returned value by B. The returned float is computed from the NIST physical constants referenced in pyscf.data.nist, so it will reflect the values provided by that constants module.
    
    Behavior and notes:
        The function performs a pure calculation with no side effects: it reads constants from pyscf.data.nist and returns the numeric result of the multiplication. It does not modify any global state or external resources. The formula used is identical to the expression in the source: nist.NUC_MAGNETON/nist.PLANCK * g. Because the result is derived from physical constants, it represents the frequency-per-field conversion factor used in PySCF for converting a nuclear g-factor into an experimental observable (Larmor frequency) when combined with an applied magnetic field. If the nist constants module is unavailable or altered, the numeric result will correspondingly fail or reflect those changes. Invalid numeric inputs (for example, non-float types not coercible to float) may raise standard Python exceptions during the multiplication.
    """
    from pyscf.data.nucprop import g_factor_to_gyromagnetic_ratio
    return g_factor_to_gyromagnetic_ratio(g)


################################################################################
# Source: pyscf.ci.gcisd.from_rcisdvec
# File: pyscf/ci/gcisd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_ci_gcisd_from_rcisdvec(civec: numpy.ndarray, nocc: int, orbspin: numpy.ndarray):
    """Convert a (spin-separated) CISD coefficient vector (RCISD or UCISD)
    into a GCISD coefficient vector suitable for PySCF generalized-CISD
    routines.
    
    This function is used within the PySCF quantum-chemistry framework to
    translate CISD coefficient vectors that are expressed in restricted
    (spatial) or unrestricted (separate alpha/beta) formats into a
    generalized (spin-orbital) CISD coefficient vector. The conversion is
    useful when downstream GCISD code in pyscf.ci.gcisd expects a single
    spin-orbital-ordered vector produced by amplitudes_to_cisdvec(c0, c1, c2).
    Internally the function detects whether the input vector corresponds to
    an RCISD (spin-restricted CISD) or a UCISD (spin-unrestricted CISD)
    representation, extracts amplitudes via cisd.cisdvec_to_amplitudes or
    ucisd.cisdvec_to_amplitudes, maps spatial amplitudes to spin-orbital
    amplitudes using the orbspin index map (spatial2spin), and reassembles
    the GCISD-format vector with amplitudes_to_cisdvec.
    
    Args:
        civec (numpy.ndarray): 1-D numpy array containing the CISD coefficient
            vector to be converted. The array is interpreted either as an
            RCISD vector or a UCISD vector depending on its length relative
            to the number of occupied/virtual orbitals derived from orbspin
            and nocc. For detection the function computes the RCISD size
            nocca*nvira + (nocca*nvira)**2 + 1 where nocca is the number of
            occupied alpha spatial orbitals and nvira = nmoa - nocca with
            nmoa = count_nonzero(orbspin == 0). If the length matches that
            formula the input is treated as RCISD, otherwise it is treated
            as UCISD and dispatched to ucisd.cisdvec_to_amplitudes. The
            array must be one-dimensional and contain the scalar reference
            amplitude and excitation amplitudes in the source CISD ordering.
        nocc (int or tuple of two ints): Specification of the occupied
            orbitals used to interpret civec in combination with orbspin.
            If a single integer is provided (typical usage), it is treated
            as the total number of occupied spin-orbitals (i.e., the number
            of electrons); the function then derives the number of occupied
            alpha and beta orbitals by counting values in orbspin[:nocc].
            Alternatively, nocc may be a length-2 sequence (nocca, noccb)
            explicitly giving the number of occupied alpha and occupied
            beta spin-orbitals respectively; this form is passed through
            directly to the UCISD amplitude extractor. The function accepts
            numpy.integer as well as Python int for the scalar form.
        orbspin (numpy.ndarray): 1-D numpy integer array that maps each
            (spatial or spin-indexed) orbital to a spin channel. Elements
            must be 0 or 1 (conventionally 0 for alpha, 1 for beta). The
            function uses orbspin to compute nmoa = count_nonzero(orbspin
            == 0) and nmob = count_nonzero(orbspin == 1), and to expand
            spatial amplitudes into spin-orbital amplitudes via spatial2spin.
            The length and contents of orbspin must be consistent with the
            orbital indexing expected by the input civec and nocc.
    
    Returns:
        numpy.ndarray: A 1-D numpy array containing the converted GCISD
        coefficient vector. This vector is produced by assembling the scalar
        reference amplitude and the single/double excitation amplitudes after
        spatial-to-spin expansion (i.e., the result of amplitudes_to_cisdvec(c0,
        c1, c2) called on amplitudes extracted from the input). The returned
        array is suitable for use with pyscf.ci.gcisd routines that accept
        GCISD-format CISD vectors.
    
    Behavior, side effects, and failure modes:
        The function performs no in-place modification of user arrays other
        than temporary views required by internal routines; it returns a new
        numpy array. It automatically chooses between RCISD and UCISD
        extraction based on the input vector length and the orbital counts
        derived from orbspin and nocc. If nocc is provided as a scalar, the
        function infers nocca and noccb from orbspin[:nocc]; if nocc is a
        two-element sequence it is interpreted as (nocca, noccb) directly.
        Typical exceptions raised when inputs are inconsistent include:
        TypeError if civec or orbspin is not a numpy.ndarray or if nocc is
        not an int/numpy.integer or a two-element sequence; ValueError or
        IndexError if orbspin contains values other than 0/1, if the length
        of orbspin is inconsistent with the orbital counts implied by civec
        and nocc, or if a two-element nocc does not have exactly two
        integer entries. Upstream routines called by this function
        (cisd.cisdvec_to_amplitudes, ucisd.cisdvec_to_amplitudes,
        spatial2spin, amplitudes_to_cisdvec) may raise additional errors for
        malformed amplitude shapes; these propagate to the caller. Use this
        function when you need a GCISD-format coefficient vector for
        subsequent generalized-CISD computations within the PySCF framework.
    """
    from pyscf.ci.gcisd import from_rcisdvec
    return from_rcisdvec(civec, nocc, orbspin)


################################################################################
# Source: pyscf.ci.ucisd.overlap
# File: pyscf/ci/ucisd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_ci_ucisd_overlap(
    cibra: numpy.ndarray,
    ciket: numpy.ndarray,
    nmo: tuple,
    nocc: tuple,
    s: list = None
):
    """pyscf.ci.ucisd.overlap
    Compute the overlap (inner product) between two CISD (Configuration Interaction with Singles and Doubles) wavefunction vectors. This function is part of the PySCF quantum-chemistry package and is used to evaluate overlaps between CISD many-electron states either in an orthonormal one-particle basis (fast path) or in a non-orthogonal one-particle basis (general path that transforms determinants by computing minors of the one-particle overlap matrices). In the PySCF domain this overlap is used when comparing states, building transition properties, or projecting wavefunctions defined in different molecular-orbital bases.
    
    Args:
        cibra (numpy.ndarray): CISD wavefunction vector for the "bra" state. This is the compact CISD vector representation (reference amplitude, single-excitation amplitudes, double-excitation amplitudes) stored as a 1D numpy array in the same layout expected by PySCF's CISD routines. The function converts this vector to separate amplitude blocks (reference, singles, doubles) using cisdvec_to_amplitudes, so cibra must be shaped and ordered consistently with the CISD implementation; otherwise an IndexError or ValueError can occur.
        ciket (numpy.ndarray): CISD wavefunction vector for the "ket" state. Same format and practical role as cibra but representing the ket state. The returned overlap is the scalar inner product <cibra|ciket> computed according to whether a non-orthogonal one-particle overlap matrix is provided (s) or not.
        nmo (tuple or int): Number of molecular orbitals. For spin-restricted spin-orbital-aware usage this is typically a tuple (nmo_alpha, nmo_beta). The implementation also accepts a single integer (or numpy.integer) when alpha and beta orbital counts are equal; in that case the code treats nmo as (nmo, nmo). nmo defines the partitioning of orbital indices into occupied and virtual spaces used when mapping the compact CISD vector into amplitude blocks.
        nocc (tuple): Number of occupied orbitals for each spin (nocca, noccb). This tuple determines the sizes of occupied and virtual spaces: nvir = nmo - nocc per spin. The function uses nocc to split CISD vectors into reference, single, and double excitation amplitudes consistent with the PySCF CISD amplitude layout.
        s (list or None): The list of one-particle overlap matrices for non-orthogonal molecular-orbital bases; expected shape and semantics: s[0] is the 2D overlap array for alpha-spin orbitals, s[1] for beta-spin orbitals. If s is None (default), the function uses the fast orthonormal basis path and returns the direct inner product of the CISD vectors (assumes the underlying one-particle basis for both vectors is orthonormal). If s is provided, each s[spin] must be a 2D numpy array representing the overlap between the bra and ket one-particle orbital bases; the function then computes determinants of relevant minors to form transformation matrices (trans_a and trans_b) and applies them to the CISD excitation blocks to obtain the correct many-electron overlap in the non-orthogonal basis.
    
    Returns:
        float: The scalar overlap value <cibra|ciket> between the two CISD wavefunctions. When s is None, this is computed via a direct inner product of the compact CISD vectors (the orthonormal-basis fast path). When s is provided, this is the full many-electron overlap obtained after: converting compact CISD vectors to amplitude blocks (reference, singles, doubles) via cisdvec_to_amplitudes; constructing lists of occupied/virtual index combinations; computing determinants of one-particle overlap minors to build per-spin transformation matrices; assembling the transformed bra representation and contracting it with the ket amplitudes (including singles and antisymmetrized doubles) to produce the final scalar overlap.
    
    Behavior, side effects, and failure modes:
        - No in-place modification of cibra or ciket is performed by the function (cisdvec_to_amplitudes is called with copy=False where available but the function does not guarantee mutation safety for external references; callers should treat inputs as read-only).
        - If s is None, the function assumes the one-particle bases for bra and ket are orthonormal and returns a direct inner product. This is the fast path used in practice when both CISD vectors are expressed in the same orthonormal MO basis.
        - If s is provided, the function constructs lists of occupied/virtual index combinations and computes determinants of many small submatrices (minors) of s[0] and s[1]. These determinants are used to transform excitation blocks; numerical instability in these determinant computations (e.g., due to near-linear dependence in s[spin]) may raise numpy.linalg.LinAlgError or produce inaccurate overlaps.
        - Input shape mismatches between cibra/ciket and the sizes implied by nmo and nocc will raise IndexError or ValueError during amplitude unpacking or when building index lists; s[0] and s[1] must be two-dimensional arrays with dimensions compatible with the orbital counts derived from nmo, otherwise indexing errors will occur.
        - The function uses numpy.linalg.det and may raise standard numpy exceptions on singular or ill-conditioned minors.
        - The code path for non-orthogonal s performs explicit construction of intermediate arrays whose sizes scale with the number of occupied and virtual orbitals; for large systems memory usage can be significant and performance may degrade.
        - The function relies on PySCF helper routines (for example cisdvec_to_amplitudes and lib.einsum) and therefore must be called in an environment where those symbols are available; missing imports will raise NameError.
    
    Practical significance in PySCF workflows:
        - Use this function to evaluate overlaps between CISD states produced in different molecular-orbital bases (for example, when comparing states from geometry-changed calculations or localized vs canonical orbital representations). Providing s enables correct many-electron overlap computation via determinant minors of the one-particle overlap matrices, which enforces proper antisymmetry and accounts for non-orthogonality at the single-particle level.
        - When both wavefunctions share the same orthonormal MO basis, omit s to use the inexpensive direct inner-product path.
    """
    from pyscf.ci.ucisd import overlap
    return overlap(cibra, ciket, nmo, nocc, s)


################################################################################
# Source: pyscf.dft.libxc.is_gga
# File: pyscf/dft/libxc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_libxc_is_gga(xc_code: str):
    """pyscf.dft.libxc.is_gga: Determine whether a given exchange-correlation functional identifier corresponds to a Generalized Gradient Approximation (GGA) functional.
    
    This function is used in the PySCF density-functional subsystem to classify Libxc/XCFun-style exchange-correlation functionals by their type. In practical DFT workflows within PySCF, knowing that a functional is a GGA signals that the functional depends on the electron density and its gradient (∇ρ) but not higher-order derivatives; this information is used to choose integration grids, to enable gradient-dependent terms in numerical evaluation, and to select appropriate functional evaluation code paths. The implementation delegates the classification to the helper function xc_type(xc_code) and performs an exact string comparison against the category name 'GGA' as returned by xc_type. The comparison is therefore sensitive to the exact output of xc_type and to its case and spelling.
    
    Args:
        xc_code (str): Exchange-correlation functional identifier string as accepted by PySCF/Libxc (for example a Libxc short name or numeric code represented as a string). This argument specifies which functional to classify. It must be a Python str because the function passes it to xc_type(xc_code) for classification. There are no defaults; the caller must supply a valid identifier string.
    
    Returns:
        bool: True if xc_type(xc_code) returns the exact string 'GGA', indicating the functional is a Generalized Gradient Approximation; False otherwise. No other side effects occur.
    
    Behavior and failure modes:
    This function performs a pure, deterministic check with no side effects. It relies entirely on the behavior of xc_type(xc_code); if xc_type raises an exception for an unrecognized or malformed xc_code, that exception will propagate to the caller. The equality test is exact and case-sensitive with respect to the value returned by xc_type.
    """
    from pyscf.dft.libxc import is_gga
    return is_gga(xc_code)


################################################################################
# Source: pyscf.dft.gen_grid.original_becke
# File: pyscf/dft/gen_grid.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_gen_grid_original_becke(g: numpy.ndarray):
    """pyscf.dft.gen_grid.original_becke computes the original Becke smoothing transformation used in atomic partitioning of numerical integration grids for density functional theory. The implementation follows Becke, J. Chem. Phys. 88, 2547 (1988), DOI:10.1063/1.454033, and corresponds to applying the cubic smoothing polynomial g <- 0.5*(3 - g**2)*g three times to the input switching variable array. This routine is the reference Python-level formulation; performance-sensitive code in PySCF uses an optimized C implementation (VXCgen_grid).
    
    Args:
        g (numpy.ndarray): Array of dimensionless switching variables. In the context of PySCF DFT grid generation, each element of g typically represents a normalized interatomic relative measure used to decide how grid points are partitioned among atoms (for example, functions derived from differences and sums of distances to two nuclei). The array shape corresponds to the number of grid points (or grid-point pair comparisons) and is preserved by this function. The input must be a numpy.ndarray with a floating-point numeric dtype so that the elementwise polynomial operations are meaningful.
    
    Returns:
        numpy.ndarray: A new numpy.ndarray with the same shape as the input g containing the smoothed switching-variable values after three successive applications of the cubic Becke smoothing polynomial (g <- 0.5*(3 - g**2)*g applied three times). These returned values are the transformed switching variables that downstream code uses to build atomic partition weights for numerical integration in DFT. The function does not modify external state; it produces and returns the transformed array (i.e., the operation is effectively pure from a functional perspective).
    
    Behavior and side effects:
        This function implements the classical Becke smoothing sequence as shown in the original (commented) reference implementation. The computation is performed elementwise using numpy operations and returns a newly allocated array; the original input object passed as g is not guaranteed to be modified in-place by this implementation. The returned array is intended to be combined with other algebraic steps in the grid-weighting pipeline to produce final atomic weights for integration.
    
    Failure modes and notes for users:
        If g is not a numpy.ndarray or does not support the required floating-point elementwise operations, numpy will raise an appropriate exception (for example, TypeError). NaN and +/-inf values in g will propagate through the polynomial operations and appear in the output; callers should ensure inputs are finite if that is required for their application. The input values are expected to be the switching variables produced by the grid-generation logic; values outside the physically meaningful switching range (as produced by upstream code) will yield mathematically valid outputs but may be physically meaningless as partitioning weights. For production and high-performance use in PySCF, prefer the C-optimized VXCgen_grid implementation referenced in the codebase.
    """
    from pyscf.dft.gen_grid import original_becke
    return original_becke(g)


################################################################################
# Source: pyscf.dft.gen_grid.treutler_prune
# File: pyscf/dft/gen_grid.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_gen_grid_treutler_prune(
    nuc: int,
    rads: numpy.ndarray,
    n_ang: int,
    radii: numpy.ndarray = None
):
    """Treutler-Ahlrichs pruning rule to assign angular-quadrature sizes to radial grid points for a given nucleus.
    
    This function implements the Treutler–Ahlrichs pruning heuristic used in PySCF's grid generation for density-functional calculations (see PySCF README and gen_grid usage). Given the radial grid coordinates along a radial axis for one nucleus, it partitions the radial points into three contiguous groups (first third, middle third, remaining third) and assigns a Lebedev angular-grid size to each radial point: the inner group is assigned 14 angular points (corresponding to Lebedev order l=5), the middle group 50 angular points (l=11), and the outer group is assigned the provided n_ang value (maximum angular resolution). The returned integer array is intended to be consumed by higher-level grid construction routines to determine how many angular quadrature points are used at each radial shell for this nucleus.
    
    Args:
        nuc (int): Nuclear charge of the nucleus for which the pruning is computed. In practice this identifies the atomic center in multi-center grid generation and is part of the gen_grid API; this integer is accepted by the function but is not used in the current implementation of the Treutler–Ahlrichs mapping (it is kept for interface consistency with other pruning schemes).
        rads (1D array): One-dimensional array of radial grid coordinates along the radial axis for the nucleus. The length of rads (nr) determines the number of radial shells; the function returns an integer array of length nr giving the angular grid size for each radial shell. rads must be a sequence or numpy array for which len(rads) is defined; the numerical values of rads are not inspected by this implementation, only their ordering/length matters.
        n_ang (int): Maximum number of angular grid points to assign to the outer radial shells (the third of rads with largest radii). This integer is used verbatim for the last partition of radial points and represents the highest angular resolution requested by the caller.
        radii (numpy.ndarray): Optional array of atomic radii or related per-nucleus radius data accepted for API compatibility with other pruning routines. Default is None. In this function, radii is ignored (no side effects) and provided only to maintain a stable gen_grid function signature; supplying radii will not change the returned result.
    
    Returns:
        numpy.ndarray: Integer array of length equal to len(rads). Each element is the number of angular quadrature points assigned to the corresponding radial grid point by the Treutler–Ahlrichs heuristic (14 for the first third of radial points, 50 for the middle third, and n_ang for the remaining points). The dtype of the returned array is int. There are no side effects: the function allocates and returns a new numpy.ndarray and does not modify its inputs.
    
    Behavior notes and failure modes:
        - Partitioning is done by integer division of nr = len(rads) into thirds using nr//3 and nr//2; for small nr the slices may be empty (e.g., nr < 3) and the assignments will still succeed without raising an exception, producing an array where some or all entries may be set to n_ang or one of the fixed values according to the integer-division boundaries.
        - The function does not validate the numeric contents of rads, nor does it use nuc or radii in the current implementation; callers requiring nucleus- or radius-dependent pruning must perform that logic externally or use a different pruning routine.
        - If rads is not a one-dimensional sequence with a well-defined length, behavior is undefined; a TypeError may occur when attempting to compute len(rads) or create the returned array.
    """
    from pyscf.dft.gen_grid import treutler_prune
    return treutler_prune(nuc, rads, n_ang, radii)


################################################################################
# Source: pyscf.dft.gen_grid.stratmann
# File: pyscf/dft/gen_grid.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_gen_grid_stratmann(g: numpy.ndarray):
    """pyscf.dft.gen_grid.stratmann computes the Stratmann–Scuseria–Frisch switching function (CPL, 257, 213 (1996); DOI:10.1016/0009-2614(96)00600-8) used in PySCF density-functional-theory (DFT) grid construction and atomic partitioning. The implementation follows Eq. 14 of the reference with the internal parameter a = 0.64 and evaluates a degree-7 odd polynomial inside the interval [-a, a], while clamping values to ±1 outside that interval. In the context of pyscf.dft.gen_grid, this function provides the elementwise scalar mapping used to produce smooth, compact switch values that appear in weighted numerical integration over molecular DFT grids.
    
    Args:
        g (numpy.ndarray): Input array of scalar arguments to the Stratmann switching function. In DFT grid generation this typically represents a normalized coordinate or difference used to partition space between atoms for numerical integration. The function treats g as a numeric array (numpy.ndarray) and computes the switching value elementwise. The input array's shape is preserved in the output. The implementation calls numpy.asarray(g) internally, so invalid types that cannot be converted to a numpy.ndarray will raise the same exceptions numpy.asarray raises.
    
    Returns:
        numpy.ndarray: Array of the same shape as g containing the switching-function values in the range [-1, 1]. For elements of g less than or equal to -a (a = 0.64) the corresponding return value is exactly -1. For elements of g greater than or equal to +a the corresponding return value is exactly +1. For elements with -a < g < a the return values are computed elementwise from the polynomial
        (1/16) * ma * (35 + ma2 * (-35 + ma2 * (21 - 5 * ma2)))
        where ma = g / a and ma2 = ma * ma. No in-place modification of the input array is performed; a new numpy.ndarray is returned (though it may share memory with numpy.asarray(g) output depending on numpy's behavior).
    
    Behavior and failure modes:
        The function implements Eq. 14 of Stratmann et al. (1996) with the hard-coded constant a = 0.64 chosen to match that equation. It accepts a numpy.ndarray for g and returns a numpy.ndarray of identical shape. If g cannot be interpreted as a numeric numpy.ndarray, numpy.asarray will raise a TypeError or ValueError which propagates to the caller. There are no other side effects. The function does not perform type promotion beyond numpy.asarray behavior and will preserve or promote dtypes according to NumPy semantics.
    """
    from pyscf.dft.gen_grid import stratmann
    return stratmann(g)


################################################################################
# Source: pyscf.dft.libxc.is_meta_gga
# File: pyscf/dft/libxc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_libxc_is_meta_gga(xc_code: str):
    """Returns whether the given exchange-correlation functional identifier corresponds to a meta-generalized-gradient-approximation (meta-GGA) functional.
    
    This function is used in the PySCF DFT integration with external functional libraries (for example Libxc, which PySCF delegates functional evaluation to). In PySCF workflows this predicate informs higher-level code whether special treatment for meta-GGA functionals is required (for example, supplying the kinetic energy density tau or handling orbital-dependent terms), because meta-GGAs are labeled with the type string 'MGGA' by the internal xc_type lookup.
    
    Args:
        xc_code (str): The exchange-correlation functional identifier supplied to PySCF/Libxc. This string is the same identifier that would be passed to pyscf.dft.libxc.xc_type and can be any functional name or code accepted by that lookup (for example a Libxc functional name). The function uses xc_type(xc_code) and compares the returned type string to 'MGGA' to decide meta-GGA status. The parameter must be a Python str; if xc_code is not recognized by the underlying xc_type function, that function may raise an exception which will propagate to the caller.
    
    Returns:
        bool: True if the functional type returned by xc_type(xc_code) is exactly the string 'MGGA', indicating a meta-GGA functional; False otherwise. There are no side effects. If xc_type raises an exception for an unrecognized or malformed xc_code, that exception is propagated and no boolean value is returned.
    """
    from pyscf.dft.libxc import is_meta_gga
    return is_meta_gga(xc_code)


################################################################################
# Source: pyscf.dft.libxc.parse_xc_name
# File: pyscf/dft/libxc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_libxc_parse_xc_name(xc_name: str = "LDA,VWN"):
    """Convert the XC (exchange–correlation) functional name to the libxc library internal IDs for the primary exchange and correlation components used by PySCF density-functional calculations.
    
    Args:
        xc_name (str): Textual specification of the exchange–correlation functional, e.g. the default "LDA,VWN". In the PySCF project and its DFT workflows (which delegate functional evaluation to external libraries such as Libxc), this string identifies the functional to be used for electronic structure calculations. The string is expected to follow the conventions accepted by pyscf.dft.libxc.parse_xc (for example comma-separated exchange and correlation names, hybrid/mixed functional syntax, or any name/alias supported by the underlying parser). This function calls parse_xc(xc_name) and extracts the first entry from the parsed exchange list and the first entry from the parsed correlation list. If the input is malformed or names are unrecognized, the underlying parser will raise an exception (for example ValueError or other errors propagated from parse_xc); callers should catch or validate input before invoking this helper. The default "LDA,VWN" corresponds to the standard local-density approximation exchange with the VWN correlation functional.
    
    Returns:
        tuple[int, int]: A pair of libxc internal identifiers (exchange_id, correlation_id). Each element is the integer ID that libxc uses internally to reference the primary exchange and primary correlation components extracted from xc_name. These IDs are the values that higher-level PySCF routines pass to the libxc backend to select the appropriate functional implementations for energy and potential evaluations. Exceptions from the parser or unexpected parsed structure (for example missing components) will be propagated instead of returning a value.
    """
    from pyscf.dft.libxc import parse_xc_name
    return parse_xc_name(xc_name)


################################################################################
# Source: pyscf.dft.libxc.define_xc_
# File: pyscf/dft/libxc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_libxc_define_xc_(
    ni: int,
    description: str,
    xctype: str = "LDA",
    hyb: float = 0,
    rsh: list = (0, 0, 0)
):
    """Define XC functional for a PySCF NumInt instance and attach evaluation and metadata helpers used by the PySCF DFT machinery.
    
    This function is used in the PySCF density-functional workflow to configure how exchange–correlation (XC) energy, potential, and higher derivatives are computed for a given numerical integrator (NumInt). It accepts either a descriptive string that names/combines LibXC/XCFun-style functionals or a user-supplied callable implementing the same eval_xc interface. The function sets ni.eval_xc to a callable that evaluates the requested XC model, and also sets helper callables ni.hybrid_coeff, ni.rsh_coeff, and ni._xc_type that return the hybrid mixing coefficient, range-separated hybrid (RSH) coefficients, and nominal XC family ('LDA'/'GGA'/'MGGA'), respectively. It also provides ni.eval_xc1, a wrapper that adapts the lower-level eval_xc output into the shape and ordering expected by the rest of PySCF (handling spin, derivative order, and special-case reordering for MGGA fxc arrays).
    
    Args:
        ni (int): An instance of :class:`NumInt` (numerical integrator) from PySCF. This object will be modified in place: its attributes eval_xc, hybrid_coeff, rsh_coeff, _xc_type, and eval_xc1 are replaced or set. The modified NumInt is returned for convenience. In the DFT domain, NumInt provides grid-based numerical integration of density-functional quantities; define_xc_ connects an XC model to that integrator so subsequent mean-field or post-SCF routines call the configured eval_xc methods.
        description (str): Either a textual description of the XC model or a callable implementing the eval_xc API. If a string, it should describe a linear combination of XC functionals in the format used by PySCF/LibXC (for example '.8*LDA+.2*B86,VWN' where the part before the comma is the exchange combination and the part after is the correlation combination). The substring "HF" in a string denotes exact (Hartree–Fock) exchange. When a string is provided, define_xc_ installs a wrapper that calls the module-level eval_xc parser for that textual description and derives hybrid and RSH coefficients from the string. If a callable is provided, it must follow the eval_xc signature used in PySCF: the callable receives (xc_code, rho, spin=0, deriv=1, omega=None) and returns a tuple like (exc, vxc, fxc, kxc). Providing a callable is useful for testing or for custom, user-defined functionals (for example, returning a simple analytic exc/vxc for a toy density).
        xctype (str): One of the strings 'LDA', 'GGA', or 'MGGA'. This denotes the nominal functional family (local density approximation, generalized gradient approximation, or meta-GGA) and is used only when description is a callable. For string descriptions, the functional family is inferred from the parsed description and this argument is ignored. The xctype value controls how many independent variables are expected and how second-derivative (fxc) arrays are interpreted and validated inside the installed eval_xc1 wrapper.
        hyb (float): Hybrid functional coefficient (a floating-point scalar). When description is a callable, this hyb value is returned by the installed ni.hybrid_coeff callable and therefore used by higher-level code (for example to scale exact-exchange contributions). When description is a string, hybrid mixing is extracted from the string and this argument is ignored. Default is 0 (no global hybrid mixing).
        rsh (list): A length-3 sequence of floats (omega, alpha, beta) specifying range-separated hybrid (RSH) parameters; provided as a Python list in the signature. omega is the exponent factor used in the attenuated Coulomb operator exp(-omega * r12)/r12; alpha and beta parametrize the long-range and short-range hybrid mixing such that the effective hybrid coefficient can be obtained as alpha + beta when appropriate. When description is a callable, this rsh tuple/list is returned by ni.rsh_coeff; when description is a string, RSH parameters are parsed from the string and this argument is ignored. Default is (0, 0, 0) meaning no range separation.
    
    Returns:
        int: The same NumInt instance passed in as ni, after modification. The function returns ni for convenience, but the primary effect is side effects on the ni object: the attributes eval_xc, hybrid_coeff, rsh_coeff, _xc_type, and eval_xc1 are set or overridden so that subsequent calls in the PySCF DFT pipeline use the configured XC model.
    
    Behavior and side effects:
    - If description is a string, define_xc_ installs a wrapper that calls the module-level eval_xc parser with that string; it also installs ni.hybrid_coeff and ni.rsh_coeff as callables that obtain coefficients by parsing the description (via hybrid_coeff(description) and rsh_coeff(description) respectively), and ni._xc_type to report the parsed family. In this mode, the provided hyb, rsh, and xctype arguments are ignored.
    - If description is a callable, define_xc_ uses the callable directly as ni.eval_xc and sets ni.hybrid_coeff to return the hyb argument, ni.rsh_coeff to return the rsh argument, and ni._xc_type to return the xctype argument.
    - define_xc_ always installs ni.eval_xc1, a wrapper that calls ni.eval_xc and reshapes/reorders its returns to the layout expected by PySCF: it validates presence of vxc/fxc/kxc according to the requested derivative order (deriv), reorders MGGA fxc arrays into the internal ordering when needed, transposes outputs when spin==1 to change shape from [grid_id, deriv_component] to [deriv_component, grid_id], stacks the derivative components with numpy.vstack, truncates to the expected output length, and finally selects indices via an internal mapping _libxc_to_xcfun_indices. This wrapper enforces consistent output shape and index ordering for downstream code.
    - The function sets ni.eval_xc to either a string-based wrapper or the provided callable and thus replaces any existing XC evaluator on ni.
    
    Failure modes and validations:
    - If description is neither a string nor a callable, a ValueError is raised with message 'Unknown description %s'.
    - The installed eval_xc1 wrapper asserts that vxc is non-None when deriv > 0, that fxc is non-None and has expected length when deriv > 1, and that kxc is non-None when deriv > 2. For GGA, fxc must have length 3 and for MGGA it must be either length 6 (expected layout) or length 10 (in which case a specific reordering is applied). These assertions raise AssertionError if the eval_xc callable (or the underlying LibXC/XCFun wrapper) returns improperly shaped or missing derivative arrays.
    - Because the wrapper relies on module-level helper functions (hybrid_coeff, rsh_coeff, xc_type) when description is a string, errors in those parsers propagate as exceptions here (for example ValueError or parsing errors) if the string is malformed.
    - The function does not validate the numeric types or ranges of hyb and rsh beyond storing and returning them; callers must ensure hyb is a float and rsh is a length-3 sequence of floats consistent with the intended RSH model.
    
    Practical significance in PySCF workflows:
    - Use define_xc_ to bind a textual LibXC/XCFun functional description or a custom eval_xc callable to a NumInt before running DFT mean-field solvers (e.g., RKS/UKS) so that energy, potentials, and functional derivatives are computed according to the chosen XC model.
    - This function is the integration point between PySCF’s grid integrator (NumInt) and external XC libraries (LibXC, XCFun) or user-defined analytic functionals; correct use ensures consistent hybrid and RSH handling and derivative ordering across the PySCF DFT code path.
    """
    from pyscf.dft.libxc import define_xc_
    return define_xc_(ni, description, xctype, hyb, rsh)


################################################################################
# Source: pyscf.dft.libxc.unregister_custom_functional_
# File: pyscf/dft/libxc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_libxc_unregister_custom_functional_(xc_code: str):
    """pyscf.dft.libxc.unregister_custom_functional_ unregisters a previously registered custom exchange-correlation (XC) functional from the module-level registries used by PySCF's DFT interface to external functional evaluators such as Libxc. This function is the counterpart to register_custom_functional_, and it removes the functional identified by its string name from both the spin-restricted and spin-unrestricted custom-functional registries so that subsequent DFT evaluations in PySCF will no longer use the custom implementation for that name.
    
    Args:
        xc_code (str): The name (identifier) of the custom XC functional to remove. This string must be the same identifier that was supplied to register_custom_functional_ when the functional was added. In the PySCF DFT workflow, xc_code serves as the dictionary key in the module-level registries _CUSTOM_FUNC_R (spin-restricted implementations) and _CUSTOM_FUNC_U (spin-unrestricted implementations). Providing this exact name instructs the routine to remove any custom routines previously associated with that XC functional identifier.
    
    Returns:
        None: This function does not return a value. Its purpose is to perform side effects on module-level state: it attempts to delete the entry keyed by xc_code from both _CUSTOM_FUNC_R and _CUSTOM_FUNC_U. If xc_code is not present in a registry, the missing-key condition is ignored (no exception is raised), making the operation idempotent and safe to call multiple times for the same xc_code. If the module-level registries (_CUSTOM_FUNC_R or _CUSTOM_FUNC_U) are not defined in the module namespace, a NameError (or another unexpected exception) may propagate; other exceptions raised during deletion are not specially handled by this function. Note that modifications to these registries affect how PySCF delegates XC functional evaluations to external libraries and are not automatically propagated to running computations; callers should ensure no active calculations rely on the custom functional being unregistered.
    """
    from pyscf.dft.libxc import unregister_custom_functional_
    return unregister_custom_functional_(xc_code)


################################################################################
# Source: pyscf.dft.libxc.nlc_coeff
# File: pyscf/dft/libxc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_libxc_nlc_coeff(xc_code: str):
    """pyscf.dft.libxc.nlc_coeff returns the non-local correlation (NLC) coefficients associated with a density-functional approximation (DFA) identified by the given functional code. This accessor is used in PySCF DFT workflows that rely on external functional libraries (for example Libxc or XCFun) to obtain parameters required by non-local correlation (dispersion-like) components of certain functionals.
    
    Args:
        xc_code (str): Functional identifier string used to select a density functional from the underlying library (Libxc/XCFun). This string is the same code passed to other PySCF/libxc interfaces (for example "PBE", "B3LYP", or a libxc numeric string), and determines which functional object _get_xc(xc_code) returns. The value must be a valid identifier recognized by the configured functional backend; providing an invalid or unknown xc_code will cause lookup to fail.
    
    Returns:
        object: The value of the nlc_coeff attribute from the functional object returned by _get_xc(xc_code). Semantically, this value contains the coefficients or parameter data that the underlying functional implementation exposes for its non-local correlation component. Callers should treat the returned object as an opaque backend-provided data structure that downstream DFT code will interpret when evaluating non-local correlation contributions.
    
    Behavior and side effects:
        This function delegates to the internal helper _get_xc(xc_code) to obtain the functional object and then returns its nlc_coeff attribute. The call has no additional side effects beyond whatever _get_xc does (for example, _get_xc may create or cache a functional object). The function does not modify global state itself.
    
    Failure modes:
        If xc_code is not recognized by the backend, _get_xc(xc_code) is expected to raise an error (for example ValueError or a backend-specific exception), which will propagate to the caller. If the returned functional object does not expose an nlc_coeff attribute, an AttributeError will be raised. Callers should handle these exceptions or ensure xc_code refers to a functional known to provide non-local correlation coefficients.
    """
    from pyscf.dft.libxc import nlc_coeff
    return nlc_coeff(xc_code)


################################################################################
# Source: pyscf.dft.libxc.hybrid_coeff
# File: pyscf/dft/libxc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_libxc_hybrid_coeff(xc_code: str, spin: int = 0):
    """pyscf.dft.libxc.hybrid_coeff: Return the hybrid-exchange coefficient descriptor for a named exchange–correlation (XC) functional.
    
    This helper looks up the internal XC descriptor for the functional identified by xc_code (via the module-private helper _get_xc) and returns its hybrid_coeff attribute. In the PySCF DFT workflow this value is used to determine how much exact (Hartree–Fock) exchange is mixed into the density functional; the value is provided by the underlying XC library (for example Libxc or XCFun) and may be a simple scalar or a more complex descriptor for range-separated or multi-component hybrids. The function performs no modification of global state and simply forwards the hybrid coefficient information from the XC descriptor to the caller.
    
    Args:
        xc_code (str): Identifier for the exchange–correlation functional. This string is passed verbatim to the internal _get_xc(xc_code, spin=spin) lookup routine, which queries the external XC backend (e.g., Libxc/XCFun) and constructs an XC descriptor object. The identifier can be a standard functional name or code known to the backend; its interpretation and allowed names follow the documentation of the backend library used by PySCF.
        spin (int): Spin option forwarded to _get_xc to request a spin-specific variant of the functional. The default 0 is the PySCF default used when no spin polarization is requested. The exact semantics and allowed integer values are determined by the XC backend and by how the functional is registered in PySCF; this function does not remap or validate spin beyond forwarding it.
    
    Returns:
        object: The hybrid_coeff attribute of the XC descriptor object returned by _get_xc(xc_code, spin=spin). This returned value encodes the mixing coefficients for exact (Hartree–Fock) exchange that the named functional requires and is intended to be consumed by PySCF DFT routines when assembling hybrid exchange contributions. The concrete representation and structure of this object depend on the underlying XC library and on the functional (for example a single numeric coefficient for global hybrids or a nested structure for range-separated / composite hybrids). The function does not convert or validate the returned representation; callers should handle the concrete form consistent with the backend's conventions.
    
    Raises:
        Any exception raised by _get_xc(xc_code, spin=spin): If the functional identifier is unknown, the backend is unavailable, or the backend lookup fails for any other reason, the same exception raised by _get_xc is propagated to the caller. The function has no side effects beyond calling _get_xc and returning the descriptor attribute.
    """
    from pyscf.dft.libxc import hybrid_coeff
    return hybrid_coeff(xc_code, spin)


################################################################################
# Source: pyscf.dft.libxc.define_xc
# File: pyscf/dft/libxc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_libxc_define_xc(
    ni: int,
    description: str,
    xctype: str = "LDA",
    hyb: float = 0,
    rsh: list = (0, 0, 0)
):
    """pyscf.dft.libxc.define_xc: Create and register an exchange–correlation (XC) functional descriptor for use by PySCF's DFT routines and the external XC evaluation libraries (Libxc or XCFun). This wrapper forwards parameters to the internal helper define_xc_ after making a shallow copy of the provided ni argument to avoid unintended modification by downstream code. In the PySCF workflow this function is used to specify which exchange and correlation functional (and any hybrid or range-separation parameters) should be used when delegating energy and potential evaluations to external libraries; the returned descriptor is consumed by DFT drivers, numerical integrators, and wrappers that call Libxc/XCFun.
    
    Args:
        ni (int): Number of integration channels or an identifier used by the downstream XC setup. The function attempts to call ni.copy() before passing the value to define_xc_, so although the annotated type is int, the implementation expects an object that supports .copy() (a shallow copy) to protect the caller's data from mutation by internal routines. If a bare Python int without a copy method is supplied, an AttributeError will be raised at runtime. In practice, ni identifies the dimensionality or indexing convention used by the integrator that will evaluate the XC functional.
        description (str): A textual description or name of the XC functional to define, using the naming conventions understood by the external library (for example Libxc functional names or custom strings recognized by the PySCF libxc wrapper). This string determines which exchange and correlation ingredients are requested from Libxc/XCFun. If the description is not recognized by the underlying library or wrapper, define_xc_ will raise an error indicating an invalid or unsupported functional name.
        xctype (str): Broad XC functional category such as "LDA" (the default), "GGA", "MGGA", or other labels understood by the libxc/XCFun interface. This parameter informs PySCF and the external library about the expected type of functional and its input/derivative ordering. Supplying an incorrect category that does not match the chosen description may cause inconsistent behavior or runtime errors during functional evaluation.
        hyb (float): Fraction of exact (Hartree–Fock) exchange to mix into the functional, expressed as a floating-point number (default 0). Typical hybrid functionals set this between 0 and 1. The hyb parameter is forwarded to the underlying define_xc_ helper and ultimately to the external library; invalid numeric values (e.g., non-finite floats) will result in errors from the helper or during later evaluation.
        rsh (list): Three-element sequence (default (0, 0, 0)) specifying range-separation parameters used for range-separated hybrid functionals. The tuple/list is passed verbatim to define_xc_ and interpreted by the libxc/XCFun wrapper according to the expected convention (for example, parameters controlling short-range/long-range splitting). Providing a sequence of incorrect length or containing invalid numeric values will cause define_xc_ or the external library to raise an error.
    
    Returns:
        object: The return value produced by the internal helper define_xc_. This is an internal exchange–correlation functional descriptor used by PySCF to configure external XC evaluation routines (Libxc/XCFun) and to pass functional metadata to DFT drivers and numerical integrators. The exact structure and type of this descriptor are defined by define_xc_ and the libxc wrapper; callers should treat the returned value as an opaque descriptor suitable for use with the rest of the PySCF DFT machinery.
    
    Behavior and side effects:
        - The function makes a shallow copy of the provided ni argument via ni.copy() before forwarding it to define_xc_; this is intended to avoid unintended mutation of caller-owned objects by downstream code. Because the annotated type is int, callers should be mindful that an object lacking a copy() method will cause an AttributeError.
        - No global state in PySCF is documented to be mutated by this wrapper itself, but define_xc_ or the external libraries it calls may register or cache functional metadata; callers should consult the libxc wrapper documentation for details about caching and global registries.
        - Defaults: xctype defaults to "LDA", hyb defaults to 0, and rsh defaults to (0, 0, 0), which correspond to a pure local density approximation with no exact exchange or range separation.
        - Failure modes include invalid functional names (description not recognized), category mismatch between xctype and description, non-copyable ni objects (AttributeError), and invalid numeric values for hyb or rsh (errors propagated from define_xc_ or the external library).
    """
    from pyscf.dft.libxc import define_xc
    return define_xc(ni, description, xctype, hyb, rsh)


################################################################################
# Source: pyscf.dft.libxc.eval_xc
# File: pyscf/dft/libxc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_libxc_eval_xc(
    xc_code: str,
    rho: numpy.ndarray,
    spin: int = 0,
    relativity: int = 0,
    deriv: int = 1,
    omega: float = None,
    verbose: int = None
):
    """pyscf.dft.libxc.eval_xc evaluates exchange–correlation (XC) energy, potentials, and higher-order functional derivatives by calling the external libxc library. This function is used inside PySCF density-functional calculations to obtain the local XC energy density (exc), the first functional derivatives that form the XC potential (vxc), the second derivatives used for response kernels (fxc), and optional third derivatives (kxc). It accepts a libxc-style functional description string (xc_code) and a grid-wise density array (rho) and returns libxc outputs mapped into PySCF conventions for restricted (spin=0) and unrestricted (spin>0) DFT.
    
    Args:
        xc_code (str): A one-line, case-insensitive string describing the linear combination of XC functionals passed to libxc. The X (exchange) and C (correlation) parts are separated by a comma, for example '.8*LDA+.2*B86,VWN'. The parser accepts operators '+', '-', and '*' and ignores whitespace. If the string contains no comma it is first looked up in the functional alias list (compound functionals declared in PySCF/XC aliases); if not found it is treated as an X-only name. An empty string "" causes the function to return exc, vxc, fxc, kxc that are vectors of zeros. The special token "HF" denotes exact exchange; when present in xc_code the HF contribution is not evaluated by libxc (it is skipped by this interface). Range-separated hybrid (RSH) forms may be given as RSH(omega,alpha,beta) or via SR_HF(omega) and LR_HF(omega) scale factors; in those cases the numeric omega parameter in the string or the explicit omega argument (see below) controls the range-separation. Note: the libxc parser includes the LDA contribution within GGA definitions and compound functionals or numeric scaling (e.g. '0.5*b3lyp') are supported as described above.
        rho (numpy.ndarray): Grid-wise electron density and required derivatives formatted for libxc. For spin = 0 (restricted/unpolarized) rho has shape ((*, N)), where N is the number of grid points, and the leading dimension enumerates components in this order: (den, grad_x, grad_y, grad_z, laplacian, tau). For spin > 0 (spin-polarized/unrestricted) rho is provided as ((*, N), (*, N)) containing separate alpha and beta blocks: (den_u, grad_x_u, grad_y_u, grad_z_u, laplacian_u, tau_u) and (den_d, grad_x_d, grad_y_d, grad_z_d, laplacian_d, tau_d). Each component is a 1-D array over grid points as required by libxc. Correct ordering and presence of derivative components (gradients, laplacian, tau) are required for MGGA/GGA evaluations; mismatched shapes or missing components will cause libxc errors or incorrect results.
        spin (int): Integer flag indicating spin treatment. Use spin = 0 for restricted (spin-unpolarized) DFT and spin > 0 for unrestricted (spin-polarized) DFT. This parameter controls how outputs vxc, fxc, and kxc are organized (different tensor shapes and symmetry reductions for restricted vs unrestricted cases). The default is 0 (restricted).
        relativity (int): Relativity flag. Present for API compatibility but has no effect on the libxc evaluation performed by this function; pass 0 (default). It is accepted to preserve compatibility with other PySCF interfaces that include a relativity argument.
        deriv (int): Non-negative integer controlling the highest order of functional derivatives requested from libxc. deriv = 0 returns only exc. deriv >= 1 requests first derivatives (vxc). deriv >= 2 requests second derivatives (fxc). deriv >= 3 requests third derivatives (kxc). The default is 1. Requesting higher derivatives increases work and memory and may return None in derivative positions that libxc or this wrapper does not supply (see Returns). Invalid or unsupported deriv values will either be clipped by libxc or raise an error from the underlying libxc interface.
        omega (float): Optional range-separation parameter used for range-separated hybrids (RSH) and short/long-range HF components when the functional string expects an omega value. If omega is None (default), omega must be supplied via the functional string (e.g. RSH(0.1,alpha,beta) or SR_HF(0.1)). When provided here, this numeric omega is passed to the libxc interface. If the functional does not accept omega, this argument has no effect.
        verbose (int): Verbosity control (int) or a Logger-like object. Present for API compatibility only; in the current libxc wrapper implementation this parameter has no effect on the evaluation. Supplying a Logger object follows PySCF conventions but will not change libxc output verbosity.
    
    Returns:
        tuple: A 4-tuple (exc, vxc, fxc, kxc) where each element is an array or a list of arrays as produced by libxc and then reorganized into PySCF conventions for downstream DFT code.
    
        exc: Exchange–correlation energy density (array-like). This is the primary energy-density output from libxc for each grid point (used to assemble the total XC energy in DFT). It is returned as the first element outbuf[0] from the libxc wrapper.
    
        vxc: First functional derivatives (XC potential) organized according to functional type and spin:
          - For LDA and spin = 0: vxc is [vrho] where vrho is outbuf[1].
          - For GGA and spin = 0: vxc is [vrho, vsigma] corresponding to outbuf[1] and outbuf[2].
          - For MGGA and spin = 0: vxc is [vrho, vsigma, None, vlapl] mapped from outbuf entries (note that some MGGA components may be None if not provided).
          - For LDA and spin > 0: vxc is [array.T] where outbuf[1:3].T provides (u,d) components for vrho.
          - For GGA and spin > 0: vxc is [outbuf[1:3].T, outbuf[3:6].T] providing separate (u,d) and sigma blocks.
          - For MGGA and spin > 0: vxc is [outbuf[1:3].T, outbuf[3:6].T, None, outbuf[6:8].T].
          The exact mapping follows the libxc wrapper ordering shown in the implementation and is necessary for constructing local XC potentials in PySCF.
    
        fxc: Second functional derivatives (response kernel) organized by functional type and spin. Entries correspond to second derivatives such as v2rho2, v2rhosigma, v2sigma2, v2lapl2, v2tau2, and mixed derivatives. Their presence and ordering depend on xctype (LDA/GGA/MGGA) and spin, and many tensor entries are returned as None when libxc does not provide them. For example:
          - For restricted LDA: fxc is [v2rho2] from outbuf[2] when deriv > 1.
          - For restricted GGA: fxc is [v2rho2, v2rhosigma, v2sigma2] from outbuf[3:6].
          - For unrestricted cases, fxc entries are transposed slices (e.g. outbuf[3:6].T) and have component orderings enumerated in the implementation comments (u_u, u_d, d_d, and larger sigma combinations).
          These second derivatives are used in linear-response, Hessians, and kernel-based post-processing in DFT workflows.
    
        kxc: Third functional derivatives (third-order response tensors) organized similarly to fxc but with more components. Returned only when deriv > 2 and populated according to xctype and spin. Many entries may be None if libxc or this wrapper does not provide the specific third-derivative component. The shapes and component orderings follow the explicit mapping in the implementation (for example, restricted GGA kxc contains four arrays mapped from outbuf[6:10], etc.). Third derivatives are used in higher-order response and advanced functional analysis; requesting them increases computational and memory cost.
    
    Behavior and side effects:
        - This function is a thin wrapper around the compiled libxc interface used by PySCF for DFT. It delegates the evaluation to libxc and then rearranges the returned buffers into PySCF-friendly lists/arrays depending on functional type (LDA/GGA/MGGA) and spin.
        - If xc_code is empty (""), the function returns exc, vxc, fxc, kxc that are vectors of zeros rather than calling a named functional.
        - The token "HF" in xc_code denotes exact exchange but this wrapper will not compute the HF matrix; the HF contribution is skipped here (it should be handled separately by the caller when exact exchange is part of the functional).
        - The parser accepts '+' '-' '*' operators and numeric scaling of component functionals; '/' is not supported in the parser.
        - The function relies on the libxc C library; if libxc is not available, miscompiled, or if xc_code names an unknown functional not present in libxc or the alias list, the underlying call may raise an exception propagated from the libxc wrapper.
        - relativity and verbose are accepted for API compatibility but currently have no effect on the libxc evaluation.
    
    Failure modes and user guidance:
        - Provide rho with shapes and ordering exactly as specified; mismatches in component count or array length will produce errors or wrong results.
        - Requesting deriv greater than supported by a given functional or by libxc will either return None for missing components or raise an error from the libxc layer.
        - For range-separated hybrids, ensure omega is provided either in xc_code or via the omega parameter; otherwise libxc will raise an error for missing omega where required.
        - If more detailed mapping of output array indices is needed, consult the libxc interface source (libxc_itrf.c) and the implementation comments in this wrapper for the exact correspondence between outbuf entries and the returned vxc/fxc/kxc lists.
    
    See also:
        - PySCF XC alias lists and mapping utilities (the functional alias keys can be inspected via pyscf.dft.xcfun.XC_ALIAS.keys()) and the libxc documentation for available functionals and their derivative support.
    """
    from pyscf.dft.libxc import eval_xc
    return eval_xc(xc_code, rho, spin, relativity, deriv, omega, verbose)


################################################################################
# Source: pyscf.dft.libxc.parse_xc
# File: pyscf/dft/libxc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_libxc_parse_xc(description: str):
    """pyscf.dft.libxc.parse_xc parses and decodes an XC (exchange–correlation) functional description string used by PySCF to interface with external functional libraries such as LibXC. The function translates a compact, human-editable description (for example ".8*LDA+.2*B86,VWN" or "B3LYP") into a machine-readable representation used by PySCF to assemble exchange and correlation contributions, to determine exact-exchange (HF) fractions, and to configure range-separated hybrids (RSH/SR_HF/LR_HF). This parser is used in density functional calculations within PySCF to map user-specified functional formulas to libxc numeric identifiers and fractional coefficients and to extract hybrid parameters required by the SCF and DFT routines.
    
    Args:
        description (str): A one-line, case-insensitive string that describes a linear combination of exchange and correlation functionals and optional scaling factors. The expected form is "Xpart,Cpart" where the substring before the comma defines the exchange contribution and the substring after the comma defines the correlation contribution; if the comma is absent, the entire string is interpreted as a compound XC functional (both X and C parts). Valid operators are "+", "-", and "*" (multiplicative scaling); blanks are ignored. Functional names may appear in arbitrary order and can be scaled by a single numeric factor (default factor = 1 when omitted). Special tokens are interpreted: "HF" denotes exact (Hartree–Fock) exchange; "RSH(alpha;beta;omega)" or "SR_HF(omega)" and "LR_HF(omega)" denote range-separated-hybrid components and set the omega parameter; numeric libxc IDs (decimal digits) are accepted directly. The parser accepts common shorthand and aliases via XC_ALIAS/XC_CODES and will query libxc through _itrf.xc_functional_get_number for names not found in the local tables. Although the argument is documented as str, the implementation also handles None (returns the default empty hybrid and no functionals), integer numeric IDs (interpreted as a single libxc ID with unit weight), and non-string iterables by joining the iterable into a "X,C" description; these alternate inputs are supported because callers in PySCF may pass None, integer, or tuple forms. The parser also recognizes and strips dispersion suffixes "-D3" and "-D4" by delegating to pyscf.scf.dispersion.parse_dft. Practical significance: callers (users or higher-level PySCF code) supply this string to select and scale libxc functionals for DFT calculations; correct string syntax is required to obtain the intended exchange/correlation mix and hybrid parameters.
    
    Behavior and notable parsing rules:
    - Comma-separated format: if the description contains ",", the left part is parsed as exchange (parsed with 'X or K' matching rules) and the right part as correlation (parsed with 'C' matching rules). If there is no comma, the whole string is parsed as a compound XC functional.
    - Operators: "+" and "-" indicate addition and subtraction of functional terms; "*" indicates multiplication by a numeric factor. Scientific-notation-like tokens using "E_" are accepted and converted internally to "E-".
    - Scaling and recursion: a compound functional name (for example "B3LYP") may itself expand to multiple libxc components; if such a compound is scaled (e.g., "0.5*B3LYP"), the scaling is applied recursively to all subcomponents so that the returned numeric coefficients reflect the overall scale.
    - Exact exchange and hybrids: "HF" increases the total HF fraction; "SR_HF" affects the short-range HF contribution, "LR_HF" affects the long-range HF contribution, and "RSH(alpha;beta;omega)" sets both alpha/beta partitioning and omega. The parser accumulates hybrid contributions into a three-element hybrid vector; multiple RSH specifications must agree on the same omega or a ValueError is raised.
    - Name resolution: the parser looks up functional names in internal maps (XC_CODES, XC_ALIAS) and in libxc via _itrf.xc_functional_get_number when necessary. If a provided functional name cannot be resolved by either mechanism, a KeyError is raised.
    - Ambiguities: when multiple internal keys match a provided name, the parser writes a warning to sys.stderr and prefers X-type matches where possible; callers should disambiguate by providing explicit prefixes (for example, "GGA_X_B88").
    - Restrictions and special cases: the parser does not accept "/" as an operator; the parser asserts against "-d3" appearing inside a custom XC description token (custom XC strings must not embed dftd3 specifiers; use the dispersion parsing interface instead). Functional names containing dashes that are known to the module are normalized to their dash-containing form via _NAME_WITH_DASH replacements.
    - Pre- and post-processing: the input is uppercased for canonical matching and passed through format_xc_code before tokenization; tokens are split on "+" after normalizing "-" to "+-" and semicolon treatment for RSH-style tokens.
    
    Side effects:
    - The function may call pyscf.scf.dispersion.parse_dft to strip dispersion markers and will call internal helpers such as format_xc_code and remove_dup. It writes informational messages to sys.stderr for ambiguous matches. It calls into the libxc interface via _itrf.xc_functional_get_number for lookups not present in the local tables. The parser mutates and returns new tuples but does not modify global XC_CODES/XC_ALIAS itself.
    
    Failure modes and exceptions:
    - KeyError is raised when a functional name cannot be resolved by XC_ALIAS/XC_CODES or by libxc.
    - ValueError is raised when inconsistent omega (range-separation) values are specified for RSH-type terms.
    - NotImplementedError is raised when an identified functional maps to a None x_id (unsupported in this parsing context).
    - AssertionError can be raised if a token contains the disallowed "-d3" substring during custom compound parsing.
    - Other exceptions may be raised by downstream calls (for example, TypeError or ValueError when parsing numeric factors) if malformed numeric tokens are provided.
    
    Returns:
        tuple: A pair describing the decoded functional. The first element is a 3-tuple (hybrid, alpha, omega) where hybrid and alpha are floats representing accumulated HF fractions (hybrid corresponds to SR_HF + LR contributions as accumulated, alpha corresponds to the LR_HF contribution used by PySCF's hybrid handling) and omega is the range-separation parameter (float, zero if not set). The second element is a tuple of (libxc-Id, fac) pairs, where libxc-Id is the numeric identifier (int) used to refer to a specific libxc functional and fac is a float coefficient applied to that libxc functional. Example returned structure: ((hyb_float, alpha_float, omega_float), ((123, 0.8), (45, 0.2))) where 123 and 45 are libxc numeric IDs and the floats are the corresponding coefficients. The second-element sequence is deduplicated (duplicates are removed) and the ordering/coefficients reflect any recursive scaling applied to compound functionals.
    """
    from pyscf.dft.libxc import parse_xc
    return parse_xc(description)


################################################################################
# Source: pyscf.dft.libxc.xc_reference
# File: pyscf/dft/libxc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_libxc_xc_reference(xc_code: str):
    """pyscf.dft.libxc.xc_reference returns the bibliographic reference(s) associated with a Libxc exchange-correlation (XC) functional identifier. In the PySCF DFT workflow, PySCF delegates evaluation of density functionals to external libraries such as Libxc; this function provides the canonical citation information for the exact XC functional requested, which is required for properly crediting the source of the functional in publications and reports (see README section on citing Libxc).
    
    Args:
        xc_code (str): String identifier of the XC functional to query. This is the same identifier accepted by the internal _get_xc lookup (for example symbolic names or Libxc codes passed to PySCF DFT routines). The argument specifies which exchange-correlation functional the caller used (or plans to use) in a calculation so that the corresponding bibliographic reference can be retrieved for citation and reproducibility.
    
    Returns:
        str: A human-readable textual reference for the specified XC functional. The returned text contains the bibliographic citation(s) that should be used when reporting results computed with the functional identified by xc_code. If the functional is composite (made from multiple component functionals), the returned text aggregates the reference information for each component so that every contributing functional is properly cited.
    
    Behavior and side effects:
        The function performs an internal lookup via _get_xc(xc_code) to resolve the identifier into an internal XC descriptor (with attributes such as nfunc and xc_arr) and then delegates to _xc_reference(nfunc, xc_arr) to format and return the citation text. There are no persistent side effects; calling this function does not modify global state or the behavior of subsequent DFT evaluations. The function is read-only with respect to functional metadata.
    
    Failure modes and errors:
        If xc_code is not recognized by the internal lookup (_get_xc) or if the underlying metadata needed to form the reference is missing, the function will propagate an error from the lookup/formatting routines (for example a lookup-related exception or a ValueError). Callers should ensure xc_code corresponds to a functional supported by the local Libxc metadata available to PySCF, and handle exceptions if the reference cannot be produced.
    
    Practical significance:
        Use this function when preparing manuscripts, reports, or provenance records for DFT calculations performed with PySCF where correct attribution of the exchange-correlation functional is required. It automates retrieval of canonical citation text tied to the exact functional identifier used in the calculation, improving reproducibility and compliance with citation guidelines for density functional calculations.
    """
    from pyscf.dft.libxc import xc_reference
    return xc_reference(xc_code)


################################################################################
# Source: pyscf.dft.radi.mura_knowles
# File: pyscf/dft/radi.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_radi_mura_knowles(n: int, charge: int = None, *args, **kwargs):
    """pyscf.dft.radi.mura_knowles: Generate Mura–Knowles (JCP 1996, DOI:10.1063/1.471749) log3 quadrature radial grid points and their index-derivatives for use in PySCF density-functional-theory (DFT) atom-centered radial integration. This function is used in the DFT radial grid construction pipeline to produce a one-dimensional radial mesh r and the corresponding derivative values dr that are used to form radial integration weights for numerical quadrature on atomic centers.
    
    Args:
        n (int): Number of radial grid points to generate. This value determines the length of both returned arrays r and dr. n is expected to be a non-negative integer; if n == 0 the function returns two empty numpy arrays. Passing a non-integer or a negative integer will cause underlying numpy calls to raise a TypeError or ValueError respectively.
        charge (int or None): Optional atomic number (nuclear charge) used to select a far-field scaling constant specific to certain elements. When charge is one of 3, 4, 11, 12, 19, 20 (which correspond to Li, Be, Na, Mg, K, Ca) the implementation sets the far-field parameter far = 7; for all other values, including None, it uses far = 5.2. The function does not validate that charge is a chemically valid atomic number beyond this membership test; non-integer values will simply not match the special-case tuple and will fall back to the default far = 5.2.
        args (tuple): Additional positional arguments accepted for API compatibility with other radial-grid constructors. This implementation does not use or modify these arguments; they are ignored.
        kwargs (dict): Additional keyword arguments accepted for API compatibility with other radial-grid constructors. This implementation does not use or modify these keyword arguments; they are ignored.
    
    Behavior and algorithm details:
        The routine implements the Mura–Knowles log3 mapping for radial grids: for i in 0..n-1 the normalized index x = (i + 0.5) / n is mapped to a radial coordinate r[i] = -far * log(1 - x**3). The array dr contains the derivative of r with respect to the integer index i, computed as dr[i] = far * 3*x*x/((1 - x**3) * n). The returned dr values are suitable for forming radial integration weights when combined with angular quadrature weights and the Jacobian of the coordinate transform. The choice of far affects the spacing and extent of the radial grid; special-case values for Li, Be, Na, Mg, K, Ca use far = 7 as indicated in the original Mura–Knowles construction, while other atoms use far = 5.2 by default.
    
    Side effects:
        None. The function is pure and does not modify global state or input arguments.
    
    Failure modes:
        If n is not an integer or is negative, numpy.empty(n) or the subsequent loop will raise an exception (TypeError or ValueError) propagated to the caller. If extremely large n is provided, memory allocation for two arrays of length n may fail with a MemoryError. Passing unexpected types for charge does not raise here but will result in the default branching behavior described above.
    
    Returns:
        tuple[numpy.ndarray, numpy.ndarray]: A pair (r, dr) where r is a one-dimensional numpy.ndarray of length n containing the radial grid points generated by the Mura–Knowles log3 mapping, and dr is a one-dimensional numpy.ndarray of length n containing the derivative dr/di (the change of r with respect to the integer grid index) computed consistently with the mapping. These arrays are intended to be used by the PySCF DFT radial integration routines to construct radial weights for atom-centered quadrature.
    """
    from pyscf.dft.radi import mura_knowles
    return mura_knowles(n, charge, *args, **kwargs)


################################################################################
# Source: pyscf.dft.radi.treutler
# File: pyscf/dft/radi.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_radi_treutler(n: int, chg: int, *args, **kwargs):
    """pyscf.dft.radi.treutler: utilities for Treutler–Ahlrichs radial grids used in PySCF density functional integration. This function constructs the Treutler–Ahlrichs (M4) mapping of a 1D radial quadrature grid and its corresponding radial increments. The radial grid produced here is the radial component used in atomic quadrature rules for numerical integration of exchange–correlation contributions in density functional calculations performed with PySCF. The implementation follows the mapping described in Treutler and Ahlrichs, J. Chem. Phys. 102, 346 (1995) and returns arrays ordered with increasing radius suitable for combination with angular weights to form full atomic quadrature weights.
    
    Args:
        n (int): Number of radial points to generate. This is the length of the returned arrays. The function allocates numpy arrays of size n and computes the Treutler–Ahlrichs mapping for indices i = 0..n-1. n must be a positive integer; providing a non-integer will typically raise a TypeError from Python runtime operations, and providing n <= 0 will result in a ValueError or an array-allocation error from numpy.empty. The computational cost is O(n).
        chg (int): Integer index used to select an atom-specific scaling parameter when atom-specific Treutler grids are enabled. Internally, if the module-level flag ATOM_SPECIFIC_TREUTLER_GRIDS is True, the code looks up xi = _treutler_ahlrichs_xi[chg]; otherwise xi is set to 1.0. chg is therefore typically the atomic number or an integer atom-type index used by the surrounding PySCF grid-generation code. If ATOM_SPECIFIC_TREUTLER_GRIDS is True and chg is out of range for _treutler_ahlrichs_xi, an IndexError will be raised. If the module-level names are not defined, NameError may be raised.
        args: Additional positional arguments captured for API compatibility. These are accepted but ignored by this implementation; they exist so callers that pass through extra positional parameters do not break. No side effects result from supplying these arguments, but passing incompatible objects as positional-only arguments may still raise TypeError before they are ignored.
        kwargs: Additional keyword arguments captured for API compatibility. These are accepted but ignored by this implementation. They allow the function to be called with extra named options by higher-level code without changing behavior. Supplying unexpected values in kwargs does not alter the computed grid; however, providing objects that trigger errors during argument parsing (unlikely here) could raise the usual Python exceptions.
    
    Returns:
        tuple(numpy.ndarray, numpy.ndarray): A pair (r, dr) of one-dimensional numpy arrays, each of length n. r is the array of radial grid coordinates computed by the Treutler–Ahlrichs mapping and returned in increasing order (the code computes values then returns r[::-1] so the first element is the smallest radius). dr is the array of radial increments corresponding to each r value computed from the analytic derivative of the mapping; dr can be used together with angular quadrature weights to form full 3D quadrature weights for integration of functions (for example, exchange–correlation integrals). Both arrays are floating-point numpy arrays (the implementation uses numpy.empty so dtype follows numpy defaults, typically float64). No other side effects occur.
    """
    from pyscf.dft.radi import treutler
    return treutler(n, chg, *args, **kwargs)


################################################################################
# Source: pyscf.dft.radi.gauss_chebyshev
# File: pyscf/dft/radi.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_radi_gauss_chebyshev(n: int, *args, **kwargs):
    """Gauss-Chebyshev radial grid generator used in PySCF density-functional calculations. Implements the Gauss–Chebyshev radial mapping described in J. Chem. Phys. 108, 3226 (1998) (DOI: 10.1063/1.475719) to produce a one-dimensional sequence of radial coordinates and their associated differential weights. This function is used by PySCF's DFT integration routines to build atomic radial grids (unitless, logarithmically scaled in the implementation) for numerical integration of radial parts of atomic orbitals and density-related quantities.
    
    Args:
        n (int): Number of radial grid points to generate. In the context of PySCF DFT radial grids, n controls the resolution of the radial quadrature: larger n yields finer sampling of the radial coordinate and more accurate numerical integrals at increased computational cost. n is expected to be a positive integer; non-positive values produce empty output arrays, and non-integer types may result in unexpected behavior or runtime errors because the implementation uses integer-based array shapes and indexing.
        args (tuple): Positional variable arguments. Present for API compatibility with other radial-grid factory functions in PySCF. This function ignores any values supplied in args; they have no effect on the computed grid. Including this parameter allows gauss_chebyshev to be called via higher-level grid-selection code that forwards extra arguments.
        kwargs (dict): Keyword variable arguments. Present for API compatibility with other radial-grid factory functions in PySCF. This function ignores any values supplied in kwargs; they have no effect on the computed grid. Supplying unsupported keywords will not change behavior but may be used by wrapper code to provide a uniform call signature across different radial-grid generators.
    
    Behavior and implementation details: The routine constructs Chebyshev-like nodes x1 and a transformed variable xi, then maps xi to a unitless radial coordinate r via a base-2 logarithmic transform (the implementation uses ln2 = 1 / log(2)). The returned dr value is computed analytically from the mapping and serves as the differential element (Jacobian) associated with r; in PySCF this dr is used together with angular weights to form full radial integration weights. The function uses NumPy for vectorized operations and returns NumPy arrays. There are no side effects: the function does not modify global state or external objects.
    
    Failure modes and numerical considerations: Passing a non-integer or ill-typed n may raise exceptions or produce unexpected array lengths because integer array construction and indexing are used internally. Very small n (n <= 0) yields empty arrays. Very large n may expose floating-point round-off or overflow/underflow issues in the mapping and weight computation; users should choose n consistent with their required integration accuracy and available numerical precision.
    
    Returns:
        tuple: A pair (r, dr) where
            r (numpy.ndarray): One-dimensional NumPy array of length n containing the computed unitless radial coordinates for the Gauss–Chebyshev radial grid. These coordinates are intended for use by PySCF DFT integration routines as the radial positions at which functions are sampled.
            dr (numpy.ndarray): One-dimensional NumPy array of length n containing the differential element (Jacobian-like) corresponding to each entry in r. In practice within PySCF, dr is combined with angular weights to form the full radial integration weights used to numerically integrate radial contributions to molecular integrals.
    """
    from pyscf.dft.radi import gauss_chebyshev
    return gauss_chebyshev(n, *args, **kwargs)


################################################################################
# Source: pyscf.dft.radi.becke
# File: pyscf/dft/radi.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_radi_becke(n: int, charge: int, *args, **kwargs):
    """pyscf.dft.radi.becke: Generate radial quadrature points and weights using Becke (J. Chem. Phys. 1988) Gauss–Chebyshev quadrature of the second kind for atomic radial integration.
    
    This function constructs a one-dimensional radial grid (points r and weights w) intended for use in PySCF's DFT radial integration routines. It implements the node/weight construction described by Becke (JCP 88, 2547 (1988); DOI:10.1063/1.454033) by (1) forming Gauss–Chebyshev nodes t and base weights on the interval [-1, 1] for the second kind, (2) adjusting those weights to remove the intrinsic sqrt(1 - t^2) weighting of the Chebyshev rule, and (3) applying the change of variables r = (1 + t)/(1 - t) * rm to map the domain to (0, +inf) where rm is chosen from BRAGG_RADII according to the supplied charge. The produced arrays r and w are suitable for numerical integration of radial parts of molecular/atomic functions (for example, the radial factor of basis functions or electron density) when assembling DFT integration grids in PySCF.
    
    Args:
        n (int): The number of radial quadrature points to generate. This integer controls the resolution of the radial grid; larger n increases integration accuracy and computational cost. n must be a positive integer. If n is not an integer or is <= 0 the function will raise an error (TypeError or ValueError, respectively).
        charge (int): Integer index used to select the reference Bragg radius from the module-level BRAGG_RADII mapping. When charge == 1 the code uses BRAGG_RADII[charge] directly; for any other integer charge the radius is scaled by 0.5. This selection sets the radial length scale rm used in the mapping from the Chebyshev domain [-1, 1] to (0, +inf). If charge is not a valid key in BRAGG_RADII a KeyError will be raised.
        args (tuple): Additional positional arguments accepted by the function signature for API compatibility with other radial-generating functions. This implementation does not use these arguments; they are ignored. Providing extra positional arguments has no effect on the returned r and w but allows calling code that forwards extra parameters to remain compatible.
        kwargs (dict): Additional keyword arguments accepted for API compatibility. Like args, these keyword arguments are ignored by this implementation. They are accepted to preserve a common interface with other grid generators and will not alter behavior, outputs, or side effects.
    
    Behavior and side effects:
        The function is pure (no side effects on global state) beyond reading BRAGG_RADII. Internally it computes:
          i = arange(1, n+1)
          t = cos(i * pi / (n + 1))
          w_base = pi / (n + 1) * sin(i * pi / (n + 1))
          r = (1 + t) / (1 - t) * rm
          w = w_base * 2 / (1 - t)**2 * rm
        where rm = BRAGG_RADII[charge] for charge == 1, otherwise rm = 0.5 * BRAGG_RADII[charge]. The returned weights w are adjusted so that numerical quadrature using (r, w) approximates integrals over the mapped radial coordinate after the change of variables. The function does not modify its inputs or any external state and is deterministic for given inputs.
    
    Failure modes and errors:
        TypeError will be raised if n is not convertible to an integer consistent with the function signature (the signature declares n: int). ValueError will be raised if n <= 0. KeyError will be raised if BRAGG_RADII does not contain the provided charge key. If numpy operations fail due to unexpected input types, corresponding numpy exceptions (e.g., TypeError) may propagate.
    
    Returns:
        tuple of numpy.ndarray:
            A pair (r, w) where both r and w are one-dimensional numpy.ndarray objects of length n. r contains the mapped radial grid points obtained from the Gauss–Chebyshev nodes via r = (1+t)/(1-t) * rm. w contains the corresponding quadrature weights after adjustment for the Chebyshev weight and the change of variables. These arrays are intended to be consumed by PySCF's DFT grid/integration machinery to perform numerical radial integration; they are returned and not stored as a side effect.
    """
    from pyscf.dft.radi import becke
    return becke(n, charge, *args, **kwargs)


################################################################################
# Source: pyscf.dft.radi.delley
# File: pyscf/dft/radi.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_radi_delley(n: int, *args, **kwargs):
    """pyscf.dft.radi.delley — Generate B. Delley radial grid points and their discrete derivatives for use in density-functional-theory (DFT) radial integration within the PySCF framework.
    
    Generates an array of n radial coordinates and a corresponding array of discrete derivatives using the log2 mapping described by B. Delley (J. Chem. Phys. 104, 9848 (1996); DOI:10.1063/1.471749). The implementation follows the "log2 algorithm" variant: it maps a uniform index variable into a monotonically increasing radial coordinate that spans from small radii up to a fixed outer radius (r_outer = 12.0 in the source code). This routine is intended to provide the radial nodes and a local spacing factor used by PySCF DFT radial quadratures (atomic radial grids) when assembling numerical integration weights in electronic-structure calculations.
    
    Args:
        n (int): Number of radial grid points to generate. The function allocates two numpy arrays of length n and fills them with the radial coordinates and their discrete derivatives. n must be a positive integer (n >= 1). If n is zero or negative the computation will produce invalid intermediate values (division by zero or log of non-positive arguments) and will typically raise a runtime error; callers should validate n before invoking this function. In the context of PySCF DFT, n controls the radial resolution of the atomic grid: larger n increases radial point density and the cost of integration but can improve accuracy.
        args (tuple): Additional positional arguments accepted for API compatibility. These arguments are not inspected or used by this implementation and have no effect on the returned arrays. They are preserved so higher-level code that forwards extra parameters to grid constructors does not break.
        kwargs (dict): Additional keyword arguments accepted for API compatibility. These keyword arguments are ignored by this function and have no side effects. Do not rely on this function honoring any keyword controls (for example to change the outer radius); the source code uses a fixed r_outer = 12.0.
    
    Behavior and numeric details:
        - The function computes step = 1.0/(n+1) and a scale factor rfac = r_outer / log(1 - (n*step)**2) with r_outer hard-coded to 12.0. For integer indices i = 1..n the radial coordinate is r[i-1] = rfac * log(1 - (i*step)**2). By construction r[n-1] equals r_outer and the sequence is monotonically increasing from small positive radii to r_outer.
        - The returned dr array contains the discrete derivative computed in code as dr[i-1] = rfac * (-2.0*i*(step)**2) / (1 - (i*step)**2). This value corresponds to the derivative of the mapping with respect to the normalized index variable (i or equivalently t = i*step) and is intended as a local scaling factor for forming radial quadrature weights (i.e., it represents how the radial coordinate changes per increment in the normalized index).
        - The radial coordinates and dr values are represented as numpy.ndarray objects (constructed via numpy.empty in the implementation) and use the floating-point dtype chosen by numpy defaults. The coordinate values are on the same length scale convention used elsewhere in PySCF radial grids (the implementation uses r_outer = 12.0, consistent with common atomic-unit length scales in quantum-chemistry programs).
        - Because the algorithm evaluates log(1 - (i*step)**2), arguments to log are strictly positive for i in 1..n (since n*step = n/(n+1) < 1). Numerical round-off for extremely large n may cause the argument to approach or fall below zero; callers should avoid excessively large n values that could trigger domain errors in log or produce poor numerical precision.
    
    Side effects and performance:
        - No global state is modified. The function returns newly allocated numpy arrays and has no other side effects.
        - Computational cost is O(n) in time and O(n) in memory. The hard-coded outer radius and the simple loop make this routine inexpensive relative to the cost of DFT integral evaluations; however increasing n increases downstream integration cost proportionally.
    
    Failure modes:
        - Passing n <= 0 will result in invalid intermediate arithmetic (division by zero or log of 1 leading to infinite rfac) and will typically raise a runtime error or produce arrays filled with infinities/NaNs.
        - Very large n can induce floating-point precision issues when computing 1 - (i*step)**2 or the logarithm; choose n appropriate for desired accuracy and machine precision.
    
    Reference:
        B. Delley, J. Chem. Phys. 104, 9848 (1996). DOI:10.1063/1.471749. The routine implements the log2 mapping described in that work and is intended for constructing atomic radial grids used by PySCF DFT routines.
    
    Returns:
        tuple: A tuple (r, dr) where r is a numpy.ndarray of shape (n,) containing the radial coordinates (monotonically increasing, with r[-1] == r_outer as implemented), and dr is a numpy.ndarray of shape (n,) containing the discrete derivative values computed for each radial node. These arrays are intended to be used directly when forming radial quadrature weights in PySCF's DFT integration pipelines.
    """
    from pyscf.dft.radi import delley
    return delley(n, *args, **kwargs)


################################################################################
# Source: pyscf.dft.xc.utils.format_xc_code
# File: pyscf/dft/xc/utils.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_xc_utils_format_xc_code(description: str):
    """pyscf.dft.xc.utils.format_xc_code formats and normalizes a user-supplied density-functional exchange–correlation (XC) description string for use inside PySCF. In the PySCF DFT workflow (which delegates functional evaluation to external libraries such as Libxc or XCFun), this function is used to produce a compact, upper-cased, whitespace-free representation of an XC description and to translate range-separated-hybrid (RSH) parameter notation from the common RSH(omega, alpha, beta) form into the internal RSH(alpha; beta; omega) form expected by downstream PySCF parsers and code.
    
    This function performs the following concrete operations observed in the source code:
    1. Removes all ASCII space characters and newline characters from description, then converts the entire string to upper case. This normalization makes functional names and tokens consistent with PySCF’s downstream parsing and with conventions used when citing or delegating to external XC libraries.
    2. If the token 'RSH' is absent after normalization, returns the normalized string unchanged.
    3. If one or more 'RSH' fragments are present, splits the string on the substring 'RSH' and for each fragment of the form RSH(omega,alpha,beta) rewrites it as RSH(alpha;beta;omega) by moving the first numeric parameter (omega) to the final position and replacing commas between the three parameters with semicolons in the internal notation. Non-RSH parts of the description are preserved in their normalized form and rejoined with the literal substring 'RSH'.
    
    Args:
        description (str): The original XC description string provided by the caller. In PySCF this typically identifies a density-functional or a compound specification that may include tokens such as 'RSH(...)' for range-separated-hybrid functionals. The function expects a Python str; the function will remove spaces and newlines and convert to upper case before performing any RSH-specific reordering. Supplying strings that are already normalized is allowed and will be returned (possibly with only the RSH reordering applied).
    
    Returns:
        str: A new string containing the formatted XC description. The returned string is the whitespace- and newline-free, upper-cased form of the input with any RSH(omega,alpha,beta) occurrences rewritten to RSH(alpha;beta;omega). This normalized form is suitable for PySCF internal parsing and interoperating with external XC libraries that PySCF references in its DFT workflows.
    
    Raises:
        TypeError: If description is not a str, Python will raise a TypeError when string methods are invoked.
        ValueError: If the input contains an 'RSH' occurrence that does not match the expected parenthesized form (for example, missing a closing ')' so that frag.split(')') does not yield two parts, or if the parenthesized content does not split into exactly three comma-separated items), the code will raise a ValueError due to failed unpacking or malformed fragments. Callers should validate or sanitize malformed RSH notations before invoking this helper to avoid exceptions.
    
    Notes:
        - The function has no side effects: it does not modify external state and only returns the transformed string.
        - The conversion is literal and syntactic; it does not validate numeric ranges or semantic correctness of the RSH parameters (omega, alpha, beta). Downstream code that consumes the returned string is responsible for numeric parsing and domain-specific validation.
        - Typical usage in PySCF is to call this utility early when processing user-provided XC specification strings so that subsequent parser code sees a consistent, internal RSH(...) notation.
    """
    from pyscf.dft.xc.utils import format_xc_code
    return format_xc_code(description)


################################################################################
# Source: pyscf.dft.xc_deriv.count_combinations
# File: pyscf/dft/xc_deriv.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_xc_deriv_count_combinations(nvar: int, order: int):
    """pyscf.dft.xc_deriv.count_combinations counts combinatorial multiplicities used when enumerating derivative components for exchange–correlation (XC) functionals in density-functional-theory (DFT) code paths. In the PySCF DFT/xc_deriv context this function provides the integer number of distinct multisets (combinations with replacement) that arise when selecting "order" items from "nvar" independent variables; this count is used to size and index arrays that store unique derivative terms of XC quantities (for example when building higher-order functional derivatives or allocating storage for symmetrized derivative tensors). The original source-level hint for the intent was the expression sum(len(combinations_with_replacement(range(nvar), o) for o in range(order)), and the implementation returns the closed-form combinatorial value via lib.comb(nvar+order, order).
    
    Args:
        nvar (int): The number of independent variables from which items are drawn in the combinatorial enumeration. In PySCF DFT/xc_deriv usage this represents the number of distinct variable components (for example independent density/gradient components or basis-indexed degrees of freedom) that contribute to XC derivative terms. This value is expected to be an integer; negative or non-integer inputs are not valid for the underlying combinatorics and will cause the underlying combinatorial routine (lib.comb) to raise an error.
        order (int): The order (non-negative integer) of the multiset selection, i.e., the number of items selected with replacement when forming each combination. In practical PySCF usage this corresponds to the derivative order or the size of the index multiset whose distinct permutations are being counted. Passing larger order increases the returned count combinatorially; non-integer or negative values are invalid and will result in an error from the underlying combinatorial function.
    
    Returns:
        int: The number of distinct combinations computed as the binomial coefficient C(nvar + order, order) returned by lib.comb(nvar+order, order). This integer is the count used to allocate and index storage for symmetrized derivative components in XC derivative routines. There are no side effects. If inputs are invalid (for example negative or non-integer), the underlying combinatorial implementation will raise an exception (TypeError or ValueError), and extremely large values for nvar and order may produce very large integers that imply large memory allocations if the result is used to size arrays.
    """
    from pyscf.dft.xc_deriv import count_combinations
    return count_combinations(nvar, order)


################################################################################
# Source: pyscf.dft.sap.sap_effective_charge
# File: pyscf/dft/sap.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_sap_sap_effective_charge(Z: int, r: numpy.ndarray):
    """pyscf.dft.sap.sap_effective_charge computes the effective (screened) nuclear charge Z(r) used in the Superposition of Atomic Potentials (SAP) initial guess for self-consistent field (SCF) electronic-structure calculations. The implementation returns exchange-only LDA based effective charges for neutral, spherically symmetric atoms derived from precomputed numerical data (sap_Zeff) and is intended to provide the screened charge as a function of radial distance for constructing SAP potentials as described in the cited references.
    
    This function is used in the PySCF SAP module to provide a radial profile of the screened nuclear charge for each atomic number Z when building initial potentials for SCF procedures. The underlying data (sap_Zeff) contain numerically precomputed effective-charge profiles obtained from fully numerical finite-element atomic calculations and spherically symmetric unrestricted Hartree–Fock references; the function interpolates those profiles to the requested radii.
    
    Args:
        Z (int): Atomic number (nuclear charge) of the neutral atom for which the screened charge is requested. This integer selects the precomputed effective-charge profile from the global sap_Zeff data array. Practical significance: the value determines which row/column of the sap_Zeff table is used as the y-values for interpolation; values less than 1 are treated as non-physical for SAP and yield a screened charge of 0.0, while values equal to or above sap_Zeff.shape[1] are outside the precomputed dataset and cause an error (the code checks this bound and raises ValueError with the message 'Atoms beyond Og are not supported').
        r (numpy.ndarray): Radial distance(s) from the nucleus, expressed in the same units used in the sap_Zeff dataset. This argument may be a scalar numpy.ndarray with ndim == 0 or a numpy.ndarray of arbitrary shape containing non-negative distances. Practical significance: r is the independent variable for which the effective (screened) nuclear charge Z(r) is evaluated by linear interpolation on the radial grid stored in sap_Zeff[0,:]. Behavior and failure modes: any negative entry in r triggers a ValueError with the message 'Distance cannot be negative'. For scalar r values that exceed the available radial grid extent checked against sap_Zeff.shape[0], the function returns 0.0. For array inputs, interpolation is performed elementwise and any elements with r >= sap_Zeff.shape[0] are set to 0.0 in the returned array. The function uses numpy.interp for linear interpolation between grid points of sap_Zeff.
    
    Returns:
        float or numpy.ndarray: The screened charge Z(r) evaluated at the supplied distance(s). If r is a scalar (0-d numpy.ndarray), a Python float is returned containing the interpolated screened charge (or 0.0 for distances beyond the precomputed grid or for Z < 1). If r is an array, a numpy.ndarray of the same shape as r is returned with elementwise interpolated screened charges; elements corresponding to distances beyond the precomputed radial grid are set to 0.0. No other side effects occur, but the function depends on the presence and correct shape of the global sap_Zeff array: if sap_Zeff is not loaded or has unexpected dimensions, a NameError or IndexError/ValueError may be raised by the function.
    
    Notes:
        - The effective-charge data in sap_Zeff were computed for neutral atoms using exchange-only LDA on top of spherically symmetric unrestricted Hartree–Fock references and high-accuracy finite-element methods. These data are intended for use in constructing the SAP initial guess for SCF; consult the cited literature for details on the theory and numerical generation of sap_Zeff.
        - The function performs simple linear interpolation via numpy.interp; no extrapolation beyond the provided grid is performed (values outside the grid are mapped to 0.0 as described).
        - The function enforces the following explicit conditions from the implementation: Z < 1 returns 0.0, Z >= sap_Zeff.shape[1] raises ValueError('Atoms beyond Og are not supported'), and any r < 0 raises ValueError('Distance cannot be negative').
    """
    from pyscf.dft.sap import sap_effective_charge
    return sap_effective_charge(Z, r)


################################################################################
# Source: pyscf.dft.xc_deriv.ud2ts
# File: pyscf/dft/xc_deriv.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_xc_deriv_ud2ts(v_ud: numpy.ndarray):
    """pyscf.dft.xc_deriv.ud2ts converts exchange–correlation (XC) derivative arrays from the spin-up/spin-down ("u","d" or "a","b") representation to the total-density/spin-density ("rho","s") representation used in PySCF's DFT grid-based integrals and response calculations. This conversion is commonly needed when evaluating XC potentials and kernels coming from spin-resolved functional evaluations (external XC libraries) and when downstream routines expect total- and spin-density derivative components. The routine delegates the low-level memory transformation to the compiled helper libdft.VXCud2ts for performance.
    
    This function accepts a NumPy array containing XC derivatives in a spin-channel representation and returns a NumPy array of the same shape and dtype containing the corresponding derivatives in the total-density / spin-density representation. The conversion implemented corresponds to the linear map vrho = (va + vb)/2 and vs = (va - vb)/2 applied to the spin channels, applied across the array layout used by PySCF's grid-based XC derivative machinery.
    
    Args:
        v_ud (numpy.ndarray): Input array of XC derivatives in the spin-up / spin-down representation. The array must be convertible to a C-contiguous numpy.ndarray (the function calls numpy.asarray with order='C'). The last two dimensions of v_ud are interpreted as (nvar, ngrids), where nvar is the number of variables per spin channel and ngrids is the number of grid points. Any leading dimensions are interpreted in paired groups that represent higher-order derivative structure; the function computes order = v_ud.ndim // 2 and therefore expects v_ud.ndim to be an even integer (for example ndims >= 2 and ndims % 2 == 0). Practically, v_ud is the array produced by PySCF/XC evaluation code that stores, for each grid point and variable, the contributions for the two spin channels; this function re-expresses those contributions as total-density and spin-density components. The dtype and shape of the returned array will match v_ud.
    
    Returns:
        numpy.ndarray: A NumPy array with the same shape and dtype as v_ud containing the XC derivatives transformed to the total-density ("rho") and spin-density ("s") representation. The returned array is a newly produced, C-contiguous array (the implementation creates an empty_like buffer and fills it via the compiled libdft.VXCud2ts routine). The input v_ud is not modified by this function.
    
    Behavior, side effects, and failure modes:
        This function always converts v_ud to a C-contiguous numpy array before processing; if v_ud is not already C-contiguous a copy will be made. The transformation is performed by the external compiled routine libdft.VXCud2ts; incorrect shapes, unexpected ndim parity (odd number of dimensions), or incompatible memory layouts may cause the compiled routine to raise an error or crash (e.g., segmentation fault) if the array layout does not match the expected (nvar, ngrids, paired derivative-block) convention. Callers should ensure v_ud.ndim is even and that the last two dimensions correspond to (nvar, ngrids) as used by PySCF's XC derivative code. No file I/O or global state is modified by this function; its only side effect is allocation of the returned NumPy array.
    """
    from pyscf.dft.xc_deriv import ud2ts
    return ud2ts(v_ud)


################################################################################
# Source: pyscf.dft.xc_deriv.ts2ud
# File: pyscf/dft/xc_deriv.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_xc_deriv_ts2ud(v_ts: numpy.ndarray):
    """Convert exchange–correlation (XC) derivative tensors from the total-density / spin-density
    ("ts") representation to the spin-up / spin-down ("u/d") representation used in
    spin-polarized density-functional calculations.
    
    This function is used within PySCF's DFT machinery to transform arrays of XC
    derivatives computed or accumulated in the combined total/spin channel basis into
    the separate spin-up and spin-down channel basis expected by other parts of the
    code (for example, when assembling spin-dependent potentials or response properties).
    The conversion is performed by calling the compiled routine libdft.VXCts2ud for
    efficient, elementwise mapping across grid points and batched derivative tensors.
    
    Args:
        v_ts (numpy.ndarray): Input array of XC derivatives in the total-density / spin-density
            representation. This array is converted to a contiguous C-ordered numpy array
            if necessary. The array must be at least 2-D; the final two dimensions are
            interpreted as (nvar, ngrids) where nvar is the number of XC derivative
            variables in the ts representation (for example, channels combining total
            and spin-density contributions) and ngrids is the number of integration grid
            points. Leading dimensions (if any) are treated as batch dimensions and the
            conversion is applied independently for each batch. The dtype must be a numeric
            floating-point type compatible with the underlying libdft routine (typically
            float64); if the dtype or memory layout is incompatible, a low-level error
            (from ctypes or the C routine) may be raised.
    
    Returns:
        numpy.ndarray: Array of the same shape and dtype as v_ts containing the XC derivatives
        represented in the spin-up / spin-down (u/d) basis. The last two dimensions remain
        (nvar, ngrids) where nvar corresponds to the variables in the u/d representation
        and ngrids is the number of grid points. The function does not modify the original
        v_ts object; it constructs and returns a new array filled by the compiled libdft
        conversion routine.
    
    Behavior and side effects:
        The function first ensures v_ts is a C-contiguous numpy array (np.asarray(..., order='C'))
        and allocates an output array of the same shape. It computes nvar and ngrids from the
        last two dimensions of v_ts and then invokes the compiled libdft.VXCts2ud routine to
        perform the mapping. The function supports batched inputs by applying the conversion
        independently across any leading dimensions. No global state is modified; memory is
        allocated for the returned array, and the original v_ts is left unchanged.
    
    Failure modes and errors:
        If v_ts has fewer than two dimensions a ValueError will be raised when extracting
        the last two shape components. If the input dtype or memory layout is incompatible
        with the libdft conversion routine, the call may raise a ctypes error or an error
        propagated from the underlying C implementation. Users should ensure the input is a
        floating-point numpy array with appropriate precision (typically float64) and that
        the last two dimensions represent (nvar, ngrids) as described above.
    """
    from pyscf.dft.xc_deriv import ts2ud
    return ts2ud(v_ts)


################################################################################
# Source: pyscf.dft.xc_deriv.transform_xc
# File: pyscf/dft/xc_deriv.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_xc_deriv_transform_xc(
    rho: numpy.ndarray,
    xc_val: numpy.ndarray,
    xctype: str,
    spin: int,
    order: int
):
    """pyscf.dft.xc_deriv.transform_xc: General transformation to construct the exchange-correlation (XC) derivative tensor used in PySCF density-functional calculations.
    
    This function transforms raw, library-provided XC values (xc_val) and the input density descriptor (rho) into a full tensor of XC derivatives of a specified order. It is used in the DFT/XC evaluation and response code paths in PySCF to build the derivative objects required for computing potentials, kernels, and higher-order response contributions. The transformation dispatches different routines for local (LDA, HF) and generalized-gradient (GGA and beyond) type functionals, accounts for spin convention (spin-restricted vs spin-polarized), and assembles contributions from lower-order sigma (|∇ρ|^2) terms into the requested higher-order derivative tensor.
    
    Args:
        rho (numpy.ndarray): Array containing the density-like variables organized for all grid points. The function expects rho to be a one-dimensional or contiguous ndarray whose total size equals (spin+1) * nvar * ngrids, where nvar and ngrids are determined internally: nvar is looked up from the internal mapping _XC_NVAR using the tuple (xctype, spin), and ngrids is inferred from the last dimension of xc_val. In practical DFT usage within PySCF, rho encodes the set of density components (for example, ρ, ∇ρ components, and other variables required by the functional) for each grid point in a batched layout. If rho does not meet the required size, an AssertionError is raised.
    
        xc_val (numpy.ndarray): Contiguous array (converted with np.asarray(order='C')) containing the raw XC coefficients returned by an external XC library (Libxc, XCFun, or similar) for every combination of variables and every grid point. The last dimension of xc_val is the number of grid points (ngrids). The leading dimension packs derivative components in the ordering expected by the internal combinatorics; transform_xc slices and unfolds these components into a full tensor. For order == 0 the function returns xc_val[0] directly. If xc_val has inconsistent shape or insufficient entries for the requested xctype/spin/order combination, an IndexError or related error can occur.
    
        xctype (str): String tag identifying the type of exchange-correlation functional variables expected, e.g., 'LDA', 'HF', or other labels used by the module to index the internal mapping _XC_NVAR. This tag determines nvar and xlen via _XC_NVAR[(xctype, spin)], and therefore selects the transformation path: LDA/HF take a simplified branch, while GGA/post-GGA functionals require unfolding and assembling tensor components. Providing an xctype not present in the internal mapping will typically raise a KeyError.
    
        spin (int): Integer spin flag indicating the spin treatment used for the functional. In PySCF DFT context this is typically 0 for spin-unpolarized (spin-restricted) functionals and 1 for spin-polarized (collinear) functionals. spin determines how many density blocks are expected in rho ((spin+1) blocks) and influences the layout of the returned tensor. Using values other than the conventionally used 0 or 1 may cause lookup failures in the internal mapping or produce an unexpected tensor layout.
    
        order (int): Non-negative integer specifying the derivative order to construct. order == 0 returns the zeroth-order XC values (xc_val[0]). order >= 1 constructs the full XC derivative tensor of that order. For LDA/HF types the returned tensor has trivial spatial-part dimensions and the function returns compacted components; for GGA and higher-order functionals the code unfolds gradient-related variables and, for even-order tensors, adds contributions originating from lower-order sigma terms (combinatorial assembly over pairs of gradient indices). If order is larger than the functional supports (as implied by xc_val and the internal combinatorics), indexing or shape errors can occur.
    
    Returns:
        numpy.ndarray: A new ndarray that contains the XC derivative tensor assembled for the requested order. The last dimension of the returned array equals the number of grid points (ngrids). The leading dimensions and their meaning depend on xctype, spin, and order: for LDA/HF the function returns compact shapes (for spin==0 a shape with order leading singleton dims followed by ngrids; for spin==1 a shape with repeated [2,1] blocks per order followed by ngrids), whereas for GGA/post-GGA the tensor contains explicit gradient/variable indices arranged according to internal combinatorics (expanded from the packed xc_val). The returned array is safe to use in subsequent XC potential, kernel, or response computations within PySCF.
    
    Behavior and side effects:
        The function converts xc_val and rho to numpy arrays with C-contiguous order using np.asarray(order='C') but does not intentionally mutate user-provided input arrays; however, numpy may return views or copies depending on the input, so the input objects should not be relied upon to be unmodified in every case. The function consults internal helper tables and routines (_XC_NVAR, count_combinations, _unfold_gga, _product_uniq_indices, _diagonal_indices, and combinatoric utilities) to determine expected variable counts and to assemble the tensor. For even derivative orders, additional sigma-derived contributions are incorporated by summing terms into diagonal positions of the output tensor.
    
    Failure modes:
        The function can raise AssertionError if rho.size does not match the expected (spin+1) * nvar * ngrids. KeyError may occur if (xctype, spin) is not present in the internal _XC_NVAR mapping. IndexError or ValueError may be raised if xc_val does not contain enough packed components for the requested order or has an unexpected shape. TypeError may be raised for invalid types passed for rho, xc_val, xctype, spin, or order. These exceptions reflect mismatches between the external XC-library outputs, the functional type tag, and the derivative order requested.
    """
    from pyscf.dft.xc_deriv import transform_xc
    return transform_xc(rho, xc_val, xctype, spin, order)


################################################################################
# Source: pyscf.dft.xcfun.nlc_coeff
# File: pyscf/dft/xcfun.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_xcfun_nlc_coeff(xc_code: str):
    """pyscf.dft.xcfun.nlc_coeff — Extract nonlocal correlation (NLC) coefficients from an XCFun-style XC code for use in PySCF density-functional calculations.
    
    This function parses an XCFun exchange–correlation specification string (xc_code) using PySCF's parse_xc routine and returns the nonlocal-correlation (NLC) components associated with the VV10-style family of functionals. In the context of PySCF DFT and the XCFun integration (see README), NLC refers to nonlocal correlation terms (for example, VV10 variants) that contribute to the total DFT energy and potentials. The returned coefficients are the names (from the internal VV10_XC mapping) and their corresponding multiplicative scaling factors as extracted from the parsed functional specification. The function upper-cases the xc_code internally, filters parsed functional components for those with numeric ids >= 5000 (the VV10/NLC id range used in the codebase), and preserves the ordering and factors produced by parse_xc.
    
    Args:
        xc_code (str): Exchange–correlation identifier string accepted by PySCF's XCFun interface and parse_xc. This is the textual specification used in PySCF DFT workflows to select and combine functionals (it may contain multiple components and scaling factors); the function converts it to upper case internally, and then inspects the parsed components to locate NLC (VV10-like) entries. Providing a code that contains the deprecated substring '__VV10' causes a RuntimeError; otherwise the string is forwarded to parse_xc and must therefore follow the same syntactic conventions expected by parse_xc.
    
    Returns:
        tuple: A tuple of 2-tuples (name, factor) listing the nonlocal-correlation components found in xc_code. 'name' is the value looked up from the module-level VV10_XC mapping using the parsed numeric id (xid) and typically identifies the specific VV10/NLC variant; 'factor' is the numeric multiplicative factor (as returned by parse_xc) to apply to that NLC component when assembling the total nonlocal-correlation contribution. The order of entries follows the order of components returned by parse_xc. If no NLC components are present in xc_code, an empty tuple is returned.
    
    Behavior, side effects, defaults, and failure modes:
    - The function is pure (no side effects) and does not mutate global state; it only reads the parse_xc result and the VV10_XC mapping.
    - Input handling: xc_code is normalized to upper case before parsing to make matching case-insensitive.
    - Deprecation check: if the substring '__VV10' appears in the provided xc_code (after upper-casing), the function raises RuntimeError with the message 'Deprecated notation for NLC functional.' This enforces that callers do not use the old/deprecated notation for VV10-style NLC.
    - Parsing errors from parse_xc are propagated to the caller; callers should ensure xc_code is valid per parse_xc's conventions.
    - If a parsed xid >= 5000 is encountered but not present in the VV10_XC mapping, a KeyError may be raised when attempting to look up VV10_XC[xid].
    - The function returns an empty tuple when no NLC (xid >= 5000) components are found; callers should handle this case when assembling nonlocal-correlation contributions in DFT energy and potential code.
    """
    from pyscf.dft.xcfun import nlc_coeff
    return nlc_coeff(xc_code)


################################################################################
# Source: pyscf.dft.xc_deriv.transform_vxc
# File: pyscf/dft/xc_deriv.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_xc_deriv_transform_vxc(
    rho: numpy.ndarray,
    vxc: list,
    xctype: str,
    spin: int = 0
):
    """Transform libxc functional derivatives into the derivative tensor of density-related parameters used by PySCF for grid-based exchange–correlation (XC) potential assembly.
    
    This function takes the raw derivative arrays returned by a libxc-like evaluator (vxc) and arranges / contracts them with the local density parameter array (rho) to produce the XC derivative tensor vp. The output vp is the derivative of the XC energy density with respect to the local parameters stored in rho (density, gradient components, and kinetic-energy density tau), in the ordering and shapes expected by downstream PySCF DFT code that assembles potentials on integration grids.
    
    Args:
        rho (numpy.ndarray): Array of local density-related parameters at each integration grid point. The last axis indexes grid points (ngrids = rho.shape[-1]). The preceding axis/axes index parameter channels and, for spin-polarized data, spin channels. The function expects the channel ordering to be: density, (nabla_x), (nabla_y), (nabla_z), tau. Concretely, for spin-polarized input rho should provide values for both spin channels in the first axis (e.g., shape like [2, nchannels, ngrids]), and for spin-unpolarized input rho should provide only channel axes (e.g., shape like [nchannels, ngrids]). The array is converted to a C-contiguous numpy.ndarray internally (np.asarray(rho, order='C')), so callers should provide numeric arrays consistent with this layout. Supplying an array with an incompatible number of channels or a mismatched ngrids compared to vxc will raise shape/broadcasting errors during computation.
        vxc (list): List of numpy arrays containing functional derivatives returned by a libxc/XC backend. The function accesses vxc[0] (fr) for the derivative with respect to the density and, for GGA and MGGA functionals, vxc[1] (fg) for derivatives with respect to gradient invariants. For MGGA, vxc[3] (ft) is used for derivatives with respect to tau. These arrays are transposed with .T inside the function to match the grid-major ordering used here. The caller must supply the entries required for the specified xctype; missing indices (e.g., vxc[1] for a GGA) will raise an IndexError.
        xctype (str): Functional class identifier specifying which derivative components are present in vxc and which output channels to produce. Recognized values handled explicitly are 'LDA', 'GGA', and 'MGGA'. 'GGA' indicates first-order gradient dependence (order = 1, nvar = 4), 'MGGA' indicates second-order dependence including tau (order = 2, nvar = 5), and any other value is treated as LDA (order = 0, nvar = 1) by this implementation. The choice of xctype controls how fr, fg, and ft from vxc are interpreted and combined with rho.
        spin (int): Spin flag indicating whether rho and the returned derivative tensor are spin-polarized. spin == 1 selects spin-polarized behavior and returns a tensor with a leading spin axis; any value other than 1 (default 0) is treated as spin-unpolarized. The default spin=0 produces the unpolarized code path. Passing an integer other than 0 or 1 will follow the unpolarized branch (i.e., only spin==1 triggers the polarized branch).
    
    Behavior and practical significance:
        - The function converts rho to a C-contiguous numpy.ndarray to ensure predictable memory layout for subsequent operations.
        - For LDA (order = 0), only density derivatives (fr) are used and the result contains only density-channel derivatives.
        - For GGA (order = 1), fr and fg are used. In the unpolarized case the gradient-channel contributions are computed as 2 * fg * rho[1:4] (matching how gradient invariants enter the derivative with respect to gradient components). In the spin-polarized case the helper _stack_fg is invoked to form the correct spin-resolved contraction of fg with rho[:,1:4].
        - For MGGA (order = 2) the tau-derivative component ft (vxc[3].T) is placed into the tau channel of the output as vp[...,4,...].
        - The function constructs vp with shapes and channel ordering that downstream PySCF routines expect for assembling the XC potential and its derivatives on grids; this mapping is essential for correct potential assembly and energy/force evaluation in grid-based DFT workflows.
        - The function does not modify its inputs in-place (rho is converted to a contiguous copy if necessary), but it returns a newly allocated numpy.ndarray vp.
    
    Defaults and failure modes:
        - Default: spin=0 (unpolarized). xctype values other than 'GGA' or 'MGGA' are treated as 'LDA'.
        - If vxc does not contain the entries required for the chosen xctype (for example, missing vxc[1] when xctype == 'GGA'), an IndexError will occur. If the grid dimension (ngrids) implied by rho differs from that implied by vxc entries, broadcasting or shape errors (ValueError) may arise during array assignments or multiplications. If rho contains non-numeric data, np.asarray will raise a TypeError or produce an array that later causes arithmetic errors.
        - The function relies on an internal helper _stack_fg for the spin-polarized GGA contraction; if that helper is not available or fails for the given fg and rho shapes, an exception will propagate to the caller.
    
    Returns:
        numpy.ndarray: The derivative tensor vp containing XC functional derivatives organized with respect to the rho parameter ordering (density, nabla_x, nabla_y, nabla_z, tau) and grid points. The exact returned shape depends on xctype and spin:
        - Spin-polarized (spin == 1):
            LDA : shape [2, 1, N] (two spin channels, one channel per spin, N grids)
            GGA : shape [2, 4, N] (two spin channels, four channels per spin: density + 3 gradient components)
            MGGA: shape [2, 5, N] (two spin channels, five channels per spin: density + 3 gradients + tau)
        - Spin-unpolarized (spin != 1):
            LDA : shape [1, N] (one density channel across N grids)
            GGA : shape [4, N] (four channels: density + 3 gradient components)
            MGGA: shape [5, N] (five channels: density + 3 gradients + tau)
        The dtype of vp follows the numeric types present in vxc (fr/fg/ft), and the array is allocated in standard C order.
    """
    from pyscf.dft.xc_deriv import transform_vxc
    return transform_vxc(rho, vxc, xctype, spin)


################################################################################
# Source: pyscf.dft.xcfun.define_xc
# File: pyscf/dft/xcfun.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_xcfun_define_xc(
    ni: int,
    description: str,
    xctype: str = "LDA",
    hyb: float = 0,
    rsh: tuple = (0, 0, 0)
):
    """Define an exchange–correlation (XC) functional in the XCFun wrapper used by PySCF's DFT modules.
    
    This is a thin wrapper that delegates to the compiled function define_xc_. The call performed is define_xc_(ni.copy(), description, xctype, hyb, rsh). The function constructs or registers an XC functional description in the XCFun backend so that PySCF can evaluate XC energies, potentials, and response properties during density-functional calculations. The implementation makes a defensive shallow copy of the provided ni value (via ni.copy()) before forwarding it to the underlying binding to avoid mutating caller-owned data structures.
    
    Args:
        ni (int): Numeric identifier or specification used by the underlying XCFun binding to describe the numerical index or auxiliary specification for the functional. In the PySCF/XCFun integration this value is forwarded (after a shallow copy with ni.copy()) to the compiled define_xc_ routine. The copy is intended to prevent mutation of caller-provided objects when ni is a mutable object that implements copy(); if ni is provided as an immutable integer the numeric value is forwarded to the backend for selection/identification of the functional.
        description (str): Textual description string understood by XCFun that specifies the functional form, parameters, or name. This string is used by XCFun to construct the exchange–correlation model (for example, names or parameter lists that XCFun recognizes). The description therefore directly determines which XC functional PySCF will use for energy and potential evaluations.
        xctype (str): Category or type of the exchange–correlation functional as a short string (default "LDA"). This value labels the functional class passed to XCFun (for example a local-density approximation vs. generalized-gradient approximation) and affects how the backend interprets the description and computes derivatives.
        hyb (float): Fraction of exact (Hartree–Fock) exchange to mix into the functional. The default 0 indicates no exact exchange. This floating-point coefficient is forwarded to the XCFun backend and therefore influences the exchange contribution computed during DFT calculations.
        rsh (tuple): Range-separation parameters provided as a tuple (default (0, 0, 0)). These three parameters are forwarded unchanged to the XCFun binding and control long/short-range separation behavior for range-separated hybrid functionals when applicable. The tuple is treated as opaque by this wrapper and interpreted by the underlying XCFun implementation.
    
    Returns:
        object: Opaque handle returned by the underlying define_xc_ routine that represents the defined exchange–correlation functional in the XCFun backend. PySCF DFT routines and other xcfun wrappers use this handle to evaluate XC energies, potentials, and higher-order derivatives. Treat this return value as an opaque token created and managed by the XCFun wrapper; it may encapsulate internal C-level resources or registration state.
    
    Notes:
        - Side effects: The call may register the functional or allocate backend resources inside the XCFun binding; callers should retain the returned handle for subsequent evaluations and let the higher-level API manage resource lifetime.
        - Defensive copy: The implementation attempts ni.copy() to avoid mutating caller data; therefore, if ni is a mutable object with a copy() method the wrapper will use a shallow copy. If ni is a plain immutable integer, the numeric value is forwarded to the backend.
        - Failure modes: Errors are propagated from the underlying XCFun/define_xc_ implementation. Typical failures include invalid or unrecognized description strings, unsupported xctype values, or incompatible hyb/rsh parameter combinations; such errors raise exceptions from the compiled binding and should be handled by the caller.
    """
    from pyscf.dft.xcfun import define_xc
    return define_xc(ni, description, xctype, hyb, rsh)


################################################################################
# Source: pyscf.dft.xc_deriv.transform_lxc
# File: pyscf/dft/xc_deriv.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_xc_deriv_transform_lxc(
    rho: numpy.ndarray,
    fxc: numpy.ndarray,
    kxc: numpy.ndarray,
    lxc: numpy.ndarray,
    xctype: str,
    spin: int = 0
):
    """pyscf.dft.xc_deriv.transform_lxc transforms libxc/xcfun vxc functional output into the derivative tensor with respect to the local parameter vector rho used by PySCF DFT code. The function maps the functional derivative arrays produced by libxc (fxc, kxc, lxc) onto the internal ordering of density-related parameters rho = [density, nabla_x, nabla_y, nabla_z, tau], producing a tensor used by PySCF to assemble exchange–correlation kernels and response quantities.
    
    Args:
        rho (numpy.ndarray): Input parameter array corresponding to the local density variables used in PySCF, ordered as [density, nabla_x, nabla_y, nabla_z, tau]. In the context of PySCF DFT and libxc/XCFun interoperability, this array represents the set of local scalar and vector densities at grid points or basis-function evaluations. The function uses the ordering and role of these components to place derivative contributions from libxc into the correct slots of the output tensor.
        fxc (numpy.ndarray): Array containing the second derivatives of the exchange–correlation energy with respect to density-like variables as returned by libxc/XCFun vxc routines (commonly denoted f_xc in literature). In practice this array encodes how the exchange–correlation potential responds to changes in the basic local parameters; transform_lxc redistributes these entries into the output derivative tensor following the rho ordering.
        kxc (numpy.ndarray): Array containing derivative components related to gradient-dependent parts of the functional as provided by libxc/XCFun vxc output. For GGA and MGGA functionals, libxc supplies contributions that couple gradient and kinetic-energy-density terms; kxc provides these quantities and transform_lxc arranges them into the parameter-derivative tensor consistent with PySCF internal conventions.
        lxc (numpy.ndarray): Array containing higher-order derivative contributions from libxc/XCFun vxc (for example, derivatives coupling different rho components required for MGGA-level response). transform_lxc integrates lxc entries into the final output tensor so that all libxc-provided coupling terms appear in the correct positions relative to rho.
        xctype (str): String indicating the exchange–correlation functional class produced by libxc/XCFun. Valid values expected by this routine correspond to the functional families documented in the codebase: 'LDA' for local density approximation, 'GGA' for generalized gradient approximation, and 'MGGA' for meta-GGA. The xctype controls the number of rho parameters present and therefore the shape of the output derivative tensor.
        spin (int): Integer flag selecting spin treatment. The default is 0. In PySCF conventions used here, spin == 0 denotes spin-unpolarized (single-component) treatment and spin != 0 denotes spin-polarized (two-component) treatment. This flag determines whether the output tensor includes separate spin channels (spin-polarized shapes) or a single combined channel (spin-unpolarized shapes).
    
    Returns:
        numpy.ndarray: The derivative tensor that maps libxc/XCFun vxc outputs (fxc, kxc, lxc) onto the parameter ordering of rho. The tensor shape depends on xctype and spin as follows (these shapes reflect PySCF internal layout for constructing XC kernels and response contributions):
        - For spin-polarized calculations (spin != 0)
            LDA : [2,1,2,1,2,1,2,1,N]
            GGA : [2,4,2,4,2,4,2,4,N]
            MGGA: [2,5,2,5,2,5,2,5,N]
        - For spin-unpolarized calculations (spin == 0)
            LDA : [1,1,1,1,N]
            GGA : [4,4,4,4,N]
            MGGA: [5,5,5,5,N]
        Here N denotes the number of spatial points or grid evaluations corresponding to the trailing dimension in the input arrays. The returned numpy.ndarray is intended for direct use in PySCF routines that assemble exchange–correlation matrices and response kernels from libxc/XCFun derivative data.
    
    Behavior and failure modes:
        - Intended behavior: transform_lxc reorders and combines entries from fxc, kxc, and lxc according to the rho parameter ordering so that downstream PySCF code can treat the result as the derivative tensor ∂^2E_xc/∂rho_i∂rho_j (and related couplings) at each grid point.
        - Defaults: spin defaults to 0 (spin-unpolarized). xctype selects between LDA, GGA, and MGGA shapes as documented above.
        - Side effects: None on inputs; the function returns a new numpy.ndarray. The tensor is computed to match PySCF internal indexing conventions for XC kernels and is used by PySCF DFT modules when interacting with libxc/XCFun.
        - Failure modes: The function must be provided with fxc, kxc, lxc arrays whose trailing dimension length matches the number of grid points N implied by rho. Mismatched shapes between rho and the derivative arrays will result in errors during transformation. Supplying an xctype value outside the documented set ('LDA', 'GGA', 'MGGA') or an unexpected spin convention may result in incorrect shapes or a raised exception. As implemented in this version of the source, the function is not yet implemented and will raise NotImplementedError if called; callers should expect this exception until a full implementation is provided.
    """
    from pyscf.dft.xc_deriv import transform_lxc
    return transform_lxc(rho, fxc, kxc, lxc, xctype, spin)


################################################################################
# Source: pyscf.dft.xcfun.rsh_coeff
# File: pyscf/dft/xcfun.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_xcfun_rsh_coeff(xc_code: str):
    """pyscf.dft.xcfun.rsh_coeff: Extract range-separated-hybrid (RSH) parameters from an exchange–correlation functional code.
    
    Args:
        xc_code (str): A functional identifier string understood by PySCF's XC parsing utilities (the same kind of string passed to density-functional calculations and to XCFun). This string encodes a composite exchange–correlation functional and may specify a range-separated-hybrid (RSH) form. In the context of PySCF and XCFun, xc_code is used to select and configure the functional whose RSH coefficients are required for evaluating exchange and correlation energies and potentials. The function forwards this string to parse_xc(xc_code) to extract hybrid information.
    
    Behavior and practical significance:
        This function parses the provided functional identifier and returns three numeric coefficients needed to configure range-separated-hybrid functionals in DFT calculations and when driving the XCFun functional library. Internally, parse_xc(xc_code) is called and is expected to return hybrid information from which the following are derived:
        - hyb is the total fraction of Hartree–Fock (HF) exchange implied by the functional specification (the overall HF mixing).
        - alpha is the short-range HF exchange component extracted from parse_xc.
        - beta is computed as hyb - alpha and therefore represents the complementary HF exchange contribution (so that alpha + beta equals the overall hyb fraction).
        The returned omega is the range-separation parameter (typically an inverse length scale) that controls how the Coulomb operator is partitioned into short- and long-range parts when evaluating screened or range-separated exchange. These values are used directly when setting up RSH hybrids for energy and potential evaluations with XCFun or PySCF DFT routines.
    
    Side effects, defaults, and failure modes:
        - There are no external side effects: the function only computes and returns numeric coefficients and does not modify global state or write files.
        - The function relies on parse_xc to interpret xc_code; if xc_code is not a valid functional identifier or does not encode the expected hybrid structure, parse_xc may raise an exception (for example, ValueError or a parsing-specific error raised by the XC parser). Consumers should handle such exceptions when calling this function.
        - If the parsed hybrid tuple does not unpack into the expected three values (hyb, alpha, omega), a Python unpacking error will occur. This indicates that the supplied xc_code does not describe a range-separated-hybrid functional in the expected format.
        - No implicit defaults for omega, alpha, or beta are created by this function; all returned values are derived from the parsed xc_code.
    
    Returns:
        tuple of float: A 3-tuple (omega, alpha, beta) where
            omega (float): The range-separation parameter (inverse length scale) controlling short-/long-range partitioning of exchange.
            alpha (float): The short-range Hartree–Fock exchange coefficient extracted from the functional specification; this is the fraction of HF exchange applied to the short-range part.
            beta (float): The remaining Hartree–Fock exchange coefficient computed as (total_hyb - alpha); when combined with alpha it yields the total HF exchange fraction implied by the functional. These numeric coefficients are intended to be used to configure RSH functionals in downstream DFT/XCFun evaluations.
    """
    from pyscf.dft.xcfun import rsh_coeff
    return rsh_coeff(xc_code)


################################################################################
# Source: pyscf.dft.xc_deriv.transform_kxc
# File: pyscf/dft/xc_deriv.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_xc_deriv_transform_kxc(
    rho: numpy.ndarray,
    fxc: list,
    kxc: list,
    xctype: str,
    spin: int = 0
):
    """Transform libxc/XCFun kernel derivatives into the derivative tensor of the
    rho parameters used by PySCF density-functional integration routines.
    
    This function is used inside the PySCF DFT pipeline to convert the raw
    functional derivative arrays produced by external density-functional libraries
    (e.g. LibXC or XCFun) into the structured derivative tensor indexed by the
    local variables that PySCF stores per integration grid point. The rho parameter
    vector referenced throughout this function corresponds to the per-grid-point
    quantities in the order: density_a, (nabla_x)_a, (nabla_y)_a, (nabla_z)_a,
    tau_a for spin channel a (and similarly for spin channel b when spin=1). The
    output tensor produced by transform_kxc is the kernel of second/third/... order
    derivatives organized consistently with the rho parameter ordering; this tensor
    is consumed by PySCF routines that assemble weighted integrals of functional
    derivatives across grids to form potentials, response contributions, and
    higher-order terms in DFT calculations.
    
    Args:
        rho (numpy.ndarray): Array of per-grid variables provided by the caller.
            The last axis indexes grid points (ngrids = rho.shape[-1]). The function
            expects the array to contain at least the density component and the
            three gradient components at indices 1:4 (i.e. rho[:,1:4] is used) and,
            for meta-GGA (MGGA) functionals, the kinetic-energy-density (tau)
            component at index 4. The function converts rho with numpy.asarray(...,
            order='C') so a contiguous array will be used internally. rho is not
            modified by this function. In PySCF, rho is the local descriptor that
            encodes the information (density, gradients, tau) required by the
            exchange-correlation functional; transform_kxc maps functional kernels
            onto derivatives with respect to these descriptors for each grid point.
        fxc (list): List of first- and second-order functional derivative arrays
            returned by the external functional library (LibXC/XCFun) for the
            chosen functional. The code accesses specific indices depending on the
            functional type: for GGA the function expects entries at indices 1 and
            2 (fxc[1], fxc[2]); for MGGA it expects indices 1, 2 and 9 (fxc[1],
            fxc[2], fxc[9]). The arrays in fxc are transposed inside this function
            (fxc[i].T) to align their axes with the grid ordering used by PySCF.
            These fxc entries represent first/second derivatives of the energy
            density with respect to the local rho variables and are required to
            build the final derivative tensor.
        kxc (list): List of higher-order kernel derivative arrays (third- and
            higher-order kernels) produced by the external functional library. The
            mapping from kxc indices to the internal tensor components depends on
            xctype. For GGA the function reads kxc[:4] (kxc[0..3]). For MGGA it
            reads the subset of indices [0, 1, 2, 3, 5, 7, 10, 12, 15, 19] which
            correspond to the third- and mixed-order kernels needed for MGGA
            assembly. For LDA the function uses kxc[0] only. The arrays in kxc are
            transposed inside this function (kxc[i].T) prior to tensor assembly.
            kxc holds the raw kernel tensors from LibXC/XCFun; transform_kxc
            restructures and contracts them with rho components (when necessary)
            to produce the final derivative tensor per grid point.
        xctype (str): Type of exchange-correlation functional; determines how many
            local variables and which kernel entries are required. Accepted values
            (case-sensitive strings) used by this function are 'LDA', 'GGA', and
            'MGGA'. The behavior is:
            - 'LDA': local-density approximation; order = 0 and a single local
              variable (density) is used; only kxc[0] is read.
            - 'GGA': generalized-gradient approximation; order = 1 and four local
              variables (density + three gradient components) are used; fxc[1],
              fxc[2], and kxc[:4] are read.
            - 'MGGA': meta-GGA; order = 2 and five local variables (density,
              three gradients, tau) are used; fxc[1], fxc[2], fxc[9], and the
              MGGA-specific subset of kxc indices are read. If xctype is not one
            of these strings, the function takes the code path labeled LDA (i.e. it
            will behave like 'LDA'). The exact indexing of fxc and kxc follows the
            conventions used by the PySCF xc_deriv utilities and the external
            functional library outputs.
        spin (int = 0): Integer flag selecting spin treatment. The default is 0
            (spin-unpolarized / non-spin-polarized), which causes the function to
            return an unpolarized derivative tensor of shape appropriate for the
            chosen xctype. If spin == 1 the function treats data as spin-polarized
            (collinear two-spin-channel data) and assembles a tensor that encodes
            derivatives for both spin channels and their couplings. Values other
            than 0 or 1 are not explicitly checked; the implementation only checks
            equality to 1 to select the spin-polarized branch, so other integers
            will follow the unpolarized code path and may lead to incorrect
            results if the provided rho/fxc/kxc correspond to spin-polarized data.
    
    Behavior and side effects:
        The function creates a new numpy.ndarray (vp) that contains the derivative
        tensor assembled from fxc and kxc, performing transpositions and explicit
        contractions with components of rho when required by the functional type.
        For GGA and MGGA functionals the function contracts gradient-related
        kernel tensors with rho[:,1:4] to build symmetric tensor components; for
        MGGA additional contractions with the kinetic-energy-density component
        (tau) are performed. The function uses helper routines in the xc_deriv
        module (e.g. _stack_fggg, _stack_fgg, _stack_fg, _stack_frr, _stack_frrr)
        to reshape and stack kernel blocks before the final assembly. The input
        arrays fxc and kxc are not modified by transform_kxc; rho is converted to a
        contiguous numpy array via numpy.asarray(..., order='C') but not otherwise
        mutated. No global state is modified.
    
    Failure modes and correctness notes:
        The function does not raise explicit exceptions for malformed inputs; common
        failure or incorrect-result modes are: providing fxc or kxc lists that do
        not contain the indices the function expects for the selected xctype,
        supplying rho arrays that do not include the gradient components at
        indices 1:4 (or tau at index 4 for MGGA), or passing spin-polarized kernel
        arrays while selecting spin=0 (or vice versa). Such mismatches will result
        in index errors, shape broadcast errors, or silently incorrect tensor
        contents. The caller is responsible for providing fxc and kxc arrays that
        follow the PySCF/external-library ordering conventions documented in the
        PySCF xc_deriv interface and in the external library documentation (LibXC/
        XCFun).
    
    Returns:
        numpy.ndarray: The assembled derivative tensor (vp) mapping derivatives of
        the exchange-correlation energy density onto derivatives with respect to
        the rho parameter vector used by PySCF per grid point. The shape of the
        returned array depends on xctype and spin. For spin-polarized data
        (spin == 1) the output shapes (as presented by this function) are:
        - LDA : [2,1,2,1,2,1,N]
        - GGA : [2,4,2,4,2,4,N]
        - MGGA: [2,5,2,5,2,5,N]
        For spin-unpolarized data (spin != 1, default) the output shapes are:
        - LDA : [1,1,1,N]
        - GGA : [4,4,4,N]
        - MGGA: [5,5,5,N]
        where N is the number of grid points (ngrids = rho.shape[-1]). The tensor
        entries are ordered to correspond to derivatives with respect to the rho
        parameters in the sequence (density, nabla_x, nabla_y, nabla_z, tau)
        per spin channel when present. The returned array is a new numpy.ndarray
        and must be consistent with the PySCF integration machinery that consumes
        these kernel derivatives.
    """
    from pyscf.dft.xc_deriv import transform_kxc
    return transform_kxc(rho, fxc, kxc, xctype, spin)


################################################################################
# Source: pyscf.dft.xcfun.eval_xc1
# File: pyscf/dft/xcfun.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_xcfun_eval_xc1(
    xc_code: str,
    rho: numpy.ndarray,
    spin: int = 0,
    deriv: int = 1,
    omega: float = None
):
    """pyscf.dft.xcfun.eval_xc1 evaluates an exchange-correlation (XC) functional and its derivatives by calling the XCFun backend via PySCF's xcfun wrapper. This function is used in PySCF density-functional calculations to obtain the XC energy density and higher-order derivatives on a set of real-space integration grid points; the output ordering of derivative components follows the XCFun convention used by the underlying C library. The implementation accepts local, semi-local, and hybrid functionals (types 'HF', 'LDA', 'GGA', 'MGGA') and supports up to MAX_DERIV_ORDER derivatives as asserted at runtime.
    
    Args:
        xc_code (str): Functional specification string understood by PySCF/ XCFun (for example, names parsed by parse_xc). This string determines which XC functional(s) are evaluated, how hybrid mixing factors and range-separation parameters are interpreted, and which XCFun internal function identifiers (fn_ids) and factors (facs) are passed to the XCFun C routine. The function will call parse_xc(xc_code) internally to extract hybrid parameters and component function identifiers.
        rho (numpy.ndarray): Input density array provided on integration grid points. This array is coerced to numpy.asarray(..., order='C', dtype=numpy.double) before use. For non-spin-polarized functionals (spin=0) rho is expected to contain the density-related variables arranged so that the final axis indexes grid points; for spin-polarized cases (spin=1) rho must contain spin-resolved variables accordingly. For meta-GGA (xctype == 'MGGA') if rho.shape[-2] == 6 the code will internally select components rho[..., [0,1,2,3,5], :] to match the MGGA variable ordering expected by XCFun. The last axis of rho is interpreted as the number of grid points (ngrids).
        spin (int): Spin flag used to select variable count and ordering from xc_deriv._XC_NVAR. Typical values are 0 for spin-unpolarized (restricted) and 1 for spin-polarized (unrestricted) evaluations. The chosen spin value affects nvar and xlen (internal variable counts) and therefore the reshape/mapping of rho into shape (spin+1, nvar, ngrids) before calling XCFun.
        deriv (int): Highest derivative order to evaluate (an integer). The function asserts deriv <= MAX_DERIV_ORDER and will raise an AssertionError if the requested derivative order exceeds the compiled/allowed maximum. The number of derivative components returned per grid point is computed as comb(xlen + deriv, deriv) where xlen depends on xctype and spin via xc_deriv._XC_NVAR.
        omega (float): Optional global range-separation parameter. If provided (not None), the single float value overrides the per-functional omega returned by parse_xc and is used for all component functionals. If hyb[2] (the parsed omega) is non-zero but multiple RSH components exist, the implementation currently duplicates the same omega value for each component (i.e., different omegas per component are not supported). If omega is None, the per-component omegas determined by parse_xc are used (or zeroed when no range separation applies).
    
    Returns:
        numpy.ndarray: A 2-D array of dtype numpy.double containing the evaluated XC derivatives arranged following XCFun's convention and transposed by PySCF before return. The returned array has shape (outlen, ngrids) where ngrids is the number of grid points inferred from rho.shape[-1], and outlen = comb(xlen + deriv, deriv) is the number of derivative components per grid point determined by the functional type (xctype) and spin. Each column corresponds to a grid point and each row corresponds to a specific derivative component in XCFun ordering (e.g., energy density, first derivatives, mixed derivatives up to the requested order).
    
    Behavior and side effects:
        - The function coerces rho to C-contiguous numpy.double, and for MGGA with six variables in the second-to-last axis it will reorder/select variables to match XCFun expectations.
        - parse_xc(xc_code) is invoked to extract hybrid mixing (hyb) and a list of (fn_id, factor) pairs (fn_facs); these determine which XCFun components are evaluated and with what scaling.
        - If hyb indicates a non-zero omega and multiple RSH components are present, the implementation sets the same omega value for all components (per-code comment: different omegas per RSH are not supported).
        - The function calls the underlying C routine _itrf.XCFUN_eval_xc to perform the evaluation; this is the primary external side effect.
        - The output is allocated as a numpy array and transposed before return to produce shape (outlen, ngrids).
    
    Failure modes and exceptions:
        - AssertionError is raised if deriv > MAX_DERIV_ORDER or if the parsed functional type is not one of ('HF', 'LDA', 'GGA', 'MGGA').
        - RuntimeError is raised if the XCFun C call (_itrf.XCFUN_eval_xc) returns a non-zero error code (indicates the backend failed to evaluate the requested functional/derivative).
        - TypeError or ValueError may be raised by numpy.asarray(...) if rho cannot be coerced to the required dtype/shape, or by downstream lookups if rho does not have the expected dimensionality (e.g., missing grid axis).
        - No attempt is made to validate that different component functionals accept distinct omegas; supplying a per-component omega is not supported by this wrapper.
    
    Note:
        - This function is intended for use within PySCF density-functional workflows that require XCFun-evaluated XC energies and response derivatives on numerical integration grids. It exposes the XCFun ordering and derivative conventions directly; callers must interpret the returned derivative-component ordering according to XCFun's documented layout.
    """
    from pyscf.dft.xcfun import eval_xc1
    return eval_xc1(xc_code, rho, spin, deriv, omega)


################################################################################
# Source: pyscf.fci.addons.civec_spinless_repr
# File: pyscf/fci/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_addons_civec_spinless_repr(ci0_r: list, norb: int, nelec_r: list):
    """pyscf.fci.addons.civec_spinless_repr converts a set of CAS-CI vectors from a spin-pure representation into a spinless representation so they can be linearly combined across different spin projections M. In the context of PySCF's FCI add-ons, this is used to map a problem with norb spatial orbitals and separate alpha/beta electron counts (neleca, nelecb) into an equivalent spinless problem with 2 * norb orbitals and (neleca+nelecb, 0) electron partitioning. The function preserves the input array datatype, makes copies of the converted vectors, and returns a stacked ndarray containing the spinless CAS-CI vectors for subsequent CAS-CI manipulations or post-processing that require a common spinless basis.
    
    Args:
        ci0_r (sequence or generator of ndarray of length nprods): CAS-CI vectors in the spin-pure representation. Each element corresponds to a CAS-CI vector for one product (one element of the input set) and must match the corresponding electron counts given in nelec_r. The sequence may be a concrete sequence (list, tuple) or a generator; the function will iterate the generator via civec_spinless_repr_generator and will copy each yielded ndarray into memory. In PySCF workflows this input typically comes from CAS-CI state vectors computed for specific (neleca, nelecb) partitions.
        norb (integer): Number of spatial orbitals in the original spin-pure representation. Practically, this function will map norb -> 2 * norb in the spinless representation (each spatial orbital is expanded into two spin-orbitals in the spinless mapping used here). The caller must supply the same norb that was used to generate the ci0_r vectors.
        nelec_r (sequence of tuple of length (2)): A sequence with one tuple (neleca, nelecb) per element of ci0_r describing the number of alpha (neleca) and beta (nelecb) electrons for that CAS-CI vector in the spin-pure representation. For each tuple, the function maps (neleca, nelecb) -> (neleca+nelecb, 0) in the spinless representation. The ordering and length of nelec_r must match ci0_r; mismatches will cause errors during generation/stacking.
    
    Returns:
        ci1_r (ndarray of shape (nprods, ndet_spinless)): Spinless CAS-CI vectors stacked along the first axis. nprods equals the number of input CI vectors provided by ci0_r, and ndet_spinless is the number of determinants in the spinless basis produced by the underlying civec_spinless_repr_generator for the doubled orbital count and total electron numbers (neleca+nelecb). The returned array is constructed by copying each vector yielded by the generator and stacking them with numpy.stack; the original ci0_r objects are not modified and the dtype of the vectors is preserved.
    
    Behavior and side effects:
        This function calls civec_spinless_repr_generator(ci0_r, norb, nelec_r) to produce a generator of converted vectors, copies each ndarray produced by that generator, and returns a single stacked ndarray. Because copies are made and the orbital count is effectively doubled (norb -> 2*norb), memory usage can increase substantially compared to the input representation. The function does not perform in-place modification of inputs and does not change the numpy dtype of the CI vectors.
    
    Failure modes and notes:
        If ci0_r and nelec_r have mismatched lengths, if norb is not an integer, or if elements yielded from the generator are not ndarrays of consistent shape, numpy.stack or the generator will raise an exception, which is propagated to the caller. Large systems may exhaust memory (MemoryError) because ndet_spinless can be much larger than the original number of determinants. This function is intended for situations where one needs to form linear combinations of CAS-CI vectors with different spin projections M by mapping them into a common spinless representation; use with caution for large norb or large total electron counts due to increased memory cost.
    
    Additional implementation detail:
        The function preserves the input dtype (it "does NOT change the datatype") and relies on civec_spinless_repr_generator to perform the element-wise mapping; it then copies each yielded ndarray and stacks them along axis 0 to form the final return array.
    """
    from pyscf.fci.addons import civec_spinless_repr
    return civec_spinless_repr(ci0_r, norb, nelec_r)


################################################################################
# Source: pyscf.fci.addons.cre_b
# File: pyscf/fci/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_addons_cre_b(ci0: numpy.ndarray, norb: int, neleca_nelecb: tuple, ap_id: int):
    """pyscf.fci.addons.cre_b constructs an (N+1)-electron configuration-interaction (CI) wavefunction by applying a beta-spin electron creation operator to an input N-electron CI wavefunction. This routine is part of the PySCF FCI addons used to manipulate CI coefficient arrays expressed in the occupation-string basis (rows index alpha strings, columns index beta strings). It maps each input beta string to the newly created beta string indices using cistring.gen_cre_str_index and applies the fermionic sign factors; an additional sign flip is applied when the number of alpha electrons is odd to account for operator interchange between alpha and beta spins.
    
    Args:
        ci0 (numpy.ndarray): CI coefficients of the input N-electron wavefunction. Expected to be a 2D array with rows for alpha occupation strings and columns for beta occupation strings. If a 1D array is provided, the function will attempt to reshape it to shape (num_strings(norb, neleca), num_strings(norb, nelecb)) where num_strings is cistring.num_strings. The function does not modify the logical contents of the input array (it binds a local reshaped view/copy when needed), but an incompatible 1D shape will raise the same exceptions as numpy.reshape.
        norb (int): Number of spatial orbitals (norb). This is the size of the single-particle orbital basis used to enumerate occupation strings. It determines the domain of valid orbital indices for the creation operator and is forwarded to cistring helper routines.
        neleca_nelecb (tuple): Tuple (neleca, nelecb) of two integers specifying the number of alpha (neleca) and beta (nelecb) electrons in the input CI function. These values are used to (1) determine expected string counts via cistring.num_strings and (2) select the appropriate creation-index table for adding a beta electron (nelecb -> nelecb+1).
        ap_id (int): Orbital index (0-based) at which the beta creation operator acts. This is an integer in the range of orbital labels [0, norb-1]. If ap_id does not match any created-orbital entry in the generated creation-index table (for example, if ap_id is outside 0..norb-1), the function produces a zero wavefunction for the attempted creation (see Returns). ap_id is interpreted exactly as an orbital label; no implicit wrapping or modulo is applied.
    
    Returns:
        numpy.ndarray: CI coefficient array for the (N+1)-electron wavefunction. Under the normal successful path this is a 2D array with the same number of rows as the input (number of alpha strings, cistring.num_strings(norb, neleca)) and with columns equal to cistring.num_strings(norb, nelecb+1) (the number of beta strings after adding one beta electron). Each output column is filled by transferring the appropriate input column(s) indexed via cistring.gen_cre_str_index and multiplied by the fermionic sign factor returned by that helper; additionally, if neleca is odd, the sign is flipped to account for the interchange of creation operators between alpha and beta spins. Special-case behavior: if nelecb >= norb (no available orbital to add another beta electron), the function returns numpy.zeros_like(ci0) immediately; note that this preserves the dimensionality and shape of the provided ci0 (so a 1D ci0 produces a 1D zeros array). The function returns a new array (ci1) and does not mutate the caller's ci0 contents.
    
    Notes, side effects, and failure modes:
        - The routine relies on cistring.gen_cre_str_index and cistring.num_strings to enumerate occupation strings and creation mappings; errors raised by those helpers (or by numpy.reshape for incompatible 1D input shapes) propagate to the caller.
        - If ci0 is 1D, the function will attempt to reshape it to the expected 2D layout; an incompatible length will raise ValueError from numpy.reshape.
        - If ap_id is outside the valid orbital index range [0, norb-1], no creation entries will match and the returned CI coefficients will be all zeros (same behavior as attempting to create a beta electron when nelecb >= norb).
        - The returned coefficients include sign conventions consistent with PySCF's second-quantized ordering; users should ensure their CI basis ordering matches cistring's conventions when interpreting or combining outputs.
    """
    from pyscf.fci.addons import cre_b
    return cre_b(ci0, norb, neleca_nelecb, ap_id)


################################################################################
# Source: pyscf.fci.addons.cre_a
# File: pyscf/fci/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_addons_cre_a(ci0: numpy.ndarray, norb: int, neleca_nelecb: tuple, ap_id: int):
    """Construct (N+1)-electron CI wavefunction by applying an alpha-electron creation operator to an N-electron CI wavefunction in PySCF's FCI addon.
    
    This function is used in the pyscf.fci.addons module to build the second-quantized state |N+1> = a^+_p |N>, where an alpha electron is created in orbital ap_id. It is intended for Full Configuration Interaction (FCI) workflows in PySCF where one needs to add an alpha electron to an existing configuration interaction (CI) coefficient array (for example, when constructing states with one extra alpha electron or building excitation/de-excitation operators). The input CI is organized with rows indexing alpha occupation bit-strings and columns indexing beta occupation bit-strings; the output has the same column dimension (beta strings) but a larger number of rows corresponding to one more alpha electron.
    
    Args:
        ci0 (numpy.ndarray): CI coefficients of the N-electron wavefunction. Expected as a NumPy array whose rows correspond to alpha occupation strings and whose columns correspond to beta occupation strings. If a 1D array (flattened vector) is provided, the function will reshape it internally to (num_alpha_strings, num_beta_strings) where num_alpha_strings = cistring.num_strings(norb, neleca) and num_beta_strings = cistring.num_strings(norb, nelecb). The function does not modify the input array in-place; it returns a new array.
        norb (int): Number of spatial orbitals in the orbital basis used by the CI expansion. This determines the dimensionality of occupation bit-strings and is passed to cistring helper routines that enumerate string indices and counts.
        neleca_nelecb (tuple): Pair of integers (neleca, nelecb) giving the number of alpha and beta electrons in the input CI function ci0. These integers determine which set of alpha strings in the input are valid and are used to compute the target number of alpha strings after creation: cistring.num_strings(norb, neleca+1).
        ap_id (int): Orbital index (0-based) specifying which orbital the alpha-electron creation operator a^+_p acts on. This is interpreted as an index into the list of orbitals {0, ..., norb-1}. If ap_id does not correspond to any legal creation from the enumerated alpha strings (for example, if the orbital is already occupied in all contributing strings or if ap_id is outside the range of created entries), the result for those entries will be zero.
    
    Returns:
        numpy.ndarray: CI coefficients for the (N+1)-electron wavefunction. This is a 2D NumPy array with rows indexed by alpha-occupation strings of N+1 alpha electrons (count = cistring.num_strings(norb, neleca+1)) and columns indexed by the same beta-occupation strings as the input (ci0.shape[1]). The returned array contains the mapped and signed coefficients resulting from the creation operator: entries are obtained by locating, for each alpha string of the input, the resulting alpha string after creating an electron in orbital ap_id, applying the phase/sign associated with fermionic creation (as given by cistring.gen_cre_str_index), and placing the signed input coefficient into the corresponding row of the output. If neleca >= norb (no available orbital to add an alpha electron), the function returns an array of zeros with the same shape as the provided ci0 (this is an early-exit case). No in-place modification of ci0 occurs.
    
    Behavior, side effects, and failure modes:
        The function relies on cistring utilities (cistring.num_strings and cistring.gen_cre_str_index) to enumerate string indices, map creation operations, and supply phase factors. If ci0 is not a NumPy ndarray or does not have an ndim attribute, an attribute error or type error may be raised. If ci0 is a 1D array, it will be reshaped internally as described above; the reshaped view is used only within the function and the original object is not altered by this function. ap_id is treated as a 0-based orbital index; there is no explicit bounds check beyond the behavior of the generated creation-index table — if ap_id is out of the range that appears in the creation index table, the function will produce zero entries for the corresponding outputs. The function returns a new NumPy array and does not perform in-place updates of the input ci0.
    """
    from pyscf.fci.addons import cre_a
    return cre_a(ci0, norb, neleca_nelecb, ap_id)


################################################################################
# Source: pyscf.dft.xc_deriv.transform_fxc
# File: pyscf/dft/xc_deriv.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_dft_xc_deriv_transform_fxc(
    rho: numpy.ndarray,
    vxc: list,
    fxc: list,
    xctype: str,
    spin: int = 0
):
    """Transform libxc / XCFun exchange-correlation functional derivatives into the
    derivative tensor of the local density parameters carried in rho. In
    density-functional theory (DFT) implementations inside PySCF, external
    libraries (for example Libxc or XCFun) provide functional derivatives of the
    exchange-correlation energy with respect to scalar and gradient-dependent
    variables. This function rearranges and combines those derivatives into a
    tensor that matches the parameter ordering used by PySCF grid-based DFT
    routines: each parameter vector is ordered as [density, (nabla_x),
    (nabla_y), (nabla_z), tau] and, for spin-polarized cases, there are separate
    blocks for the two spin channels (commonly denoted "a" and "b"). The output
    tensor produced by this routine contains the second derivatives of the
    exchange-correlation energy with respect to those parameters at each grid
    point, suitable for forming response kernels and assembling matrix elements
    in PySCF DFT response and property calculations.
    
    Args:
        rho (numpy.ndarray): Grid-wise values of the density-related parameters
            used by PySCF. For spin-unpolarized (spin == 0) calculations, rho is
            expected to provide component arrays over grid points with the slowest
            index being the grid index; commonly this takes the shape (nvar, N)
            where nvar equals 1 for LDA, 4 for GGA, and 5 for MGGA, and N is the
            number of grid points. For spin-polarized (spin == 1) calculations,
            rho is expected to carry an explicit spin axis and have shape
            (2, nvar, N). The components correspond in order to the physical
            quantities [density, nabla_x, nabla_y, nabla_z, tau] (tau present only
            for MGGA). This array is only read and not modified by the function.
        vxc (list): List of first-derivative arrays returned by a libxc/XCFun
            evaluation for the exchange-correlation potential. For GGA and MGGA
            functionals the routine uses vxc[1] (the gradient-dependent part) and
            transposes it internally; for LDA the gradient part is not used. Each
            element of vxc must be an array-like object (typically numpy.ndarray)
            shaped so that a transpose (as performed internally by this function)
            places grid points on the last axis.
        fxc (list): List of second-derivative arrays (functional Hessian blocks)
            returned by libxc/XCFun. The function selects specific entries of
            this list depending on xctype:
            - For LDA: fxc[0] (frr) is used.
            - For GGA: fxc[0] (frr), fxc[1] (frg), and fxc[2] (fgg) are used.
            - For MGGA: fxc[0] (frr), fxc[1] (frg), fxc[2] (fgg), fxc[4] (ftt),
              fxc[6] (frt), and fxc[9] (fgt) are used.
            Each selected array element is transposed internally (.T) so the
            caller should provide fxc entries with axes arranged in the
            libxc/XCFun ordering; after transposition the last axis corresponds
            to the grid index. Missing or differently ordered entries in fxc will
            cause IndexError or incorrect results.
        xctype (str): Functional type string indicating the dependence of the
            exchange-correlation functional. The implementation distinguishes:
            - 'LDA'   : local-density approximation (no gradient or kinetic
                        energy density dependence), mapped internally to order=0.
            - 'GGA'   : generalized gradient approximation (depends on density and
                        its gradient), mapped internally to order=1.
            - 'MGGA'  : meta-GGA (depends also on kinetic energy density tau),
                        mapped internally to order=2.
            Any xctype value other than the explicit 'GGA' or 'MGGA' is treated
            by the current implementation as LDA (order=0). The xctype string
            determines which entries of vxc/fxc are read and the output tensor
            dimensionality.
        spin (int): Spin flag indicating whether the density and derivatives are
            spin-unpolarized (0) or spin-polarized (1). Default is 0 (unpolarized).
            When spin == 0 the function produces a 3-dimensional tensor over
            parameter indices and grids; when spin == 1 the function produces a
            5-dimensional tensor explicitly containing blocks for the two spin
            channels. Passing any nonzero integer is treated as spin-polarized.
    
    Returns:
        numpy.ndarray: The derivative tensor of the exchange-correlation
        functional with respect to the local density parameters in rho, arranged
        for direct use in PySCF grid-based DFT code. The returned array layout and
        shapes (with N = number of grid points) are:
        - Spin-unpolarized (spin == 0)
            LDA  : shape [1, 1, N]    (second derivative wrt density only)
            GGA  : shape [4, 4, N]    (density, 3 gradient components)
            MGGA : shape [5, 5, N]    (density, 3 gradient components, tau)
        - Spin-polarized (spin == 1)
            LDA  : shape [2, 1, 2, 1, N]   (blocks for spin a/b and density)
            GGA  : shape [2, 4, 2, 4, N]   (blocks for spin a/b and 4 variables)
            MGGA : shape [2, 5, 2, 5, N]   (blocks for spin a/b and 5 variables)
        Each element of the returned tensor gives the second derivative (kernel)
        coupling the corresponding pair of parameters (for a given spin block, if
        applicable) at each grid point. No in-place modification of inputs occurs;
        the routine allocates and returns a new numpy.ndarray.
    
    Notes, side effects, and failure modes:
        - The routine is pure (no external side effects) and allocates the output
          array. It uses .T on selected entries of vxc and fxc, so those entries
          must be shaped consistently with libxc/XCFun output conventions (grid
          index on one axis such that the transpose places grids on the last
          axis).
        - If fxc does not contain the expected indices for the requested xctype,
          an IndexError will be raised. If rho has an incompatible shape for the
          requested spin/xctype combination, numpy broadcasting or indexing errors
          (IndexError, ValueError) may occur.
        - The mapping from fxc indices to named blocks (frr, frg, fgg, frt, fgt,
          ftt) follows the ordering used in the calling libxc/XCFun evaluation and
          is fixed in this implementation; callers must ensure they pass fxc and
          vxc exactly as produced by their functional evaluator.
    """
    from pyscf.dft.xc_deriv import transform_fxc
    return transform_fxc(rho, vxc, fxc, xctype, spin)


################################################################################
# Source: pyscf.fci.addons.des_b
# File: pyscf/fci/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_addons_des_b(ci0: numpy.ndarray, norb: int, neleca_nelecb: tuple, ap_id: int):
    """pyscf.fci.addons.des_b
    Construct an (N-1)-electron configuration interaction (CI) wavefunction by applying a beta-spin electron annihilation operator to an N-electron CI wavefunction. This function is used in the PySCF FCI addons to obtain the CI vector that results from removing one beta electron from a specified spatial orbital; it is commonly used when building reduced-density matrices, computing transition amplitudes that involve electron removal, or when constructing intermediate states in FCI-based post-processing.
    
    Args:
        ci0 (numpy.ndarray): CI coefficients of the input N-electron wavefunction. This is a 2D array with rows indexed by alpha-spin occupation strings and columns indexed by beta-spin occupation strings. Each element is the CI amplitude for the corresponding (alpha, beta) occupation pair. If a 1D array is passed, the function reshapes it internally to (num_alpha_strings, num_beta_strings) using cistring.num_strings(norb, neleca) and cistring.num_strings(norb, nelecb). The array is treated as read-only by this function; the input ci0 is not modified.
        norb (int): Number of spatial orbitals in the system. This determines the length of occupation bitstrings used by underlying cistring utilities (cistring.gen_des_str_index and cistring.num_strings) and bounds valid orbital indices for the annihilation operator. Values must match the orbital indexing used to construct ci0.
        neleca_nelecb (tuple): A two-element tuple (neleca, nelecb) giving the number of alpha and beta electrons in the input CI wavefunction ci0. These integers determine the dimensions of the input CI array (number of alpha strings = cistring.num_strings(norb, neleca); number of beta strings = cistring.num_strings(norb, nelecb)) and the parity correction applied to the sign prefactor when removing a beta electron.
        ap_id (int): Orbital index (0-based) specifying which spatial orbital the beta annihilation operator acts on. ap_id must be in the range [0, norb-1] for a physically meaningful annihilation; if ap_id does not match any occupied beta orbital patterns in the input ci0, the returned (N-1)-electron CI vector will be zero in the corresponding columns (see failure modes below).
    
    Behavior, side effects, and implementation notes:
        The function computes the action of the annihilation operator a_{ap_id,β} on the input CI wavefunction ci0 by consulting cistring.gen_des_str_index(range(norb), nelecb), which enumerates all possible single-beta-electron removals and returns an index table. The table entries indicate which beta strings in the input map to which beta strings in the (nelecb-1) space, together with the fermionic sign prefactor for each removal. The function:
        - Returns a new 2D array ci1 with the same number of rows (alpha strings) as ci0 and with number of columns equal to cistring.num_strings(norb, nelecb-1) (beta strings after removing one beta electron).
        - Applies the sign prefactor provided by cistring.gen_des_str_index to each mapped amplitude. Additionally, because the annihilation operator for a beta electron must be commuted past all alpha operators when expressing the result in the standard ordering used by the code, the sign is multiplied by -1 if the number of alpha electrons neleca is odd; this implements the exchange sign between alpha and beta operators used across PySCF FCI routines.
        - Handles the special-case nelecb <= 0 by returning numpy.zeros_like(ci0). This preserves the input array shape in the degenerate case where no beta electrons are present; it is a deliberate behavior implemented in the source to indicate that annihilation is not possible and to avoid shape-mismatch exceptions elsewhere in FCI workflows.
        - Accepts a 1D input vector for ci0 and will reshape it internally to the expected 2D layout using cistring.num_strings; this permits callers that store CI vectors as flat arrays to use this function without manual reshaping.
    
    Returns:
        numpy.ndarray: A 2D array of CI coefficients for the (N-1)-electron wavefunction after removing one beta electron. Rows correspond to the same set of alpha occupation strings as the input ci0. Columns correspond to beta occupation strings with one fewer beta electron (number of columns = cistring.num_strings(norb, nelecb-1)). The returned array is a newly allocated array (ci0 is not modified). In the special-case of nelecb <= 0 the function returns numpy.zeros_like(ci0) (same shape as ci0) to signal that annihilation cannot produce a valid (nelecb-1) space.
    
    Failure modes and edge cases:
        - If nelecb <= 0, the function returns numpy.zeros_like(ci0) rather than raising an exception; callers should check electron counts before relying on the output shape.
        - If ap_id is outside [0, norb-1] or if ap_id does not match any occupied beta orbital pattern in ci0, no mapping entries will be found and the returned array will contain zeros in the corresponding columns (i.e., the annihilation produces no nonzero amplitudes).
        - If ci0 has an unexpected shape that cannot be reconciled with the provided norb and neleca_nelecb values (for example, mismatched dimensions versus cistring.num_strings results), underlying cistring utilities or numpy indexing may raise exceptions (ValueError or IndexError). Callers should ensure ci0 layout and the (norb, neleca_nelecb) tuple are consistent with the CI representation used elsewhere in PySCF.
        - The function relies on cistring.gen_des_str_index and cistring.num_strings from the PySCF cistring module; if those utilities are unavailable or modified, behavior may change.
    """
    from pyscf.fci.addons import des_b
    return des_b(ci0, norb, neleca_nelecb, ap_id)


################################################################################
# Source: pyscf.fci.addons.des_a
# File: pyscf/fci/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_addons_des_a(ci0: numpy.ndarray, norb: int, neleca_nelecb: tuple, ap_id: int):
    """Construct (N-1)-electron wavefunction by removing an alpha electron from the N-electron wavefunction in the PySCF FCI addon. This function implements the second-quantized annihilation operator a_p acting on the alpha-spin part of a full-configuration-interaction (FCI) CI vector, returning a new CI array that represents the state |N-1> = a_p |N>. It is used in PySCF for tasks that require explicit electron removal on the alpha spin manifold (for example, forming Dyson orbitals, computing ionization amplitudes, or intermediate steps in spin-adapted FCI manipulations).
    
    Args:
        ci0 (2D array): CI coefficients for the input N-electron wavefunction. The array is organized with rows corresponding to alpha occupation strings and columns corresponding to beta occupation strings. Each element is the CI amplitude for the corresponding alpha/beta string product. If ci0 is provided as a 1D array, the function will reshape it into a 2D array assuming the row and column dimensions equal cistring.num_strings(norb, neleca) and cistring.num_strings(norb, nelecb) respectively (see behavior below).
        norb (int): Number of spatial orbitals in the system. This value is used to enumerate occupation strings and to generate the mapping for single-alpha-electron removal. It determines the length of bitstrings used by the cistring utilities and must match the orbital indexing used in ap_id.
        neleca_nelecb (tuple): Tuple of two integers (neleca, nelecb) where neleca is the number of alpha electrons and nelecb is the number of beta electrons in the input CI function. The function removes one alpha electron, so the output corresponds to (neleca-1, nelecb). If neleca <= 0, no removal is possible and the function returns an array of zeros shaped like the input (see behavior/failure modes).
        ap_id (int): Orbital index (0-based) specifying which alpha orbital the annihilation operator acts on. This index must refer to one of the norb spatial orbitals (conventionally 0 .. norb-1). The function locates contributions where that orbital is occupied in the alpha strings and maps them to the corresponding (neleca-1)-electron alpha strings, applying the appropriate fermionic sign from the string ordering.
    
    Behavior, side effects, defaults, and failure modes:
        - The function does not modify external state (no side effects), but it calls cistring.gen_des_str_index and cistring.num_strings to build internal index/mapping tables; those cistring utilities are part of PySCF's FCI string handling and must be available in the runtime environment.
        - If ci0.ndim == 1, ci0 is interpreted as a flattened CI vector and is reshaped into a 2D array with dimensions (num_alpha_strings, num_beta_strings) where num_alpha_strings = cistring.num_strings(norb, neleca) and num_beta_strings = cistring.num_strings(norb, nelecb). This reshape is necessary because the routine operates on alpha rows and beta columns explicitly.
        - If neleca <= 0, the function immediately returns numpy.zeros_like(ci0). This reflects the physical fact that one cannot remove an alpha electron from a system with no alpha electrons; the returned zero array has the same shape as the (possibly reshaped) input CI representation.
        - The routine constructs an index table (des_index) with cistring.gen_des_str_index(range(norb), neleca). From that table it finds entries where the annihilated orbital equals ap_id, identifies source row addresses in the input CI (alpha strings that have the orbital occupied), target row addresses in the output (alpha strings with one fewer electron), and the fermionic sign for each mapping. It multiplies the corresponding input CI rows by the sign and deposits them into the output array rows.
        - The output preserves the same number of beta-string columns as the input; only the number of alpha-string rows changes to cistring.num_strings(norb, neleca-1).
        - ap_id is interpreted as 0-based. If ap_id is outside the valid orbital range (not in 0 .. norb-1) or inconsistent with the cistring utilities, the behavior depends on cistring.gen_des_str_index and subsequent indexing; this may result in no matching entries (effectively producing zeros) or an IndexError from the underlying cistring routines. The caller should ensure ap_id and norb are consistent.
        - The function assumes the input CI array ordering matches the cistring ordering conventions used by PySCF; providing CI data with a different ordering will produce incorrect results.
    
    Returns:
        2D array: CI coefficients for the (N-1)-electron wavefunction after removing one alpha electron at orbital ap_id. The returned array is organized with rows corresponding to alpha strings for neleca-1 electrons and columns corresponding to the same beta strings as the input (nelecb). Concretely, the number of rows equals cistring.num_strings(norb, neleca-1) and the number of columns equals ci0.shape[1] (after any reshaping of a 1D input). The returned array contains the appropriately signed amplitudes resulting from the action of the annihilation operator; if neleca <= 0 the returned array is all zeros (numpy.zeros_like(ci0)).
    """
    from pyscf.fci.addons import des_a
    return des_a(ci0, norb, neleca_nelecb, ap_id)


################################################################################
# Source: pyscf.fci.addons.initguess_triplet
# File: pyscf/fci/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_addons_initguess_triplet(norb: int, nelec: tuple, binstring: str):
    """pyscf.fci.addons.initguess_triplet: Generate a normalized triplet initial guess CI vector/matrix for the PySCF FCI solver.
    
    Constructs a simple, normalized initial configuration interaction (CI) guess intended to represent a spin triplet (M_S = 0) combination for use as a starting vector in Full Configuration Interaction (FCI) diagonalization or iterative solvers within the PySCF quantum chemistry framework. The routine uses the number of spatial orbitals, the alpha/beta electron counts, and a binary occupation string that selects a particular Slater determinant (address) in one spin sector. Internally it uses cistring.num_strings to determine the number of alpha and beta string basis functions and cistring.str2addr to map the provided binary occupation pattern to the integer address of that determinant. The returned CI array has only two nonzero entries, +sqrt(1/2) and -sqrt(1/2), producing a normalized antisymmetric combination between the two determinants needed to form the triplet M_S = 0 state. This initial guess is useful in practical FCI workflows to bias the solver toward a triplet state and to accelerate convergence when a triplet solution is expected.
    
    Args:
        norb (int): Number of spatial orbitals in the active space. This integer determines the length of the binary occupation strings and is passed to cistring.num_strings and cistring.str2addr to enumerate and index determinant bitstrings. In the quantum chemistry domain, norb corresponds to the number of spatial molecular orbitals used to build Slater determinants for the FCI problem.
        nelec (tuple): A two-element tuple (neleca, nelecb) giving the number of alpha (spin-up) and beta (spin-down) electrons, respectively. These counts define the FCI sector (number of electrons per spin) and are used to compute the numbers of alpha and beta string basis functions (na and nb). The function expects a tuple of two integers; mismatched counts relative to the provided binstring will lead to errors from cistring.str2addr.
        binstring (str): A base-2 string (sequence of '0' and '1' characters) encoding the occupation pattern of a determinant in one spin sector. The string is converted to an integer via int(binstring, 2) and then mapped to an address with cistring.str2addr(norb, neleca, int(binstring,2)). The number of '1' bits in binstring must equal neleca (the first element of nelec); otherwise cistring.str2addr or the integer conversion will raise an exception. The length of binstring should be consistent with norb (leading zeros are allowed to reach norb bits).
    
    Returns:
        numpy.ndarray: A two-dimensional NumPy array ci0 with shape (na, nb), where na = cistring.num_strings(norb, neleca) and nb = cistring.num_strings(norb, nelecb). The array is a normalized initial CI guess for a triplet (M_S = 0) and contains exactly two nonzero elements: ci0[addr, 0] = +sqrt(1/2) and ci0[0, addr] = -sqrt(1/2), where addr is the index returned by cistring.str2addr for the provided binstring. The array dtype is the default NumPy float (float64). No in-place side effects occur; the function returns a newly allocated array.
    
    Behavior and failure modes:
        The function constructs a normalized antisymmetric combination of two determinants to represent a triplet-like initial guess for the FCI solver. It relies on cistring.num_strings and cistring.str2addr; therefore, errors from those utilities propagate to this function. Common failure modes include ValueError from int(binstring, 2) if binstring contains non-binary characters, and errors from cistring.str2addr if the number of set bits in binstring does not match neleca or if the resulting address is invalid for the computed na/nb sizes. The function performs no input coercion beyond the int(binstring, 2) conversion and does not modify external state.
    """
    from pyscf.fci.addons import initguess_triplet
    return initguess_triplet(norb, nelec, binstring)


################################################################################
# Source: pyscf.fci.addons.transform_ci
# File: pyscf/fci/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_addons_transform_ci(ci: numpy.ndarray, nelec: tuple, u: list):
    """Transform CI coefficients from an old one-particle orbital basis to a new
    one-particle orbital basis according to a given orbital rotation. In PySCF's
    full configuration interaction (FCI) workflow, the CI eigenproblem can be
    solved either by transforming the Hamiltonian integrals into a rotated orbital
    basis or by transforming the CI coefficient vector obtained in the old basis.
    This function implements the latter: given CI coefficients CI_old computed for
    a Hamiltonian expressed in the old basis, transform_ci returns CI_new that
    represents the same many-electron wavefunction in the rotated (new) one-particle
    basis defined by the orbital rotation matrix/matrices u. The transformation is
    performed by evaluating determinants of appropriate submatrices (minors) of u
    for all occupied-orbital patterns (alpha and beta strings), which is the
    standard Slater-determinant transformation rule under orbital rotations used in
    quantum chemistry FCI calculations.
    
    Args:
        ci (numpy.ndarray): CI coefficient array representing the many-electron
            wavefunction in the old one-particle basis. The array must contain the
            coefficients for all alpha/beta occupation strings for the given number
            of orbitals and electrons. Valid input shapes are either a flattened
            vector of length na_old*nb_old or a 2D array of shape (na_old, nb_old),
            where na_old and nb_old are the numbers of alpha and beta occupation
            strings computed from norb_old (the old number of orbitals) and the
            electron counts in nelec. The function will internally reshape ci to
            (na_old, nb_old), compute the basis transformation, and return a new
            array of shape (na_new, nb_new). The dtype of the returned array will
            be the numeric result of the linear-algebra operations (determined by
            the dtypes of u and ci).
        nelec (tuple): A tuple (neleca, nelecb) of two integers giving the number
            of alpha and beta electrons, respectively. These electron counts are
            used to enumerate occupation strings in the old and new orbital spaces
            and determine na_old, nb_old, na_new and nb_new. Supplying incorrect
            electron counts that do not correspond to the intended CI coefficients
            will produce incorrect indexing or a shape mismatch error.
        u (list): Either a single 2D numpy.ndarray or an iterable (e.g., list or
            tuple) of two 2D numpy.ndarrays describing the orbital rotation(s)
            mapping the old one-particle basis to the new one-particle basis.
            - If u is a single 2D numpy.ndarray of shape (norb_old, norb_new), it
              is interpreted as the same rotation for alpha and beta spin-orbitals
              (ua = ub = u). In that case the shapes of ua and ub are asserted to
              match (trivially true).
            - If u is an iterable of two 2D arrays, they are unpacked as
              (ua, ub) where ua has shape (norb_old, norb_new) for alpha and ub has
              shape (norb_old, norb_new) for beta. Each 2D array must have the
              number of rows equal to the number of orbitals in the old basis
              (norb_old) and the number of columns equal to the number of orbitals
              in the new basis (norb_new). If the number of columns differs from
              the number of rows (norb_old != norb_new), the resulting transformed
              CI will have a different number of occupation strings and thus a
              different output shape (na_new, nb_new). If u is not an iterable of
              length two when not a single numpy.ndarray, a Python unpacking
              ValueError will be raised.
    
    Returns:
        numpy.ndarray: CI coefficients expressed in the new one-particle basis.
        The returned array is a 2D numpy.ndarray of shape (na_new, nb_new), where
        na_new and nb_new are the numbers of alpha and beta occupation strings
        in the new orbital space (computed from norb_new and nelec). The returned
        array represents CI_new such that solving the FCI eigenproblem in the new
        basis (for integrals transformed by u) yields coefficients equivalent to
        this result. The input ci array is not modified in-place; a newly computed
        array is returned.
    
    Behavior, side effects, and failure modes:
        - The transformation follows the Slater-determinant rule: for each pair of
          old and new occupation strings the matrix element of the transformation
          equals the determinant of the submatrix of u that connects the occupied
          orbitals in the two strings. The implementation computes these minors and
          determinants explicitly.
        - Special-cases: if neleca == 0 or nelecb == 0, the corresponding
          transformation matrix is treated as a 1x1 identity (value 1) because
          there are no occupied alpha or beta orbitals to transform.
        - If neleca == nelecb and ua and ub are numerically equal, the same
          transformation matrix is reused for both spins to avoid redundant
          computation.
        - Input shape requirements: ci must contain the coefficients for the
          occupation string lists implied by nelec and the number of rows of u;
          otherwise the internal reshape or indexing will raise an exception.
        - If u is a single numpy.ndarray, it is used for both spins; if it is an
          iterable of two arrays, it must unpack to exactly two 2D arrays (ua, ub)
          or Python will raise a ValueError on unpacking.
        - The function will raise an AssertionError if, in the single-array case,
          the inferred ua and ub shapes do not match (this is a programming error
          rather than a numeric failure).
        - Determinant computations may be numerically unstable for nearly
          linearly-dependent columns in u; such cases can lead to underflow/overflow
          or loss of precision but will not be silently corrected by this routine.
        - The computational cost grows combinatorially with the number of orbitals
          and electrons due to enumerating occupation strings and evaluating many
          determinants; this routine is intended for system sizes typical for FCI
          use in PySCF and may become prohibitively expensive for large orbital
          spaces.
    
    Practical significance:
        - Use transform_ci when you have CI coefficients computed in one orbital
          basis and want to obtain the coefficients in another basis related by an
          orbital rotation u without reconstructing and re-diagonalizing the
          Hamiltonian in the new basis. This is commonly used in PySCF workflows
          where orbital rotations (e.g., from mean-field or orbital optimization)
          are applied and one wishes to map many-electron wavefunctions between
          representations efficiently and exactly within numerical precision limits.
    """
    from pyscf.fci.addons import transform_ci
    return transform_ci(ci, nelec, u)


################################################################################
# Source: pyscf.fci.addons.large_ci
# File: pyscf/fci/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_addons_large_ci(
    ci: numpy.ndarray,
    norb: int,
    nelec: tuple,
    tol: float = 0.1,
    return_strs: bool = True
):
    """pyscf.fci.addons.large_ci searches a Full Configuration Interaction (FCI) coefficient array for large-amplitude configuration state contributions and returns the corresponding determinant identifiers in either binary-string form or as occupied-orbital lists. In the PySCF quantum chemistry context (see README), this helper is used after an FCI calculation to locate and inspect the most important Slater determinants (alpha and beta occupation strings) that contribute to a correlated wavefunction. The function reshapes a flattened CI vector into the rectangular array of alpha- and beta-string combinations, thresholds by absolute amplitude, and returns matched (coefficient, alpha-id, beta-id) tuples for downstream analysis, debugging, or human inspection.
    
    Args:
        ci (numpy.ndarray): 1D array containing the flattened CI coefficient vector for all alpha-beta string pairs. Its length must equal cistring.num_strings(norb, neleca) * cistring.num_strings(norb, nelecb) where (neleca, nelecb) are unpacked from nelec; the function asserts this size and will raise AssertionError if the size does not match. The array elements may be real or complex; thresholding uses absolute values but returned coefficients preserve their original signed/complex values and phases.
        norb (int): Number of spatial orbitals used to build alpha and beta occupation strings. This integer is passed to cistring routines to compute the number of possible strings and to convert string addresses into binary string encodings or occupation lists. Practical significance: norb determines the bit-length of returned binary strings and the range of valid occupied-orbital indices.
        nelec (tuple): A pair (neleca, nelecb) of integers giving the number of alpha and beta electrons, respectively. This tuple is unpacked by _unpack_nelec and used to compute the number of alpha and beta strings via cistring.num_strings(norb, neleca) and cistring.num_strings(norb, nelecb). Invalid nelec tuples (e.g., non-integer entries) will cause the unpacking or cistring routines to raise an exception.
        tol (float): Threshold on the absolute value of CI coefficients used to select "large" contributions. Default 0.1 (as in the function signature) selects all coefficients with abs(ci) > tol. If no coefficient exceeds tol, the function falls back to returning the single largest-amplitude coefficient (by absolute value). tol is used only for selection and does not alter the input array.
        return_strs (bool): If True (default), the function returns alpha and beta identifiers as Python binary strings produced with bin(), each including the '0b' prefix; these strings represent the occupation bitmask for the determinant. If False, the function returns alpha and beta identifiers as occupied-orbital lists produced by cistring._strs2occslst, i.e., lists (per determinant) of integer orbital indices that are occupied. Choose return_strs=True for compact, human-readable bitstrings and return_strs=False for numerical occupied-orbital lists suitable for programmatic manipulation.
    
    Behavior, side effects, defaults, and failure modes:
        The function does not mutate the input ci array; it only reshapes a view of it to (na, nb) where na and nb are the numbers of alpha and beta strings. It identifies indices addra, addrb of array elements with abs(ci) > tol using numpy.where. If no elements satisfy the threshold, it finds the single index of the maximum absolute coefficient via numpy.argmax and returns that single entry. The returned list length equals the number of selected coefficients (zero cannot occur because the fallback ensures at least one is returned unless the assertion fails first).
        The function calls cistring.addrs2str to convert internal address indices into integer-encoded occupation bitstrings and then either formats them with Python's bin() (when return_strs is True) or converts them into occupied-orbital lists with cistring._strs2occslst (when return_strs is False). These cistring routines impose the canonical ordering and encoding used throughout PySCF FCI code; consumers of the returned identifiers can rely on that encoding for consistent mapping back to determinants.
        Common failure modes include:
            - AssertionError if ci.size != na * nb (mismatched flattened length).
            - Exceptions propagated from _unpack_nelec or cistring routines when nelec or norb are invalid.
            - TypeErrors if ci is not a numpy.ndarray or contains unsupported dtypes for numpy.abs/argmax operations.
        No file I/O or global state changes are performed; the function only returns Python lists and does not log or print.
    
    Returns:
        list: A list of tuples, one tuple per selected large coefficient. Each tuple has three elements: (coefficient, alpha_id, beta_id).
        If return_strs is True: coefficient is a numpy scalar (float or complex) equal to ci[alpha_index, beta_index]; alpha_id and beta_id are Python str values produced by bin(integer) such as '0b101010', representing the occupation bitmask for the alpha and beta determinants respectively.
        If return_strs is False: coefficient is the same numpy scalar; alpha_id and beta_id are lists of integers (list[int]) where each inner list enumerates the occupied orbital indices for the corresponding determinant as produced by cistring._strs2occslst.
        Ordering: the list preserves the order of indices returned by numpy.where when selecting all coefficients above tol; when falling back to the single largest coefficient, a one-element list is returned. The numeric coefficient values are the original entries from ci (not absolute values), while selection used absolute amplitudes.
    """
    from pyscf.fci.addons import large_ci
    return large_ci(ci, norb, nelec, tol, return_strs)


################################################################################
# Source: pyscf.fci.addons.guess_wfnsym
# File: pyscf/fci/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_addons_guess_wfnsym(ci: numpy.ndarray, norb: int, nelec: list, orbsym: list):
    """pyscf.fci.addons.guess_wfnsym: Guess the wavefunction symmetry (irreducible representation ID) for a CI wavefunction from its CI coefficient vector(s). This utility is part of PySCF's full configuration interaction (FCI) addons and is used to infer the total spatial symmetry label of a CI wavefunction by combining the orbital symmetry labels (orbsym) of occupied orbitals in the occupied alpha/beta occupation strings. In the PySCF quantum-chemistry framework this inferred irrep ID is used for symmetry labeling, symmetry-based checks, and for choosing symmetry-adapted post-processing or reporting.
    
    Args:
        ci (numpy.ndarray): CI coefficients. For a single CI wavefunction this is a 2D array where rows correspond to alpha occupation strings and columns correspond to beta occupation strings (the same convention used by PySCF FCI routines). If a sequence or higher-rank numpy.ndarray of CI vectors is provided, the function will evaluate the guessed symmetry for each CI vector and compare them; if they differ a warning is emitted and the symmetry from the first vector is returned. The practical role of this argument is to provide the expansion coefficients from which occupied determinant/string occupations are identified and their orbital irreps combined to produce the total wavefunction irrep.
        norb (int): Number of spatial orbitals. This integer is used with range(norb) to generate occupation strings for alpha and beta electrons (via cistring.make_strings in the FCI addon). The value must match the number of orbital symmetry labels supplied in orbsym and the orbital indexing convention used to construct ci.
        nelec (int or 2-item list): Number of electrons. Either a single integer for the total electron count or a two-item list/tuple specifying (alpha, beta) electron counts. Internally this is unpacked into (neleca, nelecb) to generate the appropriate alpha and beta occupation strings. Providing explicit (alpha, beta) counts controls how the CI coefficients are interpreted with respect to spin occupations and therefore affects the computed wavefunction symmetry.
        orbsym (list of int): Orbital symmetry labels: a list of integers where each integer is the irrep ID assigned to the corresponding orbital (length should be equal to norb). These orbital irreps are combined (by summing/mapping according to the FCI addon symmetry conventions) over occupied orbitals in each determinant/string to deduce the total irreducible representation of the CI wavefunction. The values and mapping follow the irrep indexing conventions used elsewhere in PySCF.
    
    Returns:
        int: Irrep ID of the guessed wavefunction symmetry. This integer is the irreducible representation label deduced from the provided CI coefficients and orbital symmetry labels. If ci is a single 2D numpy.ndarray (ndim <= 2), the function returns the symmetry computed for that vector. If ci contains multiple CI vectors, the function computes the symmetry for each; if they are not all identical a warning is emitted via warnings.warn('Different wfnsym ...') and the first vector's symmetry is returned. Side effects include generation of occupation strings via cistring.make_strings and possible emission of a warning when multiple CI vectors give different symmetries. The function relies on internal helpers (_unpack_nelec and _guess_wfnsym) and may raise errors (for example, from those helpers) if the provided shapes, lengths, or types (norb vs. length of orbsym, incompatible ci dimensions, or invalid nelec) are inconsistent.
    """
    from pyscf.fci.addons import guess_wfnsym
    return guess_wfnsym(ci, norb, nelec, orbsym)


################################################################################
# Source: pyscf.fci.addons.symm_initguess
# File: pyscf/fci/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_addons_symm_initguess(
    norb: int,
    nelec: list,
    orbsym: list,
    wfnsym: int = 0,
    irrep_nelec: dict = None
):
    """pyscf.fci.addons.symm_initguess generates a configuration-interaction (CI) initial guess vector/matrix that is constrained to a specified point-group irreducible representation (irrep) and intended for use as an initial wavefunction in PySCF full configuration interaction (FCI) workflows. The function was designed to assemble a CI coefficients 2D array consistent with orbital symmetry labels so downstream FCI solvers start from a symmetry-adapted guess that reduces symmetry mixing during iterative diagonalization. NOTE: this implementation is deprecated and calling it will raise a DeprecationWarning instead of returning a CI guess.
    
    Args:
        norb (int): Number of spatial orbitals used in the FCI problem. This integer determines the total orbital count taken from the molecular orbital basis and is used to size the (intended) CI initial-guess construction. In the PySCF FCI domain, norb sets the single-particle space over which many-electron configurations are defined.
        nelec (int or 2-item list): Number of electrons in the calculation. This may be a single integer for a spin-restricted electron count, or a 2-item list specifying (nalpha, nbeta) electrons for spin-unrestricted counts. The electron count defines the Fock-space sector for which the CI initial guess would be prepared and is essential to ensure the guess has the correct particle number and spin sector for FCI.
        orbsym (list of int): A list of integer irrep IDs assigning a point-group irreducible representation to each orbital in the same order as the orbitals (length must match norb). Each entry is the irrep identifier used by PySCF point-group symmetry bookkeeping; these labels determine how orbital occupations combine to produce many-electron state symmetries and are used to select configuration occupations consistent with the target wavefunction symmetry.
        wfnsym (int): The target many-electron wavefunction symmetry as an irrep ID. This integer selects which irreducible representation the generated CI guess is required to belong to. The default value is 0. In practical PySCF use, specifying wfnsym helps the FCI solver converge to an eigenstate in the desired symmetry sector.
        irrep_nelec (dict): Optional dictionary to freeze or constrain occupancies for particular irreps. Keys are irrep IDs (integers) and values indicate occupancy constraints for that irrep (for example, a fixed number of electrons or other occupancy prescription used by the original implementation). This parameter was intended to allow the user to enforce or freeze electron counts in specific irreps when building the symmetry-adapted initial guess.
    
    Returns:
        None: This function is deprecated and does not return a CI coefficient array. Instead, calling this function raises a DeprecationWarning and no CI guess is produced. Historically, the function returned a 2D array of CI coefficients whose many-electron symmetry matched wfnsym (suitable as an initial guess for PySCF FCI solvers). Because the function now raises DeprecationWarning immediately, users should not rely on it and should use current, supported FCI initial-guess facilities within PySCF.
    """
    from pyscf.fci.addons import symm_initguess
    return symm_initguess(norb, nelec, orbsym, wfnsym, irrep_nelec)


################################################################################
# Source: pyscf.fci.cistring.addr2str
# File: pyscf/fci/cistring.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_cistring_addr2str(norb: int, nelec: int, addr: int):
    """Convert a configuration-interaction (CI) determinant address to its occupation string.
    
    This function is used in the pyscf.fci.cistring module of the PySCF quantum chemistry framework to map an integer "address" (ordinal index) that identifies a CI determinant into its corresponding occupation string. In the context of CI calculations, determinants are represented as fixed-length bitstrings of length norb with exactly nelec occupied orbitals; this function returns that bitstring representation where each character is '1' for an occupied orbital and '0' for an unoccupied orbital. The function chooses an internal implementation depending on the total number of distinct strings (num_strings(norb, nelec)): for moderately sized spaces it calls the vectorized addrs2str implementation, while for very large spaces it calls a specialized _addr2str implementation. The function performs no I/O and has no side effects on program state; it only returns the string representation for the given address.
    
    Args:
        norb (int): Number of single-particle orbitals (the length of the returned occupation string). This parameter determines the size of the bitstring used to represent CI determinants and therefore controls the combinatorial space size num_strings(norb, nelec). In typical CI use within PySCF, norb is a small-to-moderate non-negative integer; values greater than or equal to 64 are not supported by this implementation and will raise NotImplementedError.
        nelec (int): Number of electrons (number of occupied positions in the occupation string). This integer selects which subset size of the norb orbitals is occupied; valid values are integers such that 0 <= nelec <= norb in the usual CI use. The function relies on num_strings(norb, nelec) to compute the total number of valid addresses for this (norb, nelec) sector.
        addr (int): Integer address (ordinal index) of the desired determinant within the ordered list of all determinants for the given (norb, nelec) sector. The address must be a non-negative integer satisfying 0 <= addr < num_strings(norb, nelec). The address meaning is the position (zero-based index) in the canonical enumeration of bitstrings used by the cistring utilities.
    
    Returns:
        str: A deterministic occupation string of length norb that represents the CI determinant corresponding to the supplied addr. Each character in the returned string is '1' to indicate an occupied orbital and '0' to indicate an unoccupied orbital. The returned string has no additional decoration or separators; it is a plain Python str suitable for downstream CI indexing, comparison, or conversion routines in PySCF.
    
    Behavior, side effects, defaults, and failure modes: If norb >= 64 the function raises NotImplementedError('norb >= 64') because this implementation does not support 64 or more orbitals. If addr is outside the valid range (addr < 0 or addr >= num_strings(norb, nelec)) the function will fail the internal assertion (AssertionError) because it asserts that the computed max_addr > addr. For moderately sized combinatorial spaces where num_strings(norb, nelec) < 2**31, the function dispatches to addrs2str(norb, nelec, [addr]) and returns the first element of that result; for larger spaces it dispatches to _addr2str(norb, nelec, addr). The choice of branch is an internal performance/implementation detail; callers do not need to select the implementation. The function has no external side effects, performs no file or network I/O, and returns a new Python str object. If auxiliary functions (num_strings, addrs2str, _addr2str) raise errors for invalid inputs or resource limits, those exceptions propagate to the caller.
    """
    from pyscf.fci.cistring import addr2str
    return addr2str(norb, nelec, addr)


################################################################################
# Source: pyscf.fci.addons.symmetrize_wfn
# File: pyscf/fci/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_addons_symmetrize_wfn(
    ci: numpy.ndarray,
    norb: int,
    nelec: list,
    orbsym: list,
    wfnsym: int = 0
):
    """Symmetrize the full configuration interaction (FCI) CI wavefunction by zeroing out determinant coefficients whose overall spatial symmetry does not match the requested target irreducible representation (irrep).
    
    This function is part of the pyscf.fci.addons utilities and is used in FCI calculations to enforce spatial symmetry on the many-electron wavefunction. It constructs alpha and beta occupation strings for the given number of orbitals and electrons, computes the symmetry of each determinant from the per-orbital irreps (orbsym), and returns a new CI coefficient array where coefficients of determinants that do not transform as the specified wfnsym are set to zero. The routine calls internal helpers (_unpack_nelec to interpret nelec, cistring.make_strings to enumerate determinants, and _symmetrize_wfn to perform the masking), and is typically used to reduce the CI space and to target states of a particular spatial symmetry in post-Hartree–Fock calculations.
    
    Args:
        ci (2D array): CI coefficients arranged with rows corresponding to alpha-electron occupation strings and columns corresponding to beta-electron occupation strings. This array contains the amplitude of each Slater determinant product (alpha string × beta string) prior to symmetry filtering.
        norb (int): Number of spatial orbitals. This integer determines the length of occupation strings generated for alpha and beta electrons and must match the length of orbsym.
        nelec (int or 2-item list): Total number of electrons as a single integer, or a two-item list [nalpha, nbeta] specifying the number of alpha and beta electrons respectively. The function internally unpacks this to (neleca, nelecb) to generate the appropriate alpha and beta occupation strings.
        orbsym (list of int): Per-orbital irrep identifiers (integer ids) that label the spatial symmetry (irreducible representation) of each orbital. The list length must equal norb. These irreps are used to determine the overall determinant symmetry by combining the occupied orbital irreps for a given occupation string.
        wfnsym (int): The target wavefunction irrep identifier. Determinants whose combined orbital irrep does not equal this integer will be zeroed in the returned CI array. Defaults to 0 (the caller should interpret irrep id 0 according to the molecular point-group labeling used in the surrounding codebase).
    
    Returns:
        2D array: A new 2D array of CI coefficients with the same row/column ordering as the input ci (rows for alpha strings, columns for beta strings). Coefficients corresponding to determinants whose overall spatial symmetry differs from wfnsym are set to zero. The original ci array is not modified; this function returns the symmetrized copy.
    
    Behavior, side effects, and failure modes:
        The function enumerates alpha and beta occupation strings for norb orbitals and neleca/nelecb electrons and uses orbsym to evaluate determinant symmetries. It performs no in-place modification of the provided ci array but returns a new array of the same dimensionality. The computational cost grows with the number of determinants (combinatorial in norb and nelec), so using this routine for very large CI spaces can be expensive in time and memory. Input validation is expected: mismatches such as len(orbsym) != norb, inconsistency between nelec and the shape of ci, or incorrectly typed inputs (non-integer irrep ids, non-2D ci) may raise exceptions (for example ValueError or TypeError) from the underlying helpers. The function assumes that orbital and wavefunction irrep ids follow the same labeling convention used elsewhere in PySCF for the molecular point group.
    """
    from pyscf.fci.addons import symmetrize_wfn
    return symmetrize_wfn(ci, norb, nelec, orbsym, wfnsym)


################################################################################
# Source: pyscf.fci.cistring.addrs2str
# File: pyscf/fci/cistring.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_cistring_addrs2str(norb: int, nelec: int, addrs: numpy.ndarray):
    """Convert a list of CI determinant addresses to occupation "strings" used by PySCF's FCI routines.
    
    Args:
        norb (int): Number of spatial orbitals in the FCI problem. This determines the width
            of each occupation string (number of orbitals whose occupation is encoded).
            In the PySCF FCI domain, norb controls the bit-width of the integer-encoded
            occupation patterns. The implementation requires norb < 64 and will raise
            NotImplementedError if norb >= 64 because the routine uses 64-bit integer
            encodings and a low-level C routine that does not support wider encodings.
        nelec (int): Number of electrons (total) for the determinants. This parameter
            defines which sector of the combinatorial list of determinants (strings)
            is addressed: num_strings(norb, nelec) is the total number of distinct
            determinants with norb orbitals and nelec electrons. The function relies on
            this value to validate input addresses and to call the underlying C routine
            that reconstructs occupation patterns for that electron count.
        addrs (numpy.ndarray): One-dimensional array of integer addresses (indices)
            into the ordered list of CI determinant strings for the given (norb, nelec)
            sector. The signature documents this as a numpy.ndarray; the function
            converts the supplied array to dtype numpy.int32 internally before use.
            Each element must satisfy 0 <= addrs[i] < num_strings(norb, nelec). If any
            element is outside this range, an AssertionError is raised. The array length
            determines how many strings are produced and the order of returned strings
            corresponds one-to-one to the input order.
    
    Returns:
        numpy.ndarray: A one-dimensional numpy.ndarray of dtype numpy.int64 and length
            equal to addrs.size. Each element is an integer-encoded occupation "string"
            (bitstring) representing a CI determinant for the given (norb, nelec).
            The returned array preserves the order of the input addresses: returned[i]
            is the occupation string corresponding to addrs[i]. The routine allocates
            this output array and populates it by calling the low-level C function
            libfci.FCIaddrs2str via ctypes; there are no other side effects visible to
            Python code.
    
    Behavior, side effects, and failure modes:
        - The function converts addrs to a numpy.ndarray of dtype numpy.int32 internally.
        - The function allocates an output numpy.ndarray of dtype numpy.int64 (named strs
          in the implementation) of size equal to addrs.size and fills it by calling the
          C routine libfci.FCIaddrs2str through ctypes. This is the primary side effect
          (allocation and a C-level write into the output buffer).
        - If norb >= 64 the function raises NotImplementedError('norb >= 64') because the
          implementation relies on 64-bit integer encodings and does not support wider
          orbital counts.
        - If num_strings(norb, nelec) >= 2**31 the function raises NotImplementedError('Large address')
          to avoid cases where addresses or internal counts exceed the implemented limits
          expected by the low-level routine.
        - If any element of addrs is not strictly less than num_strings(norb, nelec), an
          AssertionError is raised due to the runtime assertion in the implementation.
        - If addrs cannot be converted to a numpy.ndarray of integers (numpy.int32) a
          numpy conversion error will be raised by numpy.asarray.
        - The function is intended for use within PySCF's FCI code paths to map combinatorial
          addresses (indices) of determinants to their occupation patterns so callers can
          build determinants, generate excitations, or interface with other routines that
          operate on bitstring representations.
    """
    from pyscf.fci.cistring import addrs2str
    return addrs2str(norb, nelec, addrs)


################################################################################
# Source: pyscf.fci.addons.transform_ci_for_orbital_rotation
# File: pyscf/fci/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_addons_transform_ci_for_orbital_rotation(
    ci: numpy.ndarray,
    norb: int,
    nelec: tuple,
    u: numpy.ndarray
):
    """pyscf.fci.addons.transform_ci_for_orbital_rotation: Transform CI coefficients (dimension conserved) to the representation in a rotated one-particle basis used in FCI (full configuration interaction) calculations.
    
    Transforms a CI (configuration interaction) coefficient vector or tensor that was obtained for a CI Hamiltonian defined in an original one-particle orbital basis into the equivalent CI coefficients in a new one-particle basis obtained by applying an orbital rotation. In electronic-structure workflows implemented in PySCF, the same CI problem can be solved either by rotating the one- and two-electron integrals (transforming the Hamiltonian) or by transforming the CI coefficients; this function performs the latter. This is useful in contexts such as orbital optimization, post-SCF correlation analyses, or when comparing CI solutions across different orbital bases without rebuilding and diagonalizing the Hamiltonian.
    
    Args:
        ci (numpy.ndarray): CI coefficients in the original one-particle basis. This is the CI vector (or tensor) returned by FCI solvers in PySCF and has the dimensionality expected by the downstream FCI routines. The array encodes the expansion coefficients of the many-electron wavefunction in the occupation-number basis defined by the original orbitals; its shape and dtype are preserved by the transformation (the function returns an array with the same dimensionality).
        norb (int): Number of one-particle orbitals (norb) in the basis used by the CI solver. This integer identifies the dimension of the square orbital rotation matrices and is used to validate the shape of the provided rotation(s). In PySCF FCI usage this typically refers to the number of spatial orbitals per spin sector assumed by the CI representation.
        nelec (tuple): Number of electrons (nalpha, nbeta) used by the CI solver. The tuple defines the electron count in each spin sector and is required by the internal transform routine to map CI occupation patterns when applying the orbital rotation. This argument must match the electron occupancy convention used when the input ci was generated.
        u (numpy.ndarray or list of numpy.ndarray): The orbital rotation(s) that define the change of one-particle basis from the old orbitals to the new orbitals. Acceptable forms are either a single square 2D numpy.ndarray of shape (norb, norb), in which case the same unitary rotation is applied to both spin sectors, or a list of two 2D numpy.ndarray each of shape (norb, norb) providing different rotations for the alpha and beta spin subspaces. The function asserts that the provided array(s) have shape (norb, norb) and will raise an AssertionError if the shapes do not match norb.
    
    Returns:
        numpy.ndarray: CI coefficients expressed in the rotated one-particle basis. The returned array has the same dimensionality and ordering conventions as the input ci (it represents the same many-electron state in the new orbital basis). Using the returned CI coefficients with the original Hamiltonian is equivalent (within numerical precision) to solving the CI eigenproblem with the Hamiltonian transformed by u^T * h1 * u (and the corresponding two-electron integral transformation). No in-place modification of the input ci or u arrays is performed.
    
    Raises:
        AssertionError: If u is a 2D numpy.ndarray and u.shape != (norb, norb), or if u is a list and its first element does not have shape (norb, norb). This function relies on these shape checks to ensure the orbital rotation matrices match norb; incorrect shapes will trigger AssertionError. The underlying transform routine may raise other exceptions if ci or nelec are inconsistent with expected FCI conventions.
    
    Notes:
        The function delegates the actual coefficient-space transformation to the internal transform_ci routine. It preserves the dimension and normalization conventions of the input CI representation so it can be used as a direct replacement for solving the CI problem in the rotated orbital basis (i.e., CI_new = transform_ci_for_orbital_rotation(CI_old, u) is equivalent to re-solving with rotated integrals).
    """
    from pyscf.fci.addons import transform_ci_for_orbital_rotation
    return transform_ci_for_orbital_rotation(ci, norb, nelec, u)


################################################################################
# Source: pyscf.fci.cistring.gen_cre_str_index
# File: pyscf/fci/cistring.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_cistring_gen_cre_str_index(orb_list: list, nelec: int):
    """Generate mapping index from N-electron occupation strings to N+1-electron occupation strings produced by a single creation operator. This function is used in the FCI (full configuration interaction) string handling in PySCF to accelerate construction of matrix elements: for every N-electron Slater determinant (represented by a bitstring produced from orb_list and nelec) it records, for each possible creation into an unoccupied orbital, the orbital index used for creation, an unused placeholder value preserved for compatibility with upstream C routines, the integer index (address) of the resulting N+1-electron string in the ordering used by the FCI code, and the fermionic parity (sign) arising from antisymmetry when inserting the electron.
    
    Args:
        orb_list (list): List of orbital labels used to build occupation bitstrings. The length of this list defines the number of spatial spin-orbitals (norb = len(orb_list)) available for occupations and therefore determines how many creation targets exist for each N-electron string. This argument is passed to the internal make_strings routine that enumerates all N-electron bitstrings; different orb_list orders change the ordering of generated strings and thus the target addresses produced by this function. The function assumes orb_list can be handled by make_strings; if make_strings returns an OIndexList (occurs for very large orbital counts), the function raises NotImplementedError (see Failure modes).
        nelec (int): Number of electrons in the input strings (N). This integer must be strictly less than the number of orbitals (nelec < len(orb_list)), otherwise the function will fail the built-in assertion and raise AssertionError. nelec selects the sector of Slater determinants for which creation mappings are produced: the function enumerates all N-electron strings and, for each, computes which N+1-electron strings result from creating one electron in each available unoccupied orbital.
    
    Returns:
        numpy.ndarray: A 3-dimensional NumPy array of dtype numpy.int32 and shape (n_strings, norb - nelec, 4), where n_strings is the number of distinct N-electron strings produced by make_strings(orb_list, nelec) and norb = len(orb_list). For each input string index s (0 <= s < n_strings) and for each unoccupied-orbital position v (0 <= v < norb - nelec), link_index[s, v] is a length-4 integer array encoding the creation mapping as [cre, placeholder, target_address, parity]:
            cre: integer orbital index used by the creation operator (an index into orb_list).
            placeholder: reserved/unused integer retained for compatibility with the underlying C routine.
            target_address: integer index of the resulting N+1-electron string in the ordering used by the FCI string enumeration for N+1 electrons; this address can be used to look up or index into arrays of N+1-electron strings or matrix elements.
            parity: integer representing the fermionic sign (+1 or -1) that multiplies the state when the electron is inserted into the specified orbital; stored in the same int32 array.
        The returned array is produced by an internal C routine (libfci.FCIcre_str_index) and therefore uses that routine's ordering conventions for unoccupied orbitals and target addresses. The caller should treat the array as read-only mapping data used when assembling CI/FCI Hamiltonian matrix elements.
    
    Behavior, side effects, defaults, and failure modes:
        - The function computes norb = len(orb_list) and asserts nelec < norb; if this assertion fails, an AssertionError is raised.
        - The function enumerates N-electron occupation strings by calling make_strings(orb_list, nelec). If make_strings returns an OIndexList (typically indicating systems with 64 orbitals or more), the function raises NotImplementedError('System with 64 orbitals or more') because the internal C routine does not support that representation.
        - The mapping array is allocated as a contiguous numpy.int32 array and then filled by the compiled C routine libfci.FCIcre_str_index via ctypes. Errors raised by libfci (for example due to inconsistent inputs or C-layer failures) or by ctypes/numpy memory allocation will propagate as their respective Python exceptions (RuntimeError, OSError, MemoryError, etc.).
        - There are no persistent side effects (no global state is modified). The only observable effect is the returned NumPy array describing creation mappings.
        - The function preserves the ordering convention of make_strings and the underlying libfci routine; users must ensure consistent use of orb_list and string-ordering conventions when combining the returned mapping with other FCI routines.
    """
    from pyscf.fci.cistring import gen_cre_str_index
    return gen_cre_str_index(orb_list, nelec)


################################################################################
# Source: pyscf.fci.addons.overlap
# File: pyscf/fci/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_addons_overlap(
    bra: numpy.ndarray,
    ket: numpy.ndarray,
    norb: int,
    nelec: tuple,
    s: list = None
):
    """pyscf.fci.addons.overlap
    Compute the overlap (inner product) between two FCI (full configuration interaction) CI wavefunction coefficient arrays used in PySCF. This routine is used in FCI-related post-processing and analysis within the PySCF framework to evaluate <bra|ket> where bra and ket are CI coefficient tensors defined for a given number of orbitals and electron occupation. When the one-particle basis used to represent the CI wavefunctions is non-orthogonal, an optional overlap/rotation matrix or list of matrices can be provided to transform the bra coefficients into the ket orbital basis before taking the inner product.
    
    Args:
        bra (numpy.ndarray): CI coefficient array representing the "bra" wavefunction. In the PySCF FCI context this is the array of expansion coefficients for determinants/configurations corresponding to norb orbitals and nelec electron occupation (typically a tuple specifying numbers of alpha and beta electrons). The array may be complex-valued; the function uses the complex conjugate of bra when computing the overlap. If s is provided, bra is passed to transform_ci_for_orbital_rotation with arguments (bra, norb, nelec, s) to convert bra to the ket orbital basis prior to contraction. Note that this function assigns the transformed coefficients to a local variable named bra; the original object passed by the caller is not overwritten by this assignment unless the auxiliary transform function modifies the array in-place.
        ket (numpy.ndarray): CI coefficient array representing the "ket" wavefunction in the target orbital basis. ket must be consistent with norb and nelec in shape and ordering so that a direct elementwise inner product is meaningful after any optional transformation of bra. ket is not modified by this function.
        norb (int): Number of orbitals used in the CI expansion. In PySCF FCI routines this integer determines how transform_ci_for_orbital_rotation interprets orbital overlap/rotation matrices s and how CI coefficients map to occupation configurations; norb must match the orbital dimension implied by ket, bra, and any matrices supplied in s.
        nelec (tuple): Electron occupation specification used by the FCI routines, typically a two-element tuple (nalpha, nbeta) giving the number of alpha and beta electrons. This tuple is forwarded to transform_ci_for_orbital_rotation so the CI transformation is performed with the correct configuration space mapping.
        s (list): The overlap matrix of a non-orthogonal one-particle basis, supplied either as a single 2D array or as a list of 2D arrays (the original source allows a single 2D array or a list of them). When s is not None, the function calls transform_ci_for_orbital_rotation(bra, norb, nelec, s) to transform the bra CI coefficients from their native orbital basis into the ket orbital basis before computing the overlap. If s is None (default), no orbital transformation is applied and the overlap is computed directly assuming the two CI coefficient arrays are expressed in the same orthonormal one-particle basis.
    
    Returns:
        numpy.number: A scalar numeric overlap value equal to the inner product <bra|ket>. Concretely, after any optional transformation of bra, the function flattens bra and ket with ravel(), takes the complex conjugate of the flattened bra, and returns numpy.dot(bra.ravel().conj(), ket.ravel()). The returned scalar may be a floating or complex numpy scalar depending on the input coefficient arrays.
    
    Notes on behavior and failure modes:
        - The routine assumes bra and ket are CI coefficient arrays consistent with norb and nelec; mismatched shapes or inconsistent norb/nelec/s combinations will typically raise errors from numpy operations or from transform_ci_for_orbital_rotation.
        - If s is provided but has incorrect dimensions (not matching norb or not square when expected), transform_ci_for_orbital_rotation is expected to raise an error; this function does not perform additional validation beyond invoking the transform.
        - The function does not modify ket. bra is reassigned locally when a transform is applied; whether the original bra object is mutated depends on the implementation details of transform_ci_for_orbital_rotation (this function only assigns its return value to the local name bra).
        - This function is intended for use in post-processing and analysis of PySCF FCI wavefunctions where evaluating overlaps between CI states (possibly expressed in different non-orthogonal orbital bases) is required.
    """
    from pyscf.fci.addons import overlap
    return overlap(bra, ket, norb, nelec, s)


################################################################################
# Source: pyscf.fci.cistring.gen_des_str_index
# File: pyscf/fci/cistring.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_cistring_gen_des_str_index(orb_list: list, nelec: int):
    """Generate an index mapping that relates each N-electron occupation string (bitstring) defined by orb_list to the N-1-electron occupation strings produced by applying a fermionic annihilation operator to that N-electron string. This function is used in the PySCF full configuration interaction (FCI) cistring utilities to accelerate application of annihilation operators when assembling matrix elements, computing determinants, or performing excitation/de-excitation operations in FCI routines.
    
    The function builds the list of N-electron strings by calling make_strings(orb_list, nelec) and then calls the compiled helper libfci.FCIdes_str_index to fill a dense index table. The returned index table lets FCI code look up, for any N-electron string and any choice of an occupied orbital to annihilate, the address of the resulting (N-1)-electron string together with the fermionic sign (parity) resulting from the annihilation.
    
    Args:
        orb_list (list): List of orbital identifiers used to construct the occupation bitstrings. This list is passed unchanged to make_strings(orb_list, nelec). In the domain of PySCF FCI, orb_list defines the set and order of spatial spin-orbitals (or orbital labels) from which the N-electron occupation strings are drawn; the mapping produced by this function uses the same ordering and indexing convention as make_strings.
        nelec (int): Number of electrons in the source occupation strings (N). This function requires nelec > 0 and will assert if nelec is not positive. The function constructs mappings from each N-electron string to N-1-electron strings obtained by annihilating one electron.
    
    Returns:
        numpy.ndarray: A 3-dimensional integer array of shape (n_strings, nelec, 4) and dtype numpy.int32, where n_strings is the number of distinct N-electron strings returned by make_strings(orb_list, nelec). For each source string s (0 <= s < n_strings) and for each annihilation entry k (0 <= k < nelec), link_index[s, k] is a length-4 integer array with components [-, des, target_address, parity] with the following practical meanings:
            - The first element is reserved/unused by the Python layer (kept for compatibility with the underlying C routine).
            - des is the orbital index (as an integer index into orb_list) that is annihilated from the source string s. It identifies which orbital in orb_list was removed to form the target string.
            - target_address is the integer address (index) of the resulting (N-1)-electron string within the list of (N-1)-electron strings produced by make_strings(orb_list, nelec-1). This address is used by FCI routines to locate the resulting configuration efficiently.
            - parity is the integer fermionic sign (typically +1 or -1) produced by moving the annihilated creation/annihilation operator past occupied orbitals; it must be applied when accumulating matrix elements that involve the annihilation operation.
    
    Behavior and side effects:
        - The function asserts that nelec > 0; an AssertionError is raised if this is not satisfied.
        - The function calls make_strings(orb_list, nelec) to enumerate N-electron strings. If make_strings returns an OIndexList (used internally for systems with 64 orbitals or more), the function raises NotImplementedError('System with 64 orbitals or more') because the C helper libfci.FCIdes_str_index is not implemented for that internal representation.
        - The computation of the index table is performed by the compiled routine libfci.FCIdes_str_index; the Python function allocates the numpy array link_index and then passes its pointer to the C routine. No external state is modified beyond the allocation and return of this array.
    
    Failure modes:
        - AssertionError if nelec <= 0.
        - NotImplementedError if make_strings returns an OIndexList (typical for systems with >= 64 orbitals in this code path).
        - Errors raised by make_strings or by the underlying libfci.FCIdes_str_index (for example, if incompatible array shapes or memory errors occur) will propagate to the caller.
    
    Practical significance:
        - This mapping is essential for FCI implementations in PySCF where repeated annihilation operations are needed; using the precomputed index table avoids repeated bit manipulations and provides constant-time lookup of the resulting configuration index and associated sign, enabling efficient assembly of Hamiltonian elements and excitation/de-excitation operators in many-electron computations.
    """
    from pyscf.fci.cistring import gen_des_str_index
    return gen_des_str_index(orb_list, nelec)


################################################################################
# Source: pyscf.fci.cistring.gen_occslst
# File: pyscf/fci/cistring.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_cistring_gen_occslst(orb_list: tuple, nelec: int):
    """pyscf.fci.cistring.gen_occslst — Generate occupied-orbital index lists for every occupation string used in FCI string representations.
    
    Args:
        orb_list (tuple): A sequence (typically a tuple) of orbital indices that defines the available single-particle orbitals from which occupations are formed. In the PySCF FCI context, these integers identify orbital positions that can be occupied in a bitstring representation; the function converts this input to a Python list internally (orb_list = list(orb_list)). If orb_list is not iterable, a TypeError will be raised by the conversion.
        nelec (int): The number of electrons (occupied orbitals) per string. This integer must be non-negative; the function asserts nelec >= 0 and will raise an AssertionError for negative values. In the FCI domain, nelec controls the length of each returned occupation list and determines the combinatorial generation of occupation patterns.
    
    This function enumerates all distinct combinations of occupied orbitals (without repetition) of length nelec drawn from orb_list and returns them as an array-like list-of-indices structure. Each returned entry is an ordered list of the occupied orbital indices for one occupation string; the ordering of entries matches the recursive combination generation used by PySCF (for example, for orb_list = (0, 1, 2, 3) and nelec = 2 the returned rows are [[0,1], [0,2], [1,2], [0,3], [1,3], [2,3]], which corresponds to the same ordering as the bitstring generation used by make_strings in the cistring utilities). Practical significance: callers in FCI routines use this output to map between bitstring representations (occupation bit patterns) and explicit lists of occupied orbital indices required for tensor or integral assembly and for iterating over configuration space.
    
    Behavior and special cases:
        - If nelec == 0, the function returns an array representing a single empty occupation: a shape-(1, 0) integer array (zeros((1, 0), dtype=int32)). This case corresponds to the vacuum (no electrons) configuration.
        - If nelec > len(orb_list), no valid occupations exist; the function returns an empty array with shape (0, nelec) and dtype int32 (zeros((0, nelec), dtype=int32)). This allows callers to detect incompatible orbital/electron counts without raising an exception.
        - If nelec == 1, the result contains one-row lists for each orbital index in orb_list.
        - If nelec >= len(orb_list), the result is a single row equal to orb_list (all orbitals occupied).
        - The function performs no modifications on global state and has no side effects beyond constructing and returning the result array.
    
    Failure modes and complexity:
        - AssertionError is raised if nelec is negative.
        - TypeError will be raised if orb_list is not iterable when converting with list(orb_list).
        - The number of returned rows grows as the binomial coefficient C(len(orb_list), nelec), so memory and runtime scale combinatorially with orbital count and electron number; callers should avoid very large orb_list/nelec combinations.
    
    Returns:
        OIndexList: A numpy.ndarray.view of type OIndexList containing int32 entries. The array has shape (n_strings, nelec) where n_strings is the number of distinct occupation strings C(len(orb_list), nelec) (or 1 or 0 for the special cases noted). Each row is a list of occupied orbital indices corresponding to one FCI occupation string. The dtype is numpy.int32 to match downstream FCI tensor indexing conventions.
    """
    from pyscf.fci.cistring import gen_occslst
    return gen_occslst(orb_list, nelec)


################################################################################
# Source: pyscf.fci.cistring.gen_linkstr_index
# File: pyscf/fci/cistring.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_cistring_gen_linkstr_index(
    orb_list: list,
    nocc: int,
    strs: numpy.ndarray = None,
    tril: bool = False
):
    """pyscf.fci.cistring.gen_linkstr_index generates a lookup table (link index) that describes how occupation-number strings (Slater determinant bit-strings used in Full Configuration Interaction (FCI) within PySCF) are transformed by a single fermionic annihilation-creation operator pair. This lookup table is used by FCI routines to efficiently form Hamiltonian and excitation matrix elements by mapping an initial string and an excitation (annihilate an occupied orbital, create in a target orbital) to the index of the resulting string and the accompanying fermionic phase factor.
    
    Args:
        orb_list (list): Ordered list of orbital indices (the spatial or spin-orbital labels) that define the basis for the bit-strings. The length of this list determines norb (the total number of orbitals) used to compute nvir = norb - nocc. In the PySCF FCI context, orb_list selects which orbitals are considered when constructing occupation strings via make_strings and when enumerating possible excitations.
        nocc (int): Number of occupied orbitals in each string (the occupation count for the determinants). In the FCI domain this is the number of electrons (per spin sector when used in spin-specific routines) that are occupied in each occupation-number string; it sets the number of annihilation indices and therefore controls the layout and size (nocc and nocc*nvir blocks) of the returned link index.
        strs (numpy.ndarray = None): Optional one-dimensional array of integer-encoded occupation strings (string indices) sorted in strictly increasing order. If None (the default), make_strings(orb_list, nocc) is called to generate the full ordered list of strings for the given orb_list and nocc. The array is converted to numpy.int64 internally. If strs is an instance of OIndexList, the routine delegates to gen_linkstr_index_o1(orb_list, nocc, strs, tril) and returns that result instead. This parameter allows restricting the lookup table to a precomputed subset or custom ordering of strings used elsewhere in PySCF FCI workflows.
        tril (bool = False): Flag controlling whether the underlying C routine should compute the link index in a triangular/half-storage mode. The boolean value is forwarded unchanged to the low-level libfci.FCIlinkstr_index routine. In practice, tril=True is used by algorithms that only need a triangular subset of links (e.g., exploiting symmetry or half-matrix storage) while tril=False computes the full link information. Default is False.
    
    Returns:
        numpy.ndarray: A 3-dimensional NumPy array of dtype numpy.int32 with shape (na, nocc + nocc*nvir, 4), where na is the number of strings (strs.shape[0]) and nvir = len(orb_list) - nocc. Each row of the second dimension is a 4-tuple with the semantics [orb_created, orb_annihilated, resulting_string_index, sign]:
            - orb_created: integer orbital index created by the excitation (for occupied-occupied rows this equals the annihilated orbital index).
            - orb_annihilated: integer orbital index annihilated by the excitation.
            - resulting_string_index: integer index (into the provided strs array or the canonical strings generated from orb_list and nocc) of the string obtained after applying the annihilation-creation operator pair to the original string.
            - sign: integer fermionic phase factor associated with reordering creation/annihilation operators when applying the excitation; it is used when assembling matrix elements from the link table.
        The first nocc rows of the second dimension correspond to occupied-occupied "excitations" that do not change the string and therefore typically have resulting_string_index equal to the original string index; the remaining nocc*nvir rows enumerate occupied->virtual excitations (annihilate an occupied orbital i, create a virtual orbital a) starting from the original string.
    
    Behavior, side effects, and failure modes:
        - If strs is None, this function calls make_strings(orb_list, nocc) to produce the canonical ordered list of strings used throughout PySCF FCI code paths.
        - If strs is an OIndexList, the function delegates to gen_linkstr_index_o1 and returns that result; callers relying on the exact returned layout should be aware of this delegation.
        - The function converts strs to numpy.int64 internally and allocates the returned link_index array with dtype numpy.int32.
        - The function asserts that the provided strs array is strictly increasing (all(strs[:-1] < strs[1:])); if this condition is not met an AssertionError will be raised.
        - The function invokes a low-level C routine libfci.FCIlinkstr_index via ctypes to fill the link-index buffer; therefore errors in the compiled libfci backend, incompatible array layouts, or missing libfci bindings may result in runtime exceptions propagated from the underlying call.
        - No external state is mutated by this function beyond allocating and returning the link index array; the result is suitable for direct use in FCI matrix assembly and related algorithms.
    """
    from pyscf.fci.cistring import gen_linkstr_index
    return gen_linkstr_index(orb_list, nocc, strs, tril)


################################################################################
# Source: pyscf.fci.cistring.reform_linkstr_index
# File: pyscf/fci/cistring.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_cistring_reform_linkstr_index(link_index: numpy.ndarray):
    """pyscf.fci.cistring.reform_linkstr_index compresses the (a, i) pair index stored in a link-string index array into a single lower-triangular integer index. The compression produces indices that are consistent with the 4-fold permutation symmetry commonly exploited for two-electron integrals in FCI (full configuration interaction) routines, allowing downstream code to identify equivalent excitation pairs and reduce redundant integral lookups or storage.
    
    Args:
        link_index (numpy.ndarray): A 3-dimensional numpy array that encodes link-string information produced and consumed by the pyscf.fci.cistring routines. The function expects link_index to have the shape (nlink, nrow, 4) or equivalent, where the last axis holds the fields (a, i, str1, sign) for each link entry. In this convention, column 0 (a) and column 1 (i) are integer orbital indices identifying the creation/annihilation orbital pair for the link; column 2 (str1) is an integer string index used by FCI determinant string tables; column 3 (sign) is an integer sign (+1 or -1) associated with the excitation. The array must be a numpy.ndarray; passing another type may raise a TypeError. Supplying an array with fewer than two indexed columns or with insufficient trailing dimension length will raise an IndexError.
    
    Returns:
        numpy.ndarray: A new numpy.ndarray with the same shape as the input link_index. The returned array is a copy of the input with the following deterministic transformations applied: the original pair indices a and i (columns 0 and 1) are replaced so that column 0 contains the compressed lower-triangular index computed as max(a*(a+1)//2 + i, i*(i+1)//2 + a) and column 1 is set to 0 for all entries. Columns 2 and 3 (str1 and sign) are preserved without modification. The function performs an explicit copy (link_index.copy()) before modification, so the original input array is not mutated. Typical usage is to call this function during FCI Hamiltonian assembly or link-string preprocessing to map excitation pairs to a single index compatible with four-fold integral symmetry, enabling more efficient lookup and deduplication of integral contributions.
    
    Behavior, side effects, and failure modes:
        The function implements integer arithmetic and integer floor-division (//). If the elements in columns 0 and 1 are not integer-like, the arithmetic may produce unexpected results or raise errors. The function returns a new array and does not modify the input (no in-place side effects). If link_index has an unexpected shape (for example, missing the expected columns for a and i) an IndexError will be raised. The mapping uses the specific formula shown above to ensure that (a,i) and (i,a) map to the same compressed index, matching the lower-triangular packing convention used for symmetric two-electron integrals in PySCF's FCI implementation.
    """
    from pyscf.fci.cistring import reform_linkstr_index
    return reform_linkstr_index(link_index)


################################################################################
# Source: pyscf.fci.cistring.gen_linkstr_index_trilidx
# File: pyscf/fci/cistring.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_cistring_gen_linkstr_index_trilidx(
    orb_list: list,
    nocc: int,
    strs: list = None
):
    """Generate link-string index for two-body single-excitation operators with enforced lower-triangular ordering (p > q) used in PySCF FCI string handling.
    
    This function is part of the pyscf.fci.cistring utilities that build data structures for mapping excitation operators onto determinant bit-string representations in full configuration interaction (FCI) algorithms. In the domain of quantum chemistry and PySCF, gen_linkstr_index_trilidx produces the link-string index entries for operators of the form p^+ q acting on many-electron basis states, with the explicit convention that the creation orbital index p is strictly greater than the annihilation orbital index q (the "lower-triangular" or trilidx convention). The produced index has the structure [pq, *, str1, sign] for each linked excitation as returned by the underlying gen_linkstr_index call with the trilidx flag enabled. This function simply invokes gen_linkstr_index with trilidx=True and therefore yields exactly the same result as reform_linkstr_index(gen_linkstr_index(...)) when that reform operation enforces the trilidx ordering.
    
    Args:
        orb_list (list): List of orbital indices or an iterable that defines the set of single-particle orbitals considered when constructing determinant bit-strings. In practice within PySCF FCI routines, orb_list determines which orbital positions are represented in the bit-string basis and therefore which p and q values are valid for generating link strings. Providing orb_list that does not match the basis used elsewhere in the calculation will produce indices that are incompatible with those determinants.
        nocc (int): Number of occupied electrons in each determinant (number of set bits per string) used to generate the FCI string space. This integer controls the size of the determinant space over orb_list for which link strings are generated; typical use is the number of electrons (or electrons per spin sector) in the active space. If nocc is inconsistent with orb_list (for example, nocc < 0 or nocc > len(orb_list)), the underlying generator may raise an exception.
        strs (list): Optional precomputed list of determinant bit-strings (usually represented as integers or bit-vectors) to use instead of constructing the full list from orb_list and nocc. When strs is None (the default), the underlying gen_linkstr_index routine will compute the determinant strings for the given orb_list and nocc. When a list is provided, this function uses that list directly to generate link-string indices for the supplied determinants. The elements and ordering of strs must match the representation expected elsewhere in the FCI workflow; mismatches will cause incorrect mappings or propagated errors.
    
    Returns:
        list: A list of link-string index entries suitable for use in FCI matrix-vector routines and other cistring utilities. Each entry follows the structure [pq, *, str1, sign] as produced by gen_linkstr_index with trilidx=True, where pq encodes the paired orbital indices (with the enforced ordering p > q), the placeholder * contains internal metadata used by downstream routines, str1 identifies the target determinant string after applying the p^+ q operator, and sign is the fermionic phase (+1 or -1) associated with that excitation. The returned list is deterministic and has no side effects on global state.
    
    Behavior, defaults, and failure modes:
        This function is a thin wrapper that calls gen_linkstr_index(orb_list, nocc, strs, True). It enforces the trilidx (lower-triangular p>q) convention so that each two-index excitation appears once with the specified ordering. There are no side effects beyond returning the computed index list. Errors and exceptions from the underlying gen_linkstr_index (for example, due to invalid orb_list elements, inconsistent nocc, or malformed strs entries) are propagated to the caller; this function does not catch them. Use this function when the FCI workflow or storage format requires the p>q convention to avoid duplicated or symmetrically equivalent excitations.
    """
    from pyscf.fci.cistring import gen_linkstr_index_trilidx
    return gen_linkstr_index_trilidx(orb_list, nocc, strs)


################################################################################
# Source: pyscf.fci.cistring.gen_linkstr_index_o1
# File: pyscf/fci/cistring.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_cistring_gen_linkstr_index_o1(
    orb_list: list,
    nelec: int,
    strs: list = None,
    tril: bool = False
):
    """gen_linkstr_index_o1 generates a lookup table that encodes how Slater determinants
    (occupation strings) in the PySCF FCI cistring representation are related by a
    single one-electron operator a_p^\dagger a_q (a creation at orbital p and
    annihilation at orbital q). This table is used in full configuration interaction
    (FCI) routines inside PySCF to quickly enumerate nonzero connections between
    determinants produced by single excitations or diagonal (p==q) one-electron
    terms when assembling Hamiltonian or other one-body operator matrix elements.
    
    Args:
        orb_list (list): Ordered list of orbital indices that defines the orbital
            labeling used to construct occupation strings. In the implementation the
            function requires orb_list to be equal to list(range(norb)) for some
            norb (i.e., 0-based contiguous indexing). The list determines norb
            (number of orbitals) and is used to compute the number of virtual
            orbitals nvir = norb - nelec. The practical significance in the FCI
            domain is that orb_list fixes the mapping between orbital labels and
            bitstring/occupation-list representations used across the cistring
            routines; an orb_list not equal to range(norb) will trigger an
            AssertionError.
        nelec (int): Number of electrons in the occupation strings (number of
            occupied orbitals per determinant). This integer determines the length
            of each occupation list in occslst (the number of ones in each string)
            and the layout/size of the returned link table. In FCI use, nelec is
            the electron count for the configuration space being considered; nelec
            == 0 is a special-case handled by returning an empty-shaped index
            array.
        strs (list): Optional list of occupation-index lists (OIndexList). Each
            element of strs is an occupation string represented as an ordered list
            (or array/tuple) of nelec occupied orbital indices. This list serves as
            occslst (the full list of determinants) for which the link table is
            constructed. If strs is None (the default), the function generates the
            standard ordered list of occupation strings for the given orb_list and
            nelec by calling gen_occslst(orb_list, nelec). In practical FCI code you
            pass a precomputed occslst (list of OIndexList) when you need the
            link-table consistent with an externally constructed determinant order.
            If strs does not contain all determinants reachable by single excitations
            from its members (i.e., is inconsistent with orb_list and nelec),
            lookups during construction will raise a KeyError.
        tril (bool): If False (default), return the full per-determinant link table
            in the raw format described below. If True, after building the table
            the function calls reform_linkstr_index on the result and returns that
            transformed representation. The tril flag is provided for callers that
            require the alternative (e.g., triangular or reduced) storage format
            produced by reform_linkstr_index; the exact effect is the same as
            applying reform_linkstr_index(lidx) to the full index.
    
    Returns:
        numpy.ndarray: Integer array (dtype numpy.int32) encoding the one-electron
        links for each determinant in occslst. Let nstr = len(occslst) and nvir =
        norb - nelec. For the common nontrivial case nelec > 0 the returned array
        has shape (nstr, nelec*(1 + nvir), 4) and layout described column-wise as:
            Column 0: destination (creation) orbital index p (0-based).
            Column 1: source (annihilation) orbital index q (0-based).
            Column 2: address (integer index into occslst) of the resulting
                      occupation string after applying a_p^\dagger a_q.
            Column 3: phase (parity) equal to +1 or -1 giving the fermionic sign
                      associated with that operator pair and the ordering of the
                      occupation list. For the diagonal entries where p == q the
                      address equals the original determinant index and phase == 1.
        For the special case nelec == 0 the function returns numpy.zeros((0, 0, 4),
        dtype=numpy.int32).
        The returned array is intended for direct use by FCI matrix builders and
        other routines that need fast mapping from (determinant, p, q) to the
        connected determinant index and fermionic sign.
    
    Behavior, side effects, and failure modes:
        The function is pure with respect to its inputs (it does not mutate orb_list
        or strs). If strs is None the function calls gen_occslst(orb_list, nelec)
        to construct the determinant list; this is the normal default behavior when
        building link tables for the full canonical determinant ordering used in
        PySCF FCI. An AssertionError is raised if orb_list does not equal
        numpy.arange(norb) (the code enforces contiguous 0-based orbital indices).
        A KeyError may be raised during table construction if strs is provided but
        does not contain required occupation strings for lookups. TypeErrors or
        value errors may arise if inputs are not sequences/integers as expected.
        The function returns int32 arrays (explicit dtype) to minimize memory and
        to match expectations of downstream PySCF FCI routines.
    """
    from pyscf.fci.cistring import gen_linkstr_index_o1
    return gen_linkstr_index_o1(orb_list, nelec, strs, tril)


################################################################################
# Source: pyscf.fci.cistring.gen_strings4orblist
# File: pyscf/fci/cistring.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_cistring_gen_strings4orblist(orb_list: list, nelec: int):
    """pyscf.fci.cistring.gen_strings4orblist: Generate occupation bitstrings for a specified list of orbitals used by the FCI routines in PySCF.
    
    This function enumerates all distinct occupation bitstrings with a fixed number of electrons (nelec) distributed over the orbitals listed in orb_list. It is used in the pyscf.fci module to represent Slater determinants / occupation patterns compactly as integer bitmasks when constructing and manipulating Full Configuration Interaction (FCI) wavefunctions and Hamiltonians. Each returned integer is a 64-bit signed integer (numpy.int64) whose binary representation encodes orbital occupancy: a bit value of 1 indicates the corresponding orbital is occupied, and 0 indicates it is unoccupied. The lowest (right-most) bit corresponds to the lowest orbital index in orb_list, so the integer value can be interpreted directly as a binary occupation string consistent with the examples and conventions in the FCI code paths.
    
    Args:
        orb_list (list): List of orbital indices to consider when generating occupation strings. Each element is interpreted as an integer orbital index and the position of that orbital in orb_list determines which bit in the returned integer corresponds to that orbital (the element at orb_list[0] maps to the least-significant bit). The function converts the input to a list internally, so the caller should provide the indices in the desired order. Elements must be integers suitable for bit-shift operations; negative or non-integer entries will raise exceptions or cause incorrect results. The function switches to an alternative implementation (gen_occslst) when len(orb_list) >= 64 to avoid constructing bitstrings larger than a 64-bit word.
        nelec (int): Number of electrons (occupied orbitals) to place among the orbitals in orb_list. This is interpreted as a non-negative integer count. If nelec == 0 the function returns an array containing a single zero-valued bitstring (no occupied orbitals). If nelec is greater than len(orb_list) the function returns an empty array. If nelec is negative an AssertionError is raised (the function asserts nelec >= 0). Typical usage in the FCI domain is to call this with the number of spin-up or spin-down electrons to enumerate all occupation patterns for that spin sector.
    
    Returns:
        numpy.ndarray: One-dimensional numpy array of dtype numpy.int64. Each element is an integer whose binary representation is an occupation bitstring: bit-1 means occupied and bit-0 means unoccupied, with the least-significant bit corresponding to orb_list[0] (the lowest orbital in the provided list). The number of returned strings equals the binomial coefficient C(len(orb_list), nelec) for 0 <= nelec <= len(orb_list); the code asserts this equality and will raise an AssertionError if the generated count does not match num_strings(len(orb_list), nelec). Special-case returns: when nelec == 0 the return is array([0], dtype=numpy.int64); when nelec > len(orb_list) the return is an empty numpy.int64 array; when len(orb_list) >= 64 the implementation delegates to gen_occslst(orb_list, nelec) which returns an equivalent numpy.int64 array. The generation routine is combinatorial in complexity and can be memory- and CPU-intensive for large orb_list and intermediate nelec values; callers should be aware of potential performance and memory limitations.
    """
    from pyscf.fci.cistring import gen_strings4orblist
    return gen_strings4orblist(orb_list, nelec)


################################################################################
# Source: pyscf.fci.cistring.strs2addr
# File: pyscf/fci/cistring.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_cistring_strs2addr(norb: int, nelec: int, strings: list):
    """Convert a list of occupation bitstrings to CI determinant addresses used by the PySCF FCI routines.
    
    This function maps each occupation string (an integer encoding an electron occupation pattern using bit positions) to its corresponding integer address in the CI (configuration interaction) determinant ordering implemented by pyscf.fci.cistring and the underlying C helper libfci. It is intended for use when assembling or indexing FCI vectors and matrices: given raw bitstring representations of determinants, strs2addr returns the zero-based index into the CI space used throughout PySCF FCI code.
    
    Args:
        norb (int): Number of orbitals whose occupations are encoded in each bitstring. Practically, each input integer in strings must use only the lowest norb bits to represent occupations. This function requires norb < 64 because bitstrings are converted to 64-bit integers (numpy.int64) for the mapping; if norb >= 64 the function raises NotImplementedError.
        nelec (int): Number of electrons in each determinant. This value is used to determine the size and ordering of the CI space (num_strings(norb, nelec)) and to validate the address range that can be represented. If the total number of determinants num_strings(norb, nelec) is >= 2**31 the function raises NotImplementedError because addresses are returned as 32-bit integers.
        strings (list): Sequence of integer occupation strings to convert. Each element should be an integer (or convertible to numpy.int64) encoding the occupation pattern with bits corresponding to orbital occupations; typically the integer has exactly nelec bits set. The input is converted to a numpy.int64 array internally. Invalid bit patterns (for example using bits at positions >= norb or not matching nelec when such validation is expected downstream) may produce undefined results or errors from the underlying C routine.
    
    Behavior, side effects, and failure modes:
        The function converts strings to a numpy.int64 array, allocates a numpy.int32 array of the same length to hold addresses, and calls the C extension libfci.FCIstrs2addr to perform the mapping in C for efficiency. The returned addresses are zero-based indices into the CI determinant ordering used by PySCF. If strings is empty, an empty numpy.int32 array is returned. The function raises NotImplementedError when norb >= 64 or when num_strings(norb, nelec) >= 2**31 to avoid unsupported bit-widths and overflow of 32-bit addresses. If elements of strings are not representable as 64-bit integers or contain invalid occupation encodings, the underlying C routine may raise an exception or produce undefined results.
    
    Returns:
        numpy.ndarray: One-dimensional numpy array of dtype numpy.int32 and length equal to len(strings). Each element is the zero-based CI address (index) corresponding to the input occupation string according to the FCI string ordering used by pyscf.fci.cistring and libfci.
    """
    from pyscf.fci.cistring import strs2addr
    return strs2addr(norb, nelec, strings)


################################################################################
# Source: pyscf.fci.cistring.sub_addrs
# File: pyscf/fci/cistring.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_cistring_sub_addrs(
    norb: int,
    nelec: int,
    orbital_indices: list,
    sub_nelec: int = 0
):
    """The addresses (integer indices) of the FCI determinants that match occupancy conditions on a set of orbital indices. This function is part of pyscf.fci.cistring and is used in Full Configuration Interaction (FCI) workflows within the PySCF electronic-structure framework to map bitstring determinants to their linear addresses in the canonical (norb, nelec) determinant ordering produced by strs2addr and make_strings.
    
    When sub_nelec == 0 the function constructs determinant bit-strings by calling make_strings(orbital_indices, nelec) and returns their addresses in the (norb, nelec) space via strs2addr. When sub_nelec != 0 the function enumerates all (norb, nelec) determinants, counts how many of the specified orbital_indices are occupied in each determinant, selects determinants with exactly sub_nelec of those orbitals occupied, and returns the addresses of that selected subset via strs2addr. The returned addresses can be used as indices into arrays or vectors that are ordered according to the cistring (bitstring) canonical ordering used across PySCF FCI utilities.
    
    Args:
        norb (int): Total number of spatial orbitals in the FCI problem. This value is asserted to be less than 64 (assert norb < 64) because determinants are represented by 64-bit bitstrings; passing norb >= 64 triggers an AssertionError. In the domain of PySCF FCI code, norb determines the bit-width and the combinatorial size of the determinant space.
        nelec (int): Total number of electrons (occupied orbitals) in each determinant. This integer defines the occupancy constraint used to generate or enumerate determinants and is passed to make_strings and strs2addr to produce the canonical (norb, nelec) determinant ordering.
        orbital_indices (list): A Python list of orbital indices (integers) that specify which orbitals are relevant to the selection criterion. For sub_nelec != 0, each element of this list is interpreted as a bit position tested against each full-system determinant (0-based indices, expected to be in the range [0, norb-1]); the function counts how many of these indices are occupied. For sub_nelec == 0, this list is passed directly to make_strings(orbital_indices, nelec) to generate bitstrings restricted to the provided set (behavior follows the cistring.make_strings API). Supplying indices outside the valid 0..norb-1 range or non-integer entries will lead to incorrect results or runtime errors when bitwise operations are applied.
        sub_nelec (int): Optional integer flag (default 0). If sub_nelec == 0 the function uses orbital_indices as the argument to make_strings to generate bitstrings directly and returns their addresses. If sub_nelec != 0 the function treats orbital_indices as positions to be counted in the full (norb, nelec) determinant enumeration and returns addresses for determinants that have exactly sub_nelec of those specified orbitals occupied. Using a sub_nelec value larger than len(orbital_indices) or larger than nelec will simply produce an empty result (no matching determinants).
    
    Returns:
        numpy.ndarray: An array of integer addresses (indices) corresponding to determinants in the canonical (norb, nelec) ordering produced by strs2addr. The length of this array equals the number of determinants that satisfy the selection rule described above: for sub_nelec != 0, the number of full-system determinants with exactly sub_nelec of orbital_indices occupied; for sub_nelec == 0, the number of bitstrings generated by make_strings(orbital_indices, nelec). These addresses are suitable for indexing vectors or matrices that are ordered according to the cistring determinant indexing used throughout PySCF FCI routines.
    
    Failure modes and side effects: The function performs no external I/O and has no side effects beyond returning an array. It asserts norb < 64 and will raise AssertionError if that condition is violated. Invalid orbital indices (non-integers or values outside 0..norb-1) will lead to incorrect filtering or runtime errors when bitwise operations are performed. For large norb and nelec the enumeration of all determinants (performed when sub_nelec != 0) can be computationally and memory intensive due to combinatorial growth; use with care for large configuration spaces.
    """
    from pyscf.fci.cistring import sub_addrs
    return sub_addrs(norb, nelec, orbital_indices, sub_nelec)


################################################################################
# Source: pyscf.fci.cistring.tn_strs
# File: pyscf/fci/cistring.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_cistring_tn_strs(norb: int, nelec: int, n: int):
    """Generate integer-encoded Slater determinant strings that enumerate n-electron excitation
    patterns (Tn amplitudes) used by the Full Configuration Interaction (FCI) routines in
    pyscf.fci.cistring. This function constructs all determinants obtained by exciting
    exactly n electrons from the Hartree–Fock (HF) reference (first nelec orbitals occupied)
    into the virtual space (orbitals nelec..norb-1). The result is used to index Tn amplitude
    tensors in post-Hartree–Fock methods where excitations are represented as bitstrings
    encoded in Python integers (consistent with cistring.make_strings).
    
    Args:
        norb (int): Total number of spatial orbitals (the size of the one-particle basis).
            This integer determines the size of the Hilbert space partitioning into occupied
            and virtual orbitals. Must be an integer value; the implementation raises
            NotImplementedError if norb >= 64 (the function is not implemented for 64 or
            more orbitals in this routine). No other implicit conversion is performed.
        nelec (int): Number of electrons (occupied orbitals) in the Hartree–Fock reference.
            The HF reference used by this routine is the determinant with the lowest
            nelec orbitals occupied (bits 0..nelec-1 set). nelec is expected to be a
            non-negative integer. If nelec < n or norb - nelec < n (not enough occupied or
            virtual orbitals to form n-fold excitations), the function returns an empty
            1D numpy.ndarray of dtype int (see Returns).
        n (int): Excitation rank (the number of electrons to be excited). This integer
            specifies Tn (for example, n=1 for T1 amplitudes, n=2 for T2). The routine
            enumerates combinations of n occupied orbitals to remove and n virtual orbitals
            to occupy. If combinatorial conditions are not met (see nelec and norb - nelec),
            the routine returns an empty array.
    
    Behavior and practical details:
        - The routine uses cistring.make_strings to generate allowed occupation-combination
          bitmasks for occupied and virtual spaces. occs_allow is taken from
          make_strings(range(nelec), n) and reversed (occs_allow[::-1]) to produce the
          ordering of occupied removals; virs_allow is make_strings(range(nelec, norb), n).
        - The Hartree–Fock reference bitstring is constructed as hf_str = int('1'*nelec, 2)
          (bits corresponding to the lowest nelec orbitals set to one).
        - For each allowed virtual-combination mask v and each allowed occupied-combination
          mask o, the excited determinant bitstring is computed as (hf_str | v) ^ o:
          first set the virtual bits on top of the HF reference, then toggle off the
          occupied bits indicated by o. The function performs these operations in a
          broadcasted vectorized way and then flattens the 2-D array.
        - The output ordering is deterministic: virtual combinations (virs_allow) form the
          outer loop and occupied combinations (occs_allow) form the inner loop. Concretely,
          for each virtual selection the routine iterates over all occupied selections;
          thus, contiguous blocks in the returned array correspond to a fixed virtual
          selection with varying occupied choices.
        - The number of returned strings when combinatorics allow is binomial(norb-nelec, n)
          * binomial(nelec, n) (i.e., choose n virtuals from nvir and n occupied from nocc).
        - No side effects occur (the function does not modify global state). The function
          depends on numpy and cistring.make_strings.
    
    Failure modes and special cases:
        - If norb >= 64 the function raises NotImplementedError('norb >= 64').
        - If nelec < n or norb - nelec < n the function returns a zero-length numpy.ndarray
          with dtype int (numpy.zeros(0, dtype=int)); this signals that the requested
          n-fold excitations are not possible given the electron/orbital counts.
        - Inputs that violate the expected integer/non-negative nature may lead to errors
          from underlying utilities (e.g., range or make_strings); callers should pass
          valid integer counts.
    
    Returns:
        numpy.ndarray: A one-dimensional numpy array of dtype int containing integer-encoded
        Slater determinant bitstrings. Each integer encodes occupancies in the usual
        cistring convention: bit k set indicates orbital k is occupied. The array is
        flattened in row-major order where virtual combinations vary slower (outer index)
        and occupied combinations vary faster (inner index). When combinatorial conditions
        are not met the function returns a zero-length array (dtype int).
    """
    from pyscf.fci.cistring import tn_strs
    return tn_strs(norb, nelec, n)


################################################################################
# Source: pyscf.fci.direct_ep.make_rdm1e
# File: pyscf/fci/direct_ep.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_ep_make_rdm1e(fcivec: numpy.ndarray, nsite: int, nelec: tuple):
    """Compute the one-electron reduced density matrix dm_pq = <c_p^† c_q> for a full configuration interaction
    (FCI) wavefunction represented in the occupation-string basis. This function is part of the PySCF FCI routines
    (pyscf.fci.direct_ep) and is used in electronic-structure workflows to obtain the 1-particle reduced density matrix
    (1-RDM) from an FCI vector. The resulting 1-RDM is commonly used to evaluate one-electron expectation values,
    construct natural orbitals, and as input to correlated property computations in quantum chemistry.
    
    Args:
        fcivec (numpy.ndarray): Full CI wavefunction coefficients expressed in the occupation-number (string) basis.
            The array must be reshapeable by the function into shapes compatible with the numbers of alpha and beta
            occupation strings for the given nsite and nelec. Concretely, if na and nb are the numbers of alpha and
            beta strings computed internally from nsite and nelec (via cistring.num_strings), fcivec must be reshapeable
            to (na, -1) for the alpha-spin accumulation loop and to (na, nb, -1) for the beta-spin accumulation loop.
            A common valid input is a 1-D vector of length na*nb (i.e., fcivec.reshape(na, nb) or fcivec.reshape(na, nb, 1)).
            The ordering of basis states in fcivec must match the occupation-string ordering used by the cistring utilities
            (cistring.gen_linkstr_index and cistring.num_strings) because the function builds the 1-RDM by following those
            link indices and associated sign factors.
        nsite (int): Number of spatial orbitals or lattice sites in the FCI problem. This integer determines the range of
            orbital indices (0..nsite-1) and is used to generate occupation-string link tables. In domain terms within PySCF,
            nsite is the number of single-particle spatial basis functions used to construct many-electron occupation strings.
        nelec (tuple): A two-element tuple specifying the number of alpha and beta electrons as (neleca, nelecb). This
            tuple is unpacked internally (via _unpack_nelec) and drives the construction of alpha/beta string spaces. The
            order is significant: the first element is the alpha-electron count and the second is the beta-electron count.
            The provided nelec must be consistent with nsite (for example, 0 <= neleca+nelecb <= nsite for single-occupancy
            fermionic strings) and with the expectations of cistring utilities.
    
    Returns:
        numpy.ndarray: A 2-D array of shape (nsite, nsite) containing the computed one-electron reduced density matrix
        dm_pq = <c_p^† c_q>, accumulated from both alpha and beta spin contributions. Each element rdm1[p, q] is the
        expectation value of annihilating an electron in orbital q and creating one in orbital p for the provided FCI
        wavefunction. The return value is a fresh NumPy array (no in-place modification of inputs) and represents the
        physical 1-RDM used in subsequent property evaluations and orbital analyses.
    
    Behavior and failure modes:
        - The function constructs link-index tables for alpha and beta occupation strings using cistring.gen_linkstr_index
          and iterates those tables to accumulate contributions to the 1-RDM. Sign factors returned by the link tables
          (fermionic phase) are applied exactly as provided by the cistring utilities.
        - No external state or global variables are modified; the function has no side effects beyond allocating and
          returning the rdm1 array.
        - If fcivec cannot be reshaped to the required intermediate shapes (na, -1) and (na, nb, -1) implied by nsite
          and nelec, NumPy will raise a ValueError from the reshape operation. If nelec is not a valid unpackable pair
          or is inconsistent with nsite, helper routines (_unpack_nelec, cistring.*) may raise exceptions.
        - The numeric dtype of the returned array follows NumPy broadcasting and accumulation rules given the dtype of
          fcivec; callers should ensure fcivec uses an appropriate numeric dtype (real or complex) consistent with their
          FCI representation.
    """
    from pyscf.fci.direct_ep import make_rdm1e
    return make_rdm1e(fcivec, nsite, nelec)


################################################################################
# Source: pyscf.fci.direct_ep.make_rdm12e
# File: pyscf/fci/direct_ep.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_ep_make_rdm12e(fcivec: numpy.ndarray, nsite: int, nelec: tuple):
    """pyscf.fci.direct_ep.make_rdm12e computes the one-electron and two-electron reduced density matrices (RDMs) from a full configuration interaction (FCI) coefficient vector in the direct_ep/site-based representation used in PySCF. This function is used in FCI workflows to obtain spatial (site/orbital) RDMs required for expectation values, energy contributions, and property evaluation. The returned RDMs are built by summing over spin-up and spin-down occupation-string sectors and are reordered so the 2-particle RDM follows the chemist convention.
    
    Args:
        fcivec (numpy.ndarray): Flattened FCI coefficient vector containing CI amplitudes for all combinations of alpha and beta occupation strings and any additional symmetry or block structure. The array is reshaped internally to shape (na, nb, -1) where na = number of alpha strings (num_strings(nsite, neleca)) and nb = number of beta strings (num_strings(nsite, nelecb)). Practically, fcivec must contain na*nb times any extra block size elements; otherwise numpy.reshape will raise an error. The entries represent the amplitude <configuration|Psi> for each product of alpha and beta occupation strings.
        nsite (int): Number of spatial sites or orbitals in the site-based FCI representation. This integer determines the dimensions of the returned RDMs: rdm1 has shape (nsite, nsite) and rdm2 has shape (nsite, nsite, nsite, nsite). nsite must match the occupation-string generation and the physical system used to produce fcivec.
        nelec (tuple): Tuple of two integers (neleca, nelecb) giving the number of spin-up (alpha) and spin-down (beta) electrons respectively. These counts are used to generate occupation-string indices for alpha and beta sectors (via cistring.gen_linkstr_index and cistring.num_strings) and must be consistent with the length/structure of fcivec. If nelec is not a two-element tuple of integers, or the counts do not match fcivec's implicit na/nb, the function will fail when reshaping or indexing.
    
    Behavior and algorithmic details:
        The function interprets the FCI vector as organized by alpha/beta occupation strings. It generates link-index tables for creation/annihilation operators in the alpha and beta sectors (cistring.gen_linkstr_index), reshapes fcivec to (na, nb, -1), and constructs an intermediate tensor t1 that represents the result of single creation/annihilation operations applied to the CI coefficients. It accumulates contributions to the one-particle RDM via an einsum contraction between the CI block and t1 and constructs the two-particle RDM by forming the matrix product of flattened t1 tensors and reshaping/transposing the result to match the required index layout. The intermediate rdm1 and rdm2 are then passed to rdm.reorder_rdm with the flag True to produce the final ordering: rdm1_pq = <Psi|p^+ q|Psi> and rdm2_pqrs = <Psi|p^+ r^+ q s|Psi> (chemist notation). The implementation sums over all alpha and beta occupation-string sectors, so the outputs are spatial (site) RDMs that are traced/summed over spin degrees of freedom.
    
    Side effects:
        The function does not modify global state. It allocates intermediate arrays (t1, temporary dot products) and returns newly created numpy.ndarray objects for the RDMs. Memory use scales with nsite and the number of occupation strings; for large nsite or large numbers of electrons the temporary arrays can be large and may dominate memory usage.
    
    Defaults and constraints:
        There are no optional parameters or default values; all three arguments must be provided. The function assumes the standard PySCF cistring/link-index conventions for site-based FCI and that fcivec uses the corresponding ordering.
    
    Failure modes and errors:
        If fcivec cannot be reshaped to (na, nb, -1) because its size does not match the implied na*nb product, numpy.reshape will raise a ValueError. If nelec does not contain two integers, or if nsite is not an integer, TypeError or IndexError may occur when generating occupation strings or indexing link tables. If the cistring/link-index generation functions are incompatible with the provided nsite/nelec combination, those functions will raise their own exceptions. The function does not perform additional validation beyond operations that will naturally raise exceptions on inconsistent inputs.
    
    Returns:
        tuple: A pair (rdm1, rdm2) where:
            rdm1 (numpy.ndarray): One-electron reduced density matrix with shape (nsite, nsite). Elements satisfy rdm1[p, q] = <Psi|p^+ q|Psi> and represent the spatial (site/orbital) one-particle density obtained by summing over spin.
            rdm2 (numpy.ndarray): Two-electron reduced density matrix with shape (nsite, nsite, nsite, nsite). Elements satisfy rdm2[p, q, r, s] = <Psi|p^+ r^+ q s|Psi> and follow the chemist ordering (creation indices first) after internal reordering. These matrices are suitable for computing two-body expectation values and contributions to the energy and other two-particle properties in the site-based FCI context.
    """
    from pyscf.fci.direct_ep import make_rdm12e
    return make_rdm12e(fcivec, nsite, nelec)


################################################################################
# Source: pyscf.fci.direct_ep.make_rdm1p
# File: pyscf/fci/direct_ep.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_ep_make_rdm1p(
    fcivec: numpy.ndarray,
    nsite: int,
    nelec: int,
    nphonon: int
):
    """pyscf.fci.direct_ep.make_rdm1p computes the one-phonon reduced density matrix for an electron-phonon full configuration interaction (FCI) wavefunction. The function is used in the PySCF direct electron-phonon FCI module to obtain the matrix of expectation values dm[p,q] = <psi| b_p^+ b_q |psi>, where b_p^+ is the phonon creation operator on site p. This 1-phonon density matrix is commonly required to evaluate phonon observables, site-resolved phonon populations, and off-diagonal phonon coherences in electron-phonon model calculations performed with PySCF.
    
    Args:
        fcivec (numpy.ndarray): Flattened FCI wavefunction amplitudes as a NumPy array. This array must contain the amplitude coefficients for the combined electronic and phononic Fock space for a system with nsite phonon sites, nelec electrons, and up to nphonon phonon quanta per site; the function reshapes fcivec into the internal configuration shape returned by make_shape(nsite, nelec, nphonon). If fcivec does not have a size compatible with that shape, NumPy will raise a ValueError when attempting to reshape.
        nsite (int): Number of phonon sites (modes) in the model. This integer determines the dimension of the returned 1-phonon density matrix (the return is an nsite-by-nsite NumPy array). In the direct_ep FCI context, each site index corresponds to a local phonon mode coupled to electronic degrees of freedom.
        nelec (int): Number of electrons in the electronic FCI sector. This integer is used to construct the combined electron-phonon configuration shape (via make_shape) and therefore determines how fcivec is interpreted when creating excitation slices. It does not directly appear in the returned matrix dimensions, but an incorrect value will make the reshape/ index slicing inconsistent and cause runtime errors.
        nphonon (int): Maximum number of phonon quanta per site included in the FCI basis. This integer controls the phonon occupancy cutoff used to build the configuration shape and to compute the phonon creation prefactors sqrt(k) for raising occupancy from k-1 to k. nphonon must be non-negative; providing nphonon smaller than the actual maximum phonon index present in fcivec will lead to mismatch errors during reshape or slicing.
    
    Returns:
        numpy.ndarray: An nsite-by-nsite NumPy array representing the one-phonon reduced density matrix dm where dm[p,q] = <psi| b_p^+ b_q |psi>. The array dtype follows NumPy rules based on the dtype of fcivec (e.g., complex if fcivec is complex). The return is computed without modifying inputs; there are no in-place side effects.
    
    Behavior and implementation notes:
        The function first reshapes fcivec into the configuration tensor shape returned by make_shape(nsite, nelec, nphonon). It constructs an intermediate tensor t1 that holds the amplitudes after application of a single phonon creation operator at each site; phonon creation prefactors sqrt(k) (implemented via numpy.sqrt of numpy.arange(1, nphonon+1)) are applied to account for bosonic ladder operator algebra. Helper routines slices_for_cre and slices_for are used to locate and map the relevant slices of the configuration tensor corresponding to raising or lowering the local phonon occupation at each site. Finally, the one-phonon density matrix is obtained as the matrix product of the flattened t1 tensors: rdm1 = dot(t1.reshape(nsite, -1), t1.reshape(nsite, -1).T), yielding an nsite x nsite matrix of expectation values.
        No global state is modified; the function performs only local NumPy operations and returns a newly allocated array. The function will raise runtime exceptions (for example, ValueError from numpy.reshape) if fcivec size is inconsistent with the expected configuration space implied by nsite, nelec, and nphonon, or if invalid indices occur in the helper slice functions. Performance and memory usage scale with the full configuration-space size determined by make_shape; for large nsite or nphonon values the intermediate tensors may become large and lead to substantial memory use or slow computations.
    """
    from pyscf.fci.direct_ep import make_rdm1p
    return make_rdm1p(fcivec, nsite, nelec, nphonon)


################################################################################
# Source: pyscf.fci.direct_nosym.contract_2e
# File: pyscf/fci/direct_nosym.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_nosym_contract_2e(
    eri: numpy.ndarray,
    fcivec: numpy.ndarray,
    norb: int,
    nelec: tuple,
    link_index: tuple = None
):
    """pyscf.fci.direct_nosym.contract_2e contracts the two-electron part of the electronic Hamiltonian with a full configuration interaction (FCI) vector to produce the action of the 2-electron Hamiltonian on that FCI vector (H_2e |CI>). This routine is used in the PySCF FCI solver (direct_nosym) to build the contribution of electron-electron interactions to the FCI matrix-vector product needed in iterative eigensolvers and energy evaluations.
    
    The input eri is NOT the plain two-electron operator matrix (pq|rs). Instead eri must be provided in the modified form used by this routine:
    eri_{pq,rs} = (pq|rs) - (1/Nelec) sum_q (pq|qs),
    and, to restore symmetry between the index pairs (pq) and (rs),
    eri_{pq,rs} = (pq|rs) - (0.5/Nelec) [ sum_q (pq|qs) + sum_p (pq|rp) ].
    With this definition, the function computes the contracted result of the 2-electron Hamiltonian defined in the source code documentation:
    h2e = eri_{pq,rs} p^+ q r^+ s = (pq|rs) p^+ r^+ s q - (pq|rs) delta_{qr} p^+ s.
    See also direct_nosym.absorb_h1e for how one-electron terms may be combined with eri for full Hamiltonian contractions.
    
    Args:
        eri (numpy.ndarray): The modified two-electron integral tensor eri_{pq,rs} as described above. This array holds the electron repulsion information already adjusted by the Nelec-dependent subtraction to match the internal contraction convention. The routine accepts real (numpy.float64) or complex arrays; when real float64 arrays are passed and matched by fcivec.dtype, a low-level optimized C kernel (libfci.FCIcontract_2es1) is used. The function will make contiguous C-ordered copies as needed and does not modify the caller's input arrays.
        fcivec (numpy.ndarray): The FCI state vector to be acted on by the 2-electron Hamiltonian. This is the flattened CI vector for the full spin space used by the direct (no spatial symmetry) FCI solver. Its total number of elements must equal na*nb where na and nb are the number of alpha and beta occupation strings inferred from norb and nelec (via the internal _unpack routine). For real computations, providing a numpy.float64 array allows the use of the optimized C implementation; complex inputs are supported by splitting into real and imaginary parts and combining recursive calls.
        norb (int): Number of spatial orbitals in the FCI problem. This integer determines the bitstring length for occupation representations and is passed to the internal contraction routines to interpret link_index and to compute contributions for all orbital index ranges.
        nelec (tuple): Number of electrons as a tuple (nelec_alpha, nelec_beta). This tuple specifies the electron count per spin used to determine the sizes na and nb (number of alpha and beta occupation strings) and to compute link_index when not provided. The tuple must match the physical electron count for which fcivec was constructed.
        link_index (tuple, optional): Precomputed link index structures for alpha and beta spin sectors, as produced by the internal _unpack(norb, nelec, link_index) helper. If None (default), the function calls _unpack to build link_index arrays internally. When provided, link_index must follow the exact internal format expected by direct_nosym (typically a pair of integer arrays describing allowed single-particle excitations and phase/sign information). Providing link_index avoids recomputation and can improve performance.
    
    Returns:
        numpy.ndarray: A new FCI vector (same conceptual type as direct_spin1.FCIvector) that is the result of contracting the provided eri with fcivec, i.e. the vector representing H_2e |fcivec>. For real input arrays with dtype numpy.float64 (eri.dtype == fcivec.dtype == numpy.float64) the result is returned as a real numpy.ndarray and is produced by the optimized C routine; the returned array will be contiguous and has the same numeric dtype. For complex inputs the routine returns a numpy.complex128 array constructed from recursive real/imag contractions. The returned array does not alias or modify the input arrays.
    
    Behavior, side effects, defaults, and failure modes:
        - The function interprets eri according to the modified definition shown above; passing raw (pq|rs) integrals without the Nelec-dependent subtraction will produce incorrect Hamiltonian action.
        - If eri and fcivec are both numpy.float64, an optimized C kernel (libfci.FCIcontract_2es1) is called for performance; prior to that call the code makes contiguous C-ordered copies of inputs if necessary. This means that even when the C kernel is used, the original Python arrays are not modified.
        - For complex eri or fcivec, the implementation splits real and imaginary parts and performs multiple real-valued contractions, combining results to produce a numpy.complex128 output. This conversion implies a deterministic dtype promotion to complex128 in the complex-input path.
        - The function requires that fcivec.size equals na*nb where na and nb are inferred from norb and nelec (or from provided link_index). If this size condition is not met the function will fail the runtime assertion and raise AssertionError.
        - The link_index parameter, if supplied, must be in the internal format produced by _unpack; supplying an incorrectly structured link_index will produce incorrect results or may lead to errors in the low-level C call.
        - The routine does not perform the full FCI Hamiltonian contraction (it only applies the 2-electron part); to include one-electron contributions, use direct_nosym.absorb_h1e or add the H1e-contracted vector separately.
        - Numerical behavior and performance depend on use of the optimized C path for real float64 inputs; users should provide contiguous numpy.float64 arrays when high performance is required.
        - No in-place modification of the caller's eri or fcivec is performed.
    """
    from pyscf.fci.direct_nosym import contract_2e
    return contract_2e(eri, fcivec, norb, nelec, link_index)


################################################################################
# Source: pyscf.fci.direct_spin0.make_hdiag
# File: pyscf/fci/direct_spin0.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin0_make_hdiag(
    h1e: numpy.ndarray,
    eri: numpy.ndarray,
    norb: int,
    nelec: tuple,
    compress: bool = False
):
    """Construct a symmetrized, flattened Hamiltonian matrix for spin-0 full configuration
    interaction (FCI) calculations from one- and two-electron integrals.
    
    This function is part of PySCF's FCI direct solver utilities for spin-singlet
    (s = 0) problems. It builds the Hamiltonian matrix elements appropriate for a
    spin-0 FCI Hilbert space by delegating the initial construction to the
    spin-1 variant (direct_spin1.make_hdiag), then reshaping the result to a square
    matrix and explicitly symmetrizing it to reduce numerical round-off error.
    The final result is returned as a 1-D NumPy array containing the ravelled
    (symmetric) square matrix. In practice this routine is used by iterative FCI
    solvers (for example Davidson-style eigensolvers) inside PySCF to obtain the
    Hamiltonian matrix or its diagonal/block representation for preconditioning,
    matrix-vector products, and energy evaluations in quantum chemistry
    simulations.
    
    Args:
        h1e (numpy.ndarray): One-electron integrals in the molecular-orbital basis.
            This array provides the single-particle kinetic and nuclear attraction
            contributions used to form the many-body Hamiltonian. The exact array
            shape is determined by the calling code and must be consistent with
            eri, norb, and nelec; mismatched shapes will raise errors in the lower-
            level construction called by this function.
        eri (numpy.ndarray): Two-electron integrals (electron repulsion integrals)
            in the same orbital basis as h1e. These integrals encode the electron-
            electron Coulomb interaction and are combined with h1e to build the
            many-electron Hamiltonian. The array must be provided in the form
            expected by the PySCF FCI direct routines (the same convention used by
            direct_spin1.make_hdiag).
        norb (int): Number of molecular orbitals. This integer determines the
            orbital space size used by the FCI construction. It must match the
            dimensionality implied by h1e and eri as used by the underlying direct
            construction routine.
        nelec (tuple): Number of electrons as a two-element tuple (nalpha, nbeta)
            specifying the count of alpha and beta electrons for the spin-0
            calculation. This determines the many-electron Hilbert space and the
            dimension of the Hamiltonian matrix produced by the underlying
            construction routine.
        compress (bool): Optional flag, default False. Present for API compatibility
            with other make_hdiag variants; in this implementation the argument is
            accepted but not used and has no effect on the returned value. It is
            reserved for potential future behavior where compressed storage formats
            or alternative output representations might be supported.
    
    Returns:
        numpy.ndarray: A 1-D NumPy array containing the flattened (ravelled)
        symmetric Hamiltonian matrix for the spin-0 FCI space. The length of the
        returned array equals na*na where na is the dimension of the square
        Hamiltonian matrix; to recover the square matrix reshape the returned
        array with na = int(sqrt(return.size)) and shape (na, na). The array is
        produced by calling direct_spin1.make_hdiag(h1e, eri, norb, nelec),
        reshaping that result into a square matrix, symmetrizing it by averaging
        with its transpose to reduce numerical error, and then flattening it.
    
    Raises:
        ValueError: If the constructed internal array does not have a size that is
            a perfect square (so it cannot be reshaped to a square matrix), or if
            input arrays have inconsistent dimensions that prevent construction in
            the underlying direct_spin1.make_hdiag call.
        TypeError: If inputs have incorrect types (for example, non-NumPy arrays for
            h1e or eri) that the underlying routines cannot handle.
        Any exceptions raised by direct_spin1.make_hdiag propagated unchanged:
            because this function delegates the core construction to the spin-1
            implementation, input validation and low-level failures (memory errors,
            invalid integral formats, etc.) will surface from that routine.
    
    Notes:
        - This function performs no in-place modification of the caller's h1e or
          eri arrays.
        - The symmetrization step (averaging the matrix with its transpose) is
          performed to reduce numerical asymmetry introduced by finite-precision
          arithmetic in the underlying construction; users relying on perfectly
          symmetric output should still be aware of floating-point limits.
        - The routine is intended for use in PySCF's FCI workflows for quantum
          chemistry simulations as described in the PySCF project documentation and
          is not a general-purpose Hamiltonian builder outside that context.
    """
    from pyscf.fci.direct_spin0 import make_hdiag
    return make_hdiag(h1e, eri, norb, nelec, compress)


################################################################################
# Source: pyscf.fci.direct_nosym.energy
# File: pyscf/fci/direct_nosym.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_nosym_energy(
    h1e: numpy.ndarray,
    eri: numpy.ndarray,
    fcivec: numpy.ndarray,
    norb: int,
    nelec: tuple,
    link_index: dict = None
):
    """pyscf.fci.direct_nosym.energy: Compute the Full Configuration Interaction (FCI) electronic energy for a given molecular Hamiltonian and FCI coefficient vector using PySCF internal routines. This routine folds the one-electron integrals into an effective two-electron Hamiltonian with absorb_h1e, applies the two-electron Hamiltonian to the FCI vector with contract_2e, and returns the expectation value <CI|H|CI>, which is the electronic energy for the supplied FCI wavefunction in the PySCF FCI framework.
    
    Args:
        h1e (numpy.ndarray): One-electron integrals (Hamiltonian matrix elements) in the molecular orbital basis. In quantum chemistry, these represent kinetic energy plus electron-nuclear attraction contributions; they are used here to form an effective two-body Hamiltonian via absorb_h1e so that the total electronic Hamiltonian is applied to the FCI vector. Passing an incorrectly shaped or typed h1e will cause shape/type errors when absorb_h1e performs its operations.
        eri (numpy.ndarray): Two-electron repulsion integrals (electron-electron interaction tensor) in the molecular orbital basis. This tensor provides the electron-electron interaction terms used together with h1e by absorb_h1e and contract_2e to form and apply the many-electron Hamiltonian. Mismatches between eri and h1e (for example incompatible orbital counts) will raise exceptions in the called helper routines.
        fcivec (numpy.ndarray): Full Configuration Interaction (CI) coefficient vector representing the many-electron wavefunction in the chosen determinant/configuration basis. This vector is contracted with the Hamiltonian (via contract_2e) to produce H|CI>, and the dot product with the input fcivec yields the expectation value. fcivec should represent the intended wavefunction (for a normalized wavefunction the returned value is the variational energy), and supplying an unnormalized or incorrectly ordered fcivec will produce the corresponding numerical expectation value without automatic normalization.
        norb (int): Number of molecular orbitals used to define the FCI configuration space. norb controls how absorb_h1e and contract_2e interpret the integral tensors and how they enumerate determinants/occupations; providing an incorrect norb inconsistent with h1e, eri, or fcivec will lead to runtime errors.
        nelec (tuple): Electron count as a tuple (nalpha, nbeta) giving the number of alpha and beta electrons used to define the FCI space. nelec determines the occupation patterns and the size/structure of the configuration space over which the Hamiltonian acts; supplying the wrong electron counts will yield an energy corresponding to a different electronic state or raise errors when applying the Hamiltonian.
        link_index (dict, optional): Mapping/indexing structure used by contract_2e to accelerate construction and application of the Hamiltonian (for example, mapping determinants to excitation patterns and phase/sign factors). If provided, this dictionary is used directly by contract_2e to avoid recomputing link tables; if None, the underlying routines will generate or infer the required index information as needed. An incompatible link_index (mismatched to norb/nelec/fcivec) will cause contract_2e to fail.
    
    Returns:
        float: The scalar electronic energy (the expectation value <CI|H|CI>) computed for the supplied FCI coefficient vector and Hamiltonian. The returned value is produced by forming h2e = absorb_h1e(h1e, eri, norb, nelec, 0.5), computing ci1 = contract_2e(h2e, fcivec, norb, nelec, link_index), and returning numpy.dot(fcivec.flatten(), ci1.flatten()). The numerical type is a Python float or NumPy scalar (e.g., numpy.float64) consistent with numpy.dot output. No in-place modification of the provided h1e, eri, or fcivec is performed by this function.
    
    Notes:
        This routine is part of PySCF's direct (no symmetry) FCI implementation and is intended for use in quantum-chemistry workflows that require exact diagonalization or energy evaluation within the FCI space. Computational cost and memory requirements grow combinatorially with norb and nelec (exponential scaling of the FCI space), so this function is practical only for small to modest active spaces. Typical failure modes are shape or type mismatches among h1e, eri, fcivec, incorrect norb/nelec leading to indexing errors, and excessive memory/CPU demands for large systems.
    """
    from pyscf.fci.direct_nosym import energy
    return energy(h1e, eri, fcivec, norb, nelec, link_index)


################################################################################
# Source: pyscf.fci.direct_spin0.contract_2e
# File: pyscf/fci/direct_spin0.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin0_contract_2e(
    eri: numpy.ndarray,
    fcivec: numpy.ndarray,
    norb: int,
    nelec: tuple,
    link_index: numpy.ndarray = None
):
    """Contract two-electron integrals with a spin-0 (singlet) FCI vector.
    
    This function computes the action of the two-electron part of the electronic Hamiltonian on a full configuration interaction (FCI) vector specialized for spin-adapted S=0 (spin-0) calculations used by the PySCF FCI solver. It calls ao2mo.restore(4, ...) to restore 4-fold symmetry of the supplied two-electron integrals, symmetrizes and scales them to match the internal convention, and then delegates the core contraction to a compiled routine (libfci.FCIcontract_2e_spin0). The result is returned as a direct_spin1.FCIvector view with the same shape as the input fcivec. This routine is used inside PySCF to evaluate the two-electron Hamiltonian contribution for variational FCI energy/gradient evaluations and iterative FCI solvers that require repeated matrix-vector products.
    
    Args:
        eri (numpy.ndarray): Two-electron integrals array compatible with ao2mo.restore(4, eri, norb). The array supplies the electron-electron repulsion integrals in a form accepted by ao2mo.restore with norb active spatial orbitals. The function restores 4-fold permutation symmetry via ao2mo.restore(4, ...), symmetrizes (transpose_sum) and scales the restored integrals in-place prior to the contraction. The passed object is not modified in-place unless it is the same buffer returned by ao2mo.restore; callers should not rely on eri remaining unchanged.
        fcivec (numpy.ndarray): FCI vector to be acted on by the two-electron operator. The array is converted to a C-contiguous numpy.ndarray internally (numpy.asarray(..., order='C')). The code requires fcivec.size == na**2 where na is inferred from link_index (see below), and fcivec.dtype must be numpy.float64. The function returns an array with the same logical shape as this input (returned as a direct_spin1.FCIvector view).
        norb (int): Number of spatial orbitals (norb) used to interpret eri and to inform the compiled contraction routine. This integer is passed to ao2mo.restore and to the C implementation to define orbital dimensionality for the contraction.
        nelec (tuple): Electron occupation tuple (nalpha, nbeta) describing the number of alpha and beta electrons. This argument is passed to direct_spin1._unpack to produce or validate the link_index structure that encodes allowed single-particle excitations for the FCI basis in this (norb, nelec) space. The function does not itself validate detailed contents beyond forwarding nelec to the unpacker.
        link_index (numpy.ndarray): Link/index array describing the connectivity of Slater determinants (excitation links) as produced by direct_spin1._unpack(norb, nelec, link_index). The expected layout is an array whose first two dimensions are (na, nlink) (na = number of determinant strings for one spin) and additional trailing dimensions encode target occupation indices and phase/sign information. If link_index is not already a numpy.ndarray (for example, if an older format tuple is received), the function will attempt to handle common legacy formats by taking link_index[0]. The compiled routine requires link_index to be provided in the format produced by direct_spin1._unpack; supplying an incompatible structure will lead to runtime errors (e.g., shape mismatches or segmentation faults in the C routine).
    
    Returns:
        numpy.ndarray: A numpy.ndarray view of type direct_spin1.FCIvector containing the contracted two-electron contribution (same logical shape as the input fcivec). The returned array is produced by reshaping and transposing the intermediate result so that it matches fcivec.shape. The array dtype is numpy.float64. On failure, the function raises AssertionError if fcivec.size does not equal na**2 or if fcivec/eri have incorrect dtypes; other failures (for example, malformed link_index or mismatched shapes passed to the underlying C routine) raise Python exceptions or may propagate errors from the compiled library.
    
    Behavior and side effects:
        The function calls ao2mo.restore(4, eri, norb) and then lib.transpose_sum(eri, inplace=True) to symmetrize the restored integrals, and multiplies the integrals by 0.5 to match the internal contraction convention before invoking the compiled C routine. The compiled routine libfci.FCIcontract_2e_spin0 computes the contraction for spin-0 and is documented to compute one half of the full contraction; the pre-scaling of eri compensates for that. fcivec is coerced to a C-contiguous numpy.ndarray; the function enforces numpy.float64 dtype for fcivec and eri. If link_index is provided in a legacy tuple-like form, the implementation will attempt to extract the expected array via link_index[0]; callers should prefer supplying the exact output of direct_spin1._unpack to avoid ambiguity. The function performs checks using assert to ensure basic size/dtype consistency; assertion failures indicate incorrect inputs. The core contraction is performed in compiled C code via ctypes and may raise lower-level runtime errors if provided invalid pointers/shapes.
    
    Failure modes:
        AssertionError if fcivec.size != na**2 or if fcivec.dtype or eri.dtype is not numpy.float64.
        ValueError, IndexError, or runtime errors if link_index cannot be unpacked to a numpy.ndarray with compatible (na, nlink, ...) shape or if the compiled routine detects shape mismatches.
        Segmentation faults or other low-level crashes are possible if an incompatible buffer or malformed link_index is passed to the underlying C routine; always provide link_index in the format produced by direct_spin1._unpack for this (norb, nelec) problem to avoid such failures.
    """
    from pyscf.fci.direct_spin0 import contract_2e
    return contract_2e(eri, fcivec, norb, nelec, link_index)


################################################################################
# Source: pyscf.fci.direct_nosym.absorb_h1e
# File: pyscf/fci/direct_nosym.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_nosym_absorb_h1e(
    h1e: numpy.ndarray,
    eri: numpy.ndarray,
    norb: int,
    nelec: int,
    fac: float = 1
):
    """pyscf.fci.direct_nosym.absorb_h1e: Modify a two-electron Hamiltonian tensor to include the contribution from a one-electron Hamiltonian for use in full configuration interaction (FCI) routines (direct, no spatial symmetry). This function is used in the FCI direct_nosym workflow to fold a mean-field-like one-electron term into an effective two-electron integral tensor so downstream FCI code can treat the modified two-electron tensor as containing both 1e and 2e contributions.
    
    Args:
        h1e (numpy.ndarray): One-electron Hamiltonian matrix (typically the core Hamiltonian or Fock matrix) defined in the same molecular orbital basis as the provided two-electron integrals. Practically, h1e is expected to be a square 2D array with shape (norb, norb). It is used to compute an average one-electron contribution f1e that will be distributed into diagonal blocks of the two-electron tensor. The dtype of h1e participates in dtype selection for the returned array.
        eri (numpy.ndarray): Two-electron integrals. This argument may be either a 4-index electron repulsion integral (ERI) tensor with shape (norb, norb, norb, norb) or, in the common PySCF workflow when both h1e and eri have dtype numpy.float64, an object in the format accepted by ao2mo.restore(1, ..., norb) (the function will call ao2mo.restore to produce a 4-index tensor). If eri is provided as a non-float64 array, the function asserts that eri.ndim == 4 and will cast it to the result dtype computed from h1e and eri. The 4-index tensor (whether produced by restore or passed directly) is used as the base two-electron Hamiltonian to which the one-electron contribution is added.
        norb (int): Number of spatial molecular orbitals (norb). This integer determines the orbital dimension used when restoring or interpreting eri and when allocating/indexing the 4-index two-electron tensor h2e. It must match the orbital dimension of h1e and eri.
        nelec (int): Number of electrons in the system. In typical PySCF usage this is an integer total electron count. If a non-integer/container is passed (for example, an iterable like (nalpha, nbeta)), the function will internally convert it by summing its elements (nelec = sum(nelec)). The integer value is used to normalize the added one-electron contribution by dividing by (nelec + 1e-100) to avoid division-by-zero; therefore nelec should represent the correct total electron count for meaningful results.
        fac (float = 1): Multiplicative scaling factor applied to the returned modified two-electron tensor. Default is 1 (no scaling). This parameter allows the caller to rescale the final effective two-electron integrals (for example, when assembling scaled Hamiltonians or performing numerical tests).
    
    Behavior and side effects:
        - If both h1e.dtype and eri.dtype are numpy.float64, the function calls ao2mo.restore(1, eri.copy(), norb) to obtain a 4-index two-electron tensor in memory. A copy of eri is made in this branch to avoid modifying the caller's array.
        - Otherwise, the function requires eri.ndim == 4 (an explicit 4-index tensor) and creates a copy cast to the numpy.result_type(h1e, eri) dtype to ensure consistent arithmetic between h1e and eri.
        - The function computes f1e = h1e - 0.5 * einsum('jiik->jk', h2e), which represents a Fock-like correction: the one-electron operator minus half the Coulomb/exchange diagonal contraction of the two-electron tensor. This f1e is then scaled by 1/(nelec + 1e-100) to distribute the one-electron contribution per electron and to guard against exact zero electron counts.
        - The per-orbital correction f1e is added to the two-electron tensor by incrementing the slices h2e[k,k,:,:] and h2e[:,:,k,k] for each orbital index k in range(norb). This effectively embeds the one-electron contribution into the two-electron Hamiltonian blocks used in FCI direct algorithms.
        - The function returns a new numpy.ndarray representing the modified two-electron tensor multiplied by fac. The original h1e and eri inputs are not modified (copies are created where necessary), but note that allocating the 4-index tensor and its copies can be memory intensive for large norb.
    
    Failure modes and warnings:
        - If eri is not float64 and eri.ndim != 4, the function raises an AssertionError (eri must be a 4-index array in that case).
        - If norb does not match the dimensions of h1e or eri (after restore/validation), indexing operations will raise IndexError or produce incorrect results; callers must ensure consistent norb and array shapes.
        - If nelec is zero, the normalization uses (nelec + 1e-100) to avoid a ZeroDivisionError; however, dividing by a very small number leads to very large values in f1e and thus an invalid physical Hamiltonian—nelec should be a correct positive integer for meaningful results.
        - The function may allocate large temporary arrays (4-index tensors and copies), so users should account for memory usage when norb is large.
    
    Returns:
        numpy.ndarray: A 4-index two-electron integral tensor h2e of shape (norb, norb, norb, norb) that has been modified to include the one-electron contribution computed from h1e. The returned array dtype is numpy.result_type(h1e, eri) (or float64 if both inputs were float64 before restoration). The returned tensor has had the per-orbital correction added to h2e[k,k,:,:] and h2e[:,:,k,k] for all k, and the entire tensor is multiplied by fac before being returned.
    """
    from pyscf.fci.direct_nosym import absorb_h1e
    return absorb_h1e(h1e, eri, norb, nelec, fac)


################################################################################
# Source: pyscf.fci.direct_spin0.trans_rdm1
# File: pyscf/fci/direct_spin0.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin0_trans_rdm1(
    cibra: numpy.ndarray,
    ciket: numpy.ndarray,
    norb: int,
    nelec: tuple,
    link_index: list = None
):
    """pyscf.fci.direct_spin0.trans_rdm1 computes the spin-summed one-particle transition reduced density matrix (1-RDM) in the spatial (orbital) basis for a full configuration interaction (FCI) bra and ket state within the PySCF FCI direct_spin0 code path. This function is used in FCI post-processing to obtain transition 1-RDMs for evaluating one-electron expectation values and transition properties by summing the separate alpha and beta spin components returned by the spin-resolved routine trans_rdm1s.
    
    Args:
        cibra (numpy.ndarray): CI vector for the bra state. This is the FCI expansion coefficients for the bra many-electron wavefunction, represented as a NumPy array in the same internal ordering used by PySCF FCI routines. The array must be compatible with norb and nelec so that trans_rdm1s can interpret occupations and generate alpha/beta components.
        ciket (numpy.ndarray): CI vector for the ket state. This is the FCI expansion coefficients for the ket many-electron wavefunction, represented as a NumPy array. It must have the same internal ordering and be compatible with norb and nelec as cibra. cibra and ciket together define the transition between two FCI states for which the 1-RDM is constructed.
        norb (int): Number of spatial orbitals. This integer specifies the dimension of the spatial orbital basis used by the FCI calculation and therefore the dimension of each returned one-particle density matrix component. The final returned matrix has dimensions consistent with norb.
        nelec (tuple): Electron count in the form (nalpha, nbeta). This tuple gives the number of alpha and beta electrons in the FCI calculation and is used by trans_rdm1s to determine occupation patterns, allowable excitations, and the mapping between CI vector indices and orbital occupations.
        link_index (list): Optional precomputed linkage/index structure used internally by the FCI routines to map between occupation strings and excitations. When provided (as produced by other PySCF FCI helper functions), this list is used to avoid recomputing the index structures; when None, the underlying trans_rdm1s routine will construct the required link_index internally. Supplying a valid link_index can improve performance by reusing previously computed indexing information.
    
    Returns:
        numpy.ndarray: The spin-summed one-particle transition density matrix in the spatial orbital basis. This matrix is the elementwise sum of the alpha and beta one-particle transition density matrices returned by trans_rdm1s (rdm1a + rdm1b) and therefore represents the total (spin-summed) transition 1-RDM between the bra and ket CI states. The returned array is a NumPy ndarray with dimensions consistent with norb (typically shape (norb, norb)), and it is suitable for contracting with one-electron integrals to obtain transition expectation values.
    
    Behavior and side effects:
        This function is a pure computational helper with no external side effects (it does not modify inputs). It delegates the spin-resolved assembly to trans_rdm1s and then returns the elementwise sum of the alpha and beta components. If link_index is provided it is passed through to the underlying routine to avoid recomputation; otherwise link_index is built on demand. The routine assumes that cibra and ciket conform to the internal FCI ordering and dimensionality implied by norb and nelec.
    
    Failure modes:
        The function will raise an exception if the inputs are inconsistent, for example when the shapes or lengths of cibra/ciket do not match the expected size for the given norb and nelec, or if link_index (when provided) is malformed for the underlying trans_rdm1s routine. Such errors typically manifest as ValueError or IndexError from the underlying assembly routines.
    """
    from pyscf.fci.direct_spin0 import trans_rdm1
    return trans_rdm1(cibra, ciket, norb, nelec, link_index)


################################################################################
# Source: pyscf.fci.direct_spin0.make_rdm1s
# File: pyscf/fci/direct_spin0.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin0_make_rdm1s(
    fcivec: numpy.ndarray,
    norb: int,
    nelec: int,
    link_index: list = None
):
    """Create one-particle reduced density matrices (RDM1) for alpha and beta spins from a full configuration interaction (FCI) vector in the spin-0 (singlet) direct FCI implementation.
    
    This function is used in PySCF's FCI module to obtain the one-particle density matrices needed to compute expectation values (for example, one-electron energies and spin-independent one-particle properties) from an FCI wavefunction. In the spin-0/direct_spin0 context, the alpha and beta one-particle RDMs are identical; this routine builds the RDM for one spin and returns it twice to represent both spin channels.
    
    Args:
        fcivec (numpy.ndarray): The FCI CI vector representing the electronic wavefunction in the direct_spin0 representation. This array must contain the coefficients of the many-electron basis states used by the calling FCI machinery. It is passed unchanged to the underlying rdm.make_rdm1 routine. The practical significance is that fcivec encodes the correlated electronic state from which the one-particle reduced densities are computed; incorrect shape, dtype, or normalization may lead to errors or meaningless results.
        norb (int): Number of spatial orbitals used to define the one-particle basis for the RDM construction. This value determines the orbital dimension of the returned RDMs and must match the orbital count assumed when fcivec was produced. It is essential for interpreting matrix indices and for downstream property evaluation.
        nelec (int): Number of electrons in the system (total electron count for the FCI problem). This integer is used by the underlying RDM builder to know the occupation constraints and combinatorial structure of the FCI space; it must match the electron number of the provided fcivec.
        link_index (list): Optional precomputed connectivity information (link table) describing coupling between determinants or occupation strings used by the direct RDM construction routines. Providing a link_index produced by the FCI string utilities can accelerate RDM construction by avoiding recomputation of this coupling structure. If None (default), the underlying rdm.make_rdm1 routine will compute or infer the required linkage information internally, which may be slower.
    
    Returns:
        rdm1a (numpy.ndarray): One-particle reduced density matrix for the alpha-spin channel computed from fcivec. This matrix encodes expectations <a_p^† a_q> for the alpha spin and is suitable for computing one-electron properties and contributions to the total energy from the alpha electrons.
        rdm1b (numpy.ndarray): One-particle reduced density matrix for the beta-spin channel. In the spin-0 (singlet) direct FCI formalism implemented here, rdm1b is identical to rdm1a; the function therefore returns the same numpy.ndarray value for both spin channels. Users can treat the two returned matrices as separate objects for downstream code, but they represent the same numerical one-particle density for singlet FCI wavefunctions.
    
    Behavior, defaults, and failure modes:
        This function delegates the actual RDM construction to rdm.make_rdm1 with the selector 'FCImake_rdm1a' and returns the resulting matrix twice. There are no side effects beyond computing and returning the matrices. If fcivec is not a numpy.ndarray or its shape is inconsistent with norb and nelec, the underlying routines will raise TypeError or ValueError; such exceptions are propagated to the caller. Computational cost grows rapidly with norb and nelec because exact FCI RDM construction scales combinatorially with the size of the many-electron space; for large problems, consider approximate or truncated methods.
    """
    from pyscf.fci.direct_spin0 import make_rdm1s
    return make_rdm1s(fcivec, norb, nelec, link_index)


################################################################################
# Source: pyscf.fci.direct_spin0.make_rdm1
# File: pyscf/fci/direct_spin0.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin0_make_rdm1(
    fcivec: numpy.ndarray,
    norb: int,
    nelec: tuple,
    link_index: list = None
):
    """Concise summary:
    Computes the spatial one-particle reduced density matrix (RDM1) for a spin-restricted (total spin S=0) full configuration interaction (FCI) wavefunction vector and returns the result multiplied by 2 to combine alpha and beta spin contributions into spatial orbital occupancies. This function is used in the PySCF FCI direct_spin0 module to produce the one-particle density needed for post-processing tasks such as energy evaluation, property calculations, and orbital analysis in quantum chemistry simulations.
    
    Args:
        fcivec (numpy.ndarray): The FCI wavefunction vector in the determinant/CAS basis used by the FCI routines. In practical PySCF workflows this is the optimized or sampled FCI coefficient vector describing the many-electron state. The array must have the shape and ordering expected by the direct_spin0/determinant representation; invalid shapes or ordering will cause underlying routines (rdm.make_rdm1) to raise an exception. The numerical values in fcivec determine the normalization and therefore directly scale the returned RDM1.
        norb (int): Number of spatial molecular orbitals (basis functions for spatial orbitals) used to construct the RDM. This integer controls the dimensionality of the orbital space over which the one-particle density is defined and is forwarded to the underlying rdm.make_rdm1 routine. Passing an incorrect norb inconsistent with fcivec will result in errors from the contraction routine.
        nelec (tuple): A two-integer tuple specifying the number of electrons in the alpha and beta spin sectors (nalpha, nbeta) for the FCI calculation. For the spin-restricted S=0 context where this routine is intended, nalpha and nbeta are typically equal. This argument is used by the underlying rdm.make_rdm1 call to determine allowed excitations and occupation patterns for constructing the one-particle RDM.
        link_index (list): Optional precomputed linkage/index tables used by direct FCI routines to accelerate creation and contraction of reduced density matrices. When provided, these link_index tables must match the fcivec representation and norb/nelec settings. If link_index is None (the default), the underlying routines will construct or expect link information to be available by other means; providing link_index can significantly improve performance for repeated RDM constructions. Passing an incompatible link_index will produce errors from the lower-level routines.
    
    Returns:
        numpy.ndarray: The computed spatial one-particle reduced density matrix (RDM1) as returned by the underlying rdm.make_rdm1 call, multiplied by 2. The multiplication by 2 combines alpha and beta spin-channel contributions into a single spatial-orbital RDM appropriate for spin-restricted (S=0) calculations. The returned array is produced with no additional side effects; errors are raised if inputs are inconsistent or if the underlying rdm.make_rdm1 fails (for example due to mismatched shapes, invalid electron counts, or incompatible link_index).
    """
    from pyscf.fci.direct_spin0 import make_rdm1
    return make_rdm1(fcivec, norb, nelec, link_index)


################################################################################
# Source: pyscf.fci.direct_spin1.absorb_h1e
# File: pyscf/fci/direct_spin1.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin1_absorb_h1e(
    h1e: numpy.ndarray,
    eri: numpy.ndarray,
    norb: int,
    nelec: int,
    fac: float = 1
):
    """pyscf.fci.direct_spin1.absorb_h1e modifies a two-electron integral tensor to absorb the contribution of a one-electron Hamiltonian for use in full configuration interaction (FCI) routines in the direct_spin1 (spin-adapted) code path of PySCF. This routine is used in electronic-structure calculations to combine one-electron (kinetic + nuclear attraction or Fock-like) terms into an effective two-electron Hamiltonian representation so that subsequent FCI matrix assembly can operate on a single 4-index tensor.
    
    Args:
        h1e (numpy.ndarray): The one-electron Hamiltonian matrix provided as a NumPy array. In practice this is the one-electron part of the molecular Hamiltonian (for example kinetic energy plus nuclear attraction or an effective Fock-like operator) represented in the same orbital basis as the two-electron integrals. The function uses h1e to compute an average one-electron correction that is distributed into the returned two-electron tensor; the entries of h1e must be numeric and real-valued (the implementation raises NotImplementedError if h1e.dtype == numpy.complex128). The physical significance is that h1e contributes to orbital energies and coupling terms that are absorbed into the two-electron representation for the direct_spin1 FCI algorithms.
        eri (numpy.ndarray): The two-electron integrals provided as a NumPy array in the form accepted by ao2mo.restore. This array contains the electron-electron interaction integrals for the same orbital basis as h1e and is copied internally before modification. The function calls ao2mo.restore to produce a full 4-index tensor, so eri must be compatible with that routine for the supplied norb. Complex-valued eri arrays with dtype numpy.complex128 are not supported and will cause NotImplementedError. The returned tensor is derived from eri with the h1e contribution absorbed.
        norb (int): Number of spatial orbitals (norb) used to interpret and restore the two-electron integrals via ao2mo.restore. This integer determines the orbital dimension of the returned 4-index tensor and must match the orbital dimension of h1e and the eri data layout. It is used when calling ao2mo.restore(1, eri.copy(), norb) and ao2mo.restore(4, ... , norb) to map between packed and full-index representations.
        nelec (int): Number of electrons used to scale the one-electron correction when absorbing it into the two-electron integrals. This argument may be an integer or a NumPy numeric scalar; if nelec is not an int or numpy.number (for example a sequence like (n_alpha, n_beta)), the code will sum its elements (nelec = sum(nelec)) to obtain the total electron count. The computed per-orbital one-electron correction is divided by nelec (with a tiny offset 1e-100 to avoid division by zero) reflecting how the one-electron contribution is distributed per electron in the effective two-electron operator. The physical meaning is the averaging of one-electron terms per occupied electron when forming the effective two-electron Hamiltonian for FCI.
        fac (float): Multiplicative scaling factor applied to the final returned 4-index tensor. Default is 1. After absorbing the one-electron contribution into the two-electron tensor, the function multiplies the entire 4-index result by fac before returning. This parameter allows scaling the overall Hamiltonian if needed by caller code (for example to include symmetry or normalization prefactors).
    
    Behavior and side effects:
        The function first checks for explicitly complex dtypes (numpy.complex128) on h1e or eri and raises NotImplementedError for complex Hamiltonians because the current direct_spin1 implementation only handles real-valued integrals in that dtype. The input eri is copied internally (eri.copy()) before restoring to a full 4-index tensor via ao2mo.restore(1, ...). The code then computes an intermediate 2-electron tensor h2e = ao2mo.restore(1, eri.copy(), norb), computes a Fock-like one-electron correction f1e = h1e - 0.5 * einsum('jiik->jk', h2e), and scales f1e by 1.0/(nelec + 1e-100) to avoid division by zero. For each orbital index k in range(norb), the correction f1e is added into two sets of blocks of h2e via h2e[k,k,:,:] += f1e and h2e[:,:,k,k] += f1e, thereby absorbing the one-electron contributions into the two-electron tensor. Finally, ao2mo.restore(4, h2e, norb) is called to produce the returned 4-index array, which is scaled by fac and returned. The function has the side effect of allocating and returning a new NumPy array; it does not modify the original eri input (eri is copied before modification).
    
    Failure modes and constraints:
        The function will raise NotImplementedError if either h1e.dtype == numpy.complex128 or eri.dtype == numpy.complex128 because complex Hamiltonians at that specific dtype are not supported by this routine. If h1e, eri, or norb are inconsistent (for example shapes incompatible with ao2mo.restore or the implied orbital dimension), downstream operations such as ao2mo.restore or numpy.einsum may raise ValueError or IndexError. Passing nelec with an unexpected structure that is not summable may raise a TypeError when sum(nelec) is attempted; typical usage is an int or a length-2 sequence (n_alpha, n_beta). The small additive constant 1e-100 prevents ZeroDivisionError when nelec == 0 but users should avoid calling this routine with nelec == 0 as it is physically meaningless in the context of FCI.
    
    Returns:
        numpy.ndarray: A new 4-index NumPy array representing the two-electron Hamiltonian with the one-electron contribution absorbed and then scaled by fac. This returned tensor is suitable for use in direct_spin1 FCI routines that expect a modified two-electron integral tensor. The array is produced by ao2mo.restore(4, ...) from an internally modified h2e and is a different object from the input eri (eri is copied before modification).
    """
    from pyscf.fci.direct_spin1 import absorb_h1e
    return absorb_h1e(h1e, eri, norb, nelec, fac)


################################################################################
# Source: pyscf.fci.direct_spin1.energy
# File: pyscf/fci/direct_spin1.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin1_energy(
    h1e: numpy.ndarray,
    eri: numpy.ndarray,
    fcivec: numpy.ndarray,
    norb: int,
    nelec: tuple,
    link_index: list = None
):
    """Compute the FCI electronic energy (expectation value) for a given Hamiltonian and FCI vector in the direct_spin1 FCI implementation.
    
    This function is used in the PySCF quantum chemistry framework to evaluate the scalar electronic energy E = <C|H|C> for a Full Configuration Interaction (FCI) wavefunction C represented by fcivec. It first folds the one-electron integrals into the two-electron integrals via absorb_h1e (hence working with the effective two-electron Hamiltonian used by the direct_spin1 routines), then forms the Hamiltonian action on the FCI vector with contract_2e, and finally computes the dot product of the input vector with that action to produce the energy. This routine is applicable to non-relativistic electronic structure problems expressed in an orthonormal molecular orbital basis and follows the FCI conventions used by the pyscf.fci.direct_spin1 module.
    
    Args:
        h1e (numpy.ndarray): One-electron integrals in the molecular orbital basis. Practically, this is the core Hamiltonian (kinetic + nuclear attraction) matrix with shape (norb, norb), where norb is the number of spatial orbitals. The function uses these integrals when folding them into the two-electron term via absorb_h1e to produce the effective two-electron interaction used in the energy evaluation.
        eri (numpy.ndarray): Two-electron repulsion integrals in chemist/physicist notation appropriate for the direct_spin1 routines. Typically an array with 4 indices and shape (norb, norb, norb, norb). These integrals describe electron-electron Coulomb interactions and are combined with h1e by absorb_h1e; incorrect ordering or symmetry of eri will lead to wrong energies or exceptions.
        fcivec (numpy.ndarray): FCI wavefunction vector (configuration interaction coefficients). This array must be reshapeable to the expected FCI vector length for the given norb and nelec (the code calls reshape(-1) internally). In practice, fcivec is a 1D array of length equal to the number of determinants/configurations for the spin sectors determined by nelec; it may also be provided in other shapes as long as the total number of elements matches the expected dimension. The dot product of fcivec with the Hamiltonian action yields the scalar energy.
        norb (int): Number of spatial orbitals used in the FCI calculation. This integer determines the dimensionality of h1e and eri and, together with nelec, determines the size of the FCI Hilbert space. Passing a norb inconsistent with the shapes of h1e, eri, or fcivec will produce errors.
        nelec (tuple): A tuple specifying the number of electrons in each spin sector, conventionally (nalpha, nbeta). This tuple defines the electronic sector for which the FCI wavefunction fcivec is defined and is required by absorb_h1e and contract_2e to determine the mapping between configuration indices and determinant occupations.
        link_index (list, optional): Precomputed link table(s) used internally by contract_2e to enumerate excitations and accelerate Hamiltonian contraction. If provided, link_index must be compatible with norb and nelec and follow the format produced by the pyscf.fci.link_index building utilities. If None (the default), contract_2e will internally construct or infer the linking structures as needed. Providing a correct precomputed link_index can substantially reduce repeated setup cost when evaluating energies multiple times for the same orbital/nelec specification.
    
    Returns:
        numpy.float64: The scalar electronic energy E = <fcivec|H|fcivec> computed as the dot product between the input FCI vector and the Hamiltonian action computed by contract_2e after folding h1e into eri. The returned value is a machine floating-point scalar (numpy.float64) representing the expectation value of the non-relativistic electronic Hamiltonian in the chosen molecular orbital basis.
    
    Behavior, side effects, and failure modes:
        - The function has no persistent side effects on its inputs; it creates temporary folded two-electron integrals (via absorb_h1e) and a temporary Hamiltonian-applied vector (via contract_2e) but does not modify the provided h1e, eri, or fcivec arrays.
        - The one-electron integrals h1e are absorbed into the two-electron integrals with a factor 0.5 in absorb_h1e; this is a standard algebraic transformation used by the direct_spin1 FCI contraction routines to form the effective two-electron representation of the full Hamiltonian.
        - The function assumes inputs conform to the direct_spin1 module conventions: norb consistent with the leading dimensions of h1e and eri, nelec a two-element tuple of integers (nalpha, nbeta), and fcivec length matching the combinatorial dimension implied by norb and nelec. If these conditions are violated, the function will typically raise ValueError or IndexError due to shape mismatches, or TypeError for incorrect types.
        - Numerical correctness depends on the symmetry and ordering of eri and the basis in which h1e and eri are supplied; nonsymmetric or differently ordered integrals will yield incorrect energies without necessarily raising errors.
        - For very large norb and nelec, the function will be limited by memory and CPU cost of absorb_h1e and contract_2e; users should ensure available resources or use specialized reduced-scaling methods.
        - link_index, when supplied, must match the specific direct_spin1 indexing conventions; an incompatible link_index can lead to incorrect energies or runtime errors.
    
    Notes:
        - This routine is part of the PySCF FCI machinery and is intended for use by higher-level drivers and benchmarking tools that require exact (within basis) FCI energies for non-relativistic electronic Hamiltonians.
        - To compute expectation values of other operators or to obtain the Hamiltonian-applied vector explicitly, call absorb_h1e and contract_2e directly; energy() is a convenience wrapper that returns the scalar expectation value.
    """
    from pyscf.fci.direct_spin1 import energy
    return energy(h1e, eri, fcivec, norb, nelec, link_index)


################################################################################
# Source: pyscf.fci.direct_spin0.trans_rdm1s
# File: pyscf/fci/direct_spin0.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin0_trans_rdm1s(
    cibra: numpy.ndarray,
    ciket: numpy.ndarray,
    norb: int,
    nelec: int,
    link_index: list = None
):
    """pyscf.fci.direct_spin0.trans_rdm1s
    Compute the spin-resolved transition one-particle reduced density matrices (RDM1)
    for spin-restricted full configuration interaction (FCI) wavefunctions. This
    routine is used in PySCF FCI modules to obtain the alpha and beta spin parts of
    the transition one-particle RDM between two CI states (bra and ket). The returned
    matrices are suitable for evaluating one-body transition properties (for example
    transition dipoles or spin-resolved expectation values) in quantum chemistry
    calculations performed with PySCF.
    
    Args:
        cibra (numpy.ndarray): CI coefficient array for the bra state. This is the
            left-state vector in the transition matrix element <bra|...|ket>. In the
            FCI context it contains the expansion coefficients of the many-electron
            bra wavefunction in the same configuration ordering used by the ket.
            The array must be compatible with rdm.make_rdm1 and the link_index (if
            provided). If shapes or ordering are inconsistent, rdm.make_rdm1 will
            raise an error.
        ciket (numpy.ndarray): CI coefficient array for the ket state. This is the
            right-state vector in the transition matrix element <bra|...|ket>. It
            must use the same configuration basis and ordering as cibra. The ket is
            used together with cibra to construct the transition RDMs via rdm.make_rdm1.
        norb (int): Number of spatial orbitals in the FCI problem. This integer
            determines the dimension of the returned one-particle RDM matrices
            (they are returned for the spatial-orbital basis and will have
            dimensions consistent with norb). norb is also used when generating a
            default link_index (see below).
        nelec (int or tuple of two ints): Electron count. This may be provided as a
            single integer giving the total number of electrons, or as a pair
            (nalpha, nbeta) giving the number of alpha and beta electrons
            respectively. For the spin-restricted direct_spin0 implementation the
            function enforces a closed-shell condition: when a pair is supplied the
            routine asserts that nalpha == nbeta. If a single integer is supplied,
            the number of alpha electrons used to generate the default link_index
            is taken as nelec//2 (integer division). The electron count is required
            to determine the occupancy sector and to generate or validate the
            link_index structure.
        link_index (list, optional): Precomputed link index describing how creation
            and annihilation operators connect FCI configurations for the alpha
            spin string. This is the object normally produced by
            cistring.gen_linkstr_index(range(norb), neleca) and encodes the
            bit-string/linking information needed by rdm.make_rdm1 to assemble the
            RDM. If link_index is None (the default), the function will generate a
            default link_index for closed-shell cases using
            cistring.gen_linkstr_index(range(norb), neleca) where neleca is taken
            from nelec as described above. If a user supplies link_index, it must
            be consistent with norb and the electron counts of the CI vectors; an
            inconsistent link_index may cause rdm.make_rdm1 to raise errors.
    
    Returns:
        tuple(numpy.ndarray, numpy.ndarray): A pair (rdm1a, rdm1b) where rdm1a is
        the alpha-spin one-particle transition reduced density matrix and rdm1b is
        the beta-spin one-particle transition reduced density matrix. Each returned
        array is a numpy.ndarray whose matrix elements correspond to standard
        second-quantized one-body transition matrix elements of the form
        <cibra|a^+_p a_q|ciket> for the respective spin. The matrices have
        dimensions consistent with norb (typically (norb, norb) in the spatial
        orbital representation) and are intended for use in subsequent property or
        expectation-value computations in PySCF FCI workflows.
    
    Behavior and side effects:
        If link_index is None, the function will attempt to build a suitable link
        index for the alpha spin using cistring.gen_linkstr_index(range(norb),
        neleca) where neleca is derived from nelec. The routine then calls
        rdm.make_rdm1 twice (once for the alpha component and once for the beta
        component) to build the transition RDMs and returns them as a tuple.
        There are no persistent side effects: no global state is modified.
    
    Failure modes and exceptions:
        An AssertionError is raised when nelec is provided as a two-element pair
        and the two values are not equal (the function enforces a closed-shell
        condition for direct_spin0). TypeError or ValueError may be raised if
        cibra, ciket, norb, or link_index have incompatible types or shapes for the
        FCI routines invoked; such errors come from downstream utilities like
        cistring.gen_linkstr_index and rdm.make_rdm1 and are propagated to the
        caller. Ensure that cibra and ciket use the same configuration ordering and
        that link_index (if supplied) matches norb and the electron sector.
    """
    from pyscf.fci.direct_spin0 import trans_rdm1s
    return trans_rdm1s(cibra, ciket, norb, nelec, link_index)


################################################################################
# Source: pyscf.fci.direct_spin0.trans_rdm12
# File: pyscf/fci/direct_spin0.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin0_trans_rdm12(
    cibra: numpy.ndarray,
    ciket: numpy.ndarray,
    norb: int,
    nelec: tuple,
    link_index: list = None,
    reorder: bool = True
):
    """Compute spin-adapted (spin-0) transition one- and two-particle reduced density matrices (1-RDM and 2-RDM) between two full configuration interaction (FCI) many-electron states.
    
    This function is part of the pyscf.fci.direct_spin0 module of the PySCF quantum chemistry package. It constructs transition density matrices needed to evaluate expectation values and transition properties (for example transition dipole moments or two-body operator matrix elements) between a "bra" CI state and a "ket" CI state represented in the FCI determinant/configuration basis. The implementation delegates to the generic rdm.make_rdm12 kernel and then optionally reorders the returned matrices with rdm.reorder_rdm to match the internal index ordering conventions used elsewhere in PySCF.
    
    Args:
        cibra (numpy.ndarray): CI coefficient array for the bra (left) FCI state. This is the many-electron wavefunction expansion coefficients in the Slater determinant/configuration basis used by PySCF's FCI solver. The array supplies the amplitudes from which transition density matrix elements are constructed; a mismatch between its dimensionality and the specified norb/nelec will raise an error in the underlying routines.
        ciket (numpy.ndarray): CI coefficient array for the ket (right) FCI state. Analogous to cibra, this array supplies the expansion coefficients of the target FCI state. cibra and ciket together define the transition (off-diagonal) density matrices computed by this function.
        norb (int): Number of spatial orbitals (norb) in the FCI calculation. This integer specifies the orbital space over which the 1-RDM and 2-RDM are defined and must match the orbital count for which the CI coefficients were generated.
        nelec (tuple): Electron count specification used by PySCF FCI routines. Typically provided as a tuple of electron numbers accepted by the FCI code (for example (nalpha, nbeta) or other tuple form consistent with the caller). The nelec tuple determines occupation constraints and therefore the dimensionality of the CI space used to construct the density matrices.
        link_index (list): Optional precomputed link-index data structure produced by FCI utility routines (e.g. routines that encode excitation/connection patterns between determinant strings). Providing link_index can greatly accelerate the internal construction of RDMs by avoiding recomputation of these indices. If None (default), the underlying rdm.make_rdm12 implementation will build or infer the necessary linking information internally.
        reorder (bool): If True (default), the returned dm1 and dm2 are passed through rdm.reorder_rdm(..., True) to convert them to the ordering convention used by other parts of PySCF. If False, the raw ordering produced by the rdm.make_rdm12 kernel is returned. Use this flag to avoid an extra reorder when a caller expects the kernel-native index ordering.
    
    Behavior and side effects:
        The function calls rdm.make_rdm12 with kernel identifier 'FCItdm12kern_sf' to compute transition density matrices for spin-adapted (spin-0) FCI states, passing the provided CI vectors, orbital count, electron count, optional link_index, and a spin flag value 2. After obtaining the one- and two-particle transition density matrices (dm1 and dm2), it conditionally applies rdm.reorder_rdm(dm1, dm2, True) when reorder is True to align index ordering with PySCF conventions. The function has no other side effects: it does not modify cibra, ciket, nor other global state and returns new arrays (or array-like objects) produced by the rdm kernels.
    
    Defaults:
        link_index defaults to None, causing the kernel to compute linking information internally if needed. reorder defaults to True to return density matrices in the standard ordering used by PySCF higher-level routines.
    
    Failure modes and errors:
        Underlying rdm routines validate consistency between cibra, ciket, norb, and nelec. If the CI coefficient arrays have incompatible shapes or sizes relative to norb/nelec, or if link_index is malformed, the underlying routines will raise exceptions (TypeError, ValueError, or implementation-specific errors from the rdm module). Passing non-array types for cibra or ciket, a non-integer norb, or a non-tuple nelec will typically result in type errors propagated from the called routines. If reorder is not a boolean, rdm.reorder_rdm may raise an error when invoked.
    
    Returns:
        tuple: A pair (dm1, dm2) where dm1 and dm2 are the computed transition reduced density matrices returned by the rdm kernel (typically as numpy.ndarray objects). dm1 is the one-particle transition density matrix (used to compute one-electron transition properties), and dm2 is the two-particle transition density matrix (used for two-electron operator expectations and correlated property evaluations). The exact array shapes and index ordering depend on norb and nelec and on whether reorder is True; when reorder=True the matrices are reordered by rdm.reorder_rdm to the standard PySCF ordering.
    """
    from pyscf.fci.direct_spin0 import trans_rdm12
    return trans_rdm12(cibra, ciket, norb, nelec, link_index, reorder)


################################################################################
# Source: pyscf.fci.direct_spin1.make_hdiag
# File: pyscf/fci/direct_spin1.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin1_make_hdiag(
    h1e: numpy.ndarray,
    eri: numpy.ndarray,
    norb: int,
    nelec: tuple,
    compress: bool = False
):
    """Diagonal Hamiltonian for Davidson preconditioner in the direct spin-1 (UHF) FCI routine.
    
    This function constructs the diagonal elements of the full configuration interaction (FCI) Hamiltonian for use as the diagonal preconditioner in a Davidson-type iterative eigensolver. It is intended for electronic structure calculations in the PySCF framework and specifically for the UHF (unrestricted Hartree–Fock) direct-spin1 FCI implementation. The diagonal elements returned correspond to diagonal matrix elements <I|H|I> for all Slater determinant pairs formed from the generated alpha and beta occupation lists. The returned array is therefore used to accelerate convergence of iterative diagonalization by providing the H_ii values for preconditioning and shift operations.
    
    Args:
        h1e (numpy.ndarray): One-electron integrals array (Hamiltonian matrix in the one-electron basis). This must be a real-valued numpy.ndarray with dtype numpy.float64 compatible with the mean-field one-electron operator used in the FCI calculation. The function converts this array to C-contiguous order before use. It represents kinetic and nuclear attraction contributions used together with two-electron integrals to form the diagonal Hamiltonian contributions.
        eri (numpy.ndarray): Two-electron integrals array in a format accepted by ao2mo.restore(1, eri, norb). The function calls ao2mo.restore(1, eri, norb) internally to ensure the integrals are in full (ij|kl) form and then computes the Coulomb (J) and exchange (K) diagonal blocks via einsum. eri must be a real-valued numpy.ndarray with dtype numpy.float64. It provides the electron–electron interaction terms that contribute to the diagonal Hamiltonian elements.
        norb (int): Number of spatial orbitals used to interpret h1e and eri. This integer selects how ao2mo.restore expands or interprets the provided eri array and how occupation lists are generated for the given orbital space. It must match the orbital dimension used to produce h1e and eri.
        nelec (tuple): Electron occupation specification provided as a tuple of two integers (neleca, nelecb) giving the number of alpha and beta electrons, respectively. The function unpacks this tuple (via _unpack_nelec) to generate the alpha and beta occupation lists (cistring.gen_occslst) and to size the determinant product space. nelec controls the lengths na and nb of the generated occupation lists; the final diagonal has length na*nb.
        compress (bool = False): Whether to remove symmetry-forbidden elements. This parameter is accepted for API compatibility with other routines, but in the current implementation it is not used and has no effect on the output (default False). It is present to indicate the intended option to compress out determinants that are symmetry forbidden, but callers should not depend on compression taking place.
    
    Behavior, side effects, defaults, and failure modes:
        - The function requires real-valued inputs: it checks that h1e.dtype == eri.dtype == numpy.float64 and raises NotImplementedError('Complex Hamiltonian') if the arrays are not double-precision real. This prevents accidental use with complex-valued integrals.
        - Internally, h1e and the restored eri are converted to contiguous C-order arrays to ensure compatibility with the underlying C-extension routine (libfci.FCImake_hdiag_uhf). The two-electron integrals are transformed by ao2mo.restore(1, eri, norb) before contraction.
        - The function computes auxiliary diagonal Coulomb (J) and exchange (K) matrices jdiag and kdiag using numpy.einsum calls, which are then passed to the compiled libfci routine together with occupation lists generated by cistring.gen_occslst.
        - The core assembly of the diagonal is delegated to the C-extension libfci.FCImake_hdiag_uhf. Any errors raised by that C routine (for example due to incorrect array shapes or mismatched norb/nelec) will propagate as exceptions to the caller.
        - The compress argument is accepted but currently ignored; no symmetry-based pruning is performed by this implementation.
        - No in-place modification of the caller's h1e or eri arrays is performed; copies or C-contiguous views may be created internally.
    
    Returns:
        numpy.ndarray: 1-D array of dtype numpy.float64 containing the diagonal Hamiltonian elements for all product determinants formed from the alpha and beta occupation lists. Its length equals na*nb where na is the number of alpha occupations and nb is the number of beta occupations generated from (norb, neleca, nelecb). The returned array is used directly as the diagonal preconditioner (H_ii) in Davidson or other iterative eigensolvers for the FCI Hamiltonian.
    """
    from pyscf.fci.direct_spin1 import make_hdiag
    return make_hdiag(h1e, eri, norb, nelec, compress)


################################################################################
# Source: pyscf.fci.direct_spin1.get_init_guess
# File: pyscf/fci/direct_spin1.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin1_get_init_guess(
    norb: int,
    nelec: tuple,
    nroots: int,
    hdiag: numpy.ndarray
):
    """Return an initial guess composed of single Slater determinants for use as starting vectors in full configuration interaction (FCI) diagonalization routines in the pyscf.fci.direct_spin1 implementation. This function constructs simple, physically motivated initial CI vectors by selecting determinants based on the provided diagonal Hamiltonian elements and the specified number of alpha and beta electrons; the guesses are suitable for use by iterative eigensolvers (for example Davidson or Lanczos) within the PySCF FCI solver.
    
    Args:
        norb (int): Number of spatial orbitals in the FCI problem. This integer determines the size of the determinant space per spin and is used to enumerate bitstring representations of determinants. In the domain of quantum chemistry FCI calculations (as supported by PySCF), norb controls the combinatorial space of Slater determinants from which the initial guess vectors are formed.
        nelec (tuple): Electron occupation as a length-2 tuple (neleca, nelecb) giving the number of alpha and beta electrons respectively. The function unpacks this tuple to determine neleca and nelecb and uses those counts to compute the number of distinct alpha and beta bitstring determinants. Supplying an incorrect tuple shape or non-integer entries will cause unpacking or validation routines (called inside) to raise an error.
        nroots (int): Number of lowest-energy eigenstates (roots) for which to generate initial guess vectors. The function returns this many independent guess vectors, ordered to correspond to the lowest diagonal Hamiltonian elements selected for each root. Typical usage is to set nroots equal to the number of eigenpairs requested from the FCI diagonalization routine.
        hdiag (numpy.ndarray): One-dimensional array of diagonal matrix elements of the FCI Hamiltonian in the occupation-number (determinant) basis. These diagonal elements are used to choose determinants with the smallest energies as single-Slater-determinant guesses. hdiag must match the determinant-space ordering implied by norb and nelec; mismatched sizes will result in errors from internal routines.
    
    Behavior, side effects, defaults, and failure modes:
        The function first unpacks nelec into alpha and beta electron counts, computes the number of alpha and beta bitstring determinants (na and nb) using cistring utilities, and then delegates to an internal routine (_get_init_guess) to build nroots initial CI vectors. The produced guesses are single-Slater-determinant CI vectors (product of an alpha and a beta string) chosen by selecting determinants with lowest diagonal Hamiltonian values in hdiag. There are no side effects such as global state mutation; the function is pure with respect to inputs and returns a new array. Common failure modes include invalid nelec (not a length-2 tuple of integers), inconsistent sizes between norb/nelec and the length of hdiag, or negative/zero values for norb or nroots; such conditions will typically raise ValueError or IndexError originating from the unpacking and string-counting utilities invoked internally.
    
    Returns:
        numpy.ndarray: Array of initial CI guess vectors for the FCI problem. The array contains nroots independent initial vectors constructed from single Slater determinants selected according to hdiag and the specified electron occupations. These vectors are intended as starting guesses for iterative eigensolvers in the PySCF FCI workflow and should be compatible with the rest of the direct_spin1 solver pipeline.
    """
    from pyscf.fci.direct_spin1 import get_init_guess
    return get_init_guess(norb, nelec, nroots, hdiag)


################################################################################
# Source: pyscf.fci.direct_spin1.make_rdm1
# File: pyscf/fci/direct_spin1.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin1_make_rdm1(
    fcivec: numpy.ndarray,
    norb: int,
    nelec: tuple,
    link_index: tuple = None
):
    """Spin-traced one-particle density matrix for a Full Configuration Interaction (FCI) wavefunction.
    
    Computes the spin-traced one-particle reduced density matrix
    dm1[p,q] = <q_alpha^dagger p_alpha> + <q_beta^dagger p_beta>
    using the FCI state vector provided. This function is part of PySCF's FCI direct_spin1 routines and is used in electronic structure calculations to extract one-particle observables (for example, to form the expectation value of a one-electron Hamiltonian). The implementation obtains the spin-resolved matrices by calling make_rdm1s(fcivec, norb, nelec, link_index) and returns their elementwise sum. The convention for indices and operator ordering follows McWeeny, Eq. (5.4.20). The resulting matrix can be contracted with a one-particle Hamiltonian h1 as E = einsum('pq,qp', h1, rdm1) to obtain the one-body contribution to the energy.
    
    Args:
        fcivec (numpy.ndarray): The FCI state vector (wavefunction coefficients) in the determinant/configuration basis used by the direct_spin1 FCI implementation. This array encodes the amplitudes of many-electron basis states and its length must match the Hilbert space dimension specified by norb and nelec. The dtype may be real or complex depending on the calculation; the routine preserves the dtype when forming the density matrix.
        norb (int): Number of spatial orbitals used to define the one-particle basis. The returned density matrix has shape (norb, norb) and its indices correspond to these spatial orbitals. This parameter determines how the FCI vector is interpreted and how the spin-resolved RDMs are assembled.
        nelec (tuple): Electron count as a pair (nalpha, nbeta) giving the number of alpha and beta electrons in the FCI wavefunction. This tuple controls the occupation-space combinatorics used to construct intermediate mappings and therefore must correctly describe the state encoded in fcivec.
        link_index (tuple, optional): Optional precomputed connectivity/index structure describing excitations between determinants (the data structure used by the lower-level routines to accelerate RDM construction). If provided, it must be consistent with norb and nelec and with the format expected by the direct_spin1 routines; otherwise the function may raise an error. If None (the default), the function (via the called helper routines) will construct whatever internal index structures are needed; providing a valid precomputed link_index can reduce repeated overhead when making RDMs multiple times.
    
    Returns:
        numpy.ndarray: A spin-traced one-particle density matrix of shape (norb, norb). Each element is dm1[p,q] = <q_alpha^dagger p_alpha> + <q_beta^dagger p_beta>, representing the expectation value of annihilating an electron in orbital p and creating one in orbital q summed over spins. The returned array is suitable for contracting with a one-electron operator (e.g., E = einsum('pq,qp', h1, rdm1)) to obtain one-body expectation values.
    
    Behavior, side effects, defaults, and failure modes:
        This function is a pure computational routine with no external side effects beyond memory allocation. It delegates to make_rdm1s to compute spin-resolved density matrices and returns their sum. If fcivec length does not match the dimension implied by norb and nelec, or if link_index (when provided) has an incompatible structure, the function will typically raise an error from the underlying routines (IndexError, ValueError, or similar). Large norb and/or large configuration spaces implied by nelec may lead to high memory usage or long runtimes; supplying a correct precomputed link_index can improve performance for repeated RDM constructions. The routine preserves the dtype (real or complex) of intermediate arrays, so numerical dtype mismatches in later code may need explicit handling by the caller.
    """
    from pyscf.fci.direct_spin1 import make_rdm1
    return make_rdm1(fcivec, norb, nelec, link_index)


################################################################################
# Source: pyscf.fci.direct_spin1.make_rdm12
# File: pyscf/fci/direct_spin1.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin1_make_rdm12(
    fcivec: numpy.ndarray,
    norb: int,
    nelec: tuple,
    link_index: list = None,
    reorder: bool = True
):
    """Spin-traced one- and two-particle reduced density matrix builder for FCI spin-1 functions.
    
    This function computes the spin-traced one-particle density matrix (1pdm) and two-particle density matrix (2pdm) for a full configuration interaction (FCI) wavefunction represented by fcivec in the spin-adapted (spin-1) formulation used in pyscf.fci.direct_spin1. The returned 1pdm and 2pdm are suitable for evaluating expectation values and energies in electronic structure calculations. In particular, the energy contribution from one- and two-electron operators can be formed as
    E = einsum('pq,qp', h1, 1pdm) + 1/2 * einsum('pqrs,pqrs', eri, 2pdm),
    where h1[p,q] = <p|h|q> and eri[p,q,r,s] = (pq|rs). The mathematical definitions implemented are
    1pdm[p,q] = < q_alpha^dagger p_alpha > + < q_beta^dagger p_beta >;
    2pdm[p,q,r,s] = < p_alpha^dagger r_alpha^dagger s_alpha q_alpha >
                   + < p_beta^dagger r_alpha^dagger s_alpha q_beta >
                   + < p_alpha^dagger r_beta^dagger s_beta q_alpha >
                   + < p_beta^dagger r_beta^dagger s_beta q_beta >,
    i.e. the spin trace over alpha/beta spin blocks.
    
    Args:
        fcivec (numpy.ndarray): Flattened FCI wavefunction coefficients (FCI vector) in the spin-1 representation expected by pyscf.fci.direct_spin1 routines. This array is the primary input representing the many-electron wavefunction; its length and layout must be consistent with norb and nelec as required by the FCI kernel. The function does not modify fcivec.
        norb (int): Number of spatial orbitals in the active space. This integer determines the orbital index range (p,q,r,s) used in the returned density matrices and must match the orbital dimension implied by fcivec.
        nelec (tuple): Electron count as a tuple describing the number of electrons used to build fcivec in the FCI calculation. For spin-1 routines this is the total electron occupation descriptor used by the FCI driver (conventionally a tuple like (nalpha, nbeta) or a form accepted by the surrounding FCI code). The value controls which determinants are present in fcivec and therefore the resulting density matrices.
        link_index (list): Optional link-index data structure computed by FCI linking utilities and used by the internal FCI kernel to accelerate evaluation of matrix elements between determinants. Typical callers pass a precomputed link_index produced by FCI helper functions; if None, the internal kernel invoked here will handle linking according to its internal behavior. This argument is forwarded unchanged to the underlying rdm.make_rdm12_spin1 kernel.
        reorder (bool): If True (default), the function will apply rdm.reorder_rdm to the computed dm1 and dm2 with inplace=True so that the returned arrays follow the conventional orbital ordering expected by higher-level PySCF routines and post-processing. If False, the raw ordering produced by the internal kernel is returned. Note: reorder affects only the returned density matrices and does not modify the input fcivec.
    
    Returns:
        tuple:
            dm1 (numpy.ndarray): Spin-traced one-particle density matrix corresponding to the input FCI wavefunction. The matrix elements use orbital indices consistent with norb and nelec and represent <q^dagger p> summed over spins as given above. This array is suitable for direct contraction with one-electron integrals to obtain the one-electron energy contribution.
            dm2 (numpy.ndarray): Spin-traced two-particle density matrix corresponding to the input FCI wavefunction. The tensor elements use orbital indices consistent with norb and nelec and represent the spin-traced two-body expectation values as given above. This array is suitable for direct contraction with two-electron integrals to obtain the two-electron energy contribution.
    
    Behavior and side effects:
        The function delegates the heavy lifting to the internal kernel rdm.make_rdm12_spin1('FCIrdm12kern_sf', fcivec, fcivec, norb, nelec, link_index, 1) and then optionally calls rdm.reorder_rdm(dm1, dm2, inplace=True) when reorder is True. The reorder call is performed in-place on the dm1/dm2 arrays produced by the kernel, but no other input arrays (for example fcivec) are modified. The returned dm1 and dm2 are new numpy.ndarray objects produced by the internal routines (possibly modified in-place by reorder_rdm) and should be treated as owned by the caller.
    
    Failure modes and errors:
        The function will raise exceptions (for example TypeError or ValueError originating from the internal kernel) if the provided fcivec, norb, or nelec are inconsistent in type, size, or shape with one another or with the expectations of the underlying FCI routines. Providing an incorrect or incompatible link_index may also cause errors in the internal kernel. Callers should ensure fcivec, norb, and nelec reflect a valid FCI state before calling this function.
    """
    from pyscf.fci.direct_spin1 import make_rdm12
    return make_rdm12(fcivec, norb, nelec, link_index, reorder)


################################################################################
# Source: pyscf.fci.direct_spin1.make_rdm123
# File: pyscf/fci/direct_spin1.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin1_make_rdm123(
    fcivec: numpy.ndarray,
    norb: int,
    nelec: tuple,
    link_index: list = None,
    reorder: bool = True
):
    """Compute spin-traced 1-, 2-, and 3-particle reduced density matrices (RDMs)
    from a full configuration interaction (FCI) state vector in the direct_spin1
    FCI implementation of PySCF. This function is used in electronic-structure
    workflows (PySCF) to extract reduced density matrices needed for computing
    expectation values of one-, two-, and three-body operators, analysis of
    correlation, and as inputs to downstream post‑FCI routines.
    
    Args:
        fcivec (numpy.ndarray): The FCI state vector (CI coefficients) supplied as a
            NumPy array. This array contains the wavefunction amplitudes in the
            ordering expected by pyscf.fci.direct_spin1 routines and is provided as
            the primary input to rdm.make_dm123. The shape and length of fcivec must
            be consistent with the specified norb and nelec values; otherwise the
            underlying RDM construction routine will raise an exception. The array
            may be real- or complex-valued depending on the calculation.
        norb (int): Number of spatial orbitals in the FCI problem. norb determines
            how the RDM-building kernel interprets the FCI vector and therefore
            controls the implicit dimensionality of the returned density matrices.
            This integer must match the orbital count used to generate fcivec.
        nelec (tuple): Electron count provided as a tuple (nalpha, nbeta) giving the
            number of alpha and beta electrons, respectively. This tuple is used by
            the underlying RDM kernel to select the correct sector of the FCI space
            and is required for correct construction of spin-traced RDMs.
        link_index (list): Present for API compatibility with other FCI routines;
            this argument is accepted but not used by this implementation. Passing a
            non-None value has no effect on the computation performed by this
            function.
        reorder (bool): If True (default), the function post-processes the raw RDMs
            returned by the kernel by calling rdm.reorder_dm123(..., inplace=True)
            so that the returned dm1, dm2, dm3 follow the canonical ordering
            expected by downstream PySCF code in the direct_spin1 module. If False,
            the raw output from rdm.make_dm123 is returned without reordering.
            Note that when reorder is True the reordering operation is performed
            in-place on the arrays returned by the kernel.
    
    Behavior and side effects:
        The implementation calls rdm.make_dm123('FCI3pdm_kern_sf', fcivec, fcivec,
        norb, nelec) to construct the spin-traced 1-, 2-, and 3-particle density
        matrices from the provided FCI vector. If reorder is True, it then calls
        rdm.reorder_dm123(dm1, dm2, dm3, inplace=True) to convert the kernel output
        to the canonical ordering used elsewhere in pyscf.fci.direct_spin1. Because
        rdm.reorder_dm123 is invoked with inplace=True, the returned arrays may be
        modified in-place (no additional copies are made for the reordering step).
        Construction of the 3-particle RDM can be extremely memory- and
        computationally-intensive for large norb and electron counts; callers must
        ensure sufficient memory and CPU resources. Invalid input types, inconsistent
        shapes, or mismatched norb/nelec specifications will result in exceptions
        propagated from the underlying rdm routines (for example, ValueError or
        TypeError from NumPy or the RDM kernel).
    
    Returns:
        tuple: A 3-tuple (dm1, dm2, dm3) where each element is a numpy.ndarray.
        dm1 is the spin-traced one-particle reduced density matrix, dm2 is the
        spin-traced two-particle reduced density matrix, and dm3 is the
        spin-traced three-particle reduced density matrix. These arrays are the
        principal outputs used to evaluate one-, two-, and three-body expectation
        values and to supply correlated-property routines in the PySCF framework.
    """
    from pyscf.fci.direct_spin1 import make_rdm123
    return make_rdm123(fcivec, norb, nelec, link_index, reorder)


################################################################################
# Source: pyscf.fci.direct_spin1.trans_rdm1
# File: pyscf/fci/direct_spin1.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin1_trans_rdm1(
    cibra: numpy.ndarray,
    ciket: numpy.ndarray,
    norb: int,
    nelec: tuple,
    link_index: list = None
):
    """pyscf.fci.direct_spin1.trans_rdm1 computes the spin-traced transition one-particle reduced density matrix (1-RDM) for a transition between two FCI (full configuration interaction) states. The function is part of the FCI utilities in the PySCF quantum chemistry framework and returns the matrix elements used to evaluate one-electron transition properties by summing the alpha and beta spin contributions computed by the helper trans_rdm1s function.
    
    Args:
        cibra (numpy.ndarray): CI coefficient array for the "bra" many-electron FCI state. In the context of PySCF FCI routines, this is the vector of expansion coefficients in the occupation-number basis for the reference state from which the transition originates. The array must be a numerical NumPy array compatible with trans_rdm1s; mismatched shapes or incompatible dtypes will cause errors propagated from NumPy or the helper routine.
        ciket (numpy.ndarray): CI coefficient array for the "ket" many-electron FCI state. This is the vector of expansion coefficients in the occupation-number basis for the target state of the transition. The function computes transition matrix elements <cibra|a^dagger p a q|ciket> summed over spins, so cibra and ciket must represent states defined in the same orbital and electron-number space.
        norb (int): Number of spatial molecular orbitals in the active FCI space. This integer parameter determines the dimension of the returned one-particle transition density matrix and must match the orbital indexing assumed by the CI vectors cibra and ciket. If norb is inconsistent with the CI vector representation, the underlying computations will raise exceptions.
        nelec (tuple): A two-integer tuple (nalpha, nbeta) giving the number of alpha and beta electrons in the FCI calculation. This describes the occupation sector of the supplied CI vectors and is required by the FCI routines to interpret the CI amplitudes correctly. Providing an incorrect electron count will lead to incorrect results or runtime errors from the helper functions.
        link_index (list): Precomputed linking structure used by the FCI routines to map single- and double-excitation indices between occupation-number determinants. This list is an optional performance aid passed directly to trans_rdm1s. If None (the default), the underlying helper function is responsible for constructing or inferring the necessary link-index data from norb and nelec; supplying a correctly built link_index can significantly reduce setup cost for repeated calls. The content and format of link_index must follow the conventions used by PySCF FCI helper functions; otherwise, errors will be raised.
    
    Returns:
        numpy.ndarray: The spin-traced transition one-particle reduced density matrix (1-RDM) represented as a NumPy array. The returned array is the elementwise sum of the alpha and beta spin 1-RDMs produced by trans_rdm1s (rdm1a + rdm1b). Each matrix element rdm1[p,q] corresponds to the sum of spin contributions <q_alpha^dagger p_alpha> + <q_beta^dagger p_beta> for the transition between the provided CI states and is suitable for contracting with one-electron integrals to obtain transition expectation values. The function has no other side effects beyond returning this array and will propagate exceptions from trans_rdm1s or NumPy operations if inputs are invalid (for example, shape or type mismatches, or inconsistent norb/nelec).
    """
    from pyscf.fci.direct_spin1 import trans_rdm1
    return trans_rdm1(cibra, ciket, norb, nelec, link_index)


################################################################################
# Source: pyscf.fci.direct_spin1.make_rdm1s
# File: pyscf/fci/direct_spin1.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin1_make_rdm1s(
    fcivec: numpy.ndarray,
    norb: int,
    nelec: tuple,
    link_index: tuple = None
):
    """Spin-separated one-particle reduced density matrices for a Full Configuration Interaction (FCI) wavefunction.
    
    This function is used in the PySCF FCI direct spin-1 implementation to compute the spin-resolved one-particle reduced density matrices (RDM-1) for the alpha and beta spin sectors from a given FCI vector. The returned matrices correspond to the expectation values <q^dagger p> for creation/annihilation operators in the second-quantized representation and follow the convention used in McWeeny (see original implementation comment and Eq (5.4.20) in McWeeney). These spin-separated RDMs are commonly used in quantum chemistry workflows implemented in PySCF to evaluate one-body operator expectation values (for example, the one-electron energy via E = einsum('pq,qp', h1, rdm1)), to build spin-dependent density matrices for property evaluation, or as intermediates in post-FCI analyses.
    
    Args:
        fcivec (numpy.ndarray): The FCI state vector (coefficient vector) representing the many-electron wavefunction in the direct_spin1 encoding. This array contains the expansion coefficients of the electronic state in the chosen FCI basis and is passed unchanged to the underlying rdm.make_rdm1_spin1 routine as both bra and ket (pure-state expectation). The array must be compatible with the direct_spin1 indexing conventions used by PySCF; if its shape or dtype is incompatible, the underlying routines will raise an exception.
        norb (int): Number of spatial orbitals in the FCI problem. This integer determines the orbital space over which the one-particle RDMs are formed and is forwarded to the underlying rdm construction routines. It must match the orbital range used to generate or supply link_index (if provided).
        nelec (tuple): Electron count specified as a two-entry tuple (neleca, nelecb), giving the number of alpha and beta electrons respectively. This argument controls how link-index arrays are generated when link_index is None and determines which Slater determinants are present in the FCI vector. The function unpacks this tuple internally (via _unpack_nelec) to obtain neleca and nelecb.
        link_index (tuple, optional): Precomputed link-index structures for alpha and beta spin strings, typically produced by cistring.gen_linkstr_index(range(norb), neleca) and cistring.gen_linkstr_index(range(norb), nelecb). When provided, it must be a two-entry tuple (link_indexa, link_indexb) and is passed directly to the underlying rdm.make_rdm1_spin1 calls to accelerate the RDM construction. If link_index is None (the default), the function will generate link_indexa and link_indexb internally using cistring.gen_linkstr_index for the given norb and nelec. Supplying a correctly formed link_index avoids recomputation and improves performance; supplying an incorrectly formed link_index (wrong shape, type, or inconsistent with norb/nelec) will result in errors propagated from the underlying routines.
    
    Returns:
        tuple: A pair (rdm1a, rdm1b) of numpy.ndarray objects representing the spin-separated one-particle density matrices for alpha and beta spins, respectively. Each returned object is the RDM for the corresponding spin sector computed as the expectation value of the one-body operator between the provided fcivec bra and ket. These RDMs are intended for direct use in one-body expectation value evaluations (for example, contracting with a one-electron Hamiltonian h1 via einsum('pq,qp', h1, rdm1)), as intermediates for property calculations, or for further many-body analysis within PySCF. The function has no other side effects beyond optionally generating link_index when it is not provided.
    
    Notes, behavior, and failure modes:
        - The routine calls rdm.make_rdm1_spin1 twice with labels 'FCImake_rdm1a' and 'FCImake_rdm1b', passing the same fcivec as both bra and ket; this reflects computation of a pure-state RDM for each spin block.
        - If link_index is None, link-index arrays are created internally using cistring.gen_linkstr_index(range(norb), neleca) and cistring.gen_linkstr_index(range(norb), nelecb). This internal generation can incur additional cost for large spaces; to avoid repeated computation across multiple calls, precompute and pass link_index.
        - Errors will be raised by the underlying helper routines if inputs are incompatible (for example, if fcivec does not conform to the expected direct_spin1 layout, norb is inconsistent with link_index, or nelec is not a two-entry tuple). These errors are propagated rather than swallowed.
        - The function implements the RDM convention dm1[p,q] = <q^\dagger p>, consistent with the contraction form E = einsum('pq,qp', h1, rdm1) used elsewhere in PySCF.
    """
    from pyscf.fci.direct_spin1 import make_rdm1s
    return make_rdm1s(fcivec, norb, nelec, link_index)


################################################################################
# Source: pyscf.fci.direct_spin1.make_rdm1234
# File: pyscf/fci/direct_spin1.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin1_make_rdm1234(
    fcivec: numpy.ndarray,
    norb: int,
    nelec: tuple,
    link_index: list = None,
    reorder: bool = True
):
    """Spin-traced 1-, 2-, 3- and 4-particle reduced density matrices (RDMs) for a
    full configuration interaction (FCI) wavefunction in the direct_spin1 FCI
    representation.
    
    This function is used in the PySCF FCI spin-adapted direct_spin1 module to
    compute spin-traced k-particle RDMs (k = 1,2,3,4) from an FCI coefficient
    vector. The produced RDMs are spin-summed (spin-traced) and are suitable for
    use in downstream tasks in electronic-structure workflows (for example,
    evaluating expectation values, forming reduced-density-based observables, or
    contracting with electron repulsion integrals). Internally this function calls
    rdm.make_dm1234 with the 'FCI4pdm_kern_sf' kernel and, optionally,
    rdm.reorder_dm1234 to adapt the index ordering to the conventions used
    elsewhere in PySCF.
    
    Args:
        fcivec (numpy.ndarray): FCI coefficient vector (CI amplitudes) in the
            direct_spin1 representation. This array provides the bra and ket
            wavefunctions passed to the underlying RDM kernel (it is supplied as
            both the first and second wavefunction arguments to rdm.make_dm1234).
            The length and layout of fcivec must be consistent with norb and
            nelec; otherwise the underlying rdm routines will raise an error.
        norb (int): Number of spatial orbitals used to build the RDMs. This integer
            determines the orbital index range in the returned reduced density
            matrices and must match the basis used to generate fcivec.
        nelec (tuple): Electron count information required by the FCI kernel,
            typically given as a tuple of electron numbers (for example, the
            conventional (nalpha, nbeta) pair). The tuple is forwarded to the
            underlying rdm.make_dm1234 call and must reflect the actual electron
            occupation of the FCI vector.
        link_index (list): Optional link-index structure sometimes used by FCI
            kernels to map excitation links. Accepted for API compatibility with
            other FCI interfaces but not used by this implementation; the value is
            ignored by this function. Default: None.
        reorder (bool): When True (default), the function calls
            rdm.reorder_dm1234(dm1, dm2, dm3, dm4, inplace=True) after the RDMs
            are generated and returns the reordered arrays. The reorder operation
            modifies the returned numpy arrays in place (the function returns the
            same objects after reordering). When False, the RDMs produced by the
            kernel are returned without calling rdm.reorder_dm1234.
    
    Returns:
        tuple: A 4-tuple (dm1, dm2, dm3, dm4) of numpy.ndarray objects containing
        the spin-traced 1-, 2-, 3- and 4-particle reduced density matrices,
        respectively. Each element is the reduced density matrix corresponding to
        the indicated particle rank, returned in that order (dm1 first, dm4 last).
        These arrays are produced by the 'FCI4pdm_kern_sf' kernel; if reorder is
        True they have been passed through rdm.reorder_dm1234 with inplace=True.
    
    Notes and failure modes:
        - The function relies on the underlying rdm.make_dm1234 and
          rdm.reorder_dm1234 implementations. Any exceptions raised by those
          routines (for example due to inconsistent fcivec length, incorrect
          norb or nelec values, or internal indexing errors) are propagated to the
          caller.
        - The link_index parameter is accepted but intentionally ignored by this
          implementation; it is provided only for compatibility with other FCI
          interfaces in PySCF.
        - The exact memory footprint and numerical dtype of the returned numpy
          arrays follow the behavior of the underlying kernel and will depend on
          fcivec's dtype and the FCI kernel implementation.
    """
    from pyscf.fci.direct_spin1 import make_rdm1234
    return make_rdm1234(fcivec, norb, nelec, link_index, reorder)


################################################################################
# Source: pyscf.fci.direct_spin1.make_rdm12s
# File: pyscf/fci/direct_spin1.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin1_make_rdm12s(
    fcivec: numpy.ndarray,
    norb: int,
    nelec: tuple,
    link_index: list = None,
    reorder: bool = True
):
    """Spin-separated one- and two-particle reduced density matrices (RDMs) for a Full
    Configuration Interaction (FCI) wavefunction represented by a CI vector in the
    pyscf.fci.direct_spin1 implementation.
    
    This function is used in the FCI module of the PySCF framework (a Python-based
    Simulations of Chemistry Framework) to compute spin-resolved reduced density
    matrices from an FCI coefficient vector. The outputs are suitable for computing
    expectation values such as the electronic energy in the conventional chemistry
    notation:
    E = einsum('pq,qp', h1, 1pdm) + 1/2 * einsum('pqrs,pqrs', eri, 2pdm)
    where h1[p,q] = <p|h|q>, eri[p,q,r,s] = (pq|rs), 1pdm[p,q] = <q^dagger p>, and
    2pdm[p,q,r,s] = <p^dagger r^dagger s q>. In practical usage within PySCF this
    function calls lower-level kernels rdm.make_rdm12_spin1 and (optionally)
    rdm.reorder_rdm to produce RDMs in the standard orbital ordering used by the
    library.
    
    Args:
        fcivec (numpy.ndarray): The FCI coefficient vector representing the many-body
            wavefunction in the direct_spin1 FCI basis. This array contains the
            expansion coefficients for the electronic determinants/configurations
            for the specified number of orbitals (norb) and electrons (nelec). The
            vector must be compatible with the direct_spin1 internal ordering and
            size expectations; otherwise the lower-level RDM kernels will raise an
            exception (typically ValueError or an IndexError propagated from the
            kernels). The function does not modify fcivec.
        norb (int): Number of spatial orbitals used to build the FCI space. This
            integer determines the orbital dimension of the returned RDMs: 1-particle
            RDMs are arrays over these orbitals, and 2-particle RDMs are arrays with
            four orbital indices each running from 0 to norb-1. Passing an incorrect
            norb inconsistent with fcivec will cause the kernel routines to fail.
        nelec (tuple): A two-element tuple specifying the number of alpha and beta
            electrons respectively (nalpha, nbeta). This tuple defines the spin
            sector for which the FCI vector fcivec is defined and is required to
            select the correct blocks when constructing spin-separated RDMs. Mismatched
            nelec and fcivec content will lead to errors from the underlying RDM
            construction routines.
        link_index (list, optional): Precomputed connectivity/indexing information
            used by the direct-spin FCI RDM kernels to map single- and two-electron
            excitation/connectivity patterns (the same structure accepted by the
            rdm.make_rdm12_spin1 kernels). Providing a link_index that was produced
            for the same norb and nelec speeds up RDM construction. If None (the
            default), the underlying kernels will compute the required link tables
            internally, which is correct but may be slower and use more temporary
            memory. The function does not modify the provided link_index list.
        reorder (bool, optional): If True (default), the computed RDMs are passed
            to rdm.reorder_rdm with inplace=True to transform them into the standard
            molecular-orbital ordering convention used by other PySCF routines.
            This reordering is performed on the returned arrays (the function
            reassigns local references to reordered arrays) and may modify the
            underlying array memory when the reorder routine supports in-place
            reordering. If False, the raw ordering produced by the kernels is
            returned unchanged.
    
    Returns:
        tuple: A pair of tuples containing spin-separated 1- and 2-particle RDMs
        in the ordering used by PySCF (after optional reordering). The structure is:
            (dm1a, dm1b), (dm2aa, dm2ab, dm2bb)
        where:
            dm1a (numpy.ndarray): Alpha-spin 1-particle density matrix, with
                elements 1pdm[p,q] = < q^dagger p > for alpha spin orbitals.
            dm1b (numpy.ndarray): Beta-spin 1-particle density matrix, with
                elements 1pdm[p,q] = < q^dagger p > for beta spin orbitals.
            dm2aa (numpy.ndarray): Alpha-alpha-alpha-alpha 2-particle density
                matrix with elements 2pdm[p,q,r,s] = < p^dagger r^dagger s q >
                when all operator indices refer to alpha spin orbitals.
            dm2ab (numpy.ndarray): Alpha-alpha-beta-beta mixed-spin 2-particle density
                matrix corresponding to the ordering (alpha,alpha,beta,beta) with
                the same 2pdm index convention 2pdm[p,q,r,s] = < p^dagger r^dagger s q >.
            dm2bb (numpy.ndarray): Beta-beta-beta-beta 2-particle density matrix with
                the same index convention for beta spins.
        All returned arrays are numpy.ndarray objects. The 1-particle matrices have
        two indices (shape dependent on norb) and the 2-particle matrices have four
        indices (each index ranges over norb). These arrays are ready for use in
        expectation value computations (for example the energy expression given
        above). If reorder is True, the returned arrays reflect the reordered
        orbital convention; if False, they are in the raw kernel ordering.
    
    Raises and failure modes:
        The function does not itself perform extensive input validation beyond Python
        type checks; errors arising from inconsistent fcivec size, incompatible norb
        or nelec, or malformed link_index are raised by the underlying rdm.make_rdm12_spin1
        or rdm.reorder_rdm kernels (commonly ValueError, IndexError, or TypeError).
        If memory allocation fails for the intermediate or output arrays, a MemoryError
        may be raised by NumPy.
    """
    from pyscf.fci.direct_spin1 import make_rdm12s
    return make_rdm12s(fcivec, norb, nelec, link_index, reorder)


################################################################################
# Source: pyscf.fci.direct_spin1_cyl_sym.sym_allowed_indices
# File: pyscf/fci/direct_spin1_cyl_sym.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin1_cyl_sym_sym_allowed_indices(
    nelec: tuple,
    orbsym: numpy.ndarray,
    wfnsym: int
):
    """Indices of symmetry-allowed determinant pairs for each irreducible representation (irrep) in the cylindrical (linearmole) symmetry treatment used by PySCF's FCI direct spin-1 implementation.
    
    This function is used in the pyscf.fci.direct_spin1_cyl_sym module to precompute, for a given electron occupation (nelec), orbital symmetry assignment (orbsym), and target many-body wavefunction symmetry (wfnsym), the list of linearized indices of alpha/beta determinant pairs that satisfy the conservation of angular-momentum-like quantum numbers and parity required by the target wfnsym. The returned lists are intended for use when assembling FCI Hamiltonian blocks or selecting symmetry-allowed basis states; each returned array contains integer indices into the flattened product space of alpha- and beta-determinant indices, with the linearization rule index = alpha_index * nb + beta_index where nb is the number of beta strings.
    
    Args:
        nelec (tuple): A length-2 tuple (neleca, nelecb) specifying the number of alpha and beta electrons respectively. This determines which Slater strings are generated for alpha and beta spin sectors and therefore controls the dimension and content of the allowed-index lists. The function will unpack this tuple and expects two integer counts; passing a non-2-length sequence or non-integer entries will raise a Python error when unpacking or later when generating strings.
        orbsym (numpy.ndarray): One-dimensional array giving the symmetry label for each spatial orbital. In practice, entries are integer symmetry labels used by PySCF (the code applies orbsym % 10 to map to D2h-like labels and uses these to infer parity and angular-momentum-like quantum numbers). The array length (number of orbitals) is read from orbsym.size and is used to generate Slater strings over the orbital index range. Entries must be numeric integers appropriate for the rest of the PySCF symmetry machinery.
        wfnsym (int): Integer code of the target many-body wavefunction irrep (PySCF irrep integer). The function uses symm.basis.linearmole_irrep2momentum(wfnsym) to obtain the target momentum-like quantum number and also uses wfnsym % 10 to determine D2h parity (ungerade vs. gerade). wfnsym must be a valid PySCF irrep integer accepted by symm.basis.linearmole_irrep2momentum.
    
    Returns:
        list[numpy.ndarray]: A list with length equal to nirreps where nirreps is computed internally as (2 * max_momentum + 1) * max_gerades (max_momentum and max_gerades are derived from orbsym, the generated Slater-string angular momenta, and parity). Each element of the list is a one-dimensional numpy.ndarray of dtype int containing the flattened indices of allowed alpha/beta determinant pairs for that particular irrep block. The flattened index corresponds to alpha_index * nb + beta_index, where nb is the number of beta strings used. Entries may be empty arrays when no determinant pairs satisfy the symmetry constraints for that irrep. The ordering and grouping within each array follow the per-spin-string ordering produced by argsort_strs_by_irrep(...) as used in the code.
    
    Behavior, side effects, defaults, and failure modes:
        This is a pure computation function with no external side effects (it does not modify global state or write files). It deterministically generates Slater strings for alpha and beta spins (using cistring.gen_strings4orblist), computes their angular-momentum-like labels (_strs_angular_momentum), determines parity blocks from orbsym and wfnsym, and assembles the allowed combined indices by enforcing conservation of the momentum-like quantum number (al + bl == wfn_momentum) while accounting for gerade/ungerade combinations. When neleca == nelecb the same string list is reused for alpha and beta; when they differ, separate beta strings are generated. The function relies on helper routines in the same module (for example, _strs_angular_momentum, _get_orb_l, argsort_strs_by_irrep) and on symm.basis.linearmole_irrep2momentum; if these helpers are not present or accept different inputs, the function will raise the corresponding Python exception. Passing inputs of incorrect types (e.g., nelec not a length-2 tuple of ints, orbsym not a numpy.ndarray, or wfnsym not an int) will result in standard Python errors (TypeError, ValueError, or AttributeError) when the function attempts to use the values. The function does not perform explicit input validation beyond relying on the operations shown in the source code.
    
    Practical significance in PySCF:
        In PySCF's FCI workflows for systems with cylindrical/linearmole symmetry, restricting determinant pairs to those that transform according to a target wfnsym reduces the size of Hamiltonian blocks and enforces symmetry constraints on the computed many-body states. This function provides the per-irrep index lists required to build those symmetry-adapted FCI spaces efficiently.
    """
    from pyscf.fci.direct_spin1_cyl_sym import sym_allowed_indices
    return sym_allowed_indices(nelec, orbsym, wfnsym)


################################################################################
# Source: pyscf.fci.direct_spin1.pspace
# File: pyscf/fci/direct_spin1.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin1_pspace(
    h1e: numpy.ndarray,
    eri: numpy.ndarray,
    norb: int,
    nelec: tuple,
    hdiag: numpy.ndarray = None,
    np: int = 400
):
    """pyscf.fci.direct_spin1.pspace constructs a reduced-size "pspace" configuration-interaction Hamiltonian matrix used to improve the Davidson preconditioner in full configuration interaction (FCI) calculations for singlet/triplet spin-adapted direct_spin1 algorithms. The function selects a subset of many-electron determinants (by diagonal energies) and builds the corresponding small Hamiltonian block (h0) that approximates the action of the full Hamiltonian in that subspace; this small matrix is intended to be used as a preconditioning/operator model inside iterative eigensolvers (Davidson-like) in the PySCF FCI driver.
    
    Args:
        h1e (numpy.ndarray): Real-valued one-electron integrals matrix (shape (norb,norb)). In the FCI direct_spin1 context these are the spin-restricted one-electron Hamiltonian matrix elements used to construct FCI Hamiltonian matrix elements. The function requires a real floating dtype (complex128 is not supported) and will convert the array to a contiguous representation. The array is used directly to evaluate Hamiltonian couplings for the selected determinant subspace.
        eri (numpy.ndarray): Two-electron integrals in physicist's notation. The function calls ao2mo.restore(1, eri, norb) on this input, so eri may be provided in a compact or packed form acceptable to ao2mo.restore; after restore it is treated as a 4-index tensor (shape (norb,norb,norb,norb)). The dtype must be real (complex128 is not supported). This array provides the two-electron contributions to the FCI Hamiltonian restricted to the selected determinant subspace.
        norb (int): Number of spatial orbitals in the FCI problem. This integer determines the size of the single-particle basis used to enumerate determinants/strings. The implementation currently raises NotImplementedError if norb >= 64 because internal string/address tables and C helper routines in libfci do not support that orbital count.
        nelec (tuple): Electron occupation numbers as a tuple (neleca, nelecb) giving the numbers of alpha and beta electrons respectively. This tuple is used to determine the total number of alpha and beta strings (determinants) and therefore the full dimension of the FCI determinant space (na*nb). The function unpacks nelec and uses it to compute index/address mappings between linear determinant indices and separate alpha/beta string addresses.
        hdiag (numpy.ndarray): Array of diagonal Hamiltonian elements for the full determinant space (shape (na*nb,)). If None (default), the function computes the diagonal via make_hdiag(h1e, eri, norb, nelec, compress=False). The diagonal is used to select the lowest-energy determinants for the pspace and to set the diagonal entries of the returned subspace Hamiltonian. The function asserts that hdiag.size equals na*nb and will raise AssertionError if the sizes disagree.
        np (int): Requested number of determinants (subspace dimension) to include in the pspace Hamiltonian. Default is 400. The function selects up to np determinants having the smallest diagonal energies in hdiag; if the full determinant space dimension is less than or equal to np, all determinants are selected. Internally the code uses numpy.argpartition (with numpy.argsort fallback) to efficiently choose the lowest-energy addresses. Note: the function assigns a local variable named np to the actual number of selected addresses (len(addr)) after selection; this is an internal local rebind and does not modify caller variables.
    
    Behavior, side effects, and failure modes:
        The function enumerates the total number of alpha and beta strings (na and nb) from norb and nelec, and expects hdiag.size == na*nb. If hdiag is None the function calls make_hdiag to compute the diagonal energies for all determinants; this computation is performed with compress=False to yield an explicit array matching the full determinant ordering.
        The function selects a set of linear determinant indices (addr) corresponding to the lowest diagonal energies up to the requested np. If hdiag.size <= np all determinant indices are selected. Selection uses numpy.argpartition for O(N) expected behavior and falls back to numpy.argsort if argpartition is unavailable; the returned addr array is a copy of the selected indices.
        After selection, the function converts the linear indices to separate alpha and beta string addresses (addra, addrb) and then to bitstring representations (stra, strb) used by the underlying C routine. It calls the compiled libfci.FCIpspace_h0tril C helper to fill the lower-triangular part of an np-by-np matrix h0 with Hamiltonian couplings for the selected determinant subspace. If h1e and eri are sufficiently symmetric (within a HERMITIAN_THRESHOLD = 1e-10), the code treats the Hamiltonian as symmetric and mirrors the lower-triangular data to create a Hermitian matrix via lib.hermi_triu. Otherwise, the function performs an explicit second call to the C helper with transposed integrals to fill the upper-triangular part. After filling off-diagonal elements, the function sets the diagonal entries of h0 from hdiag[addr].
        The function requires a compiled libfci and lib helper routines; if these C extension routines are not available or fail, the function will raise the corresponding ImportError or exceptions propagated from the C layer.
        The function explicitly disallows complex-valued Hamiltonians: if h1e.dtype or eri.dtype equals numpy.complex128 a NotImplementedError is raised.
        The function raises NotImplementedError for norb >= 64 to signal unsupported orbital counts.
        The function asserts that the computed or provided hdiag array length equals the total number of determinants (na*nb); if this condition fails an AssertionError is raised.
        Memory/layout notes: the function arranges h1e and eri into contiguous arrays and may transpose/instrument them when filling h0; users should pass arrays consistent with ao2mo.restore conventions for eri. The returned h0 is a numpy.ndarray (C or Fortran contiguous depending on internal branch) containing a Hermitian or general real subspace Hamiltonian suitable for use as a small-model operator in Davidson preconditioning.
    
    Returns:
        addr (numpy.ndarray): One-dimensional integer array of linear indices (dtype integer) identifying the selected determinants from the full FCI determinant ordering. The indices are in the range [0, na*nb) and correspond to the determinants chosen by lowest diagonal energies; users can recover alpha/beta addresses by divmod(addr, nb) where nb is the number of beta strings computed from norb and nelec.
        h0 (numpy.ndarray): Real-valued numpy array of shape (m,m) where m == len(addr) (m <= requested np). h0 is the pspace Hamiltonian block for the selected determinants: off-diagonal matrix elements are computed from h1e and eri using libfci helper routines, and diagonal elements are set to hdiag[addr]. The matrix is Hermitian within numeric tolerance when input integrals are Hermitian; otherwise it contains the assembled real-valued couplings for the selected subspace.
    """
    from pyscf.fci.direct_spin1 import pspace
    return pspace(h1e, eri, norb, nelec, hdiag, np)


################################################################################
# Source: pyscf.fci.fci_slow.reorder_rdm
# File: pyscf/fci/fci_slow.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_fci_slow_reorder_rdm(
    rdm1: numpy.ndarray,
    rdm2: numpy.ndarray,
    inplace: bool = True
):
    """pyscf.fci.fci_slow.reorder_rdm reorders a two-particle reduced density matrix (2-RDM) prepared as a product of one-particle excitation operators into the true two-electron reduced density matrix representation used in energy evaluation in FCI calculations.
    
    This function is used in the PySCF FCI (full configuration interaction) module to convert a 2-RDM initially stored as rdm2(pq,rs) = <E^p_q E^r_s> (the expectation value of a product of one-particle excitation operators) into the reordered 2-RDM rdm2(pq,rs) = <e^{pr}_{qs}>. The reordered 2-RDM remains in Mulliken ordering (indices arranged as [e1,e1,e2,e2]) but becomes the true two-electron density matrix that, when contracted with two-electron integrals (int2e), yields the two-electron contribution to the electronic energy. The routine derives the number of molecular orbitals nmo from rdm1.shape[0] and performs an index-level correction by subtracting the one-particle density matrix from diagonal index blocks of rdm2.
    
    Args:
        rdm1 (numpy.ndarray): The one-particle reduced density matrix (1-RDM) used to correct the 2-RDM. In the FCI context this is the matrix with elements <E^p_q> (one-body expectation values). The function reads rdm1.shape[0] to determine nmo (number of molecular orbitals). Expected to be a square 2D array with shape (nmo, nmo); if not square, subsequent operations will fail (for example, attempt to reshape rdm2 will raise a ValueError or indexing will be inconsistent). rdm1 is not modified by this function and is returned unchanged for convenience.
        rdm2 (numpy.ndarray): The two-particle reduced density matrix in the form rdm2(pq,rs) = <E^p_q E^r_s> prior to reordering. The array must be reshape-compatible with shape (nmo, nmo, nmo, nmo) where nmo == rdm1.shape[0]. Acceptable initial layouts include a flattened 4D array or an already shaped 4D array; the implementation calls reshape(nmo,nmo,nmo,nmo). If reshape is not possible (size mismatch), Python will raise a ValueError. On reshaping, the function subtracts rdm1 from each slice rdm2[:,k,k,:] for k in range(nmo), implementing the conversion to the true two-electron density operator <e^{pr}_{qs}> in Mulliken ordering. The physical significance is that after this operation rdm2 can be directly contracted with two-electron integrals to obtain the two-electron energy contribution.
        inplace (bool, optional): If True (default), the function reshapes and modifies the provided rdm2 buffer in place (rdm2 is rebound locally to the reshaped view and its blocks are modified directly); the original rdm2 object passed by the caller will observe these changes if it was passed as a mutable array view compatible with the reshape. If False, the function first makes a copy of rdm2 and performs the reordering on that copy, leaving the original rdm2 unmodified. Use inplace=True to avoid the extra memory allocation when it is safe to modify the input buffer; use inplace=False when the original rdm2 must be preserved. Note that even with inplace=True, if the original array is not contiguous or cannot be viewed as the target shape without copying, NumPy may still create a copy internally and the caller should not rely on the absence of copies beyond what Python/NumPy semantics guarantee.
    
    Returns:
        tuple: A pair (rdm1, rdm2) where rdm1 is the original one-particle density matrix passed in (returned for convenience) and rdm2 is the reordered two-particle density matrix with shape (nmo, nmo, nmo, nmo) representing <e^{pr}_{qs}> in Mulliken order. The returned rdm2 is suitable for contraction with two-electron integrals to compute the two-electron part of the electronic energy in FCI calculations. If inplace=True, the returned rdm2 may be the same underlying array object as the input rdm2 (modified in place); if inplace=False, the returned rdm2 is a new array and the input rdm2 is left unmodified.
    
    Raises/Failure modes:
        The function relies on correct array shapes and sizes. If rdm1 is not a 2D square array or if rdm2 cannot be reshaped into (nmo, nmo, nmo, nmo) where nmo = rdm1.shape[0], NumPy will raise a ValueError during reshape or subsequent indexing. Misuse (wrong shapes, incompatible dtypes, or non-numeric arrays) will propagate standard NumPy exceptions. The function does not perform explicit validation beyond using rdm1.shape[0] and calling reshape; callers should ensure arrays conform to the expected FCI density matrix shapes before calling.
    """
    from pyscf.fci.fci_slow import reorder_rdm
    return reorder_rdm(rdm1, rdm2, inplace)


################################################################################
# Source: pyscf.fci.fci_dhf_slow.absorb_h1e
# File: pyscf/fci/fci_dhf_slow.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_fci_dhf_slow_absorb_h1e(
    h1e: numpy.ndarray,
    eri: numpy.ndarray,
    norb: int,
    nelec: int,
    fac: float = 1
):
    """pyscf.fci.fci_dhf_slow.absorb_h1e modifies a two-electron Hamiltonian tensor so that it includes the contribution from a one-electron Hamiltonian, producing a 4-index two-electron Hamiltonian with the one-electron effects absorbed for use in Full Configuration Interaction (FCI) routines in PySCF.
    
    Args:
        h1e (numpy.ndarray): One-electron Hamiltonian matrix in the molecular orbital basis. Expected shape is (norb, norb). This array represents kinetic energy and nuclear attraction terms (or an effective one-electron operator) used by FCI routines. The function uses h1e to compute an effective diagonal correction to the two-electron tensor; h1e is not modified by this function.
        eri (numpy.ndarray): Electron repulsion integral tensor in chemist’s notation, expected shape (norb, norb, norb, norb). This 4-dimensional array supplies the raw two-electron integrals required by FCI. The routine transposes and negates eri to form the base two-electron Hamiltonian and does not modify the input eri array in-place (intermediate arrays are created).
        norb (int): Number of spatial orbitals (norb). This integer selects diagonal indices and must be consistent with the first two dimensions of h1e and all four dimensions of eri. If norb does not match the actual dimensions of h1e or eri, NumPy indexing/broadcasting errors will occur.
        nelec (int): Number of electrons in the system. This integer is used to scale the one-electron contribution added to the diagonal blocks of the two-electron Hamiltonian by a factor 2.0/(nelec + 1e-100). The tiny constant 1e-100 prevents division-by-zero at the numerical level; physically, nelec is expected to be a non-negative integer electron count (nelec == 0 is allowed as input but produces a formally scaled result that may be meaningless for electronic structure).
        fac (float): Multiplicative scaling factor applied to the final modified two-electron Hamiltonian. Default is 1.0. This parameter allows rescaling the returned tensor for algorithmic uses (for example, unit conversions or prefactors required by downstream FCI code).
    
    Returns:
        numpy.ndarray: A new 4-dimensional numpy array representing the two-electron Hamiltonian with the one-electron contribution absorbed. The returned array has the same shape as eri (norb, norb, norb, norb). Specifically, the function computes an intermediate one-electron-like matrix f1e = h1e + 0.5 * einsum('jiik->jk', eri.transpose(0,2,3,1)), forms h2e = -eri.transpose(0,3,2,1), adds f1e * (2.0/(nelec + 1e-100)) to the diagonal blocks indexed by numpy.diag_indices(norb), and finally multiplies the whole tensor by fac before returning. No input arrays are modified in-place; the computation allocates and returns a new array.
    
    Behavior and failure modes:
        - Shape expectations: h1e must be square with dimension norb, and eri must be a 4-index tensor with each axis of length norb. Violating these expectations will result in NumPy indexing, broadcasting, or shape errors.
        - Numerical protection: The denominator for scaling the one-electron addition uses (nelec + 1e-100) to avoid a floating-point division-by-zero. This is a numeric safeguard only; passing nelec == 0 is allowed but not physically typical.
        - Types: Inputs are expected to be numeric NumPy arrays (floating-point) and integer counts for norb and nelec. Supplying non-numeric types will raise NumPy type or operation errors.
        - Side effects: The function does not modify h1e or eri in-place; it returns a newly allocated numpy.ndarray. Memory allocation and intermediate array creation may be significant for large norb.
        - Precision and scaling: fac rescales the entire returned tensor; large absolute values of fac or of intermediate integrals can lead to floating-point overflow or loss of precision inherent to NumPy arithmetic.
    """
    from pyscf.fci.fci_dhf_slow import absorb_h1e
    return absorb_h1e(h1e, eri, norb, nelec, fac)


################################################################################
# Source: pyscf.fci.direct_spin1.trans_rdm12
# File: pyscf/fci/direct_spin1.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin1_trans_rdm12(
    cibra: numpy.ndarray,
    ciket: numpy.ndarray,
    norb: int,
    nelec: tuple,
    link_index: list = None,
    reorder: bool = True
):
    """pyscf.fci.direct_spin1.trans_rdm12 computes spin-traced transition 1- and 2-particle reduced density matrices (RDMs) between two FCI many-electron states.
    
    This function is used in the PySCF quantum chemistry framework to obtain transition RDMs needed for property evaluation, response calculations, and matrix element contractions between a "bra" CI vector and a "ket" CI vector in full configuration interaction (FCI) calculations carried out in the direct_spin1 module. The returned 1-particle RDM dm1 and 2-particle RDM dm2 are spin-traced (alpha+beta summed) and follow the common quantum-chemistry conventions:
    1pdm[p,q] = < q^dagger p >
    2pdm[p,q,r,s] = < p^dagger r^dagger s q >.
    The implementation delegates the core work to rdm.make_rdm12_spin1 using the kernel 'FCItdm12kern_sf' and optionally reorders the output with rdm.reorder_rdm.
    
    Args:
        cibra (numpy.ndarray): CI expansion vector for the bra state. In the FCI context this is the many-electron wavefunction coefficients represented as a 1-D (or appropriately shaped) NumPy array in the same indexing convention expected by PySCF direct_spin1 routines. Practically, cibra is the state from which the left-side expectation values are taken when forming transition RDMs. A TypeError or shape mismatch will result if cibra is not a compatible NumPy array or does not match the requested orbital/electron space implied by norb and nelec.
        ciket (numpy.ndarray): CI expansion vector for the ket state. Analogous to cibra, this NumPy array contains the coefficients of the target many-electron wavefunction. The function computes transition matrix elements between cibra (bra) and ciket (ket). Both cibra and ciket must conform to the same configuration-space ordering; otherwise incorrect results or errors may occur.
        norb (int): Number of spatial orbitals in the FCI problem. This integer determines the orbital dimension of the returned RDMs. The resulting dm1 has shape (norb, norb) and dm2 has shape (norb, norb, norb, norb) when returned in the standard (spin-traced) ordering. Passing an incorrect norb that does not match cibra/ciket will typically raise a ValueError due to inconsistent array shapes or internal indexing failures.
        nelec (tuple): Electron occupation numbers as a tuple describing the FCI spin sector, typically (nalpha, nbeta). nelec determines the allowed configurations in the CI space and is required so the underlying kernel can enumerate and contract determinants correctly. Providing an invalid nelec (wrong length, non-integer entries, or inconsistent with cibra/ciket) can raise ValueError or produce meaningless results.
        link_index (list): Optional list of link-index data structures used to accelerate matrix-element and excitation bookkeeping during RDM construction. When provided, link_index must be precomputed for the same norb and nelec and follow the structure produced by PySCF FCI helper routines; the function will pass it directly to the internal kernel to avoid recomputing connectivity. If None (default), the function allows the internal routine to build any required link data. A mismatch between link_index contents and the other arguments can lead to ValueError or incorrect RDMs.
        reorder (bool): If True (default), the computed dm1 and dm2 are passed through rdm.reorder_rdm(..., inplace=True) before being returned; this reordering converts internal indexing to the standard PySCF/chemists' orbital ordering used by downstream code. When reorder is True the reordering operation is applied in-place to the returned arrays (the arrays returned are the reordered versions). If False, the raw ordering produced by the internal kernel is returned. Note that reorder controls only the final ordering of orbitals and does not alter cibra or ciket.
    
    Returns:
        tuple: A pair (dm1, dm2) of NumPy arrays containing the spin-traced transition reduced density matrices.
        dm1 (numpy.ndarray): The 1-particle spin-traced transition RDM with elements dm1[p,q] = < q^dagger p > and shape (norb, norb).
        dm2 (numpy.ndarray): The 2-particle spin-traced transition RDM with elements dm2[p,q,r,s] = < p^dagger r^dagger s q > and shape (norb, norb, norb, norb).
    
    Behavior and side effects:
        The function performs contractions between the supplied CI vectors using the internal rdm.make_rdm12_spin1 kernel with the identifier 'FCItdm12kern_sf'. If reorder=True (the default), rdm.reorder_rdm is invoked with inplace=True which replaces the internal arrays with their reordered versions before returning them. No global state in PySCF is modified by this call; however, the returned arrays may share memory with internal buffers depending on implementation details of the underlying routines.
    
    Failure modes:
        TypeError is likely if cibra or ciket are not numpy.ndarray. ValueError may be raised when norb and nelec are inconsistent with the shapes or indexing of cibra/ciket or when a provided link_index does not match the orbital/electron specification. Incorrect results can also occur silently if the input CI vectors do not follow the expected ordering conventions; ensure cibra and ciket were generated consistently within the same direct_spin1/FCI framework.
    """
    from pyscf.fci.direct_spin1 import trans_rdm12
    return trans_rdm12(cibra, ciket, norb, nelec, link_index, reorder)


################################################################################
# Source: pyscf.fci.direct_spin1_symm.sym_allowed_indices
# File: pyscf/fci/direct_spin1_symm.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_direct_spin1_symm_sym_allowed_indices(
    nelec: tuple,
    orbsym: numpy.ndarray,
    wfnsym: int
):
    """Indices of symmetry-allowed determinants for each irreducible representation (irrep) used by the FCI direct_spin1_symm routines. This function enumerates alpha- and beta-spin Slater determinant bitstrings for the given orbital and electron occupation, groups them by the orbital symmetry labels, and returns for each irrep the flattened indices in the product space of alpha×beta determinants that produce the requested total wavefunction symmetry wfnsym. This is used to construct or select symmetry-adapted FCI determinant spaces in PySCF (direct_spin1_symm), where restricting the determinant list by symmetry reduces the CI Hamiltonian dimension and enforces the target spatial symmetry of the computed wavefunction.
    
    Args:
        nelec (tuple): A two-element tuple (neleca, nelecb) giving the number of alpha (neleca) and beta (nelecb) electrons. These integer counts are used by cistring.gen_strings4orblist to generate the lists of alpha and beta determinant bitstrings for norb orbitals. Practically, nelec determines the sizes of the alpha and beta determinant spaces and therefore the range of returned indices. neleca and nelecb should be non-negative integers not greater than the number of orbitals (norb); if they are outside the valid range, underlying helpers (cistring.gen_strings4orblist or subsequent indexing) will raise an error.
        orbsym (numpy.ndarray): One-dimensional array of orbital symmetry labels for each spatial orbital; its size determines norb (the number of spatial orbitals). These labels are integer-coded symmetry assignments interpreted by argsort_strs_by_irrep to group Slater determinants by irreducible representation. The array length must equal the number of orbitals intended for the FCI space; mismatched lengths or non-integer/invalid symmetry labels will cause the grouping/indexing helpers to fail or produce empty groups.
        wfnsym (int): Integer encoding of the desired total spatial symmetry of the target wavefunction. In this routine the value is reduced as wfnsym_in_d2h = wfnsym % 10 to extract the D2h irrep label using PySCF's convention where the last digit encodes the D2h irrep. The wfnsym value determines which combinations of alpha- and beta-determinant irreps are considered symmetry-allowed (via a bitwise XOR with the alpha irrep index). If wfnsym is inconsistent with the orbsym labeling or with the chosen point-group conventions, the returned arrays may be empty.
    
    Returns:
        list of numpy.ndarray: A list with length TOTIRREPS (the module-level constant for number of irreps). Each element in the list is a one-dimensional numpy.ndarray of integer indices (dtype int) giving the flattened indices in the alpha×beta product space that are symmetry-allowed for the corresponding irrep index. The flattened index convention is index = alpha_index * nb + beta_index, where nb is the number of beta determinants generated for nelecb and alpha_index and beta_index come from the ordering produced by argsort_strs_by_irrep. Arrays may be empty if no determinants satisfy the symmetry condition for that irrep. No global state is modified by this function; it purely computes and returns index arrays.
    
    Behavior and failure modes:
        - The function calls cistring.gen_strings4orblist to generate determinant bitstrings and argsort_strs_by_irrep to group them by orbital irrep; exceptions raised by those helpers (ValueError, IndexError, etc.) will propagate.
        - If nelec contains values outside [0, norb] or is not a two-element tuple, cistring.gen_strings4orblist or the tuple unpacking will raise an error.
        - If orbsym is not a one-dimensional numpy array with length equal to the intended number of orbitals, grouping by irrep will fail or produce incorrect results.
        - wfnsym is interpreted modulo 10 for D2h conventions; providing a wfnsym that does not follow PySCF's required encoding may yield empty result arrays but will not itself raise an error in this function.
        - The function depends on the module-level constant TOTIRREPS and helper functions (cistring.gen_strings4orblist, argsort_strs_by_irrep); changes to those will change output structure/length.
    """
    from pyscf.fci.direct_spin1_symm import sym_allowed_indices
    return sym_allowed_indices(nelec, orbsym, wfnsym)


################################################################################
# Source: pyscf.fci.fci_dhf_slow.get_init_guess
# File: pyscf/fci/fci_dhf_slow.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_fci_dhf_slow_get_init_guess(
    norb: int,
    nelec: int,
    nroots: int,
    hdiag: numpy.ndarray
):
    """Initializes a set of CI (configuration interaction) guess vectors composed of single Slater determinants for use in the PySCF FCI solver (module pyscf.fci.fci_dhf_slow). The function constructs a list of one-hot CI vectors (each vector has unit amplitude on a single determinant) chosen from the determinants with the smallest diagonal Hamiltonian elements, and applies a tiny deterministic perturbation to the first vector to break exact degeneracies and improve the stability of iterative eigensolvers (e.g., Davidson). This routine is used as the starting guess for FCI diagonalization in quantum chemistry calculations performed with the PySCF framework.
    
    Args:
        norb (int): Number of orbitals used to enumerate Slater determinant bitstrings. In this FCI context, norb is passed to cistring.num_strings(norb, nelec) to determine the total number of determinant basis states (na). norb must be a non-negative integer; invalid values may lead to exceptions when computing the number of strings.
        nelec (int): Number of electrons used to form the Slater determinants. This integer, together with norb, determines the dimension na of each CI vector (the length of the one-hot vectors). nelec must be consistent with norb (e.g., 0 <= nelec <= norb); inconsistent values can cause cistring.num_strings to raise errors.
        nroots (int): Number of initial root vectors requested. The function returns min(nroots, hdiag.size) guess vectors. nroots is expected to be a positive integer; supplying nroots <= 0 is invalid and can produce undefined behavior or exceptions (numpy.argpartition is used internally with nroots-1).
        hdiag (numpy.ndarray): One-dimensional numpy array containing the diagonal elements of the Hamiltonian in the determinant basis (the diagonal energies for each Slater determinant). Its length (hdiag.size) should match the number of determinants na returned by cistring.num_strings(norb, nelec). The dtype of hdiag determines the dtype of the generated CI vectors (real or complex). If hdiag.ndim != 1 or its length does not match na, an IndexError or incorrect indexing may occur.
    
    Behavior and implementation details:
        The function calls cistring.num_strings(norb, nelec) to compute na, the length of each CI vector (the number of Slater determinants in the basis for the given norb and nelec). It then selects determinant addresses (indices) to seed one-hot CI vectors as follows:
        - If hdiag.size <= nroots, all indices in range(hdiag.size) are used (one vector per available diagonal element).
        - Otherwise, numpy.argpartition(hdiag, nroots-1)[:nroots] is used to pick the indices of the nroots smallest diagonal elements (i.e., determinants with the lowest diagonal energies). Note that numpy.argpartition does not guarantee full ordering among the selected indices; ties or near-degenerate diagonal elements may be chosen in an implementation-defined order.
        For each chosen address, a CI vector x of shape (na,) is created with dtype equal to hdiag.dtype, with x[addr] = 1 and all other elements zero. After creating the list of one-hot vectors, a deterministic small perturbation is applied to the first vector to break exact degeneracies: for complex dtype the function adds 1e-5 + 1e-6j to the first element and subtracts the same from the last element; for real dtype it adds/subtracts 1e-5. These constants are small deterministic numbers chosen to avoid symmetry-induced singularities in iterative diagonalization and are not randomized.
    
    Side effects and defaults:
        The function has no side effects on global state or input arrays. The only mutation performed is on the internally created CI vectors returned to the caller. The dtype of returned vectors matches hdiag.dtype. The number of returned vectors equals min(nroots, hdiag.size).
    
    Failure modes and error conditions:
        - If norb or nelec are invalid for cistring.num_strings, that call may raise an exception.
        - If hdiag is not a one-dimensional numpy.ndarray of length equal to the expected number of determinants na, indexing x[addr] may raise IndexError or produce incorrect vectors.
        - nroots must be a positive integer; nroots <= 0 can lead to invalid use of numpy.argpartition and undefined behavior.
        - Because numpy.argpartition is used to select the smallest diagonal elements, ties among diagonal elements are resolved in an implementation-dependent way; only a tiny deterministic perturbation is applied to the first vector to reduce symmetry-related degeneracy issues, but exact degenerate subspaces may still require more careful handling by the caller.
    
    Returns:
        list[numpy.ndarray]: A list of CI guess vectors. Each element is a numpy.ndarray of shape (na,) where na = cistring.num_strings(norb, nelec) and dtype equals hdiag.dtype. Each vector is a single-Slater-determinant one-hot vector (unit amplitude on the chosen determinant index). The list length is min(nroots, hdiag.size). The first returned vector contains a small deterministic perturbation (1e-5 for real dtype, or 1e-5 + 1e-6j for complex dtype) applied to its first element and the negative of that perturbation applied to its last element to help break exact degeneracies for iterative eigensolvers.
    """
    from pyscf.fci.fci_dhf_slow import get_init_guess
    return get_init_guess(norb, nelec, nroots, hdiag)


################################################################################
# Source: pyscf.fci.fci_slow.absorb_h1e
# File: pyscf/fci/fci_slow.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_fci_slow_absorb_h1e(
    h1e: numpy.ndarray,
    eri: numpy.ndarray,
    norb: int,
    nelec: int,
    fac: float = 1
):
    """pyscf.fci.fci_slow.absorb_h1e modifies a two-electron integral tensor to absorb the contribution of a one-electron Hamiltonian, producing an effective two-electron Hamiltonian used by Full Configuration Interaction (FCI) routines in PySCF. This operation is used in the pyscf.fci.fci_slow code path to combine one- and two-electron terms so downstream FCI code can work with a single 4-index operator while preserving the correct mean-field one-electron contribution.
    
    This function expects a one-electron Hamiltonian matrix and a two-electron integral array compatible with ao2mo.restore(1, eri, norb). It restores the full 4-index two-electron tensor from eri, computes an orbital-space mean-field contribution from the two-electron tensor, forms a one-electron correction f1e = h1e - 0.5 * trace_contraction(h2e), scales that correction by 1/nelec (with a tiny floor to avoid division by zero), and adds the scaled correction to the two-electron tensor on the appropriate index pairs. The returned tensor has the same floating dtype as h1e and shape (norb, norb, norb, norb). The original inputs are not modified because eri is copied before restoration; the function uses ao2mo.restore(1, eri.copy(), norb) internally.
    
    Args:
        h1e (numpy.ndarray): One-electron Hamiltonian matrix in orbital basis. Typically a square matrix of size (norb, norb). This array provides the kinetic and nuclear attraction (and any other one-electron) terms that should be absorbed into the two-electron representation. The function preserves the dtype of h1e for the returned tensor.
        eri (numpy.ndarray): Two-electron integrals provided in the format accepted by ao2mo.restore(1, eri, norb). The function calls eri.copy() and then ao2mo.restore to obtain a full 4-index tensor of shape (norb, norb, norb, norb); therefore eri may be a packed or transformed array as produced by PySCF integral routines. The original eri array passed by the caller is not modified.
        norb (int): Number of spatial orbitals. This determines the dimensionality used when restoring eri into a full 4-index tensor; the restored tensor has shape (norb, norb, norb, norb). Must be consistent with the content/shape of eri for ao2mo.restore to succeed.
        nelec (int): Number of electrons used to scale the one-electron correction. If nelec is an integer type (int or numpy.integer), that value is used. If nelec is not an integer but is iterable (for example a tuple/list [nalpha, nbeta]), the function will replace nelec by sum(nelec) to obtain the total electron count. The function divides by (nelec + 1e-100) to avoid division-by-zero; if nelec is zero this results in a very large scaling and may produce numerically unstable values.
        fac (float): Global multiplicative factor applied to the returned two-electron tensor after the one-electron contribution has been absorbed. Default is 1. This parameter can be used to scale the effective two-electron Hamiltonian (for example, to apply uniform scaling to correlation terms).
    
    Returns:
        numpy.ndarray: A four-index two-electron tensor of shape (norb, norb, norb, norb) and with the same floating dtype as h1e. This tensor is the result of restoring eri into a full 4-index representation, adding the scaled one-electron correction to index pairs (k,k,:,: ) and (:,:,k,k) for each orbital k, and finally multiplying the entire tensor by fac. No in-place modification of the original eri argument occurs because the function works on a copy; callers should expect a newly allocated numpy array.
    
    Raises and failure modes:
        If eri is incompatible with ao2mo.restore(1, eri, norb) (for example, incorrect shape or content), ao2mo.restore will raise an error. If nelec is neither an integer nor an iterable that can be summed, sum(nelec) will raise a TypeError. If nelec == 0, the division by (nelec + 1e-100) will produce extremely large values and may lead to overflow or loss of numerical reliability. If h1e and restored h2e have incompatible dtypes, h2e is cast to h1e.dtype which may involve precision loss.
    """
    from pyscf.fci.fci_slow import absorb_h1e
    return absorb_h1e(h1e, eri, norb, nelec, fac)


################################################################################
# Source: pyscf.fci.rdm.make_dm123
# File: pyscf/fci/rdm.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_rdm_make_dm123(
    fname: str,
    cibra: numpy.ndarray,
    ciket: numpy.ndarray,
    norb: int,
    nelec: tuple
):
    """pyscf.fci.rdm.make_dm123 computes spin-traced one-, two-, and three-particle reduced density matrices (1-RDM, 2-RDM, 3-RDM) from full configuration interaction (FCI) CI coefficient vectors. This routine is part of PySCF's FCI utilities and is used in post-processing FCI wavefunctions for property evaluation, embedding, and analysis that require reduced density matrices.
    
    Args:
        fname (str): Name of the C driver routine in the linked librdm library that performs the low-level RDM assembly. This string is passed to getattr(librdm, fname) and therefore must match an exported symbol in the librdm extension compiled with PySCF. The C driver controls how the RDMs are accumulated from CI vectors; providing an incorrect name will raise an AttributeError when the function attempts to resolve the symbol.
        cibra (numpy.ndarray): CI coefficient vector for the bra state. This must be a contiguous (C-order) numeric numpy array whose flattened size equals the product of the number of alpha and beta occupation strings (na * nb) generated for the specified norb and nelec. The function converts this input via numpy.asarray(..., order='C') so non-contiguous arrays are accepted but will be copied to C order. A mismatch between cibra.size and the expected na*nb triggers an AssertionError.
        ciket (numpy.ndarray): CI coefficient vector for the ket state. Same requirements and behavior as cibra. Typically cibra and ciket are identical for expectation values but they may differ for transition density matrices. The function asserts ciket.size == na*nb and converts the input to a contiguous numpy array.
        norb (int): Number of spatial orbitals in the FCI calculation. This integer determines the dimensionality of the returned RDM arrays: the 1-RDM has shape (norb, norb), the 2-RDM has shape (norb, norb, norb, norb), and the 3-RDM has shape (norb, norb, norb, norb, norb, norb). norb is used to generate link-index arrays for alpha and beta occupation strings and is passed to the underlying C driver.
        nelec (tuple): Electron occupation specified as a tuple describing the number of electrons in each spin sector. This argument is unpacked via the internal helper _unpack_nelec(nelec) to produce neleca (number of alpha electrons) and nelecb (number of beta electrons). The unpacked values determine the sizes na and nb of the alpha and beta string spaces used to verify cibra and ciket sizes and to build link-index tables.
    
    Returns:
        tuple: A 3-tuple containing (rdm1, rdm2, rdm3) where:
            rdm1 (numpy.ndarray): The spin-traced 1-particle RDM returned as a numpy array of shape (norb, norb). The function returns rdm1.T because the internal assembly produces a transposed buffer; callers should treat the returned rdm1 as the standard 1-RDM for further analysis.
            rdm2 (numpy.ndarray): The spin-traced 2-particle RDM returned as a numpy array of shape (norb, norb, norb, norb). Before any reordering, this routine follows the internal convention 2pdm[p,q,r,s] = <p^† q r^† s>. The user can call the companion reorder_dm123 routine to transform the 2-RDM into the normal chemistry ordering 2pdm[p,r,q,s] = <p^† q^† s r>.
            rdm3 (numpy.ndarray): The spin-traced 3-particle RDM returned as a numpy array of shape (norb, norb, norb, norb, norb, norb). In the internal convention used here, 3pdm[p,q,r,s,t,u] = <p^† q r^† s t^† u>. After a subsequent call to reorder_dm123, the 3-RDM is transformed to the normal ordering 3pdm[p,s,q,t,r,u] = <p^† q^† r^† u t s>. The function calls an internal helper _complete_dm3_ to symmetrize/complete entries computed by the C driver before returning.
    
    Behavior, side effects, and failure modes:
        The function converts cibra and ciket to contiguous numpy arrays with numpy.asarray(..., order='C') and builds link-index tables for alpha and beta strings using cistring.gen_linkstr_index(range(norb), neleca) and cistring.gen_linkstr_index(range(norb), nelecb). It asserts that cibra.size and ciket.size equal na*nb (the number of many-electron determinants formed from the alpha and beta strings); a mismatch raises AssertionError. The function then allocates empty numpy arrays for rdm1, rdm2, and rdm3 with shapes determined solely by norb and invokes the C driver via librdm.FCIrdm3_drv(getattr(librdm, fname), ...). Errors in resolving the fname symbol raise AttributeError; errors during the C-level computation typically propagate as exceptions from the extension and may terminate the call. The 3-RDM buffer returned by the driver is post-processed with _complete_dm3_ to restore Hermiticity/symmetry before being returned. No files are read or written by this function; it only uses in-memory arrays and the linked C driver.
    
    Practical significance:
        This function is intended for use in quantum chemistry workflows within the PySCF framework where full CI wavefunctions are available. The produced spin-traced RDMs are required for evaluating one- and multi-particle observables, constructing effective Hamiltonians for embedding/DMFT, computing reduced-density-matrix-based properties, and for interfacing with other modules that expect spin-traced RDMs. The caller is responsible for invoking reorder_dm123 when a standard chemists' ordering of indices is required for downstream code.
    """
    from pyscf.fci.rdm import make_dm123
    return make_dm123(fname, cibra, ciket, norb, nelec)


################################################################################
# Source: pyscf.fci.selected_ci.cre_des_linkstr_tril
# File: pyscf/fci/selected_ci.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_selected_ci_cre_des_linkstr_tril(strs: list, norb: int, nelec: tuple):
    """pyscf.fci.selected_ci.cre_des_linkstr_tril: Build the creation/annihilation link table for generating input strings using a lower-triangular ordering.
    
    Args:
        strs (list): Intermediates used by the selected CI routines to generate operator input strings. In the PySCF selected CI context (see pyscf.fci.selected_ci), this list contains precomputed intermediate objects or patterns that encode occupancy/string information required to build creation/destruction link relationships. The function uses these intermediates as the source data from which the link table is constructed; providing an empty or incorrectly structured list will typically cause downstream validation or index errors when the underlying routine attempts to interpret items in this list.
        norb (int): Number of orbitals. In the domain of full configuration interaction and selected CI within PySCF, norb specifies how many spatial (or spin-adapted) orbitals the link table must account for when mapping creation/destruction operator actions. norb must be an integer compatible with the content of strs; mismatched values (for example, orbital indices in strs that are outside the range implied by norb) can produce IndexError or incorrect link tables.
        nelec (tuple): Electron occupation specification, typically a tuple of electron counts (for example, (nalpha, nbeta)) used by selected CI code to constrain and organize linking of creation/destruction operators. The tuple is passed through to the underlying cre_des_linkstr implementation and is used to determine which link patterns are valid for the given electron configuration. Supplying a tuple of incorrect length or non-integer entries may raise a ValueError or TypeError in the underlying routine.
    
    Returns:
        The return value is the same object returned by calling cre_des_linkstr(strs, norb, nelec, True). Concretely, this is the creation/destruction "link table" data structure used by the selected CI implementation in PySCF to convert intermediate representations (strs) into the input strings that drive generation and application of creation/annihilation operators. The exact Python type and structure are defined by cre_des_linkstr; this wrapper simply forwards the computed link table with the tril flag set to True (lower-triangular mode). No side effects are performed on global state. Failure modes include exceptions propagated from cre_des_linkstr, such as TypeError for invalid argument types, ValueError for malformed nelec or incompatible intermediates, or IndexError if orbital indices implied by strs exceed norb.
    """
    from pyscf.fci.selected_ci import cre_des_linkstr_tril
    return cre_des_linkstr_tril(strs, norb, nelec)


################################################################################
# Source: pyscf.fci.rdm.make_dm1234
# File: pyscf/fci/rdm.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_rdm_make_dm1234(
    fname: str,
    cibra: numpy.ndarray,
    ciket: numpy.ndarray,
    norb: int,
    nelec: tuple
):
    """Spin-traced 1-, 2-, 3- and 4-particle reduced density matrices (RDMs) computed
    from Full Configuration Interaction (FCI) bra and ket CI vectors.
    
    This routine is part of PySCF's FCI machinery for constructing reduced density
    matrices used in quantum chemistry workflows (property evaluation, embedding,
    response, and analysis). It calls a compiled driver in the librdm extension to
    efficiently form the raw spin-traced RDMs from CI vectors and then completes
    higher-order tensors to enforce the expected fermionic index relationships.
    The returned arrays are NumPy ndarrays with shapes determined by the number of
    spatial orbitals (norb). The function documents the ordering conventions used
    internally and the relationship to the "normal" density-matrix order obtained
    after applying the separate reorder_dm123 routine.
    
    Behavior and important notes:
        - The function interprets 2pdm, 3pdm, and 4pdm in the intermediate (spin-
          traced but not fully permuted) ordering used by the underlying driver:
            2pdm[p,q,r,s] = < p^dagger q r^dagger s >
            3pdm[p,q,r,s,t,u] = < p^dagger q r^dagger s t^dagger u >
            4pdm[p,q,r,s,t,u,v,w] = < p^dagger q r^dagger s t^dagger u v^dagger w >
        - After calling reorder_dm123 (a separate utility), these tensors are
          transformed to the "normal" density-matrix ordering commonly used in
          post-processing:
            2pdm[p,r,q,s] = < p^dagger q^dagger s r >
            3pdm[p,s,q,t,r,u] = < p^dagger q^dagger r^dagger u t s >
            4pdm[p,t,q,u,r,v,s,w] = < p^dagger q^dagger r^dagger s^dagger w v u t >
        - Internally, the function generates alpha/beta link-index tables
          (bitstring link tables) from norb and nelec to determine the expected
          sizes of the CI vectors. The CI vectors cibra and ciket are converted to
          contiguous C-order NumPy arrays before being passed to the compiled
          driver.
        - The compiled driver invoked is librdm.FCIrdm4_drv obtained via
          getattr(librdm, fname). Therefore fname must match a callable attribute
          exposed by the librdm extension; otherwise an AttributeError will be
          raised.
        - After the compiled driver fills the raw tensors, helper routines
          _complete_dm3_ and _complete_dm4_ are applied to rdm3 and rdm4,
          respectively, to populate index permutations required by fermionic
          antisymmetry and the chosen spin-trace convention.
        - The function asserts that the flattened sizes of cibra and ciket match
          the product na*nb where na and nb are the numbers of alpha/beta Slater
          determinants implied by (norb, nelec). If these assertions fail, an
          AssertionError is raised.
    
    Args:
        fname (str): Name of the compiled rdm driver symbol in the librdm
            extension to be used. This string is passed to getattr(librdm, fname)
            and must refer to a callable that implements the FCI RDM kernel
            compatible with the data layout used here. The driver is responsible
            for filling the raw spin-traced RDM arrays; an invalid name raises
            AttributeError.
        cibra (numpy.ndarray): The CI "bra" coefficient vector (or array) for the
            many-electron state, provided as a flat array with size equal to the
            number of alpha-string states times the number of beta-string states
            (na*nb). The function converts this input to a contiguous C-ordered
            NumPy array internally. Mismatched size relative to na*nb raises an
            AssertionError. Elements are floating point (as in typical CI
            amplitudes) and represent the expansion coefficients of the bra.
        ciket (numpy.ndarray): The CI "ket" coefficient vector (or array), with
            the same layout and requirements as cibra. This is converted to a
            contiguous C-ordered NumPy array internally. It must have the same
            flattened length na*nb as cibra or an AssertionError is raised. Elements
            are floating point representing the expansion coefficients of the ket.
        norb (int): Number of spatial orbitals (norb) used to define orbital index
            ranges in the RDMs. This integer determines the dimensionality of the
            returned RDM tensors: rdm1 shape (norb, norb), rdm2 shape
            (norb, norb, norb, norb), rdm3 shape (norb,)*6, and rdm4 shape
            (norb,)*8. norb is also used to generate the alpha/beta link-index
            tables; an inconsistent norb will produce incorrect link tables and
            likely cause assertion failures or incorrect results.
        nelec (tuple): A two-element tuple specifying the number of alpha and
            beta electrons (neleca, nelecb). This tuple is unpacked to create the
            bitstring link-index tables that define na and nb (the counts of
            alpha/beta Slater determinants). The values determine the expected
            lengths of cibra and ciket and therefore directly control whether the
            AssertionError checks succeed.
    
    Returns:
        tuple: A 4-tuple of NumPy arrays (rdm1, rdm2, rdm3, rdm4) containing the
        spin-traced reduced density matrices computed from the input CI vectors.
        rdm1 is returned with a final transpose relative to the internal buffer
        (the function returns rdm1.T), so its shape and index ordering are:
            rdm1: numpy.ndarray, shape (norb, norb) corresponding to the
                one-particle density matrix for spatial orbitals.
            rdm2: numpy.ndarray, shape (norb, norb, norb, norb) corresponding to
                the two-particle RDM in the intermediate spin-traced ordering
                described above (see Behavior and notes); use reorder_dm123 to
                convert to the conventional normal ordering.
            rdm3: numpy.ndarray, shape (norb,)*6 corresponding to the three-particle
                RDM after completion by _complete_dm3_; initially produced in the
                intermediate ordering described above and convertible to normal
                ordering with reorder_dm123.
            rdm4: numpy.ndarray, shape (norb,)*8 corresponding to the four-particle
                RDM after completion by _complete_dm4_; produced in the
                intermediate ordering described above.
        All returned arrays are NumPy ndarrays allocated in C-order. On error,
        the function may raise AssertionError (size mismatches), AttributeError
        (invalid fname), TypeError (incorrect input types), or backend-related
        exceptions if the librdm extension cannot be invoked or its driver fails.
    """
    from pyscf.fci.rdm import make_dm1234
    return make_dm1234(fname, cibra, ciket, norb, nelec)


################################################################################
# Source: pyscf.fci.selected_ci.cre_des_linkstr
# File: pyscf/fci/selected_ci.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_selected_ci_cre_des_linkstr(
    strs: numpy.ndarray,
    norb: int,
    nelec: int,
    tril: bool = False
):
    """Create a link-index table that encodes creation/destruction operator links for a set of determinant occupation strings used by PySCF's selected configuration interaction (selected CI) routines. This function wraps the compiled libfci.SCIcre_des_linkstr routine to produce the integer-encoded link table that other parts of the pyscf.fci.selected_ci module use to enumerate single-electron annihilations and single excitations between input strings when assembling Hamiltonian matrix elements or generating connected determinants in full configuration interaction style algorithms.
    
    Args:
        strs (numpy.ndarray): One-dimensional array of integer-encoded occupation strings (dtype will be cast to numpy.int64). Each element represents a Slater-determinant / occupation string in the format expected by the PySCF selected CI implementation and by the underlying C routine libfci.SCIcre_des_linkstr. The array length nstrs = len(strs) is the number of input strings for which link records are generated. Practical significance: these encoded strings are the basis objects (determinants) for which creation/destruction operator links are precomputed to accelerate Hamiltonian assembly in selected CI and FCI workflows.
        norb (int): Total number of orbitals in the model space used by the selected CI calculation. In the selected CI/FCI domain this is the number of single-particle orbitals (the same orbital-count convention used throughout pyscf.fci). This parameter determines the number of virtual orbitals nvir = norb - nelec used to size the link table. Practical significance: an incorrect norb (for example smaller than nelec) will make the orbital-count logic invalid and cause an exception when allocating or filling the link table.
        nelec (int): Number of electrons (occupied orbitals) in each occupation string. This integer is used to compute the number of possible annihilation operations (nelec) and the number of possible single excitations (nelec * nvir) enumerated for each string. Practical significance: this value must match the electron count encoded in strs for the link table to be consistent with downstream selected CI routines.
        tril (bool): Optional flag (default False) forwarded to the compiled libfci routine. It is interpreted by the underlying implementation to select whether only triangular (typically lower- or upper-triangular) link structures are produced when that representation is desired by downstream code, or whether the full set of links is produced. Practical significance: passing True can reduce the amount of stored link information when only half the matrix or half the connections are required by subsequent algorithms; passing False requests the full link set. Default is False.
    
    Returns:
        numpy.ndarray: An integer array (dtype numpy.int32) named link_index with shape (nstrs, nelec + nelec * nvir, 4), where nstrs == len(strs) and nvir == norb - nelec. Each entry link_index[i, j] is a 4-integer record produced in the format expected by libfci and by pyscf.fci.selected_ci routines; it encodes the information needed to apply a creation/destruction operation (indices and sign/phase/auxiliary codes) when building Hamiltonian matrix elements or exploring connected determinants. Practical significance: this compact table is used directly by selected CI/FCI routines to accelerate operator application and matrix element construction without repeatedly decoding occupation strings.
    
    Behavior and side effects:
        The function casts strs to numpy.int64 and allocates the link_index array with dtype numpy.int32 and the exact shape produced in the source code. It then calls the compiled function libfci.SCIcre_des_linkstr to populate link_index in-place and returns that array. There are no other global side effects in Python, but the function depends on the presence and correct behavior of the libfci extension; missing or miscompiled libfci will cause an ImportError or runtime exception from the ctypes/C layer.
    
    Failure modes and errors:
        numpy and ctypes will raise exceptions for invalid inputs (for example, if strs cannot be cast to int64, or if norb and nelec produce an invalid negative nvir). If norb < nelec the computed nvir will be negative and array allocation or the underlying C routine will raise an exception. Errors originating from the compiled libfci.SCIcre_des_linkstr (for example due to unexpected input encoding in strs) will propagate as runtime errors. Users should ensure strs, norb, and nelec are consistent with each other and with the encoding conventions used by PySCF selected CI.
    """
    from pyscf.fci.selected_ci import cre_des_linkstr
    return cre_des_linkstr(strs, norb, nelec, tril)


################################################################################
# Source: pyscf.fci.selected_ci.des_des_linkstr_tril
# File: pyscf/fci/selected_ci.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_selected_ci_des_des_linkstr_tril(strs: list, norb: int, nelec: tuple):
    """pyscf.fci.selected_ci.des_des_linkstr_tril returns a link-table representation for generating input occupation strings used by the selected-configuration-interaction (selected_ci) routines in the Full Configuration Interaction (FCI) part of PySCF, with the lower-triangular ("tril") convention enabled.
    
    This function is a thin wrapper that calls des_des_linkstr(strs, norb, nelec, True). In the context of PySCF (a Python-based framework for quantum chemistry), this link table encodes how creation/destruction operators connect intermediate determinants (or occupation strings) to the target set of input strings used by selected-CI algorithms. Setting the internal tril flag to True chooses the lower-triangular ordering/convention for constructing the links, which affects how pairs and index orderings are enumerated for generation of excitation/de-excitation connections in selected-CI tensors and matrix elements.
    
    Args:
        strs (list): A list of intermediate occupation strings or representations used by the selected_ci routines. Each element is an entry that identifies a many-electron occupation configuration (an intermediate) from which links to target input strings will be generated. The list is consumed by the link-table generator to iterate over intermediates; providing an incorrectly structured list will cause the underlying generator (des_des_linkstr) to raise an error.
        norb (int): The number of spatial orbitals (norb) in the FCI problem. This integer specifies the orbital space size used when constructing links between occupations. It determines the range of orbital indices considered when forming excitation/de-excitation pairs and therefore directly controls the shape and contents of the returned link table.
        nelec (tuple): A tuple specifying the electron occupation numbers (nelec). In PySCF/FCI context this tuple typically contains the numbers of alpha and beta electrons (for example (nalpha, nbeta)) that define the particle number sector for which links are generated. The nelec tuple is used by the generator to respect particle-number constraints when mapping intermediates to target strings.
    
    Returns:
        list: A link table (list) suitable for use by selected_ci input generation and subsequent FCI/selected-CI processing. The returned list encodes, for each provided intermediate in strs and under the given norb and nelec, the connections (indices and signs/phases as produced by the underlying algorithm) to the input occupation strings according to the lower-triangular convention. This return value is intended to be consumed by other selected_ci routines that build Hamiltonian matrix elements or perform excitation/de-excitation enumerations.
    
    Behavior and side effects:
        This function has no side effects beyond calling des_des_linkstr with the tril flag set to True and returning its result. It does not modify its input arguments. The concrete layout and content of the returned link table are determined by des_des_linkstr; this wrapper only fixes the triangular convention to the "tril" variant.
    
    Failure modes:
        Errors and exceptions raised by des_des_linkstr propagate to the caller. Typical failures include type errors if strs is not a list, norb is not an integer, or nelec is not a tuple, or value errors if the inputs are inconsistent (for example, electron counts not compatible with norb or malformed intermediate entries). Users should validate inputs before calling this function if they need custom error handling.
    """
    from pyscf.fci.selected_ci import des_des_linkstr_tril
    return des_des_linkstr_tril(strs, norb, nelec)


################################################################################
# Source: pyscf.fci.selected_ci.gen_des_linkstr
# File: pyscf/fci/selected_ci.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_selected_ci_gen_des_linkstr(strs: numpy.ndarray, norb: int, nelec: int):
    """pyscf.fci.selected_ci.gen_des_linkstr generates a link table (link_index) that maps input determinant strings to the intermediate occupation patterns used by PySCF's selected configuration interaction (selected-CI) Full Configuration Interaction (FCI) routines. This link table is constructed by calling the underlying C helper functions in libfci (SCIdes_uniq_strs and SCIdes_linkstr) via ctypes and is intended for use by other selected-CI routines in PySCF to assemble Hamiltonian and excitation connections efficiently.
    
    Args:
        strs (numpy.ndarray): 1-D array of integer-encoded Slater determinant strings provided as the "input strs" for selected-CI. In the source code this array is converted to dtype numpy.int64 before processing. Each element represents a determinant encoding that the selected-CI routines use to enumerate excitations and build matrix elements. The function reads len(strs) to determine the number of input strings (nstrs) and will pass the array pointer to the libfci C routines.
        norb (int): Total number of spatial orbitals in the FCI problem. This integer is used to determine the number of virtual orbitals (nvir = norb - nelec) and, after an internal increment, the second dimension size of the returned link table (final nvir = norb - nelec + 1). norb must match the orbital count assumed by the provided strs and by downstream selected-CI logic.
        nelec (int): Number of electrons in the system (number of occupied orbitals per determinant). This controls early-exit behavior and the interfaces with libfci: if nelec < 1 the function returns None because no occupied-electron excitations are meaningful. Otherwise nelec is passed to the C routines to enumerate intermediates that connect occupied and virtual spaces for the given set of input strings.
    
    Returns:
        numpy.ndarray or None: If nelec < 1, returns None: no link table is produced because there are no electrons to generate occupation-change intermediates. Otherwise returns a numpy.ndarray link_index with dtype numpy.int32 and shape (ninter, nvir, 4), where:
        - ninter is the number of unique intermediate occupation patterns discovered by libfci.SCIdes_uniq_strs for the provided strs (the function deduplicates the raw intermediates returned by the C routine and sets ninter = len(inter)).
        - nvir is set internally to norb - nelec + 1 (the initial nvir = norb - nelec is incremented by 1 in code) and corresponds to the secondary index dimension expected by libfci.SCIdes_linkstr.
        - The last dimension of size 4 stores the integer-encoded connection information produced by the C routine; each innermost length-4 vector encodes the indices/flags that selected-CI FCI code uses to map an intermediate to input strings and to assemble operator matrix elements.
        The returned array is populated by libfci.SCIdes_linkstr via ctypes and is ready to be consumed by other pyscf.fci.selected_ci functions that construct Hamiltonian matrix elements or perform excitation bookkeeping.
    
    Behavior, side effects, and failure modes:
        - The function converts strs to a numpy.int64 array and calls two C functions from the global libfci library via ctypes: SCIdes_uniq_strs to obtain a raw list of intermediates and SCIdes_linkstr to build the final link table. These calls are side-effect free on Python-level data beyond populating the returned numpy array, but they depend on the libfci symbols being available and correctly exposed to ctypes.
        - If the libfci shared library or the expected C functions are missing, incorrectly linked, or behave unexpectedly, the ctypes calls may raise exceptions (e.g., AttributeError, OSError, or other ctypes-related errors). Such exceptions are propagated to the caller.
        - The function assumes that strs correctly encodes determinants compatible with norb and nelec; mismatches (for example, determinant encodings that imply different orbital counts) can lead to incorrect intermediate enumeration or errors from the C routines.
        - The function does not modify global state other than calling into libfci; it returns a newly allocated numpy.ndarray (or None) and does not mutate the input strs array in user-visible ways (strs is converted internally to numpy.int64).
        - The returned numpy.ndarray uses C-style (row-major) memory layout as produced by numpy and the C routines; consumers should treat its dtype as numpy.int32.
    """
    from pyscf.fci.selected_ci import gen_des_linkstr
    return gen_des_linkstr(strs, norb, nelec)


################################################################################
# Source: pyscf.fci.selected_ci.des_des_linkstr
# File: pyscf/fci/selected_ci.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_selected_ci_des_des_linkstr(
    strs: numpy.ndarray,
    norb: int,
    nelec: int,
    tril: bool = False
):
    """pyscf.fci.selected_ci.des_des_linkstr: Build the link table that maps double-excitation connections between a set of determinant-like "strings" (intermediates) used by the selected configuration interaction (selected CI) routines in PySCF's FCI module. This function prepares an index array that encodes how input determinant strings (strs) couple via two-electron excitations to intermediate strings used to assemble Hamiltonian or amplitude contributions in selected CI workflows. It is implemented by calling low-level libfci C routines (SCIdes_uniq_strs and SCIdes_des_linkstr) through ctypes and is intended for use inside PySCF FCI/selected-CI code paths that require precomputed excitation link structures for efficiency.
    
    Args:
        strs (numpy.ndarray): 1-D array of integer-encoded determinant "strings" (intermediates) provided by the caller. The function immediately converts this input to numpy.int64 (using numpy.asarray(..., dtype=numpy.int64)), so callers may pass any array-like of integers; the practical role of strs is to enumerate the starting determinants for which double-excitation links are required. The length of strs defines nstrs, the number of input strings. Typical use: pass the list of selected determinant encodings obtained from selected CI screening routines so the link table can be constructed for those determinants.
        norb (int): Total number of spatial orbitals in the system. This integer is used to compute the number of virtual orbitals (nvir = norb - nelec, then incremented by 2 inside the function to match the C-routine layout) and to pass orbital count information to the libfci routines. It determines the space of possible excitations and must match the orbital basis used to produce strs.
        nelec (int): Total number of electrons in the system (number of occupied orbitals in each determinant encoding). This integer controls the logic of the routine: if nelec < 2 the function immediately returns None because no double excitations are possible. The function also calls libfci.SCIdes_uniq_strs twice with nelec and nelec-1 to compute intermediate unique strings required for building the link table.
        tril (bool = False): Boolean flag forwarded to the libfci.SCIdes_des_linkstr C routine that controls whether the produced link table should be triangular (lower-triangular indexing) or full. Default False produces the full link table behavior expected by downstream selected-CI code; setting True requests the triangular form when the C routine supports it. This flag affects how many entries are populated in the returned index array.
    
    Returns:
        numpy.ndarray or None: When nelec >= 2, returns a numpy.ndarray of dtype numpy.int32 with shape (ninter, nvir*nvir, 4), where ninter is the number of unique intermediate strings determined internally and nvir is computed as (norb - nelec) then incremented by 2 in the function before allocating the result. The returned array is the link_index structure: each entry encodes up to four integers per link that describe how a double excitation connects an input string in strs to an intermediate string (this encoding is consumed by downstream selected-CI/Four-index routines in PySCF). If nelec < 2, returns None because no double-excitation link table is meaningful for fewer than two electrons.
    
    Behavior, side effects, defaults, and failure modes:
        This function performs in-place conversions and calls C-level routines via ctypes (libfci.SCIdes_uniq_strs and libfci.SCIdes_des_linkstr). It converts the input strs to numpy.int64 and allocates temporary integer arrays to collect unique intermediate strings; it uses set() and sorting on the C-produced arrays to ensure uniqueness and consistent ordering. The function allocates the final link_index array as numpy.zeros((ninter, nvir*nvir, 4), dtype=numpy.int32) and populates it by calling libfci.SCIdes_des_linkstr. Side effects are limited to memory allocations and the external C calls; the function does not mutate the caller's strs array (it uses a converted copy).
    
        The function will return None immediately if nelec < 2. If the required libfci C symbols are missing or incompatible, the ctypes calls will raise AttributeError or propagate a ctypes error; invalid shapes, negative norb/nelec, or inconsistent values between strs and the provided norb/nelec may lead to incorrect results or runtime failures inside the C routines. The function assumes that strs elements are valid encodings for determinants consistent with the orbital count norb and electron count nelec; providing incompatible encodings may produce undefined behavior from the underlying C library.
    
        Default behavior: tril is False (full link table). Use tril=True only when the downstream consumer expects triangular link indexing and the platform C library supports that mode.
    
        Practical significance: The returned link_index is a compact precomputed index structure that accelerates construction of Hamiltonian matrix elements and excitation-driven updates in the selected-CI implementation of PySCF's FCI module. Users working on selected-CI workflows should supply the same norb and nelec used to generate strs and should handle the returned numpy.int32 array according to PySCF's selected-CI internals.
    """
    from pyscf.fci.selected_ci import des_des_linkstr
    return des_des_linkstr(strs, norb, nelec, tril)


################################################################################
# Source: pyscf.fci.selected_ci.gen_cre_linkstr
# File: pyscf/fci/selected_ci.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_selected_ci_gen_cre_linkstr(strs: numpy.ndarray, norb: int, nelec: int):
    """Generate a creation-operator link table for selected configuration interaction (selected CI) routines.
    
    This function computes the link table that maps creation-operator actions to the input configuration "strings" (strs) used by the selected CI implementation in pyscf.fci.selected_ci. It prepares intermediate orbital indices from the provided input strings by calling compiled libfci C routines (SCIcre_uniq_strs and SCIcre_linkstr), deduplicating and sorting the intermediate list, and then filling a link-index array that subsequent selected CI code uses to apply creation operators efficiently. The function casts the input strs to numpy.int64, allocates and returns a numpy.int32 array with shape (ninter, nelec+1, 4) that contains the link information produced by libfci.SCIcre_linkstr. If no virtual orbitals exist (nelec == norb), there are no creation operations to record and the function returns None.
    
    Args:
        strs (numpy.ndarray): One-dimensional array of integer-encoded configuration strings used by the selected CI code. The array is interpreted and cast to dtype numpy.int64 inside the function and passed to the compiled libfci routines. In the context of PySCF selected CI, these strings encode Slater determinants or configuration bitstrings that identify occupied orbitals for each configuration; they must be consistent with the expectations of the libfci backend.
        norb (int): Number of spatial orbitals in the many-body problem. This integer determines the total orbital space size and, together with nelec, the number of virtual orbitals (norb - nelec). It must be greater than nelec for the function to produce a link table; if norb == nelec the function returns None because there are no creation (virtual) orbitals to link. If norb < nelec, numpy or the underlying C routine may raise an error (see Failure modes).
        nelec (int): Number of electrons (occupied orbitals) in each configuration string. This integer defines the occupied-space dimension used to build link entries and determines the second dimension size of the returned array (nelec + 1). It must be consistent with the contents of strs and with norb.
    
    Returns:
        numpy.ndarray or None: If norb != nelec, returns a numpy.ndarray of dtype numpy.int32 with shape (ninter, nelec+1, 4). Here ninter is the number of unique intermediate orbital indices discovered by the libfci SCIcre_uniq_strs routine after deduplication and sorting; the returned array is the link-index table produced by libfci.SCIcre_linkstr and is intended for use by other selected CI routines in PySCF to apply creation operators efficiently. If norb == nelec (no virtual orbitals), returns None to indicate that no link table is required.
    
    Behavior and side effects:
        - The function casts the input strs to numpy.int64 (copying if necessary) before calling into the compiled libfci functions.
        - It calls libfci.SCIcre_uniq_strs to obtain intermediate orbital indices, then deduplicates and sorts those indices in Python.
        - It allocates a zero-initialized numpy.ndarray link_index with dtype numpy.int32 and shape (ninter, nelec+1, 4), and then fills it in-place by calling libfci.SCIcre_linkstr.
        - The returned array is owned by NumPy and contains the link information required by other PySCF selected CI routines; no global state in Python is modified.
    
    Failure modes and notes:
        - If norb == nelec the function returns None (normal, non-exceptional behavior).
        - If norb < nelec, or if the inputs are inconsistent with libfci expectations (for example, strs encoding invalid orbital indices), numpy.empty or the underlying C routines may raise an error (ValueError, RuntimeError, or a crash in the C library). Callers must ensure nelec <= norb and that strs encodes valid configurations for the given norb and nelec.
        - The detailed layout and semantics of the innermost dimension of the returned array (size 4) are defined by the libfci SCIcre_linkstr convention used elsewhere in pyscf.fci.selected_ci; callers should use the returned array only with those PySCF routines that expect this specific link-index format.
    """
    from pyscf.fci.selected_ci import gen_cre_linkstr
    return gen_cre_linkstr(strs, norb, nelec)


################################################################################
# Source: pyscf.fci.fci_slow.contract_2e
# File: pyscf/fci/fci_slow.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_fci_slow_contract_2e(
    eri: numpy.ndarray,
    fcivec: numpy.ndarray,
    norb: int,
    nelec: int,
    link_index: tuple = None
):
    """pyscf.fci.fci_slow.contract_2e computes the action of the two-electron excitation operator E_{pq}E_{rs} on a full configuration interaction (FCI) CI vector. This routine is part of the slow, reference FCI implementation in PySCF and is used when assembling or applying the two-electron part of the electronic Hamiltonian to a CI vector for small systems or for correctness/debugging.
    
    This function accepts molecular-orbital two-electron integrals and a CI vector in PySCF's string-based FCI representation, contracts the integrals with single excitations generated from the string link tables for alpha and beta spin sectors, and returns a new CI vector equal to E_{pq}E_{rs}|CI>. The implementation reshapes the CI vector into a matrix of alpha- and beta-string amplitudes, uses precomputed link indices to map creation/annihilation operations between Slater determinants, performs an einsum over the four-index integral tensor, and accumulates contributions back into a flattened CI vector.
    
    Args:
        eri (numpy.ndarray): Four-index two-electron integrals in the molecular orbital basis. The array must be compatible with reshaping to shape (norb, norb, norb, norb) (for example, either already that shape or a 1D array of length norb**4). These integrals supply the matrix elements <pq|rs> (chemist's notation) used in the contraction. The dtype of eri is used during floating-point contraction and should be consistent with fcivec for best numerical behavior.
        fcivec (numpy.ndarray): CI vector representing configuration amplitudes in the string-based FCI representation. This 1D array is interpreted by the function as a matrix of shape (na, nb) after reshaping, where na = cistring.num_strings(norb, neleca) and nb = cistring.num_strings(norb, nelecb). The function preserves the dtype of fcivec in the returned vector. fcivec contains amplitudes for all combinations of alpha and beta occupation strings and must have length na*nb consistent with the provided norb and nelec.
        norb (int): Number of spatial molecular orbitals. This integer determines the shape used to interpret eri (reshaped to (norb, norb, norb, norb)), the range of orbital indices used to generate link indices if link_index is None, and the size of bit-strings considered by cistring.num_strings. norb must be consistent with the shapes/lengths of eri and fcivec.
        nelec (int or tuple): Electron count that determines the number of alpha and beta electrons. If an integer is given, it is treated as the total number of electrons and split into beta electrons nelecb = nelec//2 and alpha electrons neleca = nelec - nelecb (integer division gives a balanced split with beta taking the floor). If a tuple (neleca, nelecb) is provided, these values are used directly to determine the number of alpha and beta electrons. The values of neleca and nelecb determine na and nb and therefore the expected length of fcivec and the link-index generation.
        link_index (tuple or None): Optional precomputed pair of link-index tables for the alpha and beta spin sectors, in the form (link_indexa, link_indexb). Each link_index* is the structure produced by cistring.gen_linkstr_index(range(norb), nelec_spin) and is iterated by the algorithm as a sequence of entries tab where each entry is an iterable of tuples (a, i, str1, sign). In those tuples, a is the creation orbital index, i is the annihilation orbital index, str1 is the index of the target occupation string after the single excitation, and sign is the fermionic phase (+1 or -1) resulting from the excitation. If link_index is None, the function generates link_indexa and link_indexb internally using cistring.gen_linkstr_index(range(norb), neleca) and cistring.gen_linkstr_index(range(norb), nelecb). Providing precomputed link_index values can avoid redundant generation and improve performance when this contraction is called repeatedly.
    
    Returns:
        numpy.ndarray: A new CI vector with the same shape and dtype as fcivec (i.e., flattened length na*nb) that equals the result of applying the two-electron excitation operator E_{pq}E_{rs} to the input CI vector. The returned array is not a view of the input fcivec but a freshly allocated array; the input fcivec is not modified in-place.
    
    Behavior and side effects:
        The function reshapes fcivec internally to (na, nb) and reshapes eri to (norb, norb, norb, norb) for the contraction. It constructs an intermediate tensor t1 with shape (norb, norb, na, nb) that accumulates single-excitation contributions from alpha and beta strings, then performs an einsum contraction with eri to produce the two-electron contracted contributions, and finally scatters these contributions back to the CI amplitude array. No global state is modified; side effects are limited to local allocations. The function lives in the fci_slow module and is not optimized for large systems; expect O(norb^4 * na * nb) memory/compute scaling in the implemented loops and einsum, so use with care for large norb or electron counts.
    
    Failure modes and errors:
        If eri cannot be reshaped to (norb, norb, norb, norb) or if fcivec length is incompatible with the computed na*nb, NumPy will raise a ValueError during reshape or indexing. If nelec is neither an integer nor a two-element tuple, the function will raise a TypeError when attempting to unpack or compute neleca/nelecb. Incorrect or malformed link_index (wrong structure or inconsistent with norb and nelec) can produce IndexError or incorrect results. The function does not perform exhaustive validation of all inputs; callers are responsible for ensuring consistency between eri, fcivec, norb, nelec, and link_index.
    """
    from pyscf.fci.fci_slow import contract_2e
    return contract_2e(eri, fcivec, norb, nelec, link_index)


################################################################################
# Source: pyscf.fci.selected_ci.spin_square
# File: pyscf/fci/selected_ci.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_selected_ci_spin_square(civec_strs: numpy.ndarray, norb: int, nelec: tuple):
    """Compute the expectation value of the total spin-squared operator S^2 and the corresponding spin multiplicity for a restricted Hartree–Fock FCI (RHF-FCI) configuration-interaction (CI) wavefunction obtained from a spin-degenerate Hamiltonian in the pyscf.fci.selected_ci module. This function is intended for use in post-Hartree–Fock FCI analyses within PySCF to determine the total spin quantum number S and the multiplicity (2S+1) from an RHF-FCI CI coefficient vector produced by selected CI routines. The implementation calls the internal helper contract_ss to form S^2 acting on the CI vector and then computes the expectation value and derived quantities.
    
    Args:
        civec_strs (numpy.ndarray): CI coefficient vector arranged in the spin-string basis used by pyscf.fci.selected_ci. This array must be compatible in shape with the output of contract_ss(civec_strs, norb, nelec) because the function reshapes civec_strs to match the intermediate ci1 returned by contract_ss before forming the inner product. In practical PySCF usage, civec_strs is the FCI wavefunction expressed as a dense or appropriately-shaped numpy array constructed for an RHF reference and a spin-degenerated Hamiltonian; incorrect shapes or ordering (for example, a CI vector from a UHF calculation or different orbital ordering) will lead to shape-mismatch errors or physically meaningless results.
        norb (int): Number of spatial molecular orbitals used to build the FCI basis. This parameter informs contract_ss how the CI vector's bitstrings or determinants map to orbital occupations. In domain terms, norb is the count of spatial orbitals in the molecular problem for which the RHF-FCI wavefunction civec_strs was produced; passing an incorrect norb inconsistent with civec_strs will produce wrong expectation values or raise array-shape/logic errors.
        nelec (tuple): Electron count as a tuple (nalpha, nbeta) giving the number of alpha and beta electrons, respectively. This tuple defines the occupancy constraints used by contract_ss and is required to interpret the CI vector in terms of spin occupations. It must match the electron configuration from which civec_strs was generated; mismatched nelec will yield incorrect S^2 evaluation or runtime errors.
    
    Behavior and side effects:
        The function computes ci1 = contract_ss(civec_strs, norb, nelec), where contract_ss builds the action of the S^2 operator on the provided CI vector in the same basis and ordering used by selected_ci routines. It then computes the expectation value ss = <civec|S^2|civec> as the inner product between the original CI vector (reshaped to match ci1) and ci1 using numpy.einsum. From the scalar expectation ss (which, for a pure spin eigenstate, equals S(S+1)), the code derives the spin quantum number S via S = sqrt(ss + 0.25) - 0.5 and the multiplicity multiplicity = 2*S + 1. There are no external side effects: the function does not modify input arrays in-place and does not write files or change global state.
    
    Defaults and numerical considerations:
        No optional parameters or defaults are used; all three arguments are required. In exact arithmetic for a pure-spin RHF-FCI eigenstate obtained from a spin-degenerated Hamiltonian, ss should equal S(S+1) >= 0 and produce an integer or half-integer S. Due to numerical round-off or approximate CI vectors, S computed from ss may be non-integer; users should apply tolerance-based rounding if an integer or half-integer spin is expected. If ss < -0.25 (which is unphysical for a properly formed S^2 expectation), the square-root operation will produce a complex result or raise a runtime warning/error; such a result indicates invalid inputs or severe numerical issues.
    
    Failure modes:
        Passing a CI vector incompatible with the expected basis ordering, an incorrect norb, or an inconsistent nelec tuple will typically raise numpy shape or broadcasting errors when reshaping or contracting, or produce physically incorrect ss and multiplicity values. Using CI vectors produced for UHF references, spin-broken states, or non-spin-degenerate Hamiltonians may yield meaningless spin expectations; this function is intended for RHF-FCI CI wavefunctions derived from spin-degenerate Hamiltonians as produced by selected_ci routines. contract_ss may itself raise exceptions if inputs are malformed; these propagate to the caller.
    
    Returns:
        ss (float): The computed expectation value of the total spin-squared operator, <S^2> = S(S+1), evaluated for the input RHF-FCI CI wavefunction. This scalar is the primary physical quantity indicating the total spin content of the provided CI state in PySCF FCI analyses.
        multip (float): The computed spin multiplicity 2S+1 derived from ss via S = sqrt(ss + 0.25) - 0.5 and multiplicity = 2*S + 1. In practice, multiplicity identifies whether the state is singlet (1), doublet (2), triplet (3), etc.; due to numerical error it may be non-integer, and users should round within an appropriate tolerance when an exact multiplicity is expected.
    """
    from pyscf.fci.selected_ci import spin_square
    return spin_square(civec_strs, norb, nelec)


################################################################################
# Source: pyscf.fci.selected_ci.make_rdm2
# File: pyscf/fci/selected_ci.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_selected_ci_make_rdm2(
    civec_strs: list,
    norb: int,
    nelec: tuple,
    link_index: list = None,
    **kwargs
):
    """Spin-traced two-particle density matrix for selected-configuration-interaction (selected CI) wavefunctions in PySCF.
    
    This function constructs the spin-traced two-particle reduced density matrix (2pdm) used in FCI/selected-CI post-processing and property evaluation. The returned 2pdm implements the spin-summed definition
    2pdm[p,q,r,s] = <p_alpha^† r_alpha^† s_alpha q_alpha> +
                    <p_beta^†  r_alpha^† s_alpha q_beta> +
                    <p_alpha^† r_beta^†  s_beta  q_alpha> +
                    <p_beta^†  r_beta^†  s_beta  q_beta>,
    by calling the lower-level helper make_rdm2s to obtain spin-resolved blocks (dm2aa, dm2ab, dm2bb) and then summing them:
    dm2aa += dm2bb
    dm2aa += dm2ab
    dm2aa += dm2ab.transpose(2,3,0,1)
    The result is the spin-traced 4-index 2pdm in the molecular orbital basis, suitable for computing two-body expectation values (for example, electron repulsion energy contributions) in the selected CI context within the PySCF framework.
    
    Args:
        civec_strs (list): List of CI state vectors in the selected-CI representation expected by make_rdm2s. Each element represents a configuration-interaction expansion for one state (for example, ground or excited states) and contains the amplitudes and index information used to build the spin-resolved 2pdm blocks. This argument is required and must be consistent with norb, nelec, and link_index as used by make_rdm2s.
        norb (int): Number of spatial orbitals (molecular orbitals) in which the CI expansion is defined. This integer determines the orbital dimension of each index of the returned 2pdm (each index runs over 0..norb-1) and controls internal array allocation and indexing in the helper make_rdm2s.
        nelec (tuple): Electron count tuple giving the number of alpha and beta electrons, typically (nalpha, nbeta). This determines spin-sector dimensions used by make_rdm2s and must match the physical electron occupation of the CI vectors in civec_strs.
        link_index (list): Link index table (or None) that encodes the mapping between CI determinants and excitation/linking information used by make_rdm2s to assemble reduced density matrices efficiently. If None (the default), make_rdm2s must be able to infer or regenerate the necessary linking information from civec_strs; providing a precomputed link_index can significantly speed up repeated calls. The expected structure is the same link_index produced by PySCF routines that prepare selected-CI or FCI link tables.
        kwargs (dict): Additional keyword arguments forwarded directly to make_rdm2s. Typical forwarded options control internal behavior of the lower-level routine (for example, numerical dtype choices, workspace controls, or state selection); consult make_rdm2s for the exact supported keywords. Unknown or unsupported keywords will be handled (or rejected) by make_rdm2s and may raise TypeError or ValueError.
    
    Returns:
        numpy.ndarray: A 4-dimensional array representing the spin-traced two-particle reduced density matrix with orbital indices ordered as (p,q,r,s). Each axis has length norb. The array contains the summed contributions from all spin combinations as given in the mathematical definition above. The array dtype and memory layout are inherited from the arrays produced by make_rdm2s; it may be float or complex depending on the input CI amplitudes. On failure (for example, mismatched dimensions between civec_strs, norb, and nelec, invalid link_index structure, or invalid kwargs), the function will propagate exceptions raised by make_rdm2s (such as ValueError, IndexError, or TypeError). Be aware that memory and CPU cost scale as O(norb^4) for storage and assembly; very large norb may lead to MemoryError or long runtimes.
    """
    from pyscf.fci.selected_ci import make_rdm2
    return make_rdm2(civec_strs, norb, nelec, link_index, **kwargs)


################################################################################
# Source: pyscf.fci.selected_ci.make_rdm1
# File: pyscf/fci/selected_ci.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_selected_ci_make_rdm1(
    civec_strs: list,
    norb: int,
    nelec: tuple,
    link_index: list = None
):
    """Spin-traced 1-particle density matrix for selected-CI wavefunctions.
    
    Computes the spin-traced one-particle reduced density matrix (RDM1) defined as
    dm1[p,q] = <q_alpha^\dagger p_alpha> + <q_beta^\dagger p_beta>. The
    convention follows McWeeny (see Eq. (5.4.20) in McWeeney's book) used in the
    selected configuration interaction (selected CI) implementation within PySCF.
    The returned matrix is the elementwise sum of the alpha and beta one-particle
    density matrices produced by make_rdm1s; internally this function calls
    make_rdm1s(civec_strs, norb, nelec, link_index) and returns rdm1a + rdm1b.
    In quantum-chemical practice this spin-traced RDM1 is used to evaluate
    expectation values of one-electron operators by simple contraction, e.g.
    E_one_electron = einsum('pq,qp', h1, rdm1). The diagonal elements give
    orbital occupations and the trace of the returned matrix equals the total
    number of electrons (nelec[0] + nelec[1]) within numerical tolerance.
    
    Args:
        civec_strs (list): List representing the CI wavefunction(s) in the format
            accepted by the selected CI routines and by make_rdm1s. Each element
            is a CI-vector container or structure used by the selected-CI code to
            represent determinants/configurations and their amplitudes. This
            argument carries the many-body state information needed to build the
            one-particle density matrices for alpha and beta spins and must be
            consistent with norb and nelec.
        norb (int): Number of spatial orbitals in the active space. This integer
            sets the dimension of each axis of the returned 2D density matrix:
            the returned RDM1 has shape (norb, norb). norb must match the orbital
            indexing assumed by civec_strs and any one-electron integrals used
            with the returned RDM1.
        nelec (tuple): Electron count given as a tuple (nalpha, nbeta). This tuple
            specifies the number of alpha and beta electrons in the CI state(s)
            represented by civec_strs. The sum nalpha + nbeta is the expected
            trace of the returned spin-traced RDM1 and is used by the underlying
            routines to select the appropriate occupation space and to validate
            consistency of civec_strs.
        link_index (list): Optional precomputed linking structure (list) used by
            selected-CI routines to accelerate creation of reduced density matrices.
            When provided, this list is forwarded to make_rdm1s to reuse computed
            index/link information and avoid recomputation. If None (the default),
            the linking information is built inside the called routines; providing
            a compatible precomputed link_index can reduce runtime for repeated
            RDM constructions. The exact expected format of link_index is the same
            as produced by the linking utilities in the selected CI module and must
            be compatible with civec_strs.
    
    Returns:
        2D array: A two-dimensional matrix of shape (norb, norb) containing the
        spin-traced one-particle reduced density matrix (rdm1a + rdm1b). Each
        element is the sum of the corresponding alpha and beta 1-particle density
        elements and is suitable for contraction with one-electron integrals to
        obtain expectation values. The matrix is (within numerical precision)
        Hermitian and its trace equals the total electron count (nalpha + nbeta).
    
    Behavior, side effects, and failure modes:
        This function is a pure computation wrapper with no external side effects;
        it constructs the alpha and beta RDM1 blocks by calling make_rdm1s and
        returns their sum. If input shapes or contents are inconsistent (for
        example norb incompatible with the orbital indexing in civec_strs, or
        nelec not matching the CI vectors), the underlying routines (make_rdm1s
        and related selected-CI functions) will raise exceptions such as ValueError
        or IndexError. Providing a link_index that is incompatible with civec_strs
        may also cause errors. Numerical precision issues (e.g. small imaginary
        parts when working with complex arithmetic) can occur and should be handled
        by the caller if strict real-symmetry is required.
    """
    from pyscf.fci.selected_ci import make_rdm1
    return make_rdm1(civec_strs, norb, nelec, link_index)


################################################################################
# Source: pyscf.fci.selected_ci.trans_rdm1
# File: pyscf/fci/selected_ci.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_selected_ci_trans_rdm1(
    cibra_strs: list,
    ciket_strs: list,
    norb: int,
    nelec: tuple,
    link_index: list = None
):
    """pyscf.fci.selected_ci.trans_rdm1 computes the spin-traced transition one-particle density matrix for a transition between two selected-CI states.
    
    This function is part of the selected configuration interaction (selected_ci) FCI utilities in PySCF and is used to obtain the spin-summed transition 1-particle density matrix needed for computing transition properties (for example transition dipoles or spin-summed expectation values) between two CI states represented by lists of configuration strings. Internally it calls trans_rdm1s to obtain separate alpha and beta 1-particle transition density matrices and returns their elementwise sum. The returned matrix satisfies
    1pdm[p,q] = < q_alpha^dagger p_alpha > + < q_beta^dagger p_beta >,
    i.e. the sum of alpha and beta transition one-particle density matrix elements.
    
    Args:
        cibra_strs (list): List of configuration strings (or string-like CI descriptors) that represent the bra CI state in the selected-CI representation. These must use the same internal string format and ordering as produced by the selected_ci routines in this module; the contents and ordering determine which orbitals and occupations the transition density refers to. Practical significance: this input encodes the occupancies of the bra many-electron basis used to build the transition density.
        ciket_strs (list): List of configuration strings representing the ket CI state in the selected-CI representation. Must be compatible in format and orbital indexing with cibra_strs. Practical significance: this input encodes the occupancies of the ket many-electron basis; together with cibra_strs it defines the transition between two CI states.
        norb (int): Number of spatial orbitals in the single-particle basis used for the CI states. This integer determines the dimension of the returned one-particle density matrix (the output is defined for orbital indices 0..norb-1). Practical significance: norb must match the orbital indexing used to generate the configuration strings; mismatches will lead to inconsistent shapes or errors.
        nelec (tuple): Electron count as a 2-tuple (nalpha, nbeta) giving the number of alpha and beta electrons for the CI states. Practical significance: nelec identifies the spin sector of the CI strings and is used by the underlying routines to construct and validate excitation/link information. The function expects a two-integer tuple; providing a different structure will result in errors propagated from the internal routines.
        link_index (list, optional): Precomputed link-index table that encodes connections between occupation strings and single-particle excitation indices used by the underlying trans_rdm1s routine. If provided, it must be in the exact format expected by the selected_ci linking utilities. If None (default), trans_rdm1s will compute the required link table internally. Practical significance: supplying link_index avoids recomputing linking information when many density matrices are built from the same string set, improving performance. If the provided link_index is incompatible with the supplied CI strings or nelec, the call will fail with an error from the internal routine.
    
    Returns:
        numpy.ndarray: A two-dimensional array of shape (norb, norb) containing the spin-traced transition one-particle density matrix (rdm1a + rdm1b) for the transition from the ket state to the bra state represented by the input strings. The matrix elements are the sums of alpha and beta transition density elements and may be real or complex depending on the CI coefficients supplied elsewhere in the workflow. Practical significance: the returned array can be contracted with one-electron integrals to obtain transition expectation values or used as input to subsequent property calculations in the PySCF selected-CI workflow.
    
    Notes and failure modes:
        This function performs no additional validation beyond what is enforced by the called trans_rdm1s routine. If cibra_strs and ciket_strs use inconsistent formats, if norb does not match the orbital indexing assumed by the strings, or if nelec is not a two-integer tuple, trans_rdm1s (and thus this function) will raise a ValueError or TypeError propagated to the caller. Supplying a correct, precomputed link_index can improve performance; supplying an incorrect link_index will typically trigger errors in the internal linking/lookup logic. See also make_rdm1 and trans_rdm1s in the selected_ci module for related routines and details of alpha/beta component construction.
    """
    from pyscf.fci.selected_ci import trans_rdm1
    return trans_rdm1(cibra_strs, ciket_strs, norb, nelec, link_index)


################################################################################
# Source: pyscf.fci.spin_op.contract_ss
# File: pyscf/fci/spin_op.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_spin_op_contract_ss(fcivec: numpy.ndarray, norb: int, nelec: tuple):
    """pyscf.fci.spin_op.contract_ss contracts the total-spin-squared operator S^2 with a Full Configuration Interaction
    (FCI) CI wavefunction, returning the resulting CI vector S^2 |CI>. This routine is used in quantum-chemistry FCI
    calculations within the PySCF framework to evaluate the action of the S^2 operator on a CI expansion (for example
    to compute expected S^2 values or to form matrix-vector products involving S^2 in spin-analysis and spin-adaptation
    workflows).
    
    Args:
        fcivec (numpy.ndarray): FCI wavefunction expansion coefficients provided as a NumPy array. In practice this array
            must contain the CI coefficients for all alpha/beta string pairs and its total size must equal
            na * nb where na = cistring.num_strings(norb, neleca) and nb = cistring.num_strings(norb, nelecb).
            The function performs fcivec.reshape(na, nb) internally, so callers may pass a 1-D array of length na*nb
            or an already-shaped 2-D array with shape (na, nb). The elements are treated as floating-point CI amplitudes
            used to build the S^2|CI> result; the input array is read but not modified in-place by this function.
        norb (int): Number of spatial orbitals (spin-orbital pairs) in the basis used to construct the determinants/strings.
            This integer is passed to cistring helper functions (cistring.num_strings, cistring.gen_des_str_index,
            cistring.gen_cre_str_index) to enumerate occupation strings and to build creation/destruction index maps.
            norb must be a non-negative integer consistent with the electron counts in nelec.
        nelec (tuple): Two-element tuple (neleca, nelecb) giving the integer counts of alpha and beta electrons respectively.
            These integers determine na and nb above and select the appropriate creation/destruction maps. The function
            expects nelec to describe a physically valid occupation (0 <= neleca, nelecb <= norb). The difference
            neleca - nelecb enters the Sz^2 contribution added to the S^2 contraction.
    
    Returns:
        numpy.ndarray: A NumPy array ci1 with the contracted CI vector S^2 |CI>. The returned array has shape (na, nb),
        where na = cistring.num_strings(norb, neleca) and nb = cistring.num_strings(norb, nelecb), matching the internal
        reshape applied to the input fcivec. The returned array contains the CI coefficients of the state obtained by
        applying the spin-square operator to the input CI vector; callers can reshape or flatten this output as required
        by downstream code.
    
    Behavior and algorithmic details:
        The function computes S^2 |CI> using second-quantized creation and annihilation index maps generated from
        cistring.gen_des_str_index and cistring.gen_cre_str_index. Internally it:
        - Computes na and nb from norb and nelec with cistring.num_strings.
        - Reshapes the input fcivec to shape (na, nb).
        - Builds indexed maps for destruction (des) and creation (cre) operator actions on alpha and beta strings.
        - Uses a helper trans(...) which applies the S+ S- and S- S+ contributions by indexing, multiplying by fermionic
          sign factors, and accumulating results using lib.take_2d and lib.takebak_2d for efficient block operations.
        - Scales the summed S+S- and S-S+ contributions by 1/2 and adds the Sz^2 diagonal term ((neleca - nelecb)**2 / 4)
          multiplied by the original fcivec to produce the final ci1.
    
    Side effects and performance:
        The function does not modify the logical contents of the caller's fcivec (it only reads fcivec). It allocates
        temporary index maps (dtype numpy.int32) and a new NumPy array for the result ci1 of size na*nb. Computational
        cost scales with norb and the number of alpha/beta strings (na and nb); memory usage is dominated by the
        na*nb result and intermediate index maps.
    
    Failure modes and exceptions:
        - A ValueError (or NumPy exception) will be raised if fcivec cannot be reshaped to (na, nb) because its total size
          does not equal na*nb.
        - If nelec is not a two-element tuple of integers or contains values outside the range [0, norb], cistring helper
          functions will raise errors (ValueError or IndexError) propagated to the caller.
        - Invalid norb (non-integer or negative) will cause failures in cistring functions.
        - Type errors may occur if fcivec is not a NumPy array-like object; callers should pass a numpy.ndarray as documented.
    
    Domain significance:
        In PySCF FCI workflows, contract_ss is used to obtain the action of the total-spin-squared operator on a CI vector.
        This is essential for evaluating spin expectation values, diagnosing spin contamination, constructing spin-adapted
        operators, or forming S^2 matrix elements in iterative eigensolvers that operate on CI vectors. The routine relies
        on cistring index generation and lib.take_2d/takebak_2d utilities in the PySCF codebase for correct and efficient
        handling of fermionic sign conventions and sparse index mappings.
    """
    from pyscf.fci.spin_op import contract_ss
    return contract_ss(fcivec, norb, nelec)


################################################################################
# Source: pyscf.fci.spin_op.spin_square0
# File: pyscf/fci/spin_op.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_spin_op_spin_square0(fcivec: numpy.ndarray, norb: int, nelec: int):
    """Compute the S^2 expectation value and spin multiplicity for a restricted-Hartree–Fock full configuration interaction (RHF-FCI) CI wavefunction vector.
    
    Args:
        fcivec (numpy.ndarray): The CI coefficient vector representing an RHF-FCI wavefunction obtained from a spin-degenerated Hamiltonian. This is the flattened array of configuration interaction amplitudes in the basis expected by the internal contract_ss routine; the function will reshape fcivec to match the shape returned by contract_ss(fcivec, norb, nelec). Practically, fcivec is the FCI solution vector whose spin properties (spin contamination and nominal spin) are to be analyzed.
        norb (int): Number of spatial orbitals in the RHF-FCI problem. This integer selects the orbital space used by contract_ss to construct the S^2 operator action on the CI vector and must match the orbital count used to produce fcivec.
        nelec (int): Number of electrons in the system. This integer is used by contract_ss to interpret occupation patterns in fcivec and to compute the S^2 expectation consistent with the electron count of the provided CI vector.
    
    Returns:
        ss (float): The expectation value of the total spin-squared operator, <S^2>, evaluated on the provided RHF-FCI CI wavefunction. Numerically computed as the contraction of fcivec with the vector result of contract_ss(fcivec, norb, nelec). In a pure spin state this equals S(S+1); deviations indicate spin contamination. Domain and numerical notes: ss is expected to be nonnegative for physical states; small negative values may occur from numerical noise. If ss < -0.25, the subsequent calculation of S below will raise a ValueError because of an invalid square-root argument.
        multip (float): The spin multiplicity 2S+1 computed from the derived spin quantum number S = sqrt(ss + 0.25) - 0.5. For a pure spin state this yields an integer multiplicity (e.g., 1 for singlet, 2 for doublet, 3 for triplet). For spin-contaminated or non-eigenstate vectors, multip may be non-integer and should be interpreted as the multiplicity inferred from the expectation value rather than a strict quantum number.
    
    Behavior and failure modes: This function calls contract_ss(fcivec, norb, nelec) to obtain the action of S^2 on the CI vector and then computes the scalar expectation value and an inferred multiplicity. It has no side effects and does not modify its inputs. Errors will be raised if fcivec cannot be reshaped to match the internal representation returned by contract_ss (ValueError), if contract_ss is not available or raises an exception (NameError/ImportError or the underlying error), or if numerical values lead to an invalid square-root (ValueError when ss + 0.25 < 0). Users should supply fcivec, norb, and nelec consistent with the same RHF-FCI calculation; otherwise results are meaningless. This function is intended for post-processing spin analysis within the PySCF quantum chemistry framework to quantify spin contamination and to report the nominal spin multiplicity implied by an RHF-FCI solution.
    """
    from pyscf.fci.spin_op import spin_square0
    return spin_square0(fcivec, norb, nelec)


################################################################################
# Source: pyscf.fci.selected_ci_slow.contract_2e
# File: pyscf/fci/selected_ci_slow.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_selected_ci_slow_contract_2e(
    eri: numpy.ndarray,
    civec_strs: tuple,
    norb: int,
    nelec: int,
    link_index: tuple = None
):
    """pyscf.fci.selected_ci_slow.contract_2e: Compute the action of two-particle excitation operators contracted with the electronic two-electron integrals on a CI state within the selected-configuration-interaction (selected CI / FCI) machinery of PySCF. This function implements the tensor contraction that yields the new CI coefficient vector for the operator combination E_{pq} E_{rs} V_{pqrs} applied to a CI wavefunction |CI>, where E_{pq} are spin-orbital excitation operators and V_{pqrs} are the two-electron integrals restored by ao2mo.restore. It is used in the selected_ci_slow code path to produce the matrix-vector product required in FCI-like procedures (energy evaluation, Davidson iterations, or Hamiltonian builds) using alpha/beta string representations and link-index tables to enumerate single and double excitations efficiently.
    
    Args:
        eri (numpy.ndarray): Two-electron integral array in a form accepted by ao2mo.restore(1, eri, norb). The routine immediately calls ao2mo.restore(1, eri, norb) to obtain the full (p q | r s) tensor of shape (norb, norb, norb, norb) (or an array acceptable to ao2mo.restore). In practical PySCF use, eri typically originates from AO or MO two-electron integral routines and may be in packed or reshaped form; ao2mo.restore is used here to standardize it to the chemist's (pq|rs) ordering. The physical role of eri is to provide the electron-electron interaction tensor V_{pqrs} used to form the contraction V_{pqrs} E_{pq} E_{rs} |CI>.
    
        civec_strs (tuple): A two-element tuple (ci_coeff, ci_strs) representing the CI state. ci_coeff is a numpy.ndarray containing the CI amplitudes/coefficients in a flattened or shaped form (the code reshapes it to (na, nb) where na and nb are the numbers of alpha and beta strings). ci_strs is itself a tuple (strsa, strsb) of lists/arrays of occupation-strings (alpha and beta strings) that enumerate the occupation patterns used by the selected-CI representation. The function uses strsa and strsb (converted to numpy.asarray internally) to build or to index link tables that map creation/annihilation operations to new string indices and phase/sign factors. The ci_coeff values are the amplitudes whose linear transformation by the two-electron operator is computed.
    
        norb (int): Number of spatial orbitals (norb). This integer determines the range of orbital indices used in excitations and is passed to ao2mo.restore to interpret the input eri. It also determines the first two dimensions of the restored eri tensor and the sizes of intermediate arrays (e.g., arrays with shape (norb, norb, ...)). The function assumes norb is consistent with the shapes of eri and the bit-strings in civec_strs.
    
        nelec (int or tuple): Number of electrons. If an integer is provided, it is interpreted as the total number of electrons and is split into alpha and beta counts as nelecb = nelec // 2 and neleca = nelec - nelecb (i.e., alpha gets the odd electron if any). Alternatively, a tuple (neleca, nelecb) may be supplied to explicitly specify the number of alpha and beta electrons. The alpha/beta counts determine which link-index tables are built (or which provided ones are expected) and the lengths of the determinants/strings for alpha and beta spaces used to construct and contract excitation operators.
    
        link_index (tuple or None): Optional precomputed link-index data to avoid recomputing cre/des and des/des link tables. If provided, it must be a 4-tuple (cd_indexa, dd_indexa, cd_indexb, dd_indexb) matching the internal expectations: cd_index* are creation-destruction link tables for single excitations and dd_index* are destruction-destruction link tables for double excitations for alpha (a) and beta (b) string lists. If link_index is None (default), the function will call cre_des_linkstr and des_des_linkstr on the provided strsa and strsb to build these tables. Providing link_index can significantly reduce overhead when the same strings are used repeatedly (e.g., in iterative solvers). If link_index is provided but malformed (wrong length, inconsistent sizes, or incompatible with strsa/strsb), the function may raise indexing or shape errors.
    
    Returns:
        numpy.ndarray: A numpy array with the same shape as the input ci_coeff (the first element of civec_strs). The returned array is the transformed CI coefficient vector representing the result of applying the contracted two-electron operator to the input CI state: fcinew = <configuration-space representation of> V_{pqrs} E_{pq} E_{rs} |CI>. The function internally reshapes ci_coeff to (na, nb), constructs intermediates (t1 arrays) with shapes driven by norb and the number of alpha/beta strings, and returns the result reshaped back to ci_coeff.shape. No in-place modification of the original ci_coeff array is performed; the function allocates and returns a new array. Failure modes include shape mismatches between eri, norb, and the strings in civec_strs, invalid link_index contents, or errors raised by ao2mo.restore if eri is not in an acceptable format. In normal operation, this return value is used by higher-level selected-CI/FCI routines for energy evaluation or iterative diagonalization.
    """
    from pyscf.fci.selected_ci_slow import contract_2e
    return contract_2e(eri, civec_strs, norb, nelec, link_index)


################################################################################
# Source: pyscf.grad.mspdft.get_diabfns
# File: pyscf/grad/mspdft.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_grad_mspdft_get_diabfns(obj: str):
    """Interpret the name of a multistate pair-density functional theory (MS-PDFT)
    objective and return two callable functions that implement the objective's
    derivative components used by the MS-PDFT gradient machinery in PySCF.
    
    This function is used by PySCF gradient modules that assemble derivatives
    for MS-PDFT methods. Rather than computing derivatives immediately, it
    maps a textual MS-PDFT method identifier to the concrete implementations
    of (1) the orbital-rotation and CI-transfer portion of the Hessian-vector
    product for intermediate-state rotations and (2) the gradient with respect
    to nuclear geometry perturbations. The mapping is currently implemented
    by dynamically importing implementations from pyscf.grad.cmspdft when the
    requested method is supported.
    
    Args:
        obj (string): Specify the MS-PDFT method name. This string selects the
            pair of derivative functions to be returned. Currently the only
            supported value is "CMS" (case-insensitive). The meaning in domain
            context is: "CMS" identifies the multiconfiguration-state-specific
            pair-density functional variant whose diabatic-response and
            geometry-gradient routines live in pyscf.grad.cmspdft. The function
            treats the input case-insensitively (for example, "cms", "CMS",
            and "Cms" are equivalent). If an unsupported name is provided, the
            function raises a RuntimeError (see Failure modes below).
    
    Returns:
        diab_response (callable): A callable that computes the orbital-rotation
            and CI-transfer sectors of the Hessian-vector product of the
            MS-PDFT objective function for a given vector of intermediate-state
            rotations. In practical PySCF usage, this routine is invoked by
            MS-PDFT gradient assembly code to obtain the response of wave
            function parameters (orbital rotations and CI-transfer amplitudes)
            to perturbations in intermediate-state rotations; it does not itself
            handle first- and second-derivative terms with respect to those
            intermediate-state rotations, which are handled by the energy-class
            version of the derivative machinery.
        diab_grad (callable): A callable that computes the gradient of the MS-PDFT
            objective function with respect to a geometry perturbation. In the
            PySCF gradient workflow, this function provides the contribution of
            the MS-PDFT objective to nuclear forces (used for geometry
            optimization and molecular dynamics). The callable is intended to be
            combined with diab_response and other contributions to produce the
            full molecular gradient.
    
    Behavior, side effects, and failure modes:
        - The function does not itself perform derivative computations; it
          returns references to implementation callables.
        - For obj equal to "CMS" (case-insensitive), the function performs a
          dynamic import from pyscf.grad.cmspdft and returns the names
          diab_response and diab_grad defined in that module. This dynamic
          import is a side effect; if pyscf.grad.cmspdft is unavailable or its
          import raises an ImportError, that error will propagate to the caller.
        - If obj does not match a supported MS-PDFT type (currently anything
          other than "CMS"), the function raises RuntimeError('MS-PDFT type not supported').
        - The returned callables conform to the internal MS-PDFT gradient
          interfaces used within PySCF; callers outside the PySCF gradient
          framework should treat them as opaque callables unless consulting the
          pyscf.grad.cmspdft source for their exact call signatures.
        - The function intentionally excludes first- and second-derivative
          contributions with respect to intermediate-state rotations; those
          contributions are provided by the energy-class version of the
          derivative routines in the PySCF MS-PDFT implementation.
    """
    from pyscf.grad.mspdft import get_diabfns
    return get_diabfns(obj)


################################################################################
# Source: pyscf.fci.spin_op.spin_square_general
# File: pyscf/fci/spin_op.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_fci_spin_op_spin_square_general(
    dm1a: numpy.ndarray,
    dm1b: numpy.ndarray,
    dm2aa: numpy.ndarray,
    dm2ab: numpy.ndarray,
    dm2bb: numpy.ndarray,
    mo_coeff: tuple,
    ovlp: numpy.ndarray = 1
):
    """General spin square operator for UHF-FCI wavefunctions.
    
    Computes the expectation value of the total spin-squared operator S^2 and the corresponding spin multiplicity (2S+1) for an unrestricted Hartree–Fock full configuration interaction (UHF-FCI) wavefunction using one- and two-particle reduced density matrices in a molecular-orbital (MO) representation. This implementation projects AO-space overlaps into the MO basis when a nontrivial AO overlap matrix is provided and implements the standard decomposition of S^2 into S_z*S_z and S_+*S_- + S_-*S_+ contributions:
    <CI|S_+ S_-|CI>, <CI|S_- S_+|CI>, and <CI|S_z S_z|CI>,
    contracting the provided one-particle (dm1a, dm1b) and two-particle (dm2aa, dm2ab, dm2bb) density matrices with the projected overlap matrices. The function follows the conventional PySCF FCI/FCIDUMP indexing and uses the ordering and transpositions shown in the source code to form the alpha-beta cross terms (dm2abba, dm2baab). It returns the scalar expectation value of S^2 and the corresponding multiplicity derived from S = sqrt(<S^2> + 1/4) - 1/2, which is useful to assess spin contamination and to identify the physical spin state of a computed UHF-FCI wavefunction.
    
    Args:
        dm1a (numpy.ndarray): Alpha-spin one-particle reduced density matrix in the MO basis. This matrix is contracted with the projected alpha MO overlap (ovlpaa) via numpy.einsum('ji,ij->') in the code to form one contribution to S_z*S_z and S_+/- terms. It must be a square 2D array with dimensionality matching the number of alpha MOs present in mo_coeff; incompatible shapes will cause numpy broadcasting or dot errors.
        dm1b (numpy.ndarray): Beta-spin one-particle reduced density matrix in the MO basis. Analogous to dm1a but for beta spin; it is used together with ovlpbb in the same einsum contractions. Shape must be consistent with mo_coeff[1] (or mo_coeff if a single 2D array was provided).
        dm2aa (numpy.ndarray): Alpha-alpha two-particle reduced density matrix in the MO basis with four indices (i,j,k,l) corresponding to alpha orbital indices. The function contracts dm2aa with the projected alpha overlap matrix twice (ovlpaa, ovlpaa) using numpy.einsum('ijkl,ij,kl->') to contribute to the S_z*S_z component. Must be a 4D array with dimensions consistent with the number of alpha MOs.
        dm2ab (numpy.ndarray): Alpha-beta two-particle reduced density matrix in the MO basis with indices ordering consistent with the repository conventions used here. dm2ab is used both directly and via transpositions (dm2abba = -dm2ab.transpose(0,3,2,1) and dm2baab = -dm2ab.transpose(2,1,0,3)) to form the cross terms that contribute to S_+*S_- and S_-*S_+ expectation values and to the S_z*S_z term. Must be a 4D array whose dimensions match the alpha and beta MO counts implied by mo_coeff.
        dm2bb (numpy.ndarray): Beta-beta two-particle reduced density matrix in the MO basis. Like dm2aa but for beta spin; contracted with ovlpbb,ovlpbb to contribute to S_z*S_z. Must be a 4D array with dimensions consistent with the number of beta MOs.
        mo_coeff (tuple): A tuple (mo_coeff_alpha, mo_coeff_beta) of 2D numpy.ndarray AO->MO coefficient matrices. Each element transforms atomic-orbital (AO) basis functions to spin-dependent MO basis functions and is used to project the AO overlap into the MO basis. If a single 2D numpy.ndarray is provided instead of a tuple (the function detects this case), it is treated as identical alpha and beta MO coefficients and internally converted to (mo_coeff, mo_coeff). Each coefficient matrix must have compatible dimensions with ovlp (if ovlp is provided) so that reduce(numpy.dot, (mo_coeff[X].T, ovlp, mo_coeff[Y])) is well-defined. The practical significance is that mo_coeff determines the MO basis in which the density matrices are defined or projected, so supplying incorrect coefficients or mismatched shapes will produce incorrect S^2 values or raise linear-algebra errors.
        ovlp (numpy.ndarray): AO overlap matrix used to project from AO to MO basis when the provided density matrices are in MO basis that originates from non-orthonormal AOs. If ovlp is the integer 1 (the default), the function treats the AO overlap as the identity and computes ovlpaa = mo_coeff[0].T @ mo_coeff[0], ovlpbb = mo_coeff[1].T @ mo_coeff[1], ovlpab = mo_coeff[0].T @ mo_coeff[1], and ovlpba = mo_coeff[1].T @ mo_coeff[0]. If ovlp is a numpy.ndarray, the code computes the projected overlaps ovlpaa, ovlpbb, ovlpab, ovlpba via reduce(numpy.dot, (mo_coeff[X].T, ovlp, mo_coeff[Y])) to perform the required partial traces. ovlp must be compatible in dimension with the AO rows of mo_coeff; otherwise numpy.dot will raise an error. Using ovlp != 1 allows correct handling of non-orthonormal AO bases and non-degenerate alpha/beta orbital sets.
    
    Returns:
        tuple: A pair (ss, multip) where:
            ss (numpy.floating): The scalar expectation value of S^2 for the supplied UHF-FCI reduced density matrices, computed as the sum of S_z*S_z and the transverse S_+*S_- + S_-*S_+ contributions after projecting overlaps into the MO basis. This value quantifies total spin and spin contamination of the wavefunction: for a pure spin-S eigenstate, ss = S*(S+1).
            multip (numpy.floating): The spin multiplicity computed as 2*S + 1 with S obtained from ss via S = sqrt(ss + 1/4) - 1/2. This multiplicity is useful to identify the nominal spin state (e.g., singlet, doublet, triplet) associated with the computed expectation value.
    
    Behavior and failure modes:
        The function does not modify its input arrays in-place (it creates projected overlap arrays and transposed views). If mo_coeff is supplied as a single 2D numpy.ndarray, it is internally converted to a tuple (mo_coeff, mo_coeff); this conversion is local and has no side effects beyond the function return. The routine assumes the provided density matrices follow the PySCF indexing and ordering conventions; incorrect ordering will yield incorrect results. The function will raise numpy/linear-algebra errors (e.g., ValueError, TypeError) if array dimensionalities are incompatible for the required dot and einsum contractions, or if the arrays are not numeric; callers should validate shapes: dm1* should be square 2D arrays and dm2* should be 4D arrays consistent with the MO dimensions implied by mo_coeff and ovlp.
    """
    from pyscf.fci.spin_op import spin_square_general
    return spin_square_general(dm1a, dm1b, dm2aa, dm2ab, dm2bb, mo_coeff, ovlp)


################################################################################
# Source: pyscf.grad.rhf.make_rdm1e
# File: pyscf/grad/rhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_grad_rhf_make_rdm1e(
    mo_energy: numpy.ndarray,
    mo_coeff: numpy.ndarray,
    mo_occ: numpy.ndarray
):
    """pyscf.grad.rhf.make_rdm1e constructs the energy-weighted one-particle (one-electron) density matrix used in restricted Hartree–Fock (RHF) gradient calculations. The matrix is assembled in the atomic-orbital (AO) basis by summing contributions from molecular orbitals (MOs) that are treated as occupied (mo_occ > 0), where each occupied MO contribution is weighted by the product of its orbital energy and occupation. In PySCF this energy-weighted density appears when forming response terms and energy derivatives with respect to nuclear coordinates.
    
    Args:
        mo_energy (numpy.ndarray): One-dimensional array of molecular orbital energies. Each entry corresponds to a molecular orbital (MO) and is used to weight that MO's contribution to the energy-weighted density as (mo_energy * mo_occ) for occupied orbitals. The function selects orbitals where the corresponding entry in mo_occ is greater than zero (mo_occ > 0). mo_energy must align with the second dimension of mo_coeff and with mo_occ so that indexing mo_energy[mo_occ>0] is valid; if lengths are incompatible an IndexError or ValueError may be raised.
        mo_coeff (numpy.ndarray): Two-dimensional MO coefficient matrix that transforms MO amplitudes to the AO basis. The convention expected by this function is that columns of mo_coeff correspond to MOs (so mo_coeff[:, i] is the AO representation of MO i). Only the columns corresponding to occupied orbitals (mo_occ > 0) are used. The returned energy-weighted density is computed as the dot product of the occupied-coefficient columns weighted by (mo_energy * mo_occ) and the conjugate transpose of those columns, therefore mo_coeff may be real or complex and the result will follow accordingly. Incompatible shapes between mo_coeff and the boolean mask mo_occ>0 will produce standard NumPy errors.
        mo_occ (numpy.ndarray): One-dimensional array of occupations for each MO. Typical RHF usage supplies integer occupations (0 or 2), but fractional occupations are accepted provided they are greater than zero to be treated as occupied. The boolean mask mo_occ > 0 determines which orbitals contribute; occupations equal to or less than zero are excluded. mo_occ must have the same length as mo_energy and the number of columns in mo_coeff, otherwise indexing will fail.
    
    Returns:
        numpy.ndarray: The energy-weighted one-particle density matrix in the AO basis. This matrix is returned as a NumPy array and has the same number of rows and columns as the number of atomic orbitals (the first dimension of mo_coeff). It equals the sum_over_occupied [ (occupation * orbital_energy) * |MO><MO| ] expressed in the AO basis. There are no side effects; the function does not modify its inputs. Typical failure modes are NumPy IndexError/ValueError or TypeError raised when input arrays have incompatible shapes, are not array-like, or when broadcasting the energy-occupation weights with the selected MO coefficient columns fails.
    """
    from pyscf.grad.rhf import make_rdm1e
    return make_rdm1e(mo_energy, mo_coeff, mo_occ)


################################################################################
# Source: pyscf.grad.uhf.make_rdm1e
# File: pyscf/grad/uhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_grad_uhf_make_rdm1e(mo_energy: tuple, mo_coeff: tuple, mo_occ: tuple):
    """Construct the unrestricted (UHF) energy-weighted one-particle density matrices for alpha and beta spin channels.
    
    Args:
        mo_energy (tuple): A two-element tuple containing orbital energies for the two spin channels (alpha then beta). Each element is the set of orbital energies for that spin channel and is passed directly to pyscf.grad.rhf.make_rdm1e for the corresponding spin. In the PySCF electronic-structure context, these orbital energies characterize occupied and virtual molecular orbitals and are used to weight contributions to the one-particle energy-weighted density matrix needed for analytic gradient and force calculations.
        mo_coeff (tuple): A two-element tuple containing molecular orbital coefficient arrays for the two spin channels (alpha then beta). Each element is the MO coefficient matrix for that spin and is forwarded to pyscf.grad.rhf.make_rdm1e. In practice these matrices map atomic-orbital basis functions to molecular orbitals for each spin and determine the basis in which the energy-weighted density matrix is expressed.
        mo_occ (tuple): A two-element tuple containing orbital occupation numbers (or occupation arrays) for the two spin channels (alpha then beta). Each element specifies which orbitals are occupied for that spin and is used by pyscf.grad.rhf.make_rdm1e to form the energy-weighted density contribution from occupied orbitals. Occupation vectors are required to identify the occupied subspace when computing gradient-related density matrices.
    
    Returns:
        numpy.ndarray: A NumPy array containing the energy-weighted one-particle density matrices for the two spin channels. The first entry corresponds to the alpha-spin energy-weighted density matrix computed by pyscf.grad.rhf.make_rdm1e(mo_energy[0], mo_coeff[0], mo_occ[0]), and the second entry corresponds to the beta-spin matrix computed by pyscf.grad.rhf.make_rdm1e(mo_energy[1], mo_coeff[1], mo_occ[1]). This combined array is used in PySCF gradient routines for unrestricted Hartree–Fock and related post-HF gradient evaluations.
    
    Behavior and side effects:
        This function wraps two calls to pyscf.grad.rhf.make_rdm1e, one for each spin channel, and returns their results as a NumPy array. It does not modify its input arguments. There are no hidden side effects such as global state mutation.
    
    Failure modes and expectations:
        The function expects each of mo_energy, mo_coeff, and mo_occ to be a sequence (tuple) with exactly two elements corresponding to alpha and beta spin channels. If an input tuple has fewer or more elements, indexing (e.g., mo_energy[1]) will raise an IndexError. If the elements passed to pyscf.grad.rhf.make_rdm1e are of incorrect shape or type, the underlying rhf.make_rdm1e call will raise an error (TypeError, ValueError, or shape-related exceptions). Users should ensure the per-spin entries are valid inputs for pyscf.grad.rhf.make_rdm1e.
    """
    from pyscf.grad.uhf import make_rdm1e
    return make_rdm1e(mo_energy, mo_coeff, mo_occ)


################################################################################
# Source: pyscf.gto.basis.parse_ecp
# File: pyscf/gto/basis/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_parse_ecp(string: str, symb: str = None):
    """pyscf.gto.basis.parse_ecp parses an effective core potential (ECP) specification given as text and returns the parsed ECP data in the format expected by PySCF gto basis utilities. This function is part of the PySCF (Python-based Simulations of Chemistry Framework) gto basis handling and is used when users supply ECP definitions (for example, in NWChem-style text) that must be converted into PySCF's internal representation for attaching ECPs to atomic basis sets in electronic-structure calculations.
    
    The implementation delegates the parsing work to parse_nwchem_ecp.parse, so behavior, accepted textual conventions, and the detailed structure of the returned data follow that parser's rules. No file I/O is performed by this wrapper: the input is taken entirely from the provided string. In typical usage within PySCF, the returned value is passed directly to gto basis setup routines so that the specified ECP can be applied to the corresponding atom(s) in molecular calculations.
    
    Args:
        string (str): A text string containing the ECP specification to parse. The string is expected to follow the textual conventions supported by the NWChem-style ECP parser (parse_nwchem_ecp.parse). In the context of quantum-chemistry workflows using PySCF, this string commonly contains one or more atomic ECP blocks that enumerate potentials, angular-momentum channels, and exponent/coefficient parameters. The function parses this string and extracts the numeric and symbolic parameters required to describe the ECP.
        symb (str): Optional element symbol (for example, 'Fe', 'O') that identifies which element the ECP applies to. If provided, this symbol is forwarded to the underlying parse_nwchem_ecp.parse call and is used to associate the parsed ECP data with a specific chemical element in PySCF's gto basis data structures. If None (the default), the underlying parser may attempt to infer the element symbol from the content of string; providing symb is recommended when the input string does not unambiguously encode the element or when you want to override or clarify the element association.
    
    Returns:
        object: The parsed effective core potential data as returned by parse_nwchem_ecp.parse. The returned value contains the ECP parameterization extracted from the input string and is intended for immediate use by PySCF gto basis setup routines to attach ECPs to atoms in electronic-structure calculations. The exact internal structure and keys of this return value follow the conventions of parse_nwchem_ecp.parse; callers that need to inspect or modify the returned data should follow the parser's documented format.
    
    Raises/Failure modes and behavior notes:
        - The function directly propagates exceptions raised by parse_nwchem_ecp.parse. In particular, a KeyError may be raised if an expected element symbol or lookup key is missing in the underlying parser; an informative KeyError is planned (see TODO in source), but currently callers should be prepared to catch KeyError and inspect available symbols or keys.
        - A parsing error (for example, due to malformed numeric fields or unexpected tokens in string) will typically raise a ValueError or a parser-specific exception from the underlying implementation; callers should validate or sanitize input strings from untrusted sources.
        - No modifications to global state or files are performed; the only side effect is returning the parsed representation for further use in PySCF workflows.
    """
    from pyscf.gto.basis import parse_ecp
    return parse_ecp(string, symb)


################################################################################
# Source: pyscf.gto.basis.load_pseudo
# File: pyscf/gto/basis/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_load_pseudo(filename_or_basisname: str, symb: str):
    """Parses and loads a pseudopotential (PP) entry for use by the pyscf.gto module. This function accepts either a filesystem path to a CP2K-format pseudopotential file or a short basis/pseudopotential name that may be resolved via the internal PP_ALIAS mapping and the packaged GTH pseudopotential directory. The parsed pseudopotential data is the representation produced by the CP2K-format parser used internally by PySCF and is suitable for supplying pseudopotential information to PySCF GTO-based calculations (for example, DFT calculations that use GTH pseudopotentials).
    
    Behavior summary and domain significance: In the PySCF (Python-based Simulations of Chemistry Framework) gto submodule, pseudopotentials are used to replace atomic core electrons and reduce computational cost for quantum chemistry calculations. This function centralizes the logic for locating, loading, and parsing pseudopotential definitions. It first normalizes the element symbol, then either loads an external file if filename_or_basisname is a valid path, resolves known aliases to files installed with PySCF, or asks the CP2K-format parser to parse the provided name. Filesystem reads and alias resolution are performed as side effects.
    
    Args:
        filename_or_basisname (str): Filesystem path or short pseudopotential name to identify the pseudopotential to load. If this argument is a path to an existing file (os.path.isfile returns True), the file is read and parsed directly via the external-loader pathway. If it is not a path, the function attempts to format the name and suffix with the internal _format_pseudo_name helper and then looks up PP_ALIAS to find a packaged pseudopotential module in the library directory (_GTH_PP_DIR). If no alias matches, the value is passed to the CP2K-format parser (parse_cp2k_pp.parse) as a name to be parsed. This parameter is required and has no default.
        symb (str): Element symbol or atom identifier associated with the pseudopotential. Before use, all non-alphabetic characters are removed from this string (only A–Z and a–z letters are kept). The sanitized symbol is passed to the parser and determines which element the pseudopotential applies to; it is significant because pseudopotentials are element-specific. Provide a conventional chemical element symbol (for example, "C", "O", "Fe"), noting that any digits or punctuation present will be stripped.
    
    Returns:
        object: The parsed pseudopotential representation returned by the CP2K-format pseudopotential parser (functions such as parse_cp2k_pp.parse, parse_cp2k_pp.load, or the _load_external wrapper). The exact Python type and internal structure are those produced by the parse_cp2k_pp module; callers should treat the return as the PP/basis specification that can be consumed by pyscf.gto when assigning pseudopotentials to atoms in a calculation.
    
    Errors and failure modes:
        - If the CP2K parser raises BasisNotFoundError for the provided name, that BasisNotFoundError is propagated unchanged to the caller so calling code can detect a missing pseudopotential.
        - Any other exception raised while attempting to parse or load the pseudopotential is converted into a BasisNotFoundError with the message "Invalid PP {filename_or_basisname}", where {filename_or_basisname} is the original argument. This indicates an invalid, unreadable, or otherwise unparsable pseudopotential input.
        - Side effects include reading files from the filesystem (when filename_or_basisname is a file) and reading packaged files from the PySCF GTH PP directory when an alias is resolved.
    
    Usage note:
        This function is intended to be used by higher-level PySCF routines that construct basis sets and assign pseudopotentials for atoms in quantum chemistry calculations. It centralizes parsing and lookup semantics for CP2K-format pseudopotentials shipped with PySCF or supplied by users as external files.
    """
    from pyscf.gto.basis import load_pseudo
    return load_pseudo(filename_or_basisname, symb)


################################################################################
# Source: pyscf.gto.basis.bse.autoabs
# File: pyscf/gto/basis/bse.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_bse_autoabs(name: str, elements: list):
    """pyscf.gto.basis.bse.autoabs: Create a Coulomb fitting (auxiliary) basis set from an existing orbital basis specification using the Basis Set Exchange (BSE) helper routines and convert it into the PySCF orbital-basis representation.
    
    This function is used within the PySCF (Python-based Simulations of Chemistry Framework) gto/basis workflow to automatically generate auxiliary (Coulomb fitting) basis sets that are commonly employed in density-fitting / resolution-of-identity (RI) approximations to accelerate the evaluation of two-electron Coulomb integrals. The generation follows the prescription discussed in R. Yang, A. P. Rendell, and M. J. Frisch, J. Chem. Phys. 127, 074102 (2007), and is applicable to orbital bases accessible via the Basis Set Exchange API for elements in the covered range (for example H to Kr in the referenced work). Practical significance: the returned auxiliary basis is directly usable by PySCF density-fitting routines to reduce computational cost at the expense of an approximate representation of the Coulomb operator.
    
    Args:
        name (str): The identifier of the orbital basis set to base the auxiliary fitting basis on. This string is passed verbatim to basis_set_exchange.api.get_basis(name, elements). Typical values are basis set names recognized by the Basis Set Exchange (BSE) service (for example "cc-pVDZ", "def2-TZVP"), and the meaning is the canonical basis set family whose orbital basis functions will be used to construct the Coulomb fitting basis.
        elements (list): A list of element identifiers specifying which atomic species the requested orbital basis covers. This argument is forwarded unchanged to basis_set_exchange.api.get_basis(name, elements); elements must therefore be in the form accepted by that API (for example a list of atomic symbols or other BSE-recognized identifiers). The list tells the function which elements' orbital bases to fetch and for which elements the auxiliary (fitting) basis will be generated.
    
    Behavior and side effects:
        The function queries the Basis Set Exchange via basis_set_exchange.api.get_basis(name, elements) to obtain the orbital basis definition for the specified name and elements. It then calls manip.autoabs_basis(obs) to build an auxiliary Coulomb fitting basis from that orbital basis according to the automatic generation rules. Finally, it converts the generated auxiliary basis into PySCF's orbital-basis representation by calling _orbital_basis(auxbs) and returns the first element of that result. There are no persistent side effects in the PySCF global state performed by this function beyond the returned object; however, network or I/O behavior may occur indirectly if the basis_set_exchange API implementation fetches remote data or uses a local cache. No defaults are assumed beyond those implicit in the Basis Set Exchange retrieval and manip.autoabs_basis behavior.
    
    Failure modes and exceptions:
        If basis_set_exchange.api.get_basis cannot find or parse the specified basis (for example because name is unknown for the given elements), it will raise an exception that propagates to the caller. If manip.autoabs_basis cannot generate an auxiliary basis from the fetched orbital basis, it will raise an exception. If the auxiliary basis cannot be converted by _orbital_basis(auxbs) into the expected PySCF representation, an exception will be raised. Callers should ensure that name and elements conform to the BSE API expectations and handle exceptions from these helper routines.
    
    Returns:
        object: The generated Coulomb fitting (auxiliary) basis converted into PySCF's orbital-basis representation (specifically, the first element returned by _orbital_basis(auxbs)). This return value encapsulates the auxiliary basis function definitions (exponents, contraction coefficients, angular momenta, and element association) suitable for immediate use in PySCF density-fitting/Coulomb-fitting workflows and gto module functions that accept a basis specification.
    """
    from pyscf.gto.basis.bse import autoabs
    return autoabs(name, elements)


################################################################################
# Source: pyscf.gto.basis.bse.autoaux
# File: pyscf/gto/basis/bse.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_bse_autoaux(name: str, elements: list):
    """pyscf.gto.basis.bse.autoaux generates an auxiliary basis set for the specified orbital basis set using the Auto-Aux algorithm of Stoychev, Auer, and Neese (J. Chem. Theory Comput. 2017). This function is part of the PySCF basis utilities (pyscf.gto.basis.bse) and automates construction of auxiliary (density-fitting / resolution-of-identity) basis functions that are compatible with a given orbital basis set identified by name and restricted to a given set of chemical elements. The generated auxiliary basis is intended for use in density-fitting (RI) and related post-Hartree–Fock procedures within the PySCF framework and is produced by calling the basis-set-exchange to obtain the orbital basis and then applying the Auto-Aux generation routine.
    
    Args:
        name (str): Identifier of the orbital basis set to base the auxiliary basis on. This string is passed verbatim to the basis_set_exchange API (basis_set_exchange.api.get_basis) and therefore must be an orbital-basis name understood by the Basis Set Exchange (for example, standard labels such as 'cc-pVDZ', 'def2-TZVP', etc.). The practical significance of this parameter is that it determines the angular momenta, contraction patterns, and primitive exponents of the orbital basis from which the auxiliary functions are derived using the Auto-Aux prescription.
        elements (list): List of chemical elements for which the auxiliary basis is to be generated. Each entry should be an element identifier accepted by the basis_set_exchange.get_basis call (commonly atomic symbols like 'H', 'C', 'O' or integer atomic numbers). The function will request the orbital basis for exactly these elements and return auxiliary functions only for them; this allows restricting the auxiliary set to the subset of elements present in a molecular calculation.
    
    Returns:
        The auxiliary basis set corresponding to the requested orbital basis and elements: a PySCF-style orbital-basis data structure produced by the internal helper _orbital_basis on the auxiliary-basis description created by the Auto-Aux routine. The returned value contains the auxiliary shell information for each element listed in elements and is ready to be consumed by PySCF density-fitting routines. If the underlying basis_set_exchange API does not provide the requested orbital basis for the given name/elements, or if the Auto-Aux generator (manip.autoaux_basis) fails for the supplied orbital-basis data, the function will propagate the originating exception from those calls (for example, lookup or generation errors). No global state is modified by this function; it constructs and returns a new auxiliary-basis object suitable for immediate use in PySCF calculations.
    """
    from pyscf.gto.basis.bse import autoaux
    return autoaux(name, elements)


################################################################################
# Source: pyscf.gto.basis.bse.get_basis
# File: pyscf/gto/basis/bse.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_bse_get_basis(name: str, elements: list):
    """pyscf.gto.basis.bse.get_basis: Obtain a basis set and return it in the PySCF internal basis format used for quantum chemistry calculations.
    
    This function is used in the PySCF electronic-structure framework to retrieve an atomic-orbital basis set identified by a common basis-set name (for example "cc-pVDZ") and to convert the retrieved basis into the internal dictionary format consumed by PySCF routines (for example by pyscf.gto.Mole construction and integrals code). Internally it delegates retrieval to basis_set_exchange.api.get_basis(name, elements) and then converts the raw basis-set data into the PySCF orbital-basis representation via the module's _orbital_basis conversion routine, returning the processed dictionary.
    
    Args:
        name (str): Name of the basis set to retrieve, case insensitive. This is the canonical basis-set identifier used by the Basis Set Exchange (for example "sto-3g", "cc-pVTZ"); the value must be a string. The value controls which published basis functions (primitive exponents, contraction coefficients, shell types and shell centers) are returned for the requested elements and therefore determines the orbital basis used in downstream electronic-structure calculations.
        elements (str, int or list): Specification of the chemical element(s) for which the basis is requested. Acceptable forms are a single element symbol string (for example "H"), a single atomic number integer (for example 1), or a list of element symbols and/or atomic numbers (for example ["H", "C"] or [1, 6]). This argument restricts the returned basis to the requested element types and is used when retrieving either a single-element basis or a multi-element basis block suitable for building molecules.
    
    Returns:
        dict: A dictionary representing the requested basis set in PySCF's internal basis format. The returned dict is the processed form produced by _orbital_basis and typically maps element symbols to their shell lists, where each shell entry encodes angular momentum, primitive exponents, and contraction coefficients in the layout expected by PySCF core routines. This dict is intended for immediate consumption by PySCF molecular/integral construction code and therefore contains the full data needed to instantiate basis functions for electronic-structure computations.
    
    Behavior and side effects:
        The function calls basis_set_exchange.api.get_basis(name, elements) to obtain the canonical basis definition and then converts it with the package's _orbital_basis converter. There are no persistent side effects (no global state is modified). The returned dict is a new object suitable for use or storage by the caller.
    
    Failure modes and errors:
        If name is not a string or elements is not one of the documented types (str, int, or list), the underlying call may raise a TypeError. If the basis-set name or element specification is not found or invalid, exceptions raised by basis_set_exchange.api.get_basis propagate to the caller. Callers should catch and handle these exceptions when using this function in workflows that may request unavailable basis sets.
    """
    from pyscf.gto.basis.bse import get_basis
    return get_basis(name, elements)


################################################################################
# Source: pyscf.gto.basis.load
# File: pyscf/gto/basis/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_load(filename_or_basisname: str, symb: str, optimize: bool = False):
    """Convert a basis-set identifier or file into the PySCF internal basis representation for a single atomic symbol.
    
    This function is used throughout PySCF to obtain the basis definition that can be assigned to mol.basis[symb] for electronic structure calculations (for example, assigning a standard STO-3G or user-supplied basis to an atom). It accepts either a case-insensitive basis set name (which may match built-in aliases, GTH aliases, user-provided basis sets, or common Pople names), a filesystem path to a file containing basis definitions, or a compound identifier that encodes a contraction scheme using the "@<scheme>" suffix. The returned value is the basis data for the requested atomic symbol in the internal format expected by PySCF routines that build atomic orbital integrals.
    
    Args:
        filename_or_basisname (str): Case-insensitive basis set name or path to a basis file. If a registry/name is given, special characters in the name are tolerated/normalized and the function will attempt several resolution strategies in this order: built-in alias lookup, user-basis lookup, GTH alias lookup (which switches to CP2K-format parsing), Pople-style parsing, direct parsing with the NWchem-style parser, direct parsing with the CP2K-style parser, and finally a lookup via the basis-set-exchange (BSE) API if that optional dependency is available. If the string contains an "@<scheme>" suffix (for example "cc-pVDZ@seg"), the part after "@" is interpreted as a contraction scheme and applied to the loaded basis (the scheme is converted internally by _convert_contraction); if the path refers to an existing file, the file is parsed (NWchem-style first, then CP2K-style) and the contraction scheme is applied afterward. Providing a filesystem path causes the function to read that file; providing a basis name results in no file IO other than reading bundled data files. If the BSE API is not installed and the basis is not found locally, the function will emit a warning recommending installation of the basis-set-exchange package.
        symb (str): Atomic symbol for which to extract the basis (e.g., "C", "O"). Non-letter characters are removed from this string before lookup (only alphabetic characters are retained). The symb argument determines which element's basis is returned from a multi-element basis file or database entry; it is the key used to select the returned basis definition and is the same symbol used in mol.basis assignments.
        optimize (bool): Controls whether parsing should attempt contraction optimization when constructing the internal representation. When True, parsers may merge or optimize contraction coefficients according to PySCF's internal rules; when False (default) the basis is parsed without attempting those optimizations. The practical significance is that enabling optimization can reduce redundant contracted primitives and slightly change contraction representation while preserving numerical equivalence for most integrals. Default: False.
    
    Behavior, side effects, and failure modes:
        - If filename_or_basisname refers to an existing filesystem path, the function first tries to parse it with the NWchem-style parser and, on failure to find the requested symbol, tries the CP2K-style parser. If neither parser can provide the symbol, a BasisNotFoundError is raised.
        - If filename_or_basisname is not a file, the function attempts alias-based resolution and builtin lookups (including GTH aliases and user-provided basis directories), or invokes special parsers for Pople-style names. If these do not succeed it attempts to parse the name as an NWchem-format or CP2K-format basis identifier. If still not found and the optional basis-set-exchange integration is present, it queries BSE for the requested element; if BSE is not installed the function issues a warning suggesting installation.
        - If filename_or_basisname contains an "@<scheme>" suffix, the requested contraction scheme is parsed and converted; when the converted scheme is not 'Full', the resulting basis is truncated/converted via internal truncation routines and the returned basis reflects that contraction scheme.
        - The function may import additional modules (for alias resolution and parsing), read files from disk, and call optional external APIs (basis-set-exchange) if available. It may therefore produce I/O errors or import errors in environments lacking filesystem access or required optional dependencies.
        - On unknown basis names, unknown file contents, or other irrecoverable parsing failures, the function raises BasisNotFoundError with an explanatory message. Some parsing errors may also raise other exceptions if the underlying parser raises them; in some cases these are caught and re-raised as BasisNotFoundError with a message indicating an invalid basis.
        - The symb and filename_or_basisname inputs are normalized (special characters removed from symb; basis name comparisons are case-insensitive and normalized) before lookup.
    
    Returns:
        object: Basis data for the requested atomic symbol in PySCF's internal basis representation (the same value expected by and assignable to mol.basis[symb]). This returned object contains the orbital shells/primitives and contraction coefficients for symb according to the resolved basis set and any applied contraction scheme. If the function succeeds, the returned value has no further side effects beyond having read any necessary files or performed any optional API calls; if it fails, it raises BasisNotFoundError (or a parser-specific exception) instead of returning.
    """
    from pyscf.gto.basis import load
    return load(filename_or_basisname, symb, optimize)


################################################################################
# Source: pyscf.gto.basis.parse_cp2k.parse
# File: pyscf/gto/basis/parse_cp2k.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_parse_cp2k_parse(string: str, symb: str = None, optimize: bool = False):
    """Parse a CP2K-format basis set text and return the corresponding PySCF internal basis representation suitable for assignment to Mole.basis or Cell.basis. This function is used in the PySCF workflow to convert basis definitions produced or distributed in CP2K format (text blocks that may contain multiple element blocks and comments) into the internal data structure that PySCF quantum-chemistry objects accept.
    
    Args:
        string (str): The input text containing CP2K-format basis data. This argument provides either a single basis block (when symb is None) or one or more basis blocks concatenated together (when symb is provided). The CP2K-format text may contain comment fragments beginning with the '#' character; such comments are ignored by this function. The function treats lines that begin with the tokens 'END' or 'BASIS' as delimiters/end markers and excludes them from the parsed basis block. Practical significance: this parameter is the raw source of basis-set definitions that a user or a file export provides; it must contain the CP2K-formatted numeric and metadata lines that define shells, exponents, and contraction coefficients.
        symb (str): The chemical element symbol used to select a single element-specific basis block from string. If symb is not None, the function first splits string using the module-level BASIS_SET_DELIMITER (the same delimiter used by CP2K-style basis collections) and searches those blocks for a block matching symb; only the matching block is parsed. If symb is None, the entire string is treated as the basis block and is parsed line-by-line. Practical significance: provide symb when string contains many element entries (a full basis library) and you need to extract the basis for a single element. Default: None.
        optimize (bool): Flag forwarded to the internal parser (_parse) that controls post-processing of the parsed basis representation (for example, whether contraction optimization or equivalent-data folding is applied). Practical significance: set optimize=True when you want the returned internal basis structure to be processed for any size/efficiency optimizations supported by the internal parser; set optimize=False to preserve the raw parsed layout. Default: False.
    
    Returns:
        object: An internal PySCF basis representation produced from the CP2K-format input. The returned object is the value that can be assigned directly to Mole.basis or Cell.basis in PySCF workflows (for example, cell.basis = {'C': parse(...)}). The exact in-memory structure is the internal basis format used throughout the pyscf.gto subsystem (it encodes shells, angular momenta, exponents, contraction coefficients, and any flags produced by optimize). Practical significance: this return value bridges CP2K textual basis definitions and PySCF programmatic molecular/cell object configuration.
    
    Behavior and side effects:
        - Lines or line segments after a '#' character are treated as comments and ignored.
        - Lines that start with 'END' or 'BASIS' are not included in the parsed output.
        - If symb is provided, the function splits string on BASIS_SET_DELIMITER and searches the resulting blocks for the block corresponding to symb; the search and splitting behavior mirrors how CP2K basis libraries are commonly concatenated.
        - The function does not modify the input string argument; it constructs and returns a new internal basis object.
        - The optimize parameter is passed directly to the internal _parse routine; any optimizations or transformations performed are implementation details of _parse.
    
    Failure modes and exceptions:
        - If symb is provided but no matching basis block is found in string, the function raises BasisNotFoundError with a message indicating the missing element (e.g., "Basis not found for C"). Practical significance: callers should catch BasisNotFoundError when dynamically extracting element basis sets from larger libraries.
        - If the CP2K-format text is malformed (missing expected numeric fields or lines), the internal parser (_parse) may raise parsing or value errors; these originate from numeric parsing and the internal parser logic.
    
    Example usage in PySCF workflows:
        Use this function to convert CP2K-exported basis blocks into PySCF basis assignments, for example when setting up a Cell or Mole object: cell.basis = {'C': pyscf.gto.basis.parse_cp2k.parse(cp2k_text, symb='C')}. The function is intended for interoperability between CP2K-format basis libraries and PySCF's internal basis data structures.
    """
    from pyscf.gto.basis.parse_cp2k import parse
    return parse(string, symb, optimize)


################################################################################
# Source: pyscf.gto.basis.parse_cp2k_pp.parse
# File: pyscf/gto/basis/parse_cp2k_pp.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_parse_cp2k_pp_parse(string: str, symb: str = None):
    """pyscf.gto.basis.parse_cp2k_pp.parse parses CP2K-format pseudopotential text and returns the parsed pseudopotential in PySCF's internal basis/pseudopotential representation that can be assigned to Cell.pseudo for electronic-structure calculations. This function is used in the PySCF domain to convert CP2K-style GTH pseudopotential blocks (text that would appear in CP2K input files) into the in-memory format PySCF expects for pseudopotentials during atomistic and periodic calculations.
    
    Args:
        string (str): A CP2K-format pseudopotential text blob. This is the raw multi-line string that contains one or more CP2K "PSEUDOPOTENTIAL" blocks (for example, GTH pseudopotentials). The parser treats lines that are blank or that contain only whitespace as ignorable. When symb is None, lines that contain the literal substring 'END' or the literal substring '#PSEUDOPOTENTIAL' are removed before parsing. When symb is provided, the function splits the input on the literal marker '#PSEUDOPOTENTIAL' and searches the resulting blocks for a block corresponding to the requested element symbol. Leading and trailing whitespace on retained lines is stripped. This argument must be provided as a Python str containing the CP2K pseudopotential content (for example, the multi-line string shown in the module examples) and should follow CP2K/GTH formatting conventions expected by the helper routines used internally.
        symb (str): Optional atomic symbol (for example, 'C', 'O', 'Fe') that, if provided, restricts parsing to the single CP2K pseudopotential block for that element. If symb is not None, the function will split the provided string by the marker '#PSEUDOPOTENTIAL', search the resulting blocks for the block matching symb using the module helper _search_gthpp_block, and parse only that block. If symb is None, the function will prepare the full input by removing blank lines and any lines containing 'END' or '#PSEUDOPOTENTIAL' and then parse the remaining lines as a single pseudopotential definition. The default is None, meaning parse the whole provided input text (subject to the line filters described).
    
    Returns:
        object: The parsed pseudopotential expressed in PySCF's internal basis/pseudopotential representation suitable for assignment to Cell.pseudo. Practically, callers use the returned object as the value in a mapping from atomic symbol to pseudopotential (e.g., cell.pseudo = {'C': parse(cp2k_text)}). The exact internal structure is the module's canonical representation produced by the helper _parse and is what PySCF routines expect when reading pseudopotentials for subsequent electronic structure calculations.
    
    Behavior, side effects, defaults, and failure modes:
        - The function does not perform file I/O; it operates on the provided string only.
        - Lines beginning with comment markers are effectively ignored by the split/search behavior when symb is used; blank lines and lines containing the substrings 'END' or '#PSEUDOPOTENTIAL' are removed when symb is None.
        - If symb is provided but no matching pseudopotential block is found in the input, the function raises BasisNotFoundError with a message indicating the missing symbol (for example, "Pseudopotential not found for C."). This is a primary failure mode when the requested element is not present in the CP2K text.
        - If the CP2K block is malformed or contains unexpected formatting, parsing helper routines (_search_gthpp_block, _parse) may raise other exceptions (for example, ValueError or custom parse errors). Such exceptions propagate to the caller; callers should validate input or handle exceptions when parsing untrusted or user-supplied CP2K content.
        - Whitespace is trimmed from retained lines; the function returns the internal representation built from those cleaned lines.
        - Typical usage in the PySCF workflow is to assign the returned value to a Cell object's pseudo attribute, e.g., cell.pseudo = {'C': pyscf.gto.basis.pseudo_cp2k.parse(cp2k_text)}, enabling PySCF to use the GTH pseudopotential during calculations.
    """
    from pyscf.gto.basis.parse_cp2k_pp import parse
    return parse(string, symb)


################################################################################
# Source: pyscf.gto.basis.parse_gaussian.parse
# File: pyscf/gto/basis/parse_gaussian.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_parse_gaussian_parse(string: str, optimize: bool = True):
    """Parse a basis set specification given as a text in NWChem format and convert it
    to PySCF's internal basis representation that can be assigned to Mole.basis
    for quantum-chemistry calculations.
    
    Args:
        string (str): Multiline text in NWChem basis-set format. Each line in this
            string is treated as a single record. Lines that start with the hash
            character ('#') are ignored as comments. Inline comments beginning
            with the exclamation mark ('!') are removed from each line before
            parsing. Blank lines and any lines equal to the module-level DELIMETER
            constant are skipped. This parameter is the primary input used to
            describe atomic basis sets (primitive Gaussians, shells, and
            contractions) in a human- or program-generated NWChem-compatible form;
            the parsed result defines the orbital basis used in downstream PySCF
            Mole objects and electronic-structure routines.
        optimize (bool): If True (the default), request that the internal parser
            perform optional post-processing/optimization steps implemented by the
            private _parse routine before returning. These post-processing steps
            are implementation-defined in the module (for example, combining,
            normalizing, or canonicalizing primitives and contractions) and affect
            the compactness or canonical form of the returned internal basis
            representation. If False, the function will perform only the minimal
            parsing necessary to convert the cleaned input lines into the internal
            representation and will skip those optional post-processing steps.
            This flag controls how the parsed basis will be prepared for assignment
            to Mole.basis but does not change the textual input handling described
            above.
    
    Returns:
        dict: Internal basis-set representation produced by the module-level
        _parse function. The returned mapping is formatted in the way expected by
        PySCF's Mole.basis attribute and thus can be assigned directly to
        Mole.basis to define atomic basis sets for molecular calculations. The
        exact structure of the returned dict is the module's internal basis
        format (elements or atom labels mapped to lists of shells/primitives and
        contraction coefficients) as produced by _parse.
    
    Notes:
        - This parser implements parsing for basis data in NWChem-style syntax as
          used in quantum-chemistry basis-set specifications. It does not perform
          I/O; the caller is responsible for providing the full text via the
          string parameter.
        - The function strips inline '!' comments and ignores '#' comment lines,
          trims whitespace, and discards lines equal to DELIMETER or blank lines
          before delegating to the internal _parse routine.
        - Any parsing errors (for example, malformed NWChem-format lines) are
          raised by the internal _parse implementation and propagate to the
          caller; callers should catch exceptions if they wish to handle invalid
          input gracefully.
        - Performance is linear in the number of input lines; for very large
          basis specifications consider streaming or pre-validating the input
          before calling this function.
    """
    from pyscf.gto.basis.parse_gaussian import parse
    return parse(string, optimize)


################################################################################
# Source: pyscf.gto.basis.parse_cp2k_pp.load
# File: pyscf/gto/basis/parse_cp2k_pp.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_parse_cp2k_pp_load(pseudofile: str, symb: str, suffix: str = None):
    """Parse and load the CP2K-format pseudopotential entry for a given element symbol and return it in PySCF's internal pseudopotential representation suitable for assignment to Cell.pseudo. This function is used in the pseudopotential handling pipeline of pyscf.gto.basis.parse_cp2k_pp: it locates the CP2K pseudopotential block for the requested atom symbol in the provided pseudofile, parses that block, and converts it to the internal format that PySCF uses when constructing Hamiltonians and integrals for calculations that use pseudopotentials (for example, periodic or molecular calculations that replace core electrons with an effective potential).
    
    Args:
        pseudofile (str): Path to the CP2K-format pseudopotential file to read. The string must identify the file containing one or more pseudopotential entries in CP2K pseudopotential format. The function will open and read this file to locate the entry corresponding to the requested element symbol; if the file cannot be opened, a standard file I/O exception (e.g., FileNotFoundError, IOError) from the underlying file operations will be propagated.
        symb (str): Chemical element symbol whose pseudopotential entry should be extracted from pseudofile (for example, 'H', 'O', 'Fe'). This parameter selects which element block to search for inside the CP2K pseudopotential file. The function searches the file for the matching entry and will raise an error (propagated from the internal search or parse routines) if no matching entry is found.
        suffix (str): Optional suffix used to disambiguate or select a specific variant of the pseudopotential entry for the given element when multiple variants are present in pseudofile. If suffix is None (the default), no suffix-based filtering is applied and the function will use the first matching entry found by the internal search. If a suffix is provided, the internal search logic will attempt to match that suffix to select the appropriate entry. Supplying an incorrect suffix may cause the search to fail and an exception to be raised.
    
    Returns:
        object: The parsed pseudopotential data in PySCF's internal pseudo format. The exact Python type of this return value is the internal representation expected by pyscf.gto.Cell.pseudo; the returned object is directly assignable to Cell.pseudo and will be consumed by PySCF routines that assemble integrals and Hamiltonians using pseudopotentials.
    
    Notes and failure modes:
        - This function performs no in-place modification of the input file; its only side effect is reading pseudofile.
        - Errors from the internal helper routines (search_seg and _parse) are propagated to the caller. Typical failure modes include: file not found or unreadable (file I/O exceptions), no matching element entry found in the pseudofile (search failure), and malformed or unsupported pseudopotential block formats that cannot be parsed (parse error). Callers should catch and handle these exceptions as appropriate for their application.
        - The parsed output is intended for use within the PySCF framework (for example, assigning to Cell.pseudo for pseudopotential-based electronic structure calculations) and provides the mapping from CP2K pseudopotential text to the internal data structures PySCF uses when replacing core electrons with an effective potential.
    """
    from pyscf.gto.basis.parse_cp2k_pp import load
    return load(pseudofile, symb, suffix)


################################################################################
# Source: pyscf.gto.basis.parse_nwchem.load
# File: pyscf/gto/basis/parse_nwchem.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_parse_nwchem_load(basisfile: str, symb: str, optimize: bool = True):
    """pyscf.gto.basis.parse_nwchem.load loads a single atomic basis definition for the given atomic symbol from an NWChem-format basis file and returns the parsed basis in the internal PySCF format used for building contracted Gaussian basis sets. This function is used by PySCF to read basis set segments from external basis files and convert them to the data structures consumed by integral evaluation and electronic-structure modules.
    
    Args:
        basisfile (str): Path to a file (or a file-like identifier supported by the parsing utilities) that contains one or more basis set definitions in NWChem format. In the context of PySCF quantum-chemistry workflows, this file supplies the raw primitive and contraction data that define the atomic basis functions used in molecular calculations. The function reads this file (via the internal search_seg helper) to locate the segment for the requested atom symbol.
        symb (str): Atomic symbol identifying which atom's basis to load (for example 'H', 'C', 'O', 'Fe'). This string is matched against basis-set segments found in basisfile; the function searches for a segment corresponding to symb and extracts the raw basis data for that atom. The symbol determines which contracted Gaussian-type orbital definitions are returned and thus directly affects the basis used in downstream PySCF computations.
        optimize (bool): Flag controlling parse-time post-processing passed through to the internal parser _parse. Default True. When True, the parser is instructed to perform optimizations/transformations on the raw basis segment (such as normalization, contraction cleanup, or other format-specific adjustments implemented by parse_nwchem._parse) so the returned data are in a form more directly suitable for PySCF integrals and mean-field procedures. When False, the parser will avoid such optimization and aims to preserve the raw input representation as closely as possible. The exact behavior of this flag is implemented by parse_nwchem._parse and may evolve between releases.
    
    Returns:
        object: The parsed basis data structure produced by parse_nwchem._parse for the requested atom symbol. This object is the internal representation used by PySCF to describe the contracted Gaussian basis (primitives, contraction coefficients, exponents, angular momentum information) for symb and is consumed by downstream routines that build integrals and perform electronic-structure calculations. The concrete structure and keys are those defined by the parse_nwchem implementation; callers should treat the return value as the canonical in-memory basis description for use with PySCF APIs.
    
    Raises:
        BasisNotFoundError: If no basis-set segment for symb can be located in basisfile, a BasisNotFoundError is raised with a message indicating the missing symbol. This is the normal failure mode when the requested atomic symbol is not present in the provided NWChem-format file.
        Exception: Any parsing errors or format violations detected by the internal parser _parse (for example malformed exponent/coefficient lines) are propagated to the caller; such exceptions indicate the input basisfile contains invalid or unrecognized NWChem basis data.
    """
    from pyscf.gto.basis.parse_nwchem import load
    return load(basisfile, symb, optimize)


################################################################################
# Source: pyscf.gto.basis.parse_cp2k_pp.search_seg
# File: pyscf/gto/basis/parse_cp2k_pp.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_parse_cp2k_pp_search_seg(pseudofile: str, symb: str, suffix: str = None):
    """Locate and return the pseudopotential entry for a given atomic symbol from a CP2K/GTH-format pseudopotential file.
    
    This function is part of the CP2K pseudopotential parsing helpers in pyscf.gto.basis.parse_cp2k_pp and is used by higher-level code in PySCF that needs to read and apply Goedecker–Teter–Hutter (GTH) style pseudopotentials shipped in CP2K-format files. It opens the file given by pseudofile, splits the file into pseudopotential blocks using the CP2K marker "#PSEUDOPOTENTIAL", and then delegates the per-block selection to an internal helper (_search_gthpp_block). The returned value is the raw pseudopotential block associated with the requested atom and is intended to be consumed by subsequent parsing routines that build PySCF internal pseudopotential/basis representations.
    
    Args:
        pseudofile (str): Filesystem path to the pseudopotential file to read. The file must be a CP2K/GTH-style pseudopotential file where entries are separated by the literal string "#PSEUDOPOTENTIAL". This function opens the file, reads its entire contents into memory, and closes the file before returning; large files will therefore allocate memory equal to the file size during the call.
        symb (str): Atomic symbol to search for in the pseudopotential file (for example, "C", "O", "Fe"). The function looks for the pseudopotential block that corresponds to this atomic symbol according to the naming conventions used in the file. This argument is required and must match the symbol as used in the pseudopotential file.
        suffix (str): Optional suffix to refine which pseudopotential variant is selected for the given atomic symbol. Many CP2K/GTH pseudopotential files contain multiple variants for the same element distinguished by suffixes; when provided, this string is passed to the internal selection routine to pick the matching variant. If None (the default), the function searches for the default/no-suffix entry for symb according to the file contents and the internal helper's selection rules.
    
    Returns:
        str: The raw pseudopotential text block extracted from the file for the requested atomic symbol (and optional suffix). The returned string corresponds to the content of one "#PSEUDOPOTENTIAL" block as read from the file and is suitable for further parsing by PySCF pseudopotential/basis-parsing routines.
    
    Raises:
        BasisNotFoundError: If no pseudopotential entry matching symb (and suffix, if provided) is found in pseudofile, a BasisNotFoundError is raised to signal that the requested pseudopotential is not available.
        OSError: If the file at pseudofile cannot be opened or read (for example, because it does not exist or due to permission errors), the underlying file I/O call will raise an OSError (or a subclass) which propagates to the caller.
    
    Behavioral notes:
        - The function reads the entire file into memory and splits on the literal marker "#PSEUDOPOTENTIAL", so the file must use that marker exactly for block separation.
        - The search logic and interpretation of suffix values are implemented in the internal helper _search_gthpp_block; suffix semantics follow that helper's rules and the CP2K/GTH naming conventions.
        - This routine performs no caching; repeated calls will re-open and re-read the file each time.
    """
    from pyscf.gto.basis.parse_cp2k_pp import search_seg
    return search_seg(pseudofile, symb, suffix)


################################################################################
# Source: pyscf.gto.basis.parse_nwchem.optimize_contraction
# File: pyscf/gto/basis/parse_nwchem.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_parse_nwchem_optimize_contraction(basis: list):
    """Search the basis segments which have identical primitive exponents and merge
    their contraction coefficient columns to produce more general-contracted
    segments suitable for downstream use in PySCF. This function is intended for
    use while parsing NWChem-style basis specifications (pyscf.gto.basis.parse_nwchem)
    to reduce redundant segments that share exactly the same exponent arrays.
    It differs from to_general_contraction in that the output may still contain
    multiple segments for a given angular-momentum/kappa key; only segments whose
    exponent arrays are exactly equal are merged.
    
    Args:
        basis (list): A list of basis-segment specifications in the same structural
            convention produced by the NWChem parser used elsewhere in pyscf.gto.
            Each element of this list must be a sequence (commonly a list) that
            encodes a single shell/segment. The function inspects the second entry
            of each element: if that entry is an int, it is treated as kappa and
            the grouping key becomes the tuple of the first two entries (angular
            moment and kappa). If the second entry is not an int, the grouping key
            becomes the tuple of the first entry only (angular moment). The remaining
            entries of each element are interpreted as primitive exponent(s)
            followed by one or more contraction coefficient columns. Concretely,
            the code reads the primitive exponents and coefficient columns by
            converting the tail of the sequence to a NumPy array and transposing it,
            so each input element must have a layout compatible with that operation.
            This parameter provides the raw, parsed basis segments that the function
            analyzes and potentially merges for more compact contracted representations.
    
    Behavior and practical significance:
        - Groups segments by their key (angular moment or angular moment + kappa).
        - For each group, compares primitive-exponent arrays using exact equality
          (numpy.array_equal). Only segments whose exponent arrays are exactly
          identical are merged: the coefficient columns from such segments are
          concatenated (extended) so that the merged segment contains all
          contraction columns belonging to that unique exponent set.
        - The function builds a new list of basis segments. The output ordering of
          groups is deterministic and given by sorted(basdic.keys()), i.e. sorted
          by the grouping key tuples; within a group the segments retain the order
          induced by the grouping/merging process.
        - The result reduces redundancy when multiple segments share identical
          primitive exponents, producing more general-contracted segments that are
          often preferred in quantum-chemistry calculations for efficiency and
          consistency of contracted basis representations used throughout PySCF.
    
    Side effects and defaults:
        - This function has no external side effects: it does not modify global
          state. It returns a newly constructed list and does not alter the input
          list object.
        - There are no optional parameters or defaults; behavior is fully determined
          by the structure and contents of the provided basis list.
        - Exponent comparison uses exact floating-point equality; numerically nearly
          identical exponents that differ by tiny round-off will not be merged.
    
    Failure modes and errors:
        - If an element of basis is not a sequence of sufficient length (the code
          indexes b[1] and then slices the tail), an IndexError may be raised.
        - If elements cannot be converted to a NumPy array with a consistent shape
          for transposition (e.g., heterogeneous nested structures), NumPy may raise
          a ValueError or TypeError during array construction or transpose.
        - Because exponent equality is checked with numpy.array_equal, segments with
          exponents that should be considered the same within a tolerance will not
          be merged unless their stored floating-point values are exactly equal.
        - The function assumes the input follows the NWChem-like segment layout;
          providing data in a different format can produce incorrect results or
          raise the above errors.
    
    Returns:
        list: A new list of basis-segment specifications in the same structural
        convention as the input. Segments that had identical primitive-exponent
        arrays have been merged by concatenating their contraction coefficient
        columns, producing more general-contracted segments while preserving the
        grouping by angular moment (and kappa when present). The output can be used
        in subsequent PySCF routines that expect contracted-basis input derived
        from NWChem-style specifications.
    """
    from pyscf.gto.basis.parse_nwchem import optimize_contraction
    return optimize_contraction(basis)


################################################################################
# Source: pyscf.gto.basis.load_ecp
# File: pyscf/gto/basis/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_load_ecp(filename_or_basisname: str, symb: str):
    """pyscf.gto.basis.load_ecp loads an effective core potential (ECP) definition for a specified element from a local file, the bundled PySCF basis directory, a NWChem-formatted basis string/name, or the Basis Set Exchange (BSE). This function is used in PySCF to obtain ECP data (pseudopotentials) required by quantum chemistry calculations to replace explicit core electrons with an effective potential for the element identified by symb.
    
    This function accepts either a filesystem path to an ECP file or a basis name/identifier. If filename_or_basisname is a path to an existing file, the file is parsed as a NWChem-format ECP file. If filename_or_basisname is not a file path, the function will canonicalize the name via the repository alias map and bundled basis directory, then try to parse it as a NWChem-format basis specification. If that fails, and if the optional Basis Set Exchange integration is available in the environment, the function will query BSE for the requested basis and extract ECP data for the given element. The returned ECP data can then be supplied to PySCF molecular/basis setup routines to apply a pseudopotential for the specified element during electronic-structure calculations.
    
    Args:
        filename_or_basisname (str): Filesystem path or basis identifier used to locate ECP data. When this argument is a path to an existing file, the function parses that file using the NWChem ECP parser. When it is not a file path, the function first normalizes the name against the internal ALIAS mapping and bundled basis directory, then attempts to parse the name as a NWChem-format ECP/basis name. If parsing fails, the function will attempt to retrieve the basis from the Basis Set Exchange (BSE) API (if available). This parameter is required and must be a string; it determines the source and semantics of the lookup performed by the loader.
        symb (str): Chemical element identifier (element symbol) for which to load ECP data, e.g. "Fe" or "O". The function strips any non-alphabetic characters from this string (symb = ''.join([i for i in symb if i.isalpha()])) to obtain the canonical symbol used for lookup. symb determines which element's ECP is returned from a multi-element basis file or from the BSE result; it is required and must be provided as a string.
    
    Returns:
        dict: A Python dictionary containing ECP specification(s) for the requested element. The exact dictionary structure follows the internal NWChem/ECP parsing conventions used by PySCF (a mapping of angular-momentum channels to exponent/coefficients or an element-specific ECP entry). When a source contains multiple elements and the caller requested a specific symb, the function returns the entry for that element. If the Basis Set Exchange is queried and returns no ECP data for the requested element, an empty dict is returned. The returned dictionary is intended to be consumed by PySCF molecular/basis setup code to configure an effective core potential for electronic-structure calculations.
    
    Behavior, side effects, and failure modes:
        - The function first strips non-letter characters from symb to derive the canonical element symbol used for lookup.
        - If filename_or_basisname denotes an existing file on disk (os.path.isfile returns True), the file is parsed with the NWChem ECP parser via an internal _load_external call; this performs file I/O and may raise parser-specific exceptions that are converted to BasisNotFoundError on failure.
        - If filename_or_basisname is not a file, the function canonicalizes the name using the internal _format_basis_name and ALIAS mapping and attempts to load from the bundled basis directory under _BASIS_DIR; this path-based lookup reads files from the PySCF installation and may raise BasisNotFoundError if the alias or file is not present.
        - The function then attempts to parse filename_or_basisname as a NWChem-format basis name first with the element symb supplied (parse(filename_or_basisname, symb)) and, if that fails, without symb (parse(filename_or_basisname)). Parse errors that are not explicitly handled are converted into BasisNotFoundError with a message indicating an invalid ECP or the original filename_or_basisname.
        - As a last resort, if the module pyscf.gto.basis.bse is available and its basis_set_exchange attribute is not None, the function will call the BSE API to fetch basis data for filename_or_basisname restricted to elements=symb. This step may perform network I/O or depend on a locally cached BSE client. If BSE returns ECP data, the function returns the element-specific entry; if BSE returns no ECP data for symb, the function returns an empty dict.
        - The function raises BasisNotFoundError when the requested ECP cannot be found in any of the attempted sources, when a provided filename or basis name is invalid, or when parsing fails in a way that the loader cannot recover from. Callers should catch BasisNotFoundError to handle missing or malformed ECP specifications.
        - No new files are written by this function; side effects are limited to file reads, potential network/API calls to BSE, and in-memory parsing.
    """
    from pyscf.gto.basis import load_ecp
    return load_ecp(filename_or_basisname, symb)


################################################################################
# Source: pyscf.gto.basis.parse_nwchem.remove_zero
# File: pyscf/gto/basis/parse_nwchem.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_parse_nwchem_remove_zero(basis: list):
    """pyscf.gto.basis.parse_nwchem.remove_zero removes basis-function exponents from an NWChem-style basis description when all of their contraction coefficients are exactly zero. This function is used by the PySCF NWChem basis parser to clean parsed basis sets: it reduces memory and avoids creating basis functions that contribute nothing to integrals or molecular orbitals by eliminating exponent rows whose contraction coefficients are all zero.
    
    Args:
        basis (list): A list representing an NWChem-style basis set for one atom or a group of shells. Each element of this list is itself a list (denoted b in the implementation) with the following expected layout derived from the NWChem parser context:
            - b[0] is the shell identifier (for example, an angular-momentum label such as 'S', 'P', etc.).
            - If present, b[1] may be an integer kappa (relativistic quantum number) detected by isinstance(b[1], int); when kappa is present, the exponent/coeff blocks start at b[2:].
            - Otherwise, exponent/coeff blocks start at b[1:].
            - Each exponent/coeff block (called e_c in the code) is a sequence where e_c[0] is the Gaussian exponent (numeric) and e_c[1:] are the contraction coefficients (one or more numeric coefficients).
        The function expects this structure because it tests b[1] and slices e_c[1:] to inspect contraction coefficients. If the input deviates from this shape (for example, b has fewer than two elements or e_c has fewer than two elements), the function may raise IndexError or TypeError.
    
    Behavior and practical significance:
        The routine iterates over each shell entry in basis and removes any exponent/coeff block e_c when every contraction coefficient in e_c[1:] is exactly equal to 0 (checked with the equality operator c != 0). Exponent/coeff blocks with any nonzero coefficient are preserved. Entire shells are omitted from the returned list if all their exponent blocks are removed. The function preserves the original ordering of shells and of preserved exponent blocks within each shell. If a shell includes an integer kappa as its second element (detected via isinstance(b[1], int)), that kappa value is retained unchanged in the returned shell key.
        This cleaning step is practical when parsing basis data from NWChem-formatted input or databases in PySCF: zero-contraction rows often indicate placeholders or removed contractions and should not produce actual basis functions. Removing them prevents wasted computation and potential singularities or ill-conditioned contributions in later integral or SCF steps.
    
    Side effects, defaults, and failure modes:
        - Side effects: None on the input argument; the function constructs and returns a new list. The input list basis is not modified.
        - Exact-zero test: The function uses exact equality (c != 0) to decide whether a contraction coefficient is nonzero. Very small floating-point values that are nonzero will be preserved; the function does not apply any numerical thresholding or rounding.
        - Structural assumptions: The function assumes each shell entry has at least the elements required to access b[1] and that each exponent/coeff block has at least one coefficient (so e_c[1:] is valid). If these assumptions are violated, the function can raise IndexError or TypeError. Callers should ensure the basis argument follows the NWChem-derived structure produced by the parse_nwchem module.
        - If all exponent/coeff blocks for a shell are removed (all had zero coefficients), that shell is omitted from the returned list. This is intentional and reduces the size of the basis description.
    
    Returns:
        list: A new basis list in the same NWChem-derived structure as the input but with exponent/coeff blocks removed when all their contraction coefficients are exactly zero. The returned list contains only shells that have at least one exponent block with a nonzero contraction coefficient.
    """
    from pyscf.gto.basis.parse_nwchem import remove_zero
    return remove_zero(basis)


################################################################################
# Source: pyscf.gto.basis.parse_nwchem_ecp.load
# File: pyscf/gto/basis/parse_nwchem_ecp.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_parse_nwchem_ecp_load(basisfile: str, symb: str):
    """Load effective core potential (ECP) definition for a specified atomic symbol from an NWChem-format basis/ECP file.
    
    This function is a thin convenience wrapper used in the PySCF gto/basis subsystem to obtain the ECP information that PySCF needs to attach pseudopotentials to atoms when building molecular integrals and Hamiltonians. Internally it locates the ECP block for the requested element in the provided file (via the module's _search_ecp helper) and converts that block into PySCF's internal representation (via the module's _parse_ecp helper). The returned value is intended to be consumed by other PySCF gto/basis routines that construct basis set and ECP data for quantum-chemistry calculations.
    
    Args:
        basisfile (str): Path to a text file containing basis and ECP definitions in NWChem-style format. This is the filename (string) the function will read from; the function does not modify the file. The file is expected to include one or more element-specific "ECP" sections in the style produced for NWChem basis sets so that the internal _search_ecp helper can locate the block for the requested element.
        symb (str): Chemical element symbol identifying the atom whose ECP should be loaded (for example "H", "Fe", "Au"). This symbol is matched against the element headings/labels used in the NWChem-format ECP sections in the basisfile. The caller should provide the element label exactly as it appears in the file.
    
    Returns:
        object: Parsed ECP data structure as produced by the internal _parse_ecp helper. This object encodes the effective core potential in the internal format that PySCF's gto/basis subsystem expects and is intended to be passed to downstream PySCF functions that attach ECPs to atomic centers. The precise Python container/type is the one returned by _parse_ecp and remains compatible with other PySCF gto/basis utilities.
    
    Behavior and side effects:
        The function reads the basisfile from the filesystem and does not alter the file or global interpreter state. It first searches for an ECP entry for symb; if found, it parses and returns the corresponding ECP block. If the file cannot be opened, does not contain an ECP entry for symb, or the located ECP block cannot be parsed, the call will raise an exception coming from the underlying helpers or I/O layer (for example FileNotFoundError when the file path is invalid, or a parsing/runtime exception if the ECP block is malformed). The function performs no network I/O and has no persistent side effects beyond reading the given file.
    """
    from pyscf.gto.basis.parse_nwchem_ecp import load
    return load(basisfile, symb)


################################################################################
# Source: pyscf.gto.basis.parse_nwchem.convert_basis_to_nwchem
# File: pyscf/gto/basis/parse_nwchem.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_parse_nwchem_convert_basis_to_nwchem(symb: str, basis: list):
    """Convert the internal PySCF basis representation into a NWChem-format basis set string suitable for writing into NWChem input files or for interoperability with NWChem-based workflows in quantum chemistry. This function is part of the pyscf.gto.basis.parse_nwchem module and is used to export PySCF's in-memory contracted Gaussian basis description into the plain-text format expected by NWChem, including a summary comment line and per-shell blocks of numerical primitive/contracted data.
    
    Args:
        symb (str): The chemical element symbol for which the basis is being converted. This is the atomic symbol (for example, "H", "C", "O") as used in PySCF; the function canonicalizes the input by calling the module-level helper _std_symbol(symb) so users may pass common variants and they will be normalized before appearing in the output. The canonicalized symbol is used as the first column of each shell header line in the resulting NWChem text.
        basis (list): The internal PySCF basis description for the given element. This must be a list in which each item (here called a shell) is an indexable sequence whose first element is an angular-momentum label (a key used to look up a letter in the module-level SPDF mapping, e.g., yielding "S", "P", "D", "F") and whose remaining elements are sequences of numeric values representing primitive/contracted Gaussian data (for example, exponent and contraction coefficient entries). The function iterates over basis to:
            - aggregate, per angular-momentum type, the total number of primitives and the number of contracted functions (used to produce a comment summary line in NWChem format),
            - then emit per-shell blocks where each shell header line contains the canonicalized element symbol and the angular-momentum letter (SPDF[bas[0]]), followed by lines of numeric data for each primitive/contracted datum formatted as fixed-width floating-point values.
            The practical significance is that this list is the PySCF internal representation of basis functions for a single atom; converting it to the NWChem layout enables reuse of PySCF-generated or PySCF-parsed basis sets in NWChem calculations.
    
    Behavior and side effects:
        - The function performs two passes over the provided basis list. The first pass computes aggregate counts of primitives and contracted functions grouped by angular-momentum label and writes a single summary comment line of the form "#BASIS SET: (nprims...) -> [nctrs...]" where counts are annotated with angular-momentum letters (lowercased) derived from SPDF. The second pass writes per-shell data blocks: a header line with the canonicalized element symbol and the angular-momentum letter, followed by numeric lines for each primitive datum.
        - Numeric lines are formatted using Python's "%15.9f" format for each float and joined by single spaces; shell header lines use a fixed spacing pattern "%-2s    %s".
        - The function does not modify its inputs; it returns a new string and has no other side effects such as file I/O.
        - The function relies on module-level helpers/constants (_std_symbol and SPDF) to map element symbols and angular-momentum labels; those must be present for correct operation.
    
    Failure modes and exceptions:
        - If a shell's angular-momentum label (the first element of a basis item) is not present in the module-level SPDF mapping, a KeyError will be raised when attempting SPDF[bas[0]].
        - If the basis list or its shell entries do not have the expected indexing structure (for example, missing elements so that bas[1:] or bas[1] are invalid), an IndexError or TypeError may occur.
        - If numerical entries in the primitive/contracted data are not coercible to float, a TypeError or ValueError may be raised during string formatting.
        - The caller should ensure basis uses the PySCF internal layout expected by the parse_nwchem module to avoid these errors.
    
    Returns:
        str: A multi-line string containing the basis set in NWChem plain-text format. The returned value begins with a single comment line summarizing per-angular-momentum primitive and contracted counts, followed by one block per shell. Each shell block begins with a header line containing the canonicalized element symbol and the angular-momentum letter (from SPDF), then one formatted numeric line per primitive/contracted datum. This string is ready to be written into a NWChem input file or otherwise consumed by tools that accept NWChem-style basis definitions.
    """
    from pyscf.gto.basis.parse_nwchem import convert_basis_to_nwchem
    return convert_basis_to_nwchem(symb, basis)


################################################################################
# Source: pyscf.gto.basis.parse_nwchem.to_general_contraction
# File: pyscf/gto/basis/parse_nwchem.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_parse_nwchem_to_general_contraction(basis: list):
    """to_general_contraction(basis)
    Convert a segmented-contracted basis representation into a general-contracted basis representation.
    
    This function is used in the PySCF quantum chemistry framework to convert basis-set sections that are expressed as segmented contractions (separate contraction blocks per primitive exponent) into a single general contraction per angular-momentum (and optional kappa) section. In practice this is useful when reading or manipulating basis sets (for example, NWChem-style segmented basis data or results from gto.uncontract/gto.contract flows) so that all primitives with the same angular momentum are represented by a shared list of unique exponents and a coefficient matrix describing general contraction vectors. The conversion preserves the angular-momentum grouping (and optional relativistic kappa) and combines coefficient blocks by placing them on a block-diagonal matrix before aggregating coefficients associated with identical exponents.
    
    Args:
        basis (list): A basis-set description in segmented-contracted form. Each element of this list represents one angular-momentum section and must have the following structure:
            - If the section includes a relativistic kappa index: [l, kappa, p1, p2, ...]
            - If no kappa is present: [l, p1, p2, ...]
          where l is an integer angular-momentum quantum number (e.g., 0 for s, 1 for p), kappa (if present) is an integer identifying the relativistic block, and each pi is a list-like primitive row with numeric entries: the first entry of pi is the primitive exponent (float) and the remaining entries are contraction coefficients (floats) for that primitive within the segmented contraction block. The function expects numeric types compatible with numpy conversion; malformed entries (missing elements, non-numeric values, or incorrect nesting) will raise IndexError/TypeError/ValueError during processing. This argument is not modified in place; the function builds and returns a new basis list.
    
    Behavior and algorithmic details:
        - Sections are grouped by their key: either (l, kappa) when a second integer element is present, or (l,) otherwise. All segments with the same key are combined into a single section.
        - For each key, the primitive exponents from all segments are concatenated into a single exponent array. The coefficient matrices from each segment are combined on the block diagonal (using scipy.linalg.block_diag) so that columns in the resulting coefficient matrix correspond to the original contracted functions from each segmented block in their original ordering.
        - Exponents that are numerically identical across segments are identified by rounding to 9 decimal places and then using numpy.unique to find duplicates. Duplicate exponents are merged into a single exponent row; their corresponding coefficient rows are summed so that the resulting coefficient row represents the combined contribution of all primitives with that exponent.
        - The unique exponents in each combined section are sorted from largest to smallest (descending), and the coefficient matrix rows are ordered to match that exponent ordering.
        - The function relies on numpy and scipy.linalg.block_diag for array manipulation and block-diagonal assembly; if these packages are unavailable or incompatible, an ImportError or related exception will occur when those modules are used.
    
    Returns:
        list: A new basis description in general-contracted form. Each element in the returned list corresponds to one angular-momentum (and optional kappa) section and has the structure:
            - If kappa is present: [l, kappa, [exp1, c1_1, c1_2, ...], [exp2, c2_1, c2_2, ...], ...]
            - If kappa is absent: [l, [exp1, c1_1, c1_2, ...], [exp2, c2_1, c2_2, ...], ...]
          where each row [expi, ci_1, ci_2, ...] contains a unique exponent (float) and its associated contraction coefficients (floats). The number of coefficient columns for a section equals the total number of contracted functions contributed by the original segmented blocks for that section. Duplicate exponents present across the original segments are merged; their coefficients are combined accordingly. The returned structure is suitable for downstream PySCF routines that expect general-contracted basis sections.
    
    Side effects and failure modes:
        - The input list is not modified; a new list is constructed and returned.
        - If an input section does not follow the expected layout (missing angular-momentum integer, missing exponent/coeff rows, or non-numeric entries), processing will typically raise IndexError, TypeError, or ValueError during numpy conversion or array operations.
        - If scipy.linalg.block_diag or numpy are unavailable or raise errors, the function will fail with the corresponding ImportError or runtime error.
        - Numerical deduplication of exponents is performed after rounding to 9 decimal places; near-equal exponents that differ beyond this precision will not be merged.
    """
    from pyscf.gto.basis.parse_nwchem import to_general_contraction
    return to_general_contraction(basis)


################################################################################
# Source: pyscf.gto.basis.parse_nwchem.parse
# File: pyscf/gto/basis/parse_nwchem.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_parse_nwchem_parse(string: str, symb: str = None, optimize: bool = True):
    """Parse a basis set specification given in NWChem format and return the corresponding
    PySCF internal basis representation that can be assigned to Mole.basis. This
    function is used within the PySCF framework (Python-based Simulations of
    Chemistry Framework) to convert textual basis-set data (for example copied from
    NWChem basis libraries or files) into the list/dictionary structure that PySCF
    molecules expect. The parser ignores comment lines starting with '#', blank
    lines, and lines beginning with the keywords "BASIS SET" or "END". When a
    chemical symbol is supplied, the function will search for and extract the basis
    block for that element; otherwise it parses all provided lines.
    
    Args:
        string (str): A string containing basis data in NWChem basis format. This
            is the raw textual input that may contain multiple element blocks,
            comment lines starting with '#', blank lines, and lines with the
            markers "BASIS SET" and "END" which are ignored by the parser. Typical
            inputs are multi-line strings copied from NWChem basis set files. The
            parser uses these lines to construct the internal representation via the
            internal helper _parse.
        symb (str): Optional. When provided, symb specifies the element symbol
            (e.g., "C", "O", "He") whose basis block should be extracted from
            string before parsing. The symbol is normalized by _std_symbol and the
            function searches for the corresponding block by splitting string with
            BASIS_SET_DELIMITER and calling _search_basis_block. If the requested
            element's block is not found, the function raises BasisNotFoundError.
            If symb is None, the entire provided string (after comment/blank-line
            filtering) is parsed as-is.
        optimize (bool): Default True. If True, optimize basis contraction by
            converting segment-contracted basis descriptions in the NWChem text to
            PySCF's general contracted basis representation. This conversion alters
            the contraction representation returned (but not the numerical basis
            data) so it matches PySCF's internal format expected by Mole.basis.
            If False, contraction forms are preserved as parsed without this
            optimization.
    
    Returns:
        list: The parsed basis expressed in PySCF's internal basis format (a list
        structure suitable for assignment to Mole.basis). The exact nested list
        structure is produced by the internal helper _parse and corresponds to the
        convention used throughout PySCF for representing shells, exponents, and
        contraction coefficients (see examples in source comments). This return
        value contains no side effects beyond the returned data; it does not modify
        global state or the Mole object.
    
    Behavior, side effects, defaults, and failure modes:
        - Comment handling: Lines beginning with '#' are treated as comments and
          ignored. Blank/empty lines are ignored.
        - Block markers: Lines that begin (case-insensitive) with "BASIS SET" or
          "END" are ignored while collecting lines to parse.
        - Element selection: If symb is provided, the function normalizes the symbol
          and searches for a matching element block; absence of a matching block
          causes BasisNotFoundError to be raised.
        - Parsing: After filtering, the remaining lines are passed to the internal
          _parse function along with the optimize flag to produce the final list
          representation. If the NWChem text is malformed, the underlying parsing
          routine (_parse) may raise parsing-related exceptions (e.g., ValueError or
          custom parse errors).
        - Defaults: By default optimize=True to produce a general-contracted basis
          representation consistent with PySCF conventions.
        - Side effects: The function does not write files or modify global/module
          state; its effect is limited to returning the parsed data or raising an
          exception on error.
    
    Practical significance:
        - Use this function when importing basis sets provided in NWChem text format
          into PySCF calculations. The output can be assigned directly to
          Mole.basis to define the atomic orbital basis for subsequent electronic
          structure computations within the PySCF framework.
    """
    from pyscf.gto.basis.parse_nwchem import parse
    return parse(string, symb, optimize)


################################################################################
# Source: pyscf.gto.basis.parse_nwchem_ecp.convert_ecp_to_nwchem
# File: pyscf/gto/basis/parse_nwchem_ecp.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_parse_nwchem_ecp_convert_ecp_to_nwchem(symb: str, ecp: list):
    """Convert the internal ECP data structure used by PySCF into a text string
    formatted for NWChem ECP input blocks. This function is used in the PySCF
    gto/basis subsystem to export effective core potentials (ECPs) so they can be
    consumed by NWChem or written into NWChem-compatible input files when sharing
    pseudopotential data between quantum chemistry packages.
    
    Args:
        symb (str): Atomic symbol for which the ECP is defined. This symbol is
            normalized by the local helper _std_symbol before formatting, so the
            caller may pass common forms (for example 'C', 'c', or other variants
            accepted by _std_symbol). In the NWChem output the normalized symbol
            appears as the label at the start of each ECP line and header.
        ecp (list): Internal PySCF representation of the ECP for the given atom.
            The function expects ecp to be an indexable sequence whose first
            element (ecp[0]) is an integer used as the NWChem "nelec" value (the
            number printed after "nelec" on the first output line). The second
            element (ecp[1]) must be an iterable of ECP blocks; each block is a
            sequence or two-element structure where the first element is an
            integer angular-momentum index l and the second element is an iterable
            indexed by radial order. For each block:
                - If l == -1 the function writes a header line containing "ul"
                  after the atom symbol (this corresponds to the unlabeled/local
                  potential block in the module's convention).
                - Otherwise the integer l is mapped via the module-level SPDF
                  mapping to an angular-momentum letter (for example the mapping
                  used in this module maps indices to s/p/d/f style letters),
                  and the lowercased letter is written on the header line after
                  the atom symbol.
            The second element of each block (the radial-order container) is
            iterated with enumerate(...) to obtain r_order (an integer radial
            order starting from 0) and dat (an iterable of (exponent, coefficient)
            pairs). Each (exponent, coefficient) pair must be a two-element
            numeric sequence (both castable to float) and will be written as a
            data line containing the radial order and two floating-point numbers
            formatted with "%15.9f". A caller should therefore supply ecp in the
            same internal shape used elsewhere in PySCF: [nelec, [ [l, [dat_r0,
            dat_r1, ...]], ... ] ] where each dat_rX is iterable of (e, c).
            If the structure or element types do not conform to these
            expectations the function will raise typical Python exceptions
            (IndexError, TypeError, ValueError) when attempting to access or
            format the values.
    
    Returns:
        str: A single string containing the ECP formatted in the NWChem plain-text
        convention. The string is constructed as a sequence of lines joined with
        '\n'. The first line has the pattern "<symb> nelec <N>" where <N> is
        ecp[0] formatted as an integer. For each ECP block a header line is
        emitted as "<symb> ul" when the block's l == -1, otherwise as "<symb>
        <letter>" where <letter> is the lowercased SPDF mapping of the block's
        angular-momentum index. Following each header, one line is emitted for
        every (exponent, coefficient) pair in each radial-order entry using the
        format "%d    %15.9f  %15.9f" where the integer is the radial order and
        the two floats are the exponent and coefficient respectively. The function
        performs no file I/O and has no side effects beyond calling _std_symbol
        and reading module-level constants; the returned string must be written by
        the caller if persistence is desired.
    
    Failure modes and notes:
        - If ecp is not structured as described above the code will raise standard
          Python exceptions (IndexError/TypeError/ValueError) during indexing or
          string formatting.
        - The mapping SPDF referenced by the implementation is a module-level
          sequence used to convert integer angular-momentum indices to letters;
          callers should rely on the module's documented conventions for the
          meaning of angular-momentum indices.
        - This function is intended for interoperability/export within the PySCF
          project (see PySCF README) and produces text matching the simple NWChem
          ECP block conventions used elsewhere in the codebase.
    """
    from pyscf.gto.basis.parse_nwchem_ecp import convert_ecp_to_nwchem
    return convert_ecp_to_nwchem(symb, ecp)


################################################################################
# Source: pyscf.gto.basis.parse_nwchem_ecp.parse
# File: pyscf/gto/basis/parse_nwchem_ecp.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_parse_nwchem_ecp_parse(string: str, symb: str = None):
    """Parse NWChem-formatted effective core potential (ECP) text and return it in the PySCF internal basis format used for attaching ECPs to atoms (i.e., suitable for assignment to Mole.ecp). This function is used in the PySCF quantum chemistry framework to convert textual ECP blocks produced for NWChem into the data structure that PySCF's electronic structure routines consume when applying effective core potentials to atoms in molecular calculations.
    
    Args:
        string (str): Raw ECP content as a single string in NWChem format. The string may contain multiple ECP blocks for different elements, comment text beginning with '#' on a line, blank lines, and header/trailer lines. Typical use is to pass the contents of an ECP file (e.g., a NWChem ECP file) so PySCF can parse and attach those ECPs to a Mole object for subsequent calculations.
        symb (str): Optional atomic symbol (for example, 'Fe', 'H', 'O') that restricts parsing to the ECP block for that element only. When provided, the function first standardizes the symbol using the internal _std_symbol helper and then locates the first line in the input whose first token matches that standardized symbol; only the contiguous lines belonging to that element's block are considered. If symb is None (the default), the function attempts to parse all ECP entries found in the input text.
    
    Behavior and practical details:
        This function implements a parser for NWChem-style ECP sections. It strips inline comments after the '#' character and removes purely empty lines. Header or trailer lines that begin with the tokens 'ECP' or 'END' (case-insensitive) are ignored and not passed to the lower-level parser. When symb is supplied, lines before the identified symbol block are skipped and parsing stops when a subsequent leading token is alphabetic and does not match the requested symbol, which isolates the requested element's block. The behavior follows the original intent documented in the upstream code (which also mentions ignoring lines such as 'BASIS SET' and 'END'); the implementation explicitly filters comments, empty lines, and lines that begin with 'ECP' or 'END'. The function delegates the final interpretation of the cleaned text lines to the internal helper _parse_ecp, which produces the internal ECP representation used by PySCF.
        Defaults: symb defaults to None, meaning parse all ECP blocks present in string.
        Side effects: The function performs only string processing and returns a parsed data structure; it does not modify global state. The returned value is intended to be assigned to Mole.ecp when configuring a molecule for a calculation that uses effective core potentials.
        Failure modes and exceptions: If symb is provided but no block for that standardized symbol is found in the input lines, the function raises BasisNotFoundError indicating the requested ECP was not found. If the input text is malformed in a way that the downstream helper _parse_ecp cannot interpret, that helper may raise parsing-related exceptions (propagated to the caller). Callers should ensure the string is valid NWChem ECP text or handle these exceptions.
    
    Returns:
        object: The parsed ECP data in PySCF's internal basis format (the format produced by the internal helper _parse_ecp), suitable for assignment to Mole.ecp so that PySCF's ECP-aware routines can apply the parsed effective core potentials during quantum chemistry calculations.
    """
    from pyscf.gto.basis.parse_nwchem_ecp import parse
    return parse(string, symb)


################################################################################
# Source: pyscf.gto.mole.bse_predefined_ecp
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_bse_predefined_ecp(basis_name: str, elements: list):
    """pyscf.gto.mole.bse_predefined_ecp: Find predefined effective core potential (ECP) information for a requested basis set name and a list of atomic species using the BSE (Basis Set Exchange) metadata cached in the module. This function is used by PySCF to determine whether a given basis set (identified by basis_name) has an associated ECP definition in the repository of predefined BSE metadata and, if so, which atoms in the provided elements list require that ECP. The practical significance is to enable automatic selection or validation of ECPs when building molecular basis descriptions for electronic structure calculations.
    
    Args:
        basis_name (str): Name of the basis set to query. This string is normalized with basis._format_basis_name and looked up in the module-level BSE_META mapping to find BSE-provided metadata. If basis_name is not a str, the function returns (None, None) immediately. Typical values come from user input or basis set selection routines in PySCF and are intended to match keys in BSE_META after normalization.
        elements (list): Sequence of atom identifiers for which ECP applicability is checked. The function accepts a list of atom identifiers; if a single string is provided, it is converted to a one-element list. Each element of the list is passed to the module's charge() helper to obtain an atomic number for comparison with the ECP element list stored in BSE_META. In practice elements contains atomic symbols (e.g., 'C', 'H') or other forms accepted by charge(); the function computes a unique set of atomic numbers from the provided entries before intersecting with the ECP-capable elements for the requested basis.
    
    Returns:
        tuple: A 2-tuple (ecp, ecp_atoms) describing the ECP information found in the BSE metadata for the requested basis and the supplied elements.
            ecp (str or None): The canonical BSE-format basis set name (basis_meta[0]) that has associated ECPs, returned only if there is at least one matching element from the provided elements list. This string is the standard format name from the BSE metadata and can be used by higher-level code to reference the ECP definition. If no matching ECPs are found or the basis_name is not present in BSE_META, this value is None.
            ecp_atoms (set or None): A set of atomic identifiers (as atomic numbers returned by charge()) that both appear in the provided elements list and are listed in the ECP elements for the basis in BSE_META. If no elements match the ECP-capable atoms for the basis, or basis_name is invalid/nonexistent, this value is None. When non-None, this set indicates exactly which atomic species in the input would use the predefined ECP for the selected basis.
    
    Behavior, side effects, defaults, and failure modes:
        - The function normalizes basis_name via basis._format_basis_name(basis_name).lower() and then consults BSE_META for metadata. It does not modify BSE_META or other global state.
        - If basis_name is not an instance of str, the function immediately returns (None, None).
        - If elements is passed as a single str, it is converted to [elements]; otherwise it is treated as an iterable and de-duplicated by converting to a set before processing.
        - Each entry in elements is converted to an atomic number with charge(); therefore elements must be given in a form accepted by charge() (e.g., atomic symbols or numeric atomic numbers as supported by that helper).
        - If BSE_META contains no entry for the normalized basis_name, the function returns (None, None).
        - If a basis entry exists in BSE_META but it lists no ECP-capable elements, or none of the provided elements intersect with the basis's ECP element list, the function returns (None, None).
        - On success (there is a non-empty intersection between provided elements and the basis's ECP elements), the function returns the standard-format basis name from BSE_META as ecp and the set of matching atomic numbers as ecp_atoms.
        - No exceptions are raised by this function for normal lookup failures; failure modes are represented by returning (None, None). Exceptions may propagate from called helpers (for example, if charge() raises for an invalid element format).
    """
    from pyscf.gto.mole import bse_predefined_ecp
    return bse_predefined_ecp(basis_name, elements)


################################################################################
# Source: pyscf.gto.mole.cart2j_kappa
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_cart2j_kappa(kappa: int, l: int = None, normalized: str = None):
    """pyscf.gto.mole.cart2j_kappa: Construct the Cartesian-to-spinor transformation matrix for a given Dirac kappa.
    This function produces the complex-valued transformation matrix used in PySCF to map
    Cartesian Gaussian-type orbital (GTO) basis functions onto spinor spherical components
    parameterized by the relativistic quantum number kappa. It is used when building
    spinor integrals and interfacing with the libcint library (moleintor.libcgto.CINTc2s_ket_spinor_sf1)
    in relativistic electronic-structure calculations.
    
    Args:
        kappa (int): The Dirac kappa quantum number that identifies the spinor angular
            momentum coupling to be constructed. For positive kappa, the corresponding
            orbital angular momentum is l = kappa. For negative kappa, l is inferred
            as l = -kappa - 1. If kappa == 0 the caller must provide l explicitly
            (see l below). The sign and magnitude of kappa determine the number of
            spinor components (nd) produced by the transformation; the function uses
            the same kappa convention as the underlying libcint routine CINTc2s_ket_spinor_sf1.
        l (int or None): The orbital angular momentum quantum number (non-negative integer)
            used only when kappa == 0. In that special case, the code asserts that l is
            not None and also asserts l <= 12; if these assertions fail the function
            raises an AssertionError. For kappa != 0 this argument is ignored because
            l is derived from kappa by the rules described above. The number of Cartesian
            basis functions per spin (nf) is computed internally as (l+1)*(l+2)//2.
        normalized (str or None): Controls the normalization convention applied to the
            returned transformation matrix relative to the libcint convention. If set to
            the string 'sp' the function leaves the matrix in the same s/p-normalization
            convention used by the libcint library (the libcint convention mentioned in
            the original source). If set to any other value (including the default None),
            the function rescales the matrix for low angular momenta to match PySCF's
            non-'sp' normalization: a multiplicative factor is applied for l == 0 and
            l == 1 (numeric constants implemented in the source). This parameter does
            not accept other types; passing a non-string value may produce a behavior
            equivalent to the default branch (treated as not equal to 'sp').
    
    Returns:
        numpy.ndarray: A complex128 NumPy array containing the Cartesian-to-spinor
        transformation matrix with shape (2, nf, nd). The leading axis indexes spin
        component: index 0 corresponds to the spin-up transformation, and index 1
        corresponds to the spin-down transformation. nf is the number of Cartesian
        basis functions for the chosen l, computed as (l+1)*(l+2)//2. nd is the number
        of target spinor components and depends on kappa (for kappa>0, nd = 2*l;
        for kappa<0, nd = 2*l + 2; for kappa==0, nd = 4*l + 2 when l is provided). The
        returned array has dtype numpy.complex128 and Fortran (column-major) memory
        ordering in the intermediate construction, and is reshaped to (2, nf, nd)
        before being returned.
    
    Behavior, side effects, and failure modes:
        This routine builds the transformation matrix by calling the external libcint
        helper function moleintor.libcgto.CINTc2s_ket_spinor_sf1 via ctypes. Therefore,
        a functional installation of the corresponding compiled library and the
        moleintor.libcgto binding is required; if that symbol is not available an
        AttributeError or an ImportError will be raised when the function is invoked.
        The function asserts when kappa == 0 and l is None or when the provided l > 12,
        raising AssertionError in those cases. For kappa values outside reasonable
        physical ranges the behavior follows the libcint implementation; no additional
        input validation is performed beyond the assertions described. The numeric
        rescaling applied when normalized != 'sp' is implemented only for l == 0 and
        l == 1 in the source; other l values are left unchanged by that branch.
        No in-place modification of user arrays occurs; the function allocates and
        returns a new NumPy array.
    """
    from pyscf.gto.mole import cart2j_kappa
    return cart2j_kappa(kappa, l, normalized)


################################################################################
# Source: pyscf.gto.mole.atom_types
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_atom_types(atoms: list, basis: dict = None, magmom: numpy.ndarray = None):
    """pyscf.gto.mole.atom_types identifies symmetry-inequivalent atom groups in a PySCF molecular atom list and optionally refines those groups by atomic basis equivalence and collinear magnetic moment. It is used in PySCF to determine which atom indices share the same chemical identity and basis representation (important for assigning basis sets, exploiting molecular symmetry, and handling ghost atoms), and to split those groups further when spin polarization (magnetic moment) distinguishes otherwise identical atomic sites.
    
    Args:
        atoms (list): A list of atom descriptors in the same format used by PySCF molecular input. Each entry is expected to be an indexable sequence whose first element is the atomic label string (for example 'H', 'C', 'O', or a label beginning with 'GHOST'). The function uses the first element of each atom descriptor as the symbol to group by and returns indices into this input list. The index values in the returned groups are zero-based positions into this list.
        basis (dict): Optional mapping from atom labels (strings) to basis specification objects (the same basis identifiers used elsewhere in PySCF). When basis is None (the default), grouping is done by the raw atom label string (after handling GHOST renaming). When a basis dict is provided, the function consults a standardization routine (_std_symbol) to compare the provided atom label and its standardized symbol; atoms whose basis entries are identical (basis[a_label] == basis[std_symbol]) are merged under the standardized symbol key. This behavior is used to ensure that atoms with equivalent basis definitions (even if labeled differently) are treated as symmetry-equivalent for basis assignment. The basis argument must be a dict if provided; the function does not change basis itself.
        magmom (numpy.ndarray): Optional one-dimensional array of per-atom magnetic moment identifiers used to further split atom groups by collinear spin orientation. The array is converted internally with numpy.asarray; each element is compared against the group's atom indices. Allowed magmom values are exactly -1, 0, or 1, which the function maps to suffixes 'd', 'o', and 'u' respectively. If magmom is provided, groups that contain more than one unique magmom value are subdivided into new dictionary keys formed as "ELEMENT_suffix" (for example "Fe_u" for up, "Fe_d" for down, "Fe_o" for zero). The magmom array must have one entry for each atom index referenced in atoms; if its length or indexing is inconsistent with atoms, an IndexError may occur.
    
    Returns:
        dict: A dictionary mapping element keys (strings) to lists of integer atom indices (list of int). Keys are typically the atom label or a standardized element symbol returned by _std_symbol. If an atom label started with 'GHOST' (case-insensitive), it is renamed internally to a label starting with 'X' followed by the characters after 'GHOST' (for example 'GHOST-H' becomes 'X-H') and that renamed label appears as the key. When magmom is provided and a group contains multiple distinct magmom values, additional keys are created by appending an underscore and a one-letter suffix to the element key: '_u' for magmom == 1, '_d' for magmom == -1, and '_o' for magmom == 0; the associated values are lists of zero-based atom indices that belong to that subgroup. The function does not modify the input atoms list or the basis dict; it returns a new dictionary describing the grouping.
    
    Raises and failure modes:
        RuntimeError: Raised when magmom contains a value that is not one of -1, 0, or 1. The error message is "Magmom should be chosen from [-1, 0, 1], but %s is given" where %s is the offending magmom value.
        IndexError: May be raised if magmom is provided but its length or indexing does not cover the atom indices referenced in atoms (the function indexes magmom with positions from atoms without explicit length checks).
        KeyError: Not raised by the grouping logic when basis is present because the code checks membership before dictionary access; however, providing an unexpected basis structure (not a dict mapping labels to comparable basis objects) can lead to unexpected errors elsewhere.
    
    Behavioral notes and side effects:
        The function treats atom label matching in a case-sensitive way except for detection of the substring 'GHOST' which is checked case-insensitively. It internally calls a standardization helper (_std_symbol) to obtain a canonical element symbol for comparisons; readers should consult the module implementation of _std_symbol to understand how nonstandard labels are normalized. The returned index lists reference the original atoms list and are suitable for downstream operations in PySCF that need groups of equivalent atomic sites for symmetry, basis assignment, or spin-polarized calculations. The function creates and returns a new dictionary and does not mutate the atoms or basis inputs.
    """
    from pyscf.gto.mole import atom_types
    return atom_types(atoms, basis, magmom)


################################################################################
# Source: pyscf.gto.mole.cart2j_l
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_cart2j_l(l: int, normalized: str = None):
    """pyscf.gto.mole.cart2j_l: Compute the Cartesian-to-spinor transformation matrix for angular momentum l used in PySCF to convert Cartesian Gaussian-type orbitals (GTOs) into a spinor angular-momentum basis block. This transformation is used in PySCF when assembling integrals or converting basis-function coefficient vectors between Cartesian GTO representations and spinor (total-angular-momentum) representations required for relativistic or spinor-enabled electronic-structure operations.
    
    Args:
        l (int): The orbital angular momentum quantum number for which the transformation matrix is requested. Typical values are 0 for s, 1 for p, 2 for d, etc. This parameter selects the size and structure of the returned transformation block corresponding to the set of Cartesian GTOs with angular momentum l. In practice, callers supply the same l used to enumerate the Cartesian basis functions so that multiplying the returned matrix with a vector of Cartesian GTO coefficients yields the coefficients in the spinor-angular-momentum representation for that l.
        normalized (str): How the Cartesian GTOs are normalized before transformation. Accepted values documented here are None and 'sp'. When normalized == 'sp', the s and p functions are normalized according to the convention used by the libcint library; this affects the numerical values of the transformation matrix so it matches libcint-produced integrals and routines. When normalized is None, the function defers to the default normalization behavior implemented by the underlying cart2spinor_kappa(0, l, normalized) call. The caller should pass the same normalization convention used elsewhere in their workflow (for example, to match integral evaluation conventions) to avoid inconsistent normalization between basis sets and integrals.
    
    Returns:
        The Cartesian-to-spinor transformation matrix for angular momentum l produced by calling cart2spinor_kappa(0, l, normalized). The returned matrix is intended to be applied to a vector of Cartesian GTO coefficients for angular momentum l to obtain the coefficients in the spinor-angular-momentum basis. Consult cart2spinor_kappa for the precise array type, dimensionality, and memory layout returned in your PySCF installation. There are no side effects from calling this function.
    
    Failure modes and notes:
        The function delegates validation and construction to cart2spinor_kappa(0, l, normalized). If l is not a non-negative integer or if normalized contains an unsupported value, the underlying routine may raise an exception (TypeError or ValueError). To ensure consistency across a calculation, use the same normalized convention when obtaining transformation matrices and when evaluating integrals (for example, to match libcint conventions).
    """
    from pyscf.gto.mole import cart2j_l
    return cart2j_l(l, normalized)


################################################################################
# Source: pyscf.gto.mole.cart2zmat
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_cart2zmat(coord: numpy.ndarray):
    """pyscf.gto.mole.cart2zmat converts a list/array of Cartesian atomic coordinates into a z-matrix style multiline string used by PySCF for simple text representation of molecular geometry.
    
    Args:
        coord (numpy.ndarray): Array of Cartesian coordinates for the atoms in the molecule. The function expects coord to be an array-like sequence of 3D position vectors (typically shape (N, 3) where N is the number of atoms) containing numeric values. Each row coord[i] is the Cartesian position of atom i in the same linear coordinate units used by the caller (the function does not perform unit conversion). In the PySCF context, this function is used to produce a compact z-matrix-style string that can be printed, logged, or used when constructing simple geometry input fragments for molecular calculations; the coordinates provided determine all bond lengths, bond angles, and dihedral angles computed by the function.
    
    Behavior and practical details:
        The function emits a multiline string where each line corresponds to one atom expressed in a z-matrix-like format. The first line is always the literal "1" (the function uses the value '1' as a placeholder element/label for each atom in this textual representation). For two atoms the second line contains the index of the reference atom (1) followed by the bond distance between atom 2 and atom 1. For three atoms the third line contains the bond distance from atom 3 to atom 1 and the bond angle at atom 1 between atoms 2 and 3. For four or more atoms each subsequent line contains three reference indices and three numeric values: the bond distance to the primary reference atom, the bond angle (in degrees) with respect to the secondary reference, and the dihedral angle (in degrees) defined using the tertiary reference. Indices used in the output are 1-based and refer to earlier atoms in the order given by coord. Numeric formatting uses '%.15g' for distances and angles converted to degrees with high precision.
    
        The function determines angles and dihedrals using vector dot and cross products via numpy. To detect special geometric cases it compares cross-product norms to a small tolerance: a cross-product norm abs(nb) < 1e-7 is treated as collinear. When three points that define an angle or dihedral are collinear the corresponding dihedral angle is set to 0.0 degrees in the output. The code computes arccos of normalized dot products to obtain angles; because arccos is sensitive to floating point rounding, inputs slightly outside [-1, 1] may generate warnings or NaNs if the caller supplies degenerate coordinates (for example, duplicate points producing zero-length vectors).
    
    Side effects and defaults:
        The function has no external side effects (it does not modify the input array, global state, or files). It does import and use numpy functions internally. There are no optional parameters or defaults beyond the implicit 1e-7 collinearity tolerance and the string numeric formatting shown above.
    
    Failure modes and error conditions:
        Providing coord with fewer than the expected number of components per atom (not 3D vectors) or supplying non-numeric entries can lead to exceptions from numpy (for example ValueError or TypeError) or propagate NaNs/inf in the output. If any pairwise vector used in angle or dihedral calculations has zero length (e.g., duplicate coordinates) the division by the vector norm may produce a division-by-zero, resulting in RuntimeWarnings and NaN values in the produced string. The user should validate that coord contains distinct, well-formed 3D coordinates to avoid these numerical issues.
    
    Returns:
        str: A newline-separated string representing a z-matrix style description of the input geometry. Each line corresponds to an atom and contains the element placeholder '1' followed by numeric fields: for the second atom a single bond length; for the third atom a bond length and bond angle in degrees; for the fourth and subsequent atoms a bond length (to a reference atom), a bond angle in degrees, and a dihedral angle in degrees. The returned string is suitable for printing or simple logging within PySCF workflows that require a human-readable z-matrix-like geometry fragment.
    """
    from pyscf.gto.mole import cart2zmat
    return cart2zmat(coord)


################################################################################
# Source: pyscf.gto.mole.cart2sph
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_cart2sph(l: int, c_tensor: numpy.ndarray = None, normalized: str = None):
    """Cartesian to real spherical transformation matrix.
    
    Converts coefficients or a transformation tensor for Cartesian Gaussian-type orbitals
    (GTOs) into the corresponding coefficients in the real (tesseral) spherical-harmonic
    representation used by PySCF and the underlying libcint integrals. This function is
    used in atomic-orbital basis conversions and integral transformations inside the
    PySCF quantum-chemistry framework (for example, when translating Cartesian AO
    representations to real spherical AOs for integral evaluation or post-processing).
    
    Behavior and domain significance:
    - The angular momentum quantum number l selects the shell type (l=0 -> s, l=1 -> p,
      l=2 -> d, ...). The function computes a matrix that maps Cartesian GTO components
      (nf = (l+1)*(l+2)//2 Cartesian functions) to real spherical harmonics (nd = 2*l+1).
      These sizes are used throughout PySCF and libcint when handling basis functions.
    - For l == 0 or l == 1 the conversion is trivial up to a normalization scaling:
      if normalized == 'sp' (the libcint convention where s and p functions are already
      normalized), the input tensor is returned unchanged; otherwise a fixed scalar
      normalization factor is applied (0.282094791773878143 for s, and
      0.488602511902919921 for p). These numeric factors are the standard normalization
      constants that map unnormalized Cartesian s/p basis functions to the real spherical
      normalization used in PySCF and libcint.
    - For 2 <= l <= 15 the function calls the compiled C helper moleintor.libcgto.CINTc2s_ket_sph
      to form the full Cartesian-to-spherical transformation. The C function writes into
      a Fortran-ordered output buffer for efficient downstream use in PySCF integrals.
    - The function asserts l <= 15; angular momenta above 15 are not supported and will
      raise an AssertionError.
    
    Args:
        l (int): Angular momentum quantum number for the shell whose Cartesian-to-spherical
            transformation is requested. l determines the number of Cartesian functions
            nf = (l+1)*(l+2)//2 and the number of real spherical functions nd = 2*l+1.
            This parameter selects the shell type (0=s, 1=p, 2=d, ...). The implementation
            supports 0 <= l <= 15; values greater than 15 trigger an AssertionError.
        c_tensor (numpy.ndarray): Optional input Cartesian coefficient tensor or matrix.
            When None (the default), an identity nf-by-nf matrix is used, producing the
            pure Cartesian->spherical transformation matrix for the chosen l. If provided,
            the array is converted with numpy.asarray(..., order='F') and reshaped to
            (-1, nf) so that the number of rows (ngrid) can be any integer and each row
            contains nf Cartesian components. This allows conversion of multiple Cartesian
            coefficient vectors (one per row) in a single call. The function returns an
            array with the same row count (ngrid) transformed to spherical components.
            The reshaping and Fortran memory order are side effects: the input is not
            modified in-place but is read after conversion and reshape.
        normalized (str): Controls s/p normalization handling. If set to the string
            'sp' (the libcint convention), s and p functions are assumed already normalized
            and no additional scalar normalization is applied for l==0 or l==1; in that
            case the function returns c_tensor unchanged (except for the array conversion
            and reshape described above). Any other value (including None) causes the
            standard scalar normalization factors to be applied for l==0 and l==1. This
            parameter is only consulted for l in {0, 1}; it is ignored for l >= 2.
    
    Returns:
        numpy.ndarray: A NumPy array containing the Cartesian-to-real-spherical transformed
        coefficients. If c_tensor was reshaped to shape (ngrid, nf), the returned array
        has shape (ngrid, nd) with nd = 2*l+1. For the common case c_tensor is None, the
        function returns the transformation matrix of shape (nf, nd) obtained by applying
        the conversion to an nf-by-nf identity (nf = (l+1)*(l+2)//2). For l == 0 or l == 1
        the function returns the (possibly scalar-scaled) c_tensor (after conversion and
        reshape); for l >= 2 it returns the array produced by the compiled C routine.
        The returned array uses floating-point numeric type (float64 by default) and, for
        l >= 2, is allocated in Fortran (column-major) order for compatibility with the
        underlying C/Fortran integrals.
    
    Failure modes and side effects:
    - AssertionError if l > 15.
    - If the compiled C helper moleintor.libcgto.CINTc2s_ket_sph is unavailable or fails,
      an AttributeError or an error propagated from the C layer may be raised.
    - The function performs a numpy.asarray(..., order='F') conversion and reshape of
      c_tensor; this conversion is not done in-place and the original object is not
      modified, but the returned array may have different memory layout/dtype than the
      original input.
    """
    from pyscf.gto.mole import cart2sph
    return cart2sph(l, c_tensor, normalized)


################################################################################
# Source: pyscf.gto.mole.conc_env
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_conc_env(
    atm1: numpy.ndarray,
    bas1: numpy.ndarray,
    env1: numpy.ndarray,
    atm2: numpy.ndarray,
    bas2: numpy.ndarray,
    env2: numpy.ndarray
):
    """pyscf.gto.mole.conc_env concatenates the integral environment arrays of two Mole-like objects to build a single combined environment suitable for computing cross-molecule integrals (for example, integrals between basis functions µ on mol1 and ν on mol2, <µ|ν>). This helper is used in PySCF to prepare the internal integer/pointer tables (atm, bas) and the floating-point environment vector (env) that the low-level integral engines (for example, gto.moleintor.getints) expect when evaluating integrals that span two separate Mole instances.
    
    The function returns new arrays that represent the concatenation of the per-molecule integral descriptors. It adjusts pointer and atom-index columns in the second molecule's atm and bas arrays so that their internal offsets refer correctly into the concatenated env and the combined atom list. The function copies and modifies the atm2 and bas2 inputs internally and does not mutate the original caller arrays.
    
    Args:
        atm1 (numpy.ndarray): Integer array encoding atom-related pointers and metadata for the first molecule (mol1). In PySCF this array stores integer fields used by integral routines (pointer indices to coordinates, Zetas, etc.). The array is treated as a 2-D integer table; its length (number of rows) is interpreted as the number of atoms in mol1 (natm_off). This argument is essential for building cross-integral environments because its atom indices and pointer fields become the lower-index part of the concatenated atom table.
        bas1 (numpy.ndarray): Integer array encoding basis-function descriptors for the first molecule (mol1). In PySCF this array stores integers such as the index of the atom each basis belongs to and pointer offsets into the env array for exponents and coefficients. It is treated as a 2-D integer table and becomes the first block of the concatenated basis table; its atom indices and pointer fields are used unchanged in the output.
        env1 (numpy.ndarray): One-dimensional numeric array (environment vector) for the first molecule (mol1) that stores floating-point data required by integrals (coordinates, exponents, contraction coefficients, etc.). The length of this array (off) is used as an offset to relocate pointer fields from the second molecule so both molecules reference the same combined env buffer.
        atm2 (numpy.ndarray): Integer array encoding atom-related pointers and metadata for the second molecule (mol2). This array is copied internally and then modified: pointer-type columns (e.g., pointers to coordinate or Zeta entries) are incremented by off = len(env1) so they point into the concatenated env, and atom indices will be shifted by the number of atoms in atm1. The caller’s atm2 is not modified because the function operates on a copy, but atm2 must be a numpy.ndarray with the expected integer table layout used by PySCF integral routines.
        bas2 (numpy.ndarray): Integer array encoding basis-function descriptors for the second molecule (mol2). This array is copied internally and then modified: the ATOM_OF column (which designates which atom a basis belongs to) is incremented by natm_off = len(atm1) so that atom indices refer to the concatenated atom table, and pointer columns for exponent and coefficient entries are incremented by off to refer into the concatenated env. The original bas2 passed by the caller remains unchanged.
        env2 (numpy.ndarray): One-dimensional numeric array (environment vector) for the second molecule (mol2). This array is concatenated after env1 to form the combined environment. Values in env2 are not modified; their indices are referenced by adjusted pointer fields written into the copied bas2/atm2.
    
    Returns:
        tuple: A 3-tuple (atm, bas, env) containing the concatenated integral parameters suitable for passing to PySCF integral routines.
            atm (numpy.ndarray): A new 2-D integer array (dtype numpy.int32) formed by vertically stacking atm1 and the adjusted copy of atm2. This array contains the combined atom descriptors for the composite system; pointer fields referencing env entries have been offset by len(env1) for the second-molecule rows, and atom counts reflect the combined atom list.
            bas (numpy.ndarray): A new 2-D integer array (dtype numpy.int32) formed by vertically stacking bas1 and the adjusted copy of bas2. The ATOM_OF indices in the second block have been incremented by len(atm1) and pointer fields for exponent/coefficient entries have been incremented by len(env1), so the basis table consistently references the combined atm and env.
            env (numpy.ndarray): A 1-D numeric array produced by concatenating env1 and env2 (numpy.hstack((env1, env2))). This env holds the floating-point data (coordinates, Gaussian exponents, contraction coefficients, etc.) for both molecules in a single buffer. The dtype of env is preserved from the inputs.
    
    Behavior, side effects, and failure modes:
        - The function does not mutate the arrays passed in by the caller; atm2 and bas2 are copied before modification, and the returned atm and bas are new numpy.int32 arrays. env is a new array produced by hstack, leaving env1 and env2 unchanged.
        - The function assumes atm1, bas1, atm2, bas2 are numpy.ndarray objects structured as the PySCF internal integer tables (with the specific columns that integral routines expect, for example PTR_COORD, PTR_ZETA, ATOM_OF, PTR_EXP, PTR_COEFF). If these arrays do not have the expected number of columns or dtype that supports the integer indexing performed in the code, IndexError or dtype-related exceptions (e.g., TypeError from unsupported in-place add) may be raised.
        - env1 and env2 are assumed to be 1-D numpy.ndarray objects that can be concatenated; their lengths determine the pointer offsets applied to the copied atm2 and bas2. If env1 is not a 1-D sequence with a defined len(), behavior will be undefined.
        - The function enforces that returned atm and bas have dtype numpy.int32 (via numpy.asarray(..., dtype=numpy.int32)). If the caller relies on a different integer dtype in atm/bas, they must convert the outputs explicitly after calling this function.
        - This helper is intended to prepare data for low-level integral evaluators (e.g., gto.moleintor.getints) when evaluating integrals that involve basis functions from two separate Mole instances. It is not a general-purpose array concatenation utility and depends on PySCF’s internal table layouts.
    """
    from pyscf.gto.mole import conc_env
    return conc_env(atm1, bas1, env1, atm2, bas2, env2)


################################################################################
# Source: pyscf.gto.mole.dyall_nuc_mod
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_dyall_nuc_mod(nuc_charge: int, nucprop: dict = {}):
    """pyscf.gto.mole.dyall_nuc_mod computes the Dyall empirical Gaussian nuclear charge exponent zeta for a given atomic number and optional nuclear properties. This function implements the parametrization of L. Visscher and K. Dyall (At. Data Nucl. Data Tables, 67, 207 (1997)) used in PySCF to define a finite Gaussian nuclear charge distribution rho(r) = nuc_charge * Norm * exp(-zeta * r^2), where zeta controls the spatial width of the nuclear charge distribution. In the PySCF electronic-structure context, this zeta is used when modeling extended (non-point) nuclei for integrals and relativistic corrections, particularly relevant for heavier elements where finite-nucleus effects matter.
    
    The function derives zeta from an empirical radius r computed from the nuclear mass via
    r = (0.836 * mass**(1./3) + 0.570) / 52917.7249
    and then zeta = 1.5 / (r**2). The numeric constant 52917.7249 and the coefficients 0.836 and 0.570 follow the Dyall parametrization; the mass value is taken from nucprop['mass'] if provided, otherwise from elements.ISOTOPE_MAIN[nuc_charge], which supplies the default isotope mass used across PySCF. The returned zeta is a floating-point Gaussian exponent appropriate for constructing the normalized Gaussian nuclear charge distribution used by PySCF routines.
    
    Args:
        nuc_charge (int): The nuclear charge (atomic number) of the element for which the Dyall nuclear model parameter is requested. This integer selects the element and (when nucprop does not supply an explicit mass) is used to look up the default isotope mass in elements.ISOTOPE_MAIN[nuc_charge]. Practical significance: choosing the correct atomic number ensures the zeta corresponds to the intended element and its default isotope in PySCF calculations; an incorrect or out-of-range integer may cause a lookup failure.
        nucprop (dict): Optional dictionary of nuclear properties that can override defaults from PySCF element tables. Recognized key:
            'mass' (numeric): If provided, this numeric value (expected to be the isotope mass in the same units as elements.ISOTOPE_MAIN entries) is used to compute the empirical radius r and thus zeta. If nucprop is omitted or empty (the default is {}), the function uses elements.ISOTOPE_MAIN[nuc_charge] to obtain the mass. Note: the default argument is a dictionary literal but the function does not mutate nucprop, so there are no side effects from using a mutable default in this implementation.
    
    Behavior and side effects:
        The function performs a pure numeric computation and has no side effects: it does not modify global state or mutate the nucprop argument. It returns a single floating-point exponent zeta suitable for constructing a Gaussian nuclear charge distribution of the form rho(r) = nuc_charge * Norm * exp(-zeta * r^2). The calculation follows the Dyall parametrization and is consistent with PySCF's usage of element isotope data via elements.ISOTOPE_MAIN.
    
    Failure modes and errors:
        If nuc_charge is not present in elements.ISOTOPE_MAIN and nucprop does not supply a 'mass' entry, a KeyError will be raised when attempting to look up the default mass. If the provided 'mass' value is non-numeric, a TypeError may occur during the mass**(1./3) operation. If mass <= 0, the computation may produce invalid results or raise exceptions (e.g., ZeroDivisionError if r evaluates to zero). Callers should validate nuc_charge and nucprop['mass'] before calling this function when operating outside typical PySCF element tables.
    
    Returns:
        float: The Dyall Gaussian exponent zeta computed as 1.5 / (r**2), where r is the empirical nuclear radius computed from the provided or default isotope mass. This scalar float is the exponent parameter used to define the Gaussian nuclear charge distribution implemented in PySCF routines.
    """
    from pyscf.gto.mole import dyall_nuc_mod
    return dyall_nuc_mod(nuc_charge, nucprop)


################################################################################
# Source: pyscf.gto.mole.expand_etb
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_expand_etb(l: int, n: int, alpha: float, beta: float):
    """pyscf.gto.mole.expand_etb generates a list of Gaussian-type orbital (GTO) exponents in the even-tempered form used to populate Mole.basis entries in PySCF. This function is used in the PySCF quantum-chemistry framework to produce a sequence of radial exponents for primitive GTOs for a given angular momentum shell; those exponents determine the spatial extent and decay of the basis functions used in electronic structure calculations.
    
    Args:
        l (int): Angular momentum of the basis functions for the generated shell. In PySCF and quantum chemistry this is the orbital angular momentum quantum number (e.g., 0 for s, 1 for p, 2 for d) and is reproduced verbatim in each returned basis entry as the first element of the entry [l, [exponent, 1]]. The function does not modify l; it is included to format the returned Mole.basis-style entries.
        n (int): Number of Gaussian-type primitives to generate for the shell. The function computes n exponents. If n is zero or negative the function returns an empty list (no shell entries). n is interpreted as an integer count; non-integer values may raise a TypeError when used in range().
        alpha (float): Base exponent factor used to compute each primitive exponent. Each primitive exponent value is computed from alpha and beta according to the implementation formula exponent = alpha * beta**i (see below). alpha controls the smallest exponent produced (when i = 0) and thus the most diffuse primitive in the generated set.
        beta (float): Geometric progression ratio between successive exponents. The sequence of raw exponents is generated by multiplying alpha by successive powers of beta. beta determines how rapidly exponents grow between primitives; values greater than 1 produce a spread from diffuse to compact functions, values between 0 and 1 produce the opposite progression. Using zero or negative beta is permitted by the code but will produce correspondingly zero or sign-alternating exponents, which may be physically inappropriate for basis construction.
    
    Returns:
        list: Formatted :attr:`~Mole.basis`. A Python list of length n (or empty if n <= 0) containing Mole.basis-style entries for a single angular-momentum shell. Each element has the exact structure [l, [exponent, 1]] where:
            - l is the angular momentum argument passed to the function (int).
            - exponent is a float computed by the implementation as exponent = alpha * beta**i for integer i values from n-1 down to 0 (i.e., the returned list is ordered from the largest exponent to the smallest exponent).
            - the integer 1 is the contraction multiplicity used here to indicate a single primitive (this function does not perform contractions).
        There are no side effects: the function returns a newly allocated list and does not modify global state or the input arguments.
    
    Behavior and failure modes:
        - Exponents are computed using Python floating-point arithmetic and returned in descending order (highest exponent first) because the implementation iterates i in reversed(range(n)).
        - If n <= 0 the function returns [] (no entries).
        - If non-integer or otherwise incompatible types are passed for l or n, a TypeError or ValueError may be raised by Python built-ins (for example, range() requires an integer n).
        - The function does not validate the chemical appropriateness of alpha and beta; users should choose values consistent with quantum-chemistry basis construction practices in PySCF. Invalid choices (e.g., beta == 0 or large negative values) will produce numeric exponents that may be unsuitable for Mole.basis and can lead to downstream errors in SCF or correlated calculations.
    """
    from pyscf.gto.mole import expand_etb
    return expand_etb(l, n, alpha, beta)


################################################################################
# Source: pyscf.gto.mole.etbs
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_etbs(etbs: list):
    """pyscf.gto.mole.etbs: Utilities to generate even-tempered Gaussian atomic basis primitives and format them for assignment to a Mole.basis in PySCF quantum-chemistry calculations.
    
    Generates a flattened list of basis primitives from a sequence of even-tempered basis (ETB) specifications. Each ETB specification is interpreted as a geometric progression of Gaussian exponents defined by an initial exponent and a common ratio; the function expands each specification into primitive Gaussian entries and returns them in the format expected by Mole.basis so they can be used directly in electronic-structure calculations (Hartree–Fock, DFT, correlated methods) implemented within PySCF.
    
    Args:
        etbs (list): A sequence of even-tempered basis specifications. Each element must be a 4-tuple of the form (l, n, alpha, beta) where l is the angular momentum (integer) identifying the shell (for example, 0 for s, 1 for p), n is the number of primitives to generate (integer), alpha is the initial exponent (numeric), and beta is the geometric ratio between successive exponents (numeric). The list is processed in order; for each tuple the function calls expand_etb(l, n, alpha, beta) to produce the primitives for that shell and then concatenates (flattens) all results into a single list. Practical significance: callers provide compact ETB specifications to produce standard uncontracted primitive Gaussian entries for use as a Mole.basis without manually computing each exponent. No defaults are assumed for tuple elements; each tuple must supply all four values.
    
    Behavior and side effects:
        The function iterates over the provided etbs list, invoking expand_etb on each tuple and then applying lib.flatten to combine the per-shell lists into a single list. It does not modify global state or the provided input list in place; it returns a new list object suitable for assigning to Mole.basis. The order of primitives in the returned list preserves the ordering of shells and primitives produced by each expand_etb call. Any formatting conventions (for example, each primitive represented as [l, [exponent, coefficient]]) follow the Mole.basis representation used elsewhere in PySCF.
    
    Failure modes:
        If etbs is not an iterable of 4-tuples the function will propagate errors raised by expand_etb or by Python when attempting to iterate or unpack elements. If individual tuple elements have incorrect types (e.g., non-numeric alpha or beta, non-integer l or n) the expansion function expand_etb is expected to raise an error, which will propagate to the caller. The function does not perform extensive validation beyond relying on expand_etb and Python's type system, so callers should ensure each tuple conforms to the (l, n, alpha, beta) structure before calling.
    
    Returns:
        list: A flattened list formatted for Mole.basis. Each element is a basis primitive entry in the form [l, [exponent, coefficient]] where l is the angular momentum integer, exponent is a numeric Gaussian exponent produced by the even-tempered expansion, and coefficient is the contraction coefficient (typically 1 for uncontracted primitives produced by this helper). The returned list can be assigned directly to a Mole object's basis attribute to define the atomic basis used in subsequent PySCF calculations.
    """
    from pyscf.gto.mole import etbs
    return etbs(etbs)


################################################################################
# Source: pyscf.gto.basis.parse
# File: pyscf/gto/basis/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_basis_parse(string: str, symb: str = None, optimize: bool = False):
    """pyscf.gto.basis.parse parses textual basis set and pseudopotential (ECP/PP) blocks written in NWChem or CP2K formats and returns a PySCF internal representation suitable for assignment to Mole.basis or Cell.basis. This function is used within the PySCF quantum chemistry framework to convert basis/ECP text (for example, basis set blocks copied from NWChem output files or CP2K basis/pseudopotential specifications) into the Python data structures that PySCF electronic-structure routines expect.
    
    The parser recognizes three main dispatch cases based on markers in the input text: if the substring "ECP" appears it is treated as an NWChem-format ECP and routed to the NWChem ECP parser; if the substring "GTH" appears it is treated as a CP2K/Goedecker–Teter–Hutter pseudopotential/basis block and routed to the CP2K parsers (the presence of "PSEUDOPOTENTIAL" within a "GTH" block selects the CP2K pseudopotential parser); otherwise the text is assumed to be an NWChem-format basis set and routed to the NWChem basis parser. Blank lines and literal lines that contain "BASIS SET" or "END" are ignored during parsing. The returned structure is intended to be directly assignable to mol.basis or cell.basis to define atomic basis functions or pseudopotentials in molecular and periodic calculations.
    
    Args:
        string (str): The input text containing basis set or pseudopotential specification in NWChem or CP2K format. This is the raw multi-line string (for example, copied from NWChem basis set files or CP2K element blocks) that the function will parse. Blank lines and lines containing the literal tokens "BASIS SET" and "END" are ignored. The content of this string determines which internal parser is invoked: presence of "ECP" selects the NWChem ECP parser, presence of "GTH" selects CP2K-related parsers, and otherwise the NWChem basis parser is used.
        symb (str): Optional atomic symbol (for example, "He" or "C") that indicates which element the provided basis/ECP block corresponds to. When provided, this guides the parser and is used as the key under which the returned basis/pseudopotential data is associated in the PySCF internal format. If None, the parser will attempt to infer the element symbol from the text where possible.
        optimize (bool): Flag that controls whether contraction information should be optimized during parsing. When True, the parser will call subroutines with contraction-optimization enabled so the resulting internal representation may combine or transform contracted Gaussian primitives to a form that reduces redundant contractions (this can affect computational efficiency of subsequent integral construction). When False, contraction coefficients and shell definitions are preserved as explicitly given in the input. The flag is passed through to the specific format parsers (CP2K or NWChem) and influences only how contraction data is represented in the returned structure.
    
    Returns:
        dict: A Python dictionary in PySCF's internal basis/pseudopotential representation that is suitable for direct assignment to Mole.basis or Cell.basis. Keys are atomic symbol strings (or other identifiers used by the caller), and values are the nested data structures used by PySCF to describe shells, exponents, contraction coefficients, and, when present, ECP/pseudopotential parameters. This structure encodes the information required by PySCF integrals and electronic-structure code to construct basis functions and to apply pseudopotentials.
    
    Raises:
        ValueError: If the input text is malformed, contains inconsistent numerical entries, or does not match any of the supported formats (NWChem or CP2K), the parser raises ValueError indicating a parsing failure. No side effects are performed on Mole or Cell objects; the function is pure and returns the parsed data structure.
    """
    from pyscf.gto.basis import parse
    return parse(string, symb, optimize)


################################################################################
# Source: pyscf.gto.mole.fakemol_for_cgtf_charge
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_fakemol_for_cgtf_charge(
    coord: numpy.ndarray,
    expnt: numpy.ndarray = 1e+16,
    contr_coeff: numpy.ndarray = 1
):
    """Constructs a lightweight pyscf.gto.Mole that represents a Gaussian charge distribution centered at a single coordinate for use in CGTF charge-related integral routines.
    
    This function is used in the PySCF Gaussian integrals machinery when a localized Gaussian representation of an external point/compact charge is required (for example, in charge fitting or charge-interaction integrals used by CGTF-related code). It builds a minimal Mole object with internal arrays (_atm, _bas, _env) arranged so integrals can be evaluated as if there were an atom with one or a contracted set of s-type Gaussian primitives representing the charge. The returned Mole is marked as built (fakemol._built == True) and is intended only as a transient container for integral evaluation, not as a full chemical system description.
    
    Args:
        coord (numpy.ndarray): A 2D array with shape (1, 3) containing the Cartesian coordinates (x, y, z) of the center of the Gaussian charge distribution. The function asserts coord.shape[0] == 1 and will raise AssertionError if this is not satisfied. In the CGTF/charge context, this coordinate is the physical location of the point-like or compact Gaussian charge that the Mole will represent.
        expnt (numpy.ndarray): Exponent(s) of the Gaussian primitive(s). Default is 1e+16. The function accepts scalar values or 1D arrays; inputs are converted via numpy.asarray(expnt).ravel(). If a single scalar is provided, a single primitive with that exponent is created. If an array is provided, its length must equal the length of contr_coeff and the function will create a contracted basis made from those exponents. Very large exponents (the default 1e+16) produce an extremely tightly localized Gaussian that approximates a point charge for integral purposes.
        contr_coeff (numpy.ndarray): Contraction coefficient(s) for the Gaussian primitive(s). Default is 1. The function accepts scalar values or 1D arrays; inputs are converted via numpy.asarray(contr_coeff).ravel(). For a single primitive, a single coefficient is used. For multiple primitives, the array size must match that of expnt; otherwise an AssertionError is raised. These coefficients are scaled internally to produce a normalized charge distribution for use in integrals.
    
    Behavior and internal details:
        The function constructs internal arrays fakeatm, fakebas, and fakeenv consistent with PySCF internal layout (ATM_SLOTS, BAS_SLOTS, PTR_ENV_START, and pointer constants referenced in the module). It places the coordinate into fakeenv and sets pointers in fakeatm/fakebas so integrals code can locate the center and primitive data.
        The provided contraction coefficients are normalized for a Gaussian charge distribution using the formula coeff_normalized = contr_coeff / (2 * sqrt(pi) * gaussian_int(2, expnt)). The gaussian_int(2, expnt) function from the module is used to compute required radial integrals for normalization. For a single exponent, the environment entries appended are [expnt, normalized_coeff]. For multiple exponents, the environment stores pairs of exponents and normalized coefficients stacked and flattened.
        The constructed Mole instance has its _atm, _bas, and _env attributes set from these arrays and fakemol._built set to True before being returned. The Mole is suitable for passing to PySCF integral routines that expect a Mole, but it is a synthetic object intended only to represent the Gaussian charge distribution.
    
    Defaults:
        expnt defaults to 1e+16 and contr_coeff defaults to 1, which together approximate a point charge at coord while still using the Gaussian integral machinery.
    
    Failure modes and exceptions:
        AssertionError is raised if coord.shape[0] != 1 or if expnt and contr_coeff are both arrays of differing lengths (the latter only applies when expnt is not a scalar). If expnt and contr_coeff cannot be converted to 1D numpy arrays by numpy.asarray(...).ravel(), the conversion will raise the underlying numpy error. The function assumes module-level constants (ATM_SLOTS, BAS_SLOTS, PTR_ENV_START, and pointer indices) and gaussian_int are defined; if they are not, Python NameError or AttributeError will result.
    
    Returns:
        Mole: A pyscf.gto.Mole instance configured to represent the specified Gaussian charge distribution. The Mole has _atm, _bas, and _env populated to describe one atom-like center with one contracted s-type basis representing the charge, and fakemol._built is set to True. The returned Mole is intended for immediate use in CGTF/charge integral routines and does not modify global state.
    """
    from pyscf.gto.mole import fakemol_for_cgtf_charge
    return fakemol_for_cgtf_charge(coord, expnt, contr_coeff)


################################################################################
# Source: pyscf.gto.mole.fakemol_for_charges
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_fakemol_for_charges(coords: numpy.ndarray, expnt: numpy.ndarray = 1e+16):
    """Construct a fake pyscf.gto.mole.Mole that encodes point charges located at the given Cartesian coordinates using narrow Gaussian charge distributions.
    
    This helper is used within the PySCF (Python-based Simulations of Chemistry Framework) codebase to represent external point charges or localized monopoles as very narrow Gaussian basis functions so that existing integrals/routines that expect a Mole object (with _atm, _bas, _env layout) can be reused for embedding, QM/MM point-charge fields, or any calculation that requires a Mole-like container of charges. The function builds internal ATM and BAS integer arrays and an ENV array that stores coordinates and Gaussian exponent/coeff pairs, and sets the returned Mole._built flag to True so downstream PySCF routines treat it as a ready Mole object.
    
    Args:
        coords (numpy.ndarray): Real-valued Cartesian coordinates of the charges. The array must have shape (nbas, 3), where nbas is the number of point charges. Each row is (x, y, z) in the same length units used by the calling PySCF session. The function reads coords.shape[0] to determine the number of basis centers and flattens coords (coords.ravel()) into the Mole._env array. Supplying coordinates with the wrong dimensionality or with a first dimension not equal to the number of intended charges will lead to incorrect internal layout and likely errors in downstream integral routines.
        expnt (numpy.ndarray): Gaussian exponent(s) used to approximate each point charge by a normalized Gaussian function exp(-expnt*r^2). This parameter is converted with numpy.asarray(expnt).ravel(); therefore expnt may be provided as a scalar or as a 1-D numpy.ndarray. If expnt is a scalar (the default 1e16), the same exponent is used for all charges. If expnt is an array, its length must equal the number of rows in coords (nbas); otherwise the function asserts and raises an AssertionError. Typical use passes a very large positive exponent (the default 1e16) to closely approximate a delta-like point charge. expnt values should be finite and positive; zero or negative exponents produce non-localized or divergent Gaussians and will produce incorrect normalization coefficients.
    
    Behavior and side effects:
        The function constructs integer arrays fakeatm and fakebas with shapes (nbas, ATM_SLOTS) and (nbas, BAS_SLOTS) respectively, and assembles fakeenv (a Python list that becomes a 1-D numpy._env array) containing the flattened coordinates followed by exponent/coefficient pairs. For a scalar expnt, a single exponent/coeff pair is appended and the same pair is referenced by all basis centers. For an array expnt of length nbas, each center gets its own exponent/coeff pair; coefficients are computed as 1 / (2 * sqrt(pi) * gaussian_int(2, expnt)) consistent with PySCF's gaussian integral normalization so that each Gaussian carries unit monopole weight for use as a point charge. The function sets the Mole._atm, Mole._bas, and Mole._env attributes on a newly created pyscf.gto.mole.Mole instance and sets Mole._built = True. No file I/O occurs.
    
    Defaults:
        If expnt is omitted, the default value 1e16 is used (a very large exponent that approximates a point charge by a very narrow Gaussian). The function accepts either a scalar or a 1-D numpy.ndarray for expnt; when an array is provided its length must match the number of coordinates.
    
    Failure modes:
        If coords does not have shape (nbas, 3) or is not convertible to a 1-D flattened coordinate vector as expected, downstream code will fail; this function does not perform exhaustive shape validation beyond using coords.shape[0] and coords.ravel(). If expnt is provided as an array whose size is not equal to the number of coordinates (nbas), the function raises an AssertionError. Providing non-finite, zero, or negative exponent values will produce meaningless normalization coefficients and invalid charge representations.
    
    Returns:
        pyscf.gto.mole.Mole: A Mole instance whose internal low-level layout encodes the requested Gaussian charges. The returned Mole has its _atm and _bas integer tables populated to reference entries in _env, _env contains the flattened coordinates followed by exponent and coefficient values (either one shared pair or one pair per center depending on expnt), and _built is set to True so that standard PySCF integrals and routines accept the object as a ready Mole representing the specified point-charge-like Gaussian distributions.
    """
    from pyscf.gto.mole import fakemol_for_charges
    return fakemol_for_charges(coords, expnt)


################################################################################
# Source: pyscf.gto.mole.format_basis
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_format_basis(basis_tab: dict, sort_basis: bool = True):
    """Convert a Mole.basis-like mapping into PySCF's internal basis-set data format used by integral formation and other electronic-structure routines.
    
    This function is used inside PySCF to prepare atom-centered basis descriptions provided by the user (for example via Mole.basis) into the canonical internal representation expected by downstream code such as integral builders and basis-manipulation utilities (for example decontract_basis). The function normalizes atom keys, converts each atom's basis specification using PySCF's basis converter pipeline, removes empty entries, and optionally sorts the resulting shell list by angular momentum so that functions which assume grouped angular-momentum blocks operate correctly.
    
    Args:
        basis_tab (dict): Mapping similar to Mole.basis that associates an atom identifier (for example 'H', 'C', or position-tagged labels such as 'H^2') to a basis specification. The mapping itself must be a dict object (it cannot be a str). Each value (atom basis specification) may be a basis name, a predefined basis description, or an explicit list/tuple describing shells; the converter produced by _generate_basis_converter is used to translate the provided specification into the internal form. The atom keys are normalized to element symbols by _atom_symbol before conversion.
        sort_basis (bool): If True (default), the resulting list of shells for each atom is sorted by angular momentum (shell[0], ascending). Sorting groups basis functions of the same angular momentum together, which is important for routines such as decontract_basis that assume grouped angular-momentum blocks. If False, the original order produced by the converter is preserved (except that empty/false shells are filtered out).
    
    Behavior and side effects:
        The function constructs and returns a new dict (it does not mutate the input mapping). For each atom in basis_tab, the function calls the internal converter (created by _generate_basis_converter()) with the normalized atom symbol and the provided atom_basis. The converter returns a sequence of shells. Each shell in the internal format is represented as a two-element sequence/object where the first element is the integer angular momentum (l) and the second element is the sequence of primitives for that shell. Each primitive is itself a sequence (tuple or list) whose first entry is the primitive exponent and subsequent entries are contraction coefficients. Empty or falsey shells are removed before optional sorting. When sort_basis is True, shells are sorted by their angular-momentum index (shell[0]) to ensure same-l shells are contiguous.
    
    Failure modes:
        If the converter returns an empty sequence for an atom (no basis could be found or produced), the function raises BasisNotFoundError with a message indicating the normalized atom symbol. Passing a non-dict as basis_tab (for example a plain str) is not supported and will not be interpreted as a full basis mapping; such misuse will typically result in a runtime error when the code attempts to iterate mapping items. The function does not perform further validation of individual primitive numeric types beyond what the underlying converter and downstream code expect.
    
    Returns:
        dict: A new mapping from normalized atomic symbol strings to the formatted basis description. Each value is a list/sequence of shells in the internal form: [ (l, primitives), ... ] where l is the integer angular momentum and primitives is a sequence of primitive tuples/lists (each primitive begins with the exponent followed by contraction coefficients). This formatted mapping is what PySCF internal routines (integral evaluators, SCF drivers, and basis-manipulation utilities) consume.
    """
    from pyscf.gto.mole import format_basis
    return format_basis(basis_tab, sort_basis)


################################################################################
# Source: pyscf.gto.mole.fromstring
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_fromstring(string: str, format: str = "xyz"):
    """pyscf.gto.mole.fromstring converts a molecular geometry string in a supported format into the internal line-based geometry representation used by PySCF utilities and tests.
    
    Args:
        string (str): Input text containing molecular geometry in one of the supported formats. The content and layout must match the chosen format:
            - For format='xyz' the function expects an XYZ-format string where the first two lines are the atom count and an optional title/comment, followed by lines with atomic data; the function will return only the geometry block (all lines after the first two header lines).
            - For format='sdf' the function expects an SDF record with an atom/bond count line at raw[3] and atom lines following; the function will parse the first 3+N lines and emit one line per atom in the internal "<symbol> <x> <y> <z>" arrangement described below.
            - For format='raw' the function treats the provided string as already in the internal representation and returns it unchanged. The internal representation (used by tests and other PySCF helpers) is a newline-separated sequence of atomic lines where each line is exactly "<symbol> <x> <y> <z>" (symbol followed by three Cartesian coordinate fields separated by whitespace).
            - For format='zmat' the function returns the string unchanged because the Z-matrix form is already an alternative internal representation.
            The function performs only textual parsing and reordering; it does not perform unit conversion, validation of chemical connectivity, or numerical checks beyond splitting and rearranging tokens. Malformed input (missing lines, incorrect column counts) will raise the underlying Python exceptions (ValueError, IndexError) described in Raises:.
        format (str): Format identifier for the input string. Accepted, case-insensitive values are 'xyz', 'sdf', 'raw', and 'zmat'. The default is "xyz". The value controls how the function interprets and converts the input into the internal line-based geometry representation. Unknown format values will cause the function to raise NotImplementedError.
    
    Returns:
        str: A string in PySCF's internal line-based geometry format (newline-separated lines of atomic entries) appropriate for downstream molecule construction and testing utilities:
            - For 'xyz': returns the geometry block from the XYZ string (all lines after the first two lines), typically a sequence of atomic lines with symbol and Cartesian coordinates.
            - For 'sdf': returns a newline-joined sequence where each atom line is formatted as "<symbol> <x> <y> <z>" by reordering tokens parsed from the SDF atom lines.
            - For 'raw' and 'zmat': returns the original input string unchanged (these formats are treated as already in an internal or alternative internal representation).
        The returned string is intended for immediate use by PySCF molecule-building code paths and test fixtures that expect the internal line-based geometry format.
    
    Raises:
        NotImplementedError: If format is not one of the supported identifiers ('xyz', 'sdf', 'raw', 'zmat').
        ValueError, IndexError: For malformed input strings that do not contain the expected header or atom lines for the requested format (for example, an XYZ string without two header lines or an SDF without the expected atom count line and atom records). These are raised as the underlying Python exceptions from string splitting and integer conversion operations.
    
    Notes:
        - The function is a lightweight, format-specific parser intended primarily for testing and simple conversions; it does not replace full-featured molecular file readers or writers.
        - The format detection is case-insensitive because the function lower-cases the provided format string before branching.
        - No side effects occur (the function does not modify files or global state); it returns a new string or raises an exception on error.
    """
    from pyscf.gto.mole import fromstring
    return fromstring(string, format)


################################################################################
# Source: pyscf.gto.mole.format_pseudo
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_format_pseudo(pseudo_tab: dict):
    """Convert the input pseudopotential table (pseudo_tab) to the internal data format used by PySCF's GTO module for pseudopotentials.
    
    This function is used in the PySCF framework to prepare pseudopotential data so that downstream modules (basis set handling, integral evaluation, and quantum chemistry solvers) can consume a consistent, fully expanded representation. The input pseudo_tab is a mapping for atomic sites to pseudopotential specifications; values in pseudo_tab may be either:
    - a string identifier naming a pseudopotential (in which case pyscf.pbc.gto.pseudo.load is called to obtain the internal representation for the standardized atomic symbol), or
    - an already-formatted pseudopotential data structure (in which case the value is used verbatim).
    
    The function canonicalizes atom labels using the internal helper _symbol(atom) before using them as keys in the returned mapping. When a string identifier is provided for an atom, _std_symbol_without_ghost is used to compute the standardized symbol passed to pyscf.pbc.gto.pseudo.load. The returned structure matches the internal :attr:`pseudo` layout expected by PySCF's GTO routines.
    
    Args:
        pseudo_tab (dict): Mapping of atoms to pseudopotential specifications. Each key is an atom identifier accepted by the module (for example an element symbol or an atom specification used elsewhere in PySCF). Each value must be either a string pseudopotential identifier (for example a filename or a keyword recognized by pyscf.pbc.gto.pseudo.load) or an already-formatted pseudopotential data structure matching PySCF's internal format. The function does not accept a string for pseudo_tab itself; passing a string (instead of a dict-like mapping with an items() method) will raise an error because the implementation iterates pseudo_tab.items(). This parameter represents the user-provided pseudopotential assignment for a molecule or cell and is typically derived from user input or higher-level molecule construction routines.
    
    Returns:
        dict: A new dictionary mapping standardized atomic symbols (str) to the formatted pseudopotential representation used internally by PySCF. The value for each atom is structured as follows (same semantics as PySCF's :attr:`pseudo` internal format):
        { atom: ( (nelec_s, nelec_p, nelec_d, ...),
                  rloc,
                  nexp,
                  (cexp_1, cexp_2, ..., cexp_nexp),
                  nproj_types,
                  (r1, nproj1, ( (hproj1[1,1], hproj1[1,2], ..., hproj1[1,nproj1]),
                                 (hproj1[2,1], hproj1[2,2], ..., hproj1[2,nproj1]),
                                 ...
                                 (hproj1[nproj1,1], hproj1[nproj1,2], ...        ) )),
                  (r2, nproj2, ( (hproj2[1,1], hproj2[1,2], ..., hproj2[1,nproj2]),
                  ... ) )
                )
        ... }
        In this structure: the first tuple gives the number of pseudo valence electrons per angular momentum channel (nelec_s, nelec_p, ...); rloc is the local potential radius; nexp and the cexp_* entries are parameters for the local potential expansion; nproj_types is the number of projector types; each (rk, nprojk, (...)) block encodes projector radii, number of projectors, and the projector coefficient matrices hprojk. These fields are numeric and tuple/sequence containers as required by PySCF internal routines. The function returns a freshly constructed dict and does not modify the input pseudo_tab.
    
    Behavior, side effects, and failure modes:
    - For values in pseudo_tab that are strings, the function calls pyscf.pbc.gto.pseudo.load(value, std_symbol) to obtain the internal pseudopotential representation. That load operation may read files or consult installed pseudopotential databases and therefore can raise exceptions if the identifier is not found or the file cannot be read; such exceptions propagate to the caller.
    - For values that are not strings, the function assumes the value is already in the correct internal pseudopotential format and inserts it into the output mapping unchanged.
    - The function canonicalizes atom keys with the internal helpers _symbol and _std_symbol_without_ghost before using them as keys in the returned dict; if those helpers fail to parse an atom label, their exceptions will propagate.
    - The function constructs and returns a new dict and does not mutate the input pseudo_tab.
    - Passing a non-mapping (for example a string) as pseudo_tab will cause an error when the function attempts to call pseudo_tab.items().
    
    Example usage:
    Given a user pseudopotential assignment for periodic calculations, calling format_pseudo({'H': 'gth-blyp', 'He': 'gth-pade'}) will return a dict where 'H' and 'He' map to their respective expanded internal pseudopotential representations as loaded by pyscf.pbc.gto.pseudo.load.
    """
    from pyscf.gto.mole import format_pseudo
    return format_pseudo(pseudo_tab)


################################################################################
# Source: pyscf.gto.mole.from_zmatrix
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_from_zmatrix(atomstr: str):
    """Convert a Z-matrix string to Cartesian coordinates and atom symbols suitable for PySCF molecular input.
    
    Args:
        atomstr (str): Multiline Z-matrix specification as a single string. This string is interpreted according to the Z-matrix parsing logic used in PySCF: semicolons (';') are treated as line separators, commas (',') are treated as token separators (they are replaced by spaces before parsing), blank lines and lines beginning with '#' are ignored as comments, and numeric fields may be Python expressions that are evaluated with eval() unless the module-level flag DISABLE_EVAL is set. Each non-comment line must begin with an atomic symbol token followed by additional tokens that specify how the atom is positioned relative to previously defined atoms:
            - A single token line ("Symbol") places the atom at the origin (first atom).
            - Three-token lines ("Symbol X R") treat the third token as a numeric expression or literal for a bond length R and place the atom on the +x axis at distance R relative to the origin or to the reference atom implied by prior entries (this corresponds to the second atom in a typical Z-matrix).
            - Five-token lines ("Symbol ibond bond iangle angle") supply four values (the code accepts the four values either as separate tokens or as an evaluable expression). The first value (ibond, 1-based index) selects the reference atom for the bond length; the second value (bond) is the bond length; the third value (iangle, 1-based index) selects the reference atom that defines the bond angle; and the fourth value (angle) is the bond angle in degrees. The function converts angles from degrees to radians and uses rotation matrices (pyscf.symm.rotation_mat) to place the atom in 3D.
            - Seven-or-more-token lines include dihedral information ("Symbol ibond bond iangle angle idih dihedral"), where idih (1-based index) selects the atom that defines the dihedral and dihedral is given in degrees. The code parses six numeric values (ibond, bond, iangle, angle, idih, dihedral) and computes the Cartesian placement using successive rotations.
            The parser enforces increasing requirements for the minimum number of tokens per line as atoms are added and raises an error if a line does not meet the current minimum. Index arguments in the Z-matrix are 1-based in the input and converted internally to 0-based indices.
    
    Returns:
        list: A Python list of tuples [(symbol, coord), ...] where symbol is the atomic symbol string returned by the module helper _atom_symbol (e.g., 'H', 'C', 'O'), and coord is a numpy.ndarray with shape (3,) containing the Cartesian coordinates computed by the Z-matrix parser. The returned list order follows the input Z-matrix order and is suitable for constructing PySCF molecular objects (for example, as the geometry argument to pyscf.gto.Mole). No global state in the parser is modified except that the function observes the module-level DISABLE_EVAL flag to decide whether to evaluate numeric expressions.
    
    Behavior, defaults, and failure modes:
        - Parsing rules: The function first normalizes the input by replacing ';' with newline and ',' with space, then processes each non-empty, non-comment line sequentially. The first atom with fewer than three tokens is placed at the origin. The second atom (three-token line) is placed on the +x axis. Subsequent atoms use 4-value (bond + angle) or 6-value (bond + angle + dihedral) specifications to compute a Cartesian displacement vector relative to previously placed atoms.
        - Angle units: Angle values supplied in the Z-matrix are interpreted as degrees by this function and converted to radians internally before applying trigonometric operations.
        - Use of eval: If DISABLE_EVAL is False (default behavior in many PySCF deployments), numeric fields and expressions are evaluated with Python's eval(), allowing expressions such as "2.0", "3/2", or "1.0+0.1". If DISABLE_EVAL is True, the function avoids eval() and parses numeric tokens with float() where appropriate, and treats combined-value tokenization accordingly. Because eval() executes arbitrary Python code, passing untrusted input while DISABLE_EVAL is False is a security risk.
        - Geometry construction: The function uses pyscf.symm.rotation_mat to build rotation matrices for placing atoms by rotating reference vectors. It contains fallbacks for nearly colinear or degenerate vectors (small-norm cross products) to avoid numerical singularities in common Z-matrix patterns, but some degenerate or inconsistent Z-matrix specifications may still lead to numerical instability.
        - Exceptions and errors: The function raises ValueError when a line does not contain the required number of tokens given the current parsing state. It may raise AssertionError if an angle value is negative or, for dihedral cases, out of the [0, 180] degree range after conversion (the code asserts ang >= 0 and in the dihedral branch asserts ang <= pi). Indexing errors (IndexError) will occur if the Z-matrix refers to atom indices that have not yet been defined (1-based indices must reference previously defined atoms). Other exceptions that can arise include TypeError or ValueError from invalid numeric conversion, ZeroDivisionError or numerical issues in degenerate geometries, and security-related consequences if eval() executes malicious input.
        - Practical significance: This function is used in the PySCF codebase to convert human-readable Z-matrix specifications into explicit Cartesian coordinates for electronic structure calculations. The returned list of (symbol, coord) pairs is the standard lightweight representation of molecular geometry in PySCF and can be passed to classes and routines that build basis functions, compute integrals, or perform quantum chemistry workflows.
        - No side-effectful modification of external files or global molecular state occurs; the function only returns the computed symbol/coordinate list.
    """
    from pyscf.gto.mole import from_zmatrix
    return from_zmatrix(atomstr)


################################################################################
# Source: pyscf.gto.mole.format_ecp
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_format_ecp(ecp_tab: dict):
    """pyscf.gto.mole.format_ecp converts a user-supplied ECP (effective core potential) specification into the internal ECP data format used by PySCF's molecular integrals and basis handling routines. This function is used when constructing a Mole object or reading atomic basis/ECP input so that downstream code always sees a consistent mapping from element symbol to the ECP definition (including the number of core electrons and radial/ang-momentum projectors).
    
    Args:
        ecp_tab (dict): Mapping of atom identifiers to ECP specifications supplied by the user. Each key is an atom identifier that _atom_symbol can accept (for example, an atomic index or an atomic label); keys are converted to standardized element symbols (ghost suffixes removed) via _atom_symbol and _std_symbol_without_ghost. Each value may be either:
            - a str: interpreted as the name or path of a standard ECP to load via basis.load_ecp(str_value, stdsymb). In this case the function attempts to load a predefined ECP dataset for the standardized element symbol; if basis.load_ecp returns None or an empty result, the function does not raise an exception but writes a diagnostic message to sys.stderr and does not add an entry for that atom to the returned mapping.
            - a non-str (typically already in the internal structure): treated as an already-formatted ECP datum and inserted into the returned mapping unchanged.
          The caller should provide a dict keyed by atom identifiers with values that are either a filename/label string or an internal-format ECP object. This parameter is required and must be of type dict; no other input types are accepted by the function.
    
    Returns:
        dict: A mapping from standardized element symbols (strings) to internal ECP data structures. The internal format is preserved from PySCF conventions and has the shape:
            { atom_symbol: (nelec,
                            ((l,  # l = -1 for UL, l >= 0 for |l><l| projectors
                              (  # radial components grouped by powers of r (r^0, r^1, r^2, ...)
                                ((exp_1, c_1), (exp_2, c_2), ...),  # coefficients for r^0
                                ((exp_1, c_1), (exp_2, c_2), ...),  # coefficients for r^1
                                ((exp_1, c_1), ...),                 # coefficients for r^2
                                ...
                              )
                             ),
                             ...
                            )
            }
        Here, nelec is the number of core electrons represented by the ECP for that element; each l entry contains tuples of (exponent, coefficient) pairs for the radial projector terms grouped by the power of r. The returned dict contains only entries that were successfully resolved or were provided already in internal format. Side effects include calls to basis.load_ecp for string-valued entries and writes to sys.stderr when a requested standard ECP cannot be found; the function does not raise an exception in that lookup-failure case (the original code commented out a BasisNotFoundError and instead reports to stderr).
    """
    from pyscf.gto.mole import format_ecp
    return format_ecp(ecp_tab)


################################################################################
# Source: pyscf.gto.mole.gaussian_int
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_gaussian_int(n: int, alpha: float):
    """pyscf.gto.mole.gaussian_int computes the definite integral int_0^inf x^n exp(-alpha x^2) dx and returns its closed-form value using the Gamma function. In the PySCF quantum-chemistry context this routine is used to evaluate one-dimensional radial moments that appear when analytically integrating Gaussian-type functions (e.g., normalization factors and radial parts of overlap, kinetic, and two-electron integrals). The function implements the known identity
    Gamma((n+1)/2) / (2 * alpha^{(n+1)/2}),
    so callers obtain the analytic contribution of x^n times a Gaussian damping factor without numerical quadrature.
    
    Args:
        n (int): Exponent of x in the integrand x^n. In typical quantum-chemistry use this integer arises from angular-momentum or radial powers in Gaussian basis-function integrals and determines the moment being evaluated. Mathematically, the integral converges at the origin only when n > -1; for other n the value is not finite. The implementation computes n1 = (n + 1) * 0.5 and passes it to the Gamma function.
        alpha (float): Positive quadratic exponent in the Gaussian factor exp(-alpha * x^2). In PySCF this parameter comes from the Gaussian primitive exponent that controls the spatial decay of basis functions; larger alpha produces a more rapidly decaying integrand. For the usual real-valued integral the real part of alpha must be positive to ensure convergence. The code uses alpha**n1 in the denominator, so alpha should not be zero to avoid division by zero.
    
    Returns:
        float: The analytical value of the integral int_0^inf x^n exp(-alpha x^2) dx computed as scipy.special.gamma((n+1)/2) / (2. * alpha**((n+1)/2)). For standard real inputs satisfying n > -1 and alpha > 0 this is a real floating-point result representing the contribution of the radial moment to Gaussian integrals in quantum-chemistry calculations. If alpha is nonpositive or if n is outside the convergence range, the result may be infinite, undefined, or complex (depending on Python/scipy numeric behavior); the function itself does not perform input validation beyond the arithmetic operations and will propagate exceptions raised by scipy.special.gamma or by invalid numeric operations. The function has no side effects.
    """
    from pyscf.gto.mole import gaussian_int
    return gaussian_int(n, alpha)


################################################################################
# Source: pyscf.gto.mole.is_au
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_is_au(unit: str):
    """Return whether the given unit string is recognized as atomic units (A.U.) by PySCF.
    
    This function is part of pyscf.gto.mole and is used within the PySCF molecular input and geometry handling code to decide whether user-supplied unit strings should be interpreted as atomic units (a.u.). In quantum chemistry and within PySCF, atomic units are a common internal convention for expressing distances, energies, and other physical quantities; correctly detecting that a user requested atomic units affects scaling and interpretation of numerical values passed to the library.
    
    Args:
        unit (str): A unit identifier provided by the caller (for example, from molecule input). The function expects a Python str and performs a case-insensitive check of its prefix. Practically, strings that start with 'AU' (e.g., 'au', 'A.U.', 'AU') or with 'B' (commonly used as a shorthand for Bohr, e.g., 'B', 'Bohr', 'BOHR') are treated as indicating atomic units. If unit is not a str (for example, None, a numeric type, or another object), the function will not attempt conversion and will return False.
    
    Returns:
        bool: True if unit is a str whose uppercase form begins with either 'B' or 'AU', indicating the value should be interpreted in atomic units (a.u.). Returns False if unit is not a str or if the string does not start with those prefixes. Note that this prefix-based recognition is simple and may accept other strings beginning with 'B' (such as 'barn') as atomic units; callers that require stricter validation should perform additional checks before relying on this result.
    
    Side effects:
        None. This function is pure and does not modify global state, files, or objects. It only inspects the provided argument and returns a boolean.
    """
    from pyscf.gto.mole import is_au
    return is_au(unit)


################################################################################
# Source: pyscf.gto.mole.fromfile
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_fromfile(filename: str, format: str = None):
    """pyscf.gto.mole.fromfile reads a molecular geometry from a plain text file and returns the parsed representation suitable for constructing a PySCF molecule (primarily used in test code and simple I/O workflows).
    
    This function opens the file at the given path, optionally infers the format from the filename extension when format is None, reads the entire file as text, and delegates parsing to pyscf.gto.mole.fromstring. Supported textual input formats (as recognized by this function and passed to fromstring) include "raw", "xyz", "zmat", and "sdf". The "raw" format is a simple, line-oriented format where each non-empty line contains an atomic symbol followed by three Cartesian coordinates: symbol x y z. The function uses a with-open context to ensure the file is closed after reading.
    
    Args:
        filename (str): Filesystem path to the input file containing molecular geometry. This is the path that will be opened for reading in text mode. The argument must be a string because the function calls os.path.splitext(filename) to derive the extension when format is None; passing a non-string will raise a TypeError. Typical values are paths ending in .xyz, .zmat, .sdf or any other extension; when format is None the extension (the substring after the final dot) is converted to lower case and used to choose the parser.
        format (str): Explicit parser format name to use when interpreting the file contents. Valid values understood by this function are "raw", "xyz", "zmat", and "sdf". If format is None (the default), the implementation will infer the format by taking os.path.splitext(filename)[1][1:].lower() and using that extension if it is one of "xyz", "zmat", or "sdf"; otherwise the function falls back to the "raw" format. Passing an unsupported format string will be forwarded to pyscf.gto.mole.fromstring and may cause a parsing error there.
    
    Returns:
        object: The parsed molecular geometry as returned by pyscf.gto.mole.fromstring when called with the file contents and the chosen format. The returned object is the representation used by PySCF routines to describe atomic coordinates/structure and is suitable for constructing a pyscf.gto.Mole or for other downstream PySCF geometry handling. Any parsing errors, file I/O errors (for example FileNotFoundError if the path does not exist), or decoding errors will be raised to the caller. The function has the side effect of opening and reading the file contents (the file is closed automatically), and otherwise does not modify external state.
    """
    from pyscf.gto.mole import fromfile
    return fromfile(filename, format)


################################################################################
# Source: pyscf.gto.mole.gto_norm
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_gto_norm(l: int, expnt: float):
    """Normalized factor for a Gaussian-type orbital (GTO) radial function r^l * exp(-alpha * r^2).
    
    This function computes the scalar normalization constant N that enforces
    1/sqrt(integral_0^inf [g(r)]^2 r^2 dr) for the radial part g(r) = r^l exp(-alpha r^2).
    It is used throughout the PySCF quantum-chemistry codebase to normalize primitive
    GTO radial functions when building basis functions for molecular electronic-structure
    calculations (see the repository README for PySCF context). The returned normalization
    factor ensures that the associated three-dimensional GTO basis function has unit
    norm under the usual volume element r^2 dr dOmega.
    
    Args:
        l (int): Angular momentum quantum number for the radial factor r^l. This must
            be an integer greater than or equal to 0; negative values are not allowed.
            In the context of basis functions, l determines the polynomial prefactor
            of the radial part and therefore the orbital type (s, p, d, ...).
        expnt (float): Gaussian exponent alpha in the radial factor exp(-alpha * r^2).
            This is the numerical exponent that controls the radial decay of the
            Gaussian primitive. In practice, expnt is supplied from basis-set definitions
            and determines the spatial extent of the GTO primitive; larger values
            produce more tightly localized functions.
    
    Returns:
        float: The normalization factor N (a positive real scalar) such that multiplying
        the primitive radial function r^l * exp(-alpha * r^2) by N yields a normalized
        radial part with respect to the radial integral weight r^2. This value is
        computed from the analytic integral of g(r)^2 and returned as a Python float.
    
    Raises:
        ValueError: If l < 0, a ValueError is raised with the message 'l should be >= 0'.
            This enforces the mathematical requirement that the angular momentum
            index be non-negative.
    
    Behavior and implementation notes:
        The function implements the normalization used for primitive GTO radial parts
        in PySCF and is equivalent to the closed-form expression derived from the
        definite integral of r^{2l+2} exp(-2*alpha*r^2) over r in [0, infinity). The
        current implementation delegates the integral evaluation to an internal
        gaussian_int routine (called with order = 2*l+2 and exponent = 2*alpha)
        and returns 1/sqrt(integral). The function has no side effects (it does not
        modify global state) and returns a scalar float. Although the code uses NumPy
        utilities internally, the documented input types are a Python integer for l
        and a Python float for expnt. Passing nonstandard numeric values (for example,
        expnt equal to zero or a negative number) can produce non-finite or invalid
        results because the underlying radial integral diverges in those cases; such
        input values are not validated by this function beyond the check on l.
    References:
        The normalization convention follows the treatment of GTO primitives used in
        quantum-chemistry literature (see H. B. Schlegel and M. J. Frisch, Int. J.
        Quant. Chem., 54 (1995), 83-87), and is the convention used in PySCF basis
        set handling.
    """
    from pyscf.gto.mole import gto_norm
    return gto_norm(l, expnt)


################################################################################
# Source: pyscf.gto.mole.filatov_nuc_mod
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_filatov_nuc_mod(nuc_charge: float, nucprop: dict = {}):
    """pyscf.gto.mole.filatov_nuc_mod computes the Gaussian exponent parameter zeta for the Filatov nuclear charge distribution model used in PySCF to represent a finite (smeared) nuclear charge density of the form rho(r) = nuc_charge * Norm * exp(-zeta * r^2). This exponent is an empirical fit (Filatov & Cremer) expressed in the implementation below and is used whenever a Gaussian representation of the nuclear charge is required in molecular-integral construction or relativistic/finite-nucleus corrections within the PySCF framework.
    
    The routine evaluates an empirical expression for an effective nuclear radius r (using a fit that depends on the scalar nuclear charge and the library constant param.LIGHT_SPEED) and returns zeta = 1 / (r**2). The implementation follows the fits reported in M. Filatov and D. Cremer, Theor. Chem. Acc. 108, 168 (2002) and Chem. Phys. Lett. 351, 259 (2002). The result is a single scalar floating-point Gaussian exponent used to parameterize the radial decay of the Gaussian nuclear charge distribution.
    
    Args:
        nuc_charge (float): Nuclear charge value (Z) supplied as a Python float. In practical PySCF use this represents the total nuclear charge that multiplies the normalized Gaussian density rho(r) = nuc_charge * Norm * exp(-zeta * r^2). The function calls charge(nuc_charge) internally to coerce/validate the input; passing zero will lead to a division-by-zero when evaluating the fit (nuc_charge appears in a 1/nuc_charge term) and therefore is invalid. Non-numeric types will raise TypeError or a related error from the internal charge() routine. The numerical value directly controls the fitted radius and hence the returned zeta: larger nuc_charge generally leads to a different fitted radius and therefore a different Gaussian exponent according to the Filatov fit.
        nucprop (dict): Optional dictionary of per-nucleus properties accepted for API compatibility with other nuclear models. This argument is provided with a default empty dict and is currently ignored by the Filatov fit implementation (no keys are read and there are no side effects). It is present to allow callers that pass a properties mapping without changing call sites; changing this dict has no effect on the returned zeta.
    
    Returns:
        float: The Gaussian exponent zeta for the Filatov nuclear charge distribution (a positive floating-point scalar). This value parameterizes the Gaussian nuclear density rho(r) = nuc_charge * Norm * exp(-zeta * r^2) and is intended for use in constructing nuclear potentials and integrals that model finite nuclear size effects in quantum-chemical calculations. If the computation cannot be performed because nuc_charge is zero or produces invalid arithmetic, a Python exception (e.g., ZeroDivisionError, TypeError, or a ValueError propagated from charge()) will be raised instead of returning a value.
    
    References:
        M. Filatov and D. Cremer, Theor. Chem. Acc. 108, 168 (2002).
        M. Filatov and D. Cremer, Chem. Phys. Lett. 351, 259 (2002).
    
    Notes:
        The computed zeta depends on the global constant param.LIGHT_SPEED and the behavior of charge(), so modifications to those global objects affect the returned value. The function performs no I/O and has no persistent side effects.
    """
    from pyscf.gto.mole import filatov_nuc_mod
    return filatov_nuc_mod(nuc_charge, nucprop)


################################################################################
# Source: pyscf.gto.mole.len_spinor
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_len_spinor(l: int, kappa: int):
    """pyscf.gto.mole.len_spinor returns the number of spinor components (spinor basis functions) associated with a given orbital angular momentum quantum number and kappa index. This helper is used in the PySCF molecular integrals and basis construction code to determine how many spinor functions should be allocated or iterated for a particular (l, kappa) channel when building relativistic or spinor-enabled basis sets in the pyscf.gto.mole module.
    
    Args:
        l (int): Orbital angular momentum quantum number for the shell. In the context of PySCF and atomic/molecular basis construction, l selects the spatial angular momentum (e.g., 0 for s, 1 for p). This parameter is expected to be an integer (typically non-negative in normal quantum-chemical use). The function uses l in simple linear formulas to compute the spinor count; if l is negative or not an integer the numeric result may be non-physical or a TypeError may be raised by Python arithmetic/compare operations.
        kappa (int): Kappa index that distinguishes spinor coupling types for the given angular momentum. In PySCF this integer controls which formula is used to count spinor components: a kappa value of 0 triggers the special case for full four-component-like counting (4*l + 2), kappa < 0 selects the (2*l + 2) branch, and kappa > 0 selects the (2*l) branch. The value is compared to zero using integer comparisons; if kappa is not an int the comparison may raise a TypeError.
    
    Returns:
        int: The number of spinor components associated with the specified l and kappa. The returned integer is computed exactly as implemented in pyscf.gto.mole.len_spinor: 4*l + 2 when kappa == 0, 2*l + 2 when kappa < 0, and 2*l when kappa > 0. This return value is intended for use in allocating arrays, iterating over spinor channels, and bookkeeping when constructing spinor or relativistic basis functions in PySCF. There are no side effects. Invalid or non-physical inputs (for example negative l in a chemical context, or non-integer types) will not be validated by this function and can lead to non-physical return values or runtime TypeError/ValueError from Python operations.
    """
    from pyscf.gto.mole import len_spinor
    return len_spinor(l, kappa)


################################################################################
# Source: pyscf.gto.mole.len_cart
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_len_cart(l: int):
    """pyscf.gto.mole.len_cart computes the number of Cartesian Gaussian-type basis functions associated with a given angular momentum quantum number. This function is part of the PySCF gto.mole utilities and is used when building atomic orbital basis sets, allocating integrals and arrays, and mapping angular momentum labels (s, p, d, f, ...) to the corresponding number of Cartesian components required by Cartesian Gaussian basis representations.
    
    Args:
        l (int): Angular momentum quantum number for the atomic orbital. This is expected to be a non-negative integer where l = 0 corresponds to an s-type function, l = 1 to p-type, l = 2 to d-type, l = 3 to f-type, and so on. The function computes the Cartesian count using the combinatorial formula (l + 1) * (l + 2) // 2, which yields common values: l=0 -> 1, l=1 -> 3, l=2 -> 6, l=3 -> 10. The argument has no default and must be supplied by the caller. Passing negative integers is not physically meaningful for angular momentum (the formula will produce a numeric result for some negative inputs but such results should not be used in basis construction). Passing non-integer types is not supported by the function signature (annotated as int) and may produce an incorrect or non-integer numeric result; callers should ensure l is an int before calling.
    
    Returns:
        int: The number of Cartesian basis functions for the given angular momentum, computed as (l + 1) * (l + 2) // 2. This integer value is used in PySCF to determine the dimensionality of arrays and the number of Cartesian components per atomic orbital when constructing Cartesian Gaussian basis sets. The function has no side effects (it is pure and does not modify global state). Note that very large values of l will produce correspondingly large return values and may lead to large memory allocations downstream when those counts are used to size arrays.
    """
    from pyscf.gto.mole import len_cart
    return len_cart(l)


################################################################################
# Source: pyscf.gto.mole.format_atom
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_format_atom(
    atoms: list,
    origin: numpy.ndarray = 0,
    axes: numpy.ndarray = None,
    unit: str = "angstrom"
):
    """pyscf.gto.mole.format_atom converts a user-provided molecular geometry (the same form accepted by Mole.atom in PySCF) into PySCF's internal atomic list format used throughout the library for building Mole objects, performing integrals, and running quantum-chemical simulations. The function normalizes nuclear-charge notations to element symbols, converts coordinates into atomic units (Bohr) according to the specified unit, applies an optional rotation (axes) and translation (origin), and accepts both inline geometry strings and Python lists or tuples as input. This conversion is a necessary preprocessing step in PySCF so downstream modules receive a consistent, unit-correct, and oriented geometry.
    
    Args:
        atoms (list or str): Input geometry in the same forms accepted by Mole.atom. Practical examples from the source include a Python list of atom specifications (e.g. [['H', (0.0, 0.0, 0.0)], ['O', (0.0, 0.0, 1.0)]]) or a string containing atom lines separated by newlines, semicolons, or commas. If a string names an existing filesystem path, the file will be read and parsed. The parser accepts numeric coordinates, atomic-number or symbol notations (numeric nuclear charges are converted to element symbols), recognizes comment lines beginning with '#', ignores blank lines, and will call a Z-matrix parser (from_zmatrix) when the first non-comment token on the first line has fewer than four entries. Improperly formatted coordinate tokens raise ValueError. This argument is the primary user-facing way to supply molecular geometries to PySCF routines, so correct formatting here ensures accurate molecular integrals and electronic-structure results.
        origin (numpy.ndarray): New axis origin used to translate coordinates before returning them. If origin is the default scalar 0, the input geometry is treated as already referenced to the global origin (0,0,0). In practice provide a length-3 array-like specifying the translation vector (in the same units as the input coordinates) to shift all atomic positions: the function computes (coords - origin) before applying axes and unit conversions. Supplying a non-3-vector will lead to broadcasting/subtraction errors or incorrect geometry; malformed origin values are a source of ValueError or NumPy errors at runtime.
        axes (numpy.ndarray): Optional 3x3 matrix whose rows (new_x, new_y, new_z) define a new coordinate basis to rotate/scale the input coordinates. If axes is None (the common/default case), the function uses the 3x3 identity matrix so no rotation is applied. When provided, axes is multiplied by the coordinate vectors (after translating by origin and scaling by unit) to produce coordinates expressed in the new basis. Passing an array of incorrect shape or non-numeric entries will raise NumPy errors; axes is used to orient the molecule for symmetry alignment, fragment placement, or to match external coordinate conventions in downstream PySCF workflows.
        unit (str or number): Descriptor of the units of the input coordinates. If unit is a string and refers to atomic units (common accepted strings include 'B', 'b', 'Bohr', 'bohr', 'AU', 'au' as recognized by the is_au helper), the coordinates are treated as already in Bohr and no length conversion is performed. If unit is a string referring to angstrom units (e.g. 'A', 'a', 'Angstrom', 'angstrom', 'Ang', 'ang') or any other non-AU string, the function converts Angstrom to Bohr by multiplying coordinates with (1 / param.BOHR). If unit is a numeric value, it is interpreted as the Bohr length in angstroms (for example, ~0.529177 for Bohr) and the code uses 1.0 / unit as the conversion factor; setting unit=1 preserves the numeric values of the input coordinates (no unit conversion). This parameter controls how the input geometry is converted to atomic units required by PySCF integrals; incorrect unit settings lead to physically incorrect interatomic distances and consequently wrong electronic-structure results.
    
    Returns:
        list: A list of pairs (symbol, [x, y, z]) in PySCF's internal format, where symbol is the atomic symbol string (nuclear charge numbers in the input have been converted to symbols) and [x, y, z] is a length-3 list of floating-point coordinates in atomic units (Bohr) after applying the origin translation and axes transformation. Example return value: [('F', [-1.0, -1.0, -1.0]), ('H', [-1.0, -1.0, 0.0])]. The returned list is the canonical geometry representation consumed by PySCF Mole construction and integral routines.
    
    Behavior, side effects, defaults, and failure modes:
        - If atoms is a string and matches an existing file path, the function attempts to read and parse that file (via fromfile); I/O errors or parsing failures from the file will propagate as exceptions (the implementation writes a short stderr message before re-raising ValueError for parse failures).
        - Inline string parsing treats semicolons as line separators and commas/tabs/extra whitespace as token separators; lines starting with '#' are ignored as comments; blank lines are ignored.
        - If the first non-comment line has fewer than four whitespace-separated tokens, the parser will treat the input as a Z-matrix and call from_zmatrix to expand internal coordinates to Cartesian coordinates.
        - Numeric coordinate tokens are normally parsed with float(); if that raises ValueError and the module-level flag DISABLE_EVAL is False, the code falls back to eval() on the coordinate expressions (this can execute arbitrary code and thus presents a security risk if parsing untrusted strings). If DISABLE_EVAL is True and parsing fails, a ValueError is raised with a message indicating the failed line.
        - If no atoms remain after parsing (empty or only-comment input), the function returns an empty list.
        - axes defaults to the 3x3 identity matrix when None; origin defaults to 0 which is interpreted as no translation. unit defaults to "angstrom" (string) per the function signature and original behavior, which causes conversion from Angstrom to Bohr using the library constant param.BOHR unless an atomic-unit string or numeric conversion factor is provided.
        - The function raises ValueError on malformed coordinate lines (e.g., wrong number of coordinate components) and may raise various NumPy exceptions if origin or axes have incompatible shapes. Calling code should catch these exceptions when parsing user-provided or file-based geometries.
        - No persistent global state is modified, but the function may read files and (unless DISABLE_EVAL is True) may evaluate expressions via eval during parsing.
        - This preprocessing is essential in PySCF: incorrect inputs here produce wrong geometries and therefore incorrect energies, integrals, and derived properties in quantum-chemical calculations.
    """
    from pyscf.gto.mole import format_atom
    return format_atom(atoms, origin, axes, unit)


################################################################################
# Source: pyscf.gto.mole.loads
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_loads(molstr: str):
    """pyscf.gto.mole.loads deserializes a JSON document string into a pyscf.gto.mole.Mole object used by the PySCF (Python-based Simulations of Chemistry Framework) library. This function is intended to restore a Mole instance previously serialized by the corresponding dumps routine so that geometry, basis, effective core potentials (ECP), and internal low-level arrays can be used directly in quantum chemistry calculations, checkpoint recovery, or interprocess transfer within PySCF workflows.
    
    Args:
        molstr (str): A JSON document represented as a Python str. The JSON is expected to be the output of pyscf.gto.mole.dumps or an equivalent serializer that encodes a Mole object's state. Typical required keys encoded in this string include 'atom', 'basis', and 'ecp' stored as Python-expressible strings; optional keys include 'pseudo' for pseudopotential data and metadata fields such as '_atm', '_bas', '_env', and '_ecpbas' representing internal arrays. The function parses the string with json.loads to a dict and then reconstructs Python-level objects by updating a new Mole instance's __dict__ and evaluating the textual Python expressions (via eval) for atom, basis, ecp, and pseudo. Because eval is used, numpy.array is imported into the local namespace to allow array(...) expressions in the serialized text to evaluate correctly. Do not pass untrusted input: eval will execute arbitrary code contained in molstr and thus presents a security risk if molstr originates from an untrusted source.
    
    Behavior and side effects:
        The function creates a new Mole() instance and updates its __dict__ with the dictionary obtained from json.loads(molstr). It then replaces string-encoded attributes by evaluating them: mol.atom, mol.basis, mol.ecp, and, if present, mol.pseudo are converted from their textual representations to Python objects by eval. Internal numeric bookkeeping arrays are converted to NumPy arrays with fixed dtypes: mol._atm -> numpy.int32, mol._bas -> numpy.int32, mol._env -> numpy.double, and mol._ecpbas -> numpy.int32. If mol.symmetry is true and mol._symm_orig is not None, the function imports pyscf.symm and reconstructs symmetry-adapted orbitals and irrep identifiers via symm.symm_adapted_basis, setting mol._symm_orig, mol._symm_axes, mol.symm_orb, mol.irrep_id, and mol.irrep_name accordingly. For backward compatibility with older PySCF checkpoints, if mol.symmetry is true and mol.symm_orb is present in a compressed legacy format, the function decompresses the stored representation into full NumPy arrays and assigns mol.symm_orb. The function also imports the name array from numpy into the eval namespace to support legacy serialized expressions.
    
    Failure modes and exceptions:
        json.loads will raise json.JSONDecodeError (or ValueError on some Python versions) if molstr is not valid JSON. Evaluating textual fields with eval can raise NameError, SyntaxError, TypeError, ValueError, or arbitrary exceptions if the serialized expressions are malformed or reference names not present in the eval environment. Because eval executes code, malicious input can execute arbitrary Python code; do not call this function on untrusted data. Importing pyscf.symm may raise ImportError if the symm module is unavailable. Reconstruction of symmetry objects relies on the serialized metadata having compatible shapes and contents; mismatches or corrupted legacy encodings can raise IndexError or other array-shape-related errors during decompression.
    
    Returns:
        Mole: A pyscf.gto.mole.Mole instance reconstructed from the JSON string. The returned object has its high-level attributes (atom, basis, ecp, optional pseudo) converted from their serialized string forms to Python objects, internal arrays converted to NumPy arrays with types suitable for PySCF internals, and symmetry-related structures reconstructed when the serialized data contains the necessary metadata. The function returns the new Mole for immediate use in PySCF calculations; no file I/O is performed by this function itself.
    """
    from pyscf.gto.mole import loads
    return loads(molstr)


################################################################################
# Source: pyscf.gto.mole.make_bas_env
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_make_bas_env(basis_add: list, atom_id: int = 0, ptr: int = 0):
    """Convert a PySCF Mole.basis specification into the two arrays expected by the
    libcint integral engine: the per-shell descriptor array ("bas") and the
    flattened numerical environment array ("env"). This function is used in the
    PySCF gto/mole code path to translate a Python-level basis specification
    (basis_add) into the low-level, contiguous layout required by libcint for
    efficient computation of one- and two-electron integrals. The function handles
    contracted Gaussian primitives, optional relativistic kappa values, per-shell
    angular momentum, exponent/coefficent sorting, and normalization steps that
    match PySCF conventions (calls gto_norm and, when GLOBAL NORMALIZE_GTO is set,
    _calls _nomalize_contracted_ao_). It also emits a warning to stderr if a shell
    has angular momentum > 14 because the integral library may not support it.
    
    Args:
        basis_add (list): A list of basis-shell specifications to convert. Each
            element b in basis_add must be an indexable sequence where b[0] is the
            angular momentum (integer). If b[1] is an integer (checked using
            isinstance(b[1], (int, numpy.integer))), it is interpreted as the
            relativistic kappa value for the shell and the remaining items b[2:]
            are the primitive specifications; otherwise b[1:] are taken as the
            primitive specifications and kappa is assumed 0. Each primitive
            specification must itself be a sequence whose first entry is the
            exponent and whose remaining entries are contraction coefficients for
            each contracted function (so that after sorting by exponent the code
            constructs a 2D numpy array where column 0 contains exponents and the
            remaining columns contain contraction coefficients). The function
            sorts primitives in descending exponent order, applies per-primitive
            normalization factors via gto_norm(angl, exponents), and (if the
            global NORMALIZE_GTO flag is true) applies additional contracted-AO
            normalization via _nomalize_contracted_ao. This parameter is the
            primary, high-level representation of basis data used throughout PySCF
            and must follow the structure expected by the rest of the library.
        atom_id (int): Integer identifier of the atom to which all shells in
            basis_add belong. This value is written into the "bas" descriptor for
            every shell as the first field (libcint uses this to associate shells
            with atomic positions in the global coordinate/environment arrays).
            Default is 0. The function does not validate that atom_id matches any
            external molecule structure; it simply writes the supplied integer
            into each bas entry.
        ptr (int): Integer starting offset into the flattened environment array
            (env). This function treats ptr as the current insertion index for
            exponent and coefficient data and advances it according to the number
            of primitives and contraction coefficients in each shell. For each
            shell, ptr_exp is set to the current ptr, ptr_coeff is ptr_exp + nprim,
            and after appending the exponent and coefficient blocks ptr is updated
            to ptr_coeff + nprim*nctr. Supplying a nonzero ptr allows callers to
            concatenate multiple calls into a single env array. Default is 0.
    
    Returns:
        tuple: A pair (bas, env) prepared for libcint usage.
        bas (numpy.ndarray of dtype numpy.int32): A 2-D array with shape (-1, BAS_SLOTS)
            where each row is a shell descriptor matching libcint's expected layout.
            Each row is produced in the order used in the source code:
            [atom_id, angl, nprim, nctr, kappa, ptr_exp, ptr_coeff, 0]. The array is
            created with numpy.array(..., numpy.int32) and reshaped to have BAS_SLOTS
            columns; BAS_SLOTS is a module-level constant used by PySCF/libcint.
        env (numpy.ndarray of dtype numpy.double): A 1-D flattened array containing
            all primitive exponents and contraction coefficients appended in the
            order produced in the code: for each shell the exponent vector (nprim
            values) is appended first, followed by the coefficient matrix stored
            column-major as cs.T.reshape(-1) (after applying gto_norm and optional
            contracted-AO normalization). The function uses lib.flatten to ensure
            the result is a plain 1-D numeric array suitable for passing to C-level
            integrals.
    
    Behavior and side effects:
        - The function does not mutate basis_add; it reads each shell specification
          and constructs new numpy arrays for bas and env.
        - Primitive exponents for each shell are sorted in descending order before
          further processing; contraction coefficients are reordered to match that
          sorting.
        - Coefficients are multiplied by per-primitive normalization factors
          returned by gto_norm(angl, exponents) via numpy.einsum('pi,p->pi', ...).
          If the module-global flag NORMALIZE_GTO is true, coefficients are further
          normalized by calling _nomalize_contracted_ao(angl, exponents, coeffs).
        - If a shell has angular momentum greater than 14, the function writes a
          warning message to sys.stderr: "Warning: integral library does not
          support basis with angular momentum > 14". This is a warning only; the
          function will still attempt to construct bas/env arrays but libcint may
          later fail or produce incorrect integrals.
        - The function relies on module-level symbols (gto_norm, _nomalize_contracted_ao,
          NORMALIZE_GTO, lib.flatten, BAS_SLOTS) to perform normalization and final
          flattening; their presence and semantics affect the output format.
    
    Failure modes and errors:
        - If elements of basis_add are malformed (missing expected entries, wrong
          nesting, or items of incompatible types), the function may raise
          IndexError, TypeError, or ValueError when accessing b[...] elements,
          converting to numpy arrays, or unpacking shapes. Callers must ensure
          basis_add follows the structure described above.
        - Incorrect atom_id or ptr types (non-integer) will likely raise TypeError
          when used to build the bas array or when performing pointer arithmetic.
        - The function does not validate consistency between bas entries and any
          external coordinate/environment arrays; mismatches must be avoided by
          the caller to prevent downstream errors in integral evaluation.
    
    Practical significance in PySCF:
        - This conversion is a core step when preparing basis data for integral
          evaluation in PySCF. The returned bas/env pair is passed to the C-level
          libcint routines that compute overlap, kinetic, nuclear attraction, and
          electron repulsion integrals; therefore, correctness of sorting,
          normalization, and pointer arithmetic here is essential for numerically
          correct quantum chemistry calculations in PySCF.
    """
    from pyscf.gto.mole import make_bas_env
    return make_bas_env(basis_add, atom_id, ptr)


################################################################################
# Source: pyscf.gto.mole.unpack
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_unpack(moldic: dict):
    """Unpack a dictionary produced by pyscf.gto.mole.pack to reconstruct a pyscf.gto.mole.Mole object used as input for quantum chemistry calculations.
    
    This function creates a new Mole instance and populates its attribute dictionary directly from the provided mapping. It is intended to reverse the transformation performed by pyscf.gto.mole.pack so that a serialized or transferred representation of a molecule (for example, saved to disk, sent between processes, or persisted for later reuse) can be restored as a Mole object ready to be used by PySCF routines (SCF, DFT, post-HF methods). Note that unpack bypasses Mole.__init__ initialization logic and therefore does not perform validation, recomputation of derived attributes, or initialization side effects that the constructor might normally run.
    
    Args:
        moldic (dict): Dictionary previously produced by pyscf.gto.mole.pack that encodes the internal state and input arguments of a pyscf.gto.mole.Mole. The keys and values are copied into the new Mole instance's __dict__ using a shallow update. In the domain of electronic structure calculations, moldic typically contains fields such as atomic coordinates, basis set specifications, charge, spin, and other Mole attributes required to set up integrals and mean-field calculations. The caller is responsible for providing a dict in the expected pack format; passing other mappings or dicts with incompatible keys or value types may produce a Mole with incorrect or inconsistent state.
    
    Returns:
        Mole: A new pyscf.gto.mole.Mole instance whose attribute dictionary has been updated from moldic. The returned object is intended to be used as the same kind of Mole input that would be constructed by calling the Mole constructor with equivalent arguments, but because __init__ is not invoked, some derived attributes or internal caches may be missing or stale. Consumers should call any necessary Mole methods or reinitialize derived data if required before using the object in computations.
    
    Failure modes and side effects:
        - If moldic is not a dict, a TypeError may be raised when attempting to update the Mole.__dict__.
        - The update is shallow: mutable objects referenced in moldic remain shared with the caller and are not deep-copied.
        - Keys in moldic that do not correspond to established Mole attributes will be set as attributes on the returned object, which can lead to unexpected behavior in downstream PySCF code.
        - There is no compatibility guarantee across PySCF versions: unpacking a dict produced by pack from a different PySCF release may omit required fields or include deprecated ones, leading to runtime errors when the Mole is used in calculations.
    """
    from pyscf.gto.mole import unpack
    return unpack(moldic)


################################################################################
# Source: pyscf.gto.mole.sph2spinor_l
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_sph2spinor_l(l: int):
    """pyscf.gto.mole.sph2spinor_l: Compute the real spherical-to-spinor transformation matrix for a given orbital angular momentum l.
    
    This function returns the linear transformation matrix that maps coefficient vectors expressed in the real-valued spherical harmonic basis (orbital angular momentum l) into the spinor spherical-harmonic basis used in two-component/spinor representations within PySCF. It is a thin wrapper that delegates to pyscf.gto.mole.sph2spinor_kappa with kappa fixed to 0 (sph2spinor_kappa(0, l)). In practical quantum-chemistry workflows inside PySCF, this matrix is used when constructing spinor orbitals, transforming integrals, or converting basis-function expansions between real spherical harmonics and the spinor basis required by relativistic or spin-dependent computations.
    
    Args:
        l (int): Orbital angular momentum quantum number. This parameter specifies the angular momentum shell for which the transformation is produced (commonly l = 0, 1, 2, ... for s, p, d, ... shells). The value of l identifies the real spherical-harmonic subspace dimension and therefore determines the size and structure of the returned transformation matrix. The function expects an integer-valued l; invalid values (for example, non-integer or negative) will be rejected by the underlying routine sph2spinor_kappa.
    
    Returns:
        ndarray: A dense transformation matrix that, when left-multiplied with a column vector of expansion coefficients in the real spherical-harmonic basis for angular momentum l, yields the corresponding coefficients in the spinor spherical-harmonic basis. The matrix is produced by calling sph2spinor_kappa(0, l) and carries the same mathematical role and orientation as that routine's return value. No in-place modification of input arguments occurs.
    
    Behavior and failure modes:
        The function has no side effects beyond returning the matrix. It delegates all computation and validation to pyscf.gto.mole.sph2spinor_kappa with kappa fixed to 0. If l is not a valid orbital angular momentum accepted by the underlying routine, an exception originating from sph2spinor_kappa will be raised; callers should ensure l is an appropriate non-negative integer for their application.
    """
    from pyscf.gto.mole import sph2spinor_l
    return sph2spinor_l(l)


################################################################################
# Source: pyscf.gto.mole.uncontract
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_uncontract(_basis: list):
    """pyscf.gto.mole.uncontract: Uncontract a PySCF internal-format contracted basis (_basis) into a flat list of primitive Gaussian basis entries suitable for routines that require primitive (uncontracted) functions, such as low-level integral generation, linear-dependency checks, or exporting primitives for analysis. This function implements the behavior used in PySCF to convert contracted basis descriptions (lists of shells with contracted primitives) into a list where each primitive has an explicit exponent and a unit contraction coefficient.
    
    Args:
        _basis (list): The contracted basis description in PySCF internal format. Each element of _basis is expected to be a list-like shell entry whose first item is the angular momentum (int). The second item may be an integer kappa (for relativistic/generalized-contraction information) or the first primitive tuple; when the second item is an integer (detected by isinstance(kappa, (int, np.integer))), the remaining items (from index 2 onward) are treated as primitive tuples; otherwise, primitives start from index 1. Each primitive tuple is expected to provide the exponent as its first element (the code uses p[0] to read the exponent). The function converts contracted primitives into entries with a contraction coefficient of 1. Practical significance: callers should pass the same internal basis representation produced or used elsewhere in PySCF (for example, output of gto.load or molecule._basis) so that uncontracted primitives match the conventions used across PySCF.
    
    Returns:
        list: A flat list of uncontracted primitive basis entries. Each entry in the returned list is one of the following forms derived directly from the internal input convention:
            - [angl, kappa, [exponent, 1]] when the shell had an integer kappa in the input (kappa preserved and the contraction coefficient set to 1),
            - [angl, [exponent, 1]] when the shell did not include a kappa integer (contraction coefficient set to 1).
        The returned list preserves only one primitive per unique exponent (duplicates are removed). Duplication removal is implemented by rounding primitive exponents to 9 decimal places and calling numpy.unique; primitives are then ordered from larger exponent to smaller exponent within each angular momentum block before being concatenated into the final list. There is no other side effect beyond emitting a warning for nonzero kappa shells.
    
    Behavior, defaults, and failure modes:
        - The function uses an internal MAXL = 10 and allocates temporary lists for angular momenta 0..9. If an input shell has angular momentum >= 10, the function will raise an IndexError because the internal arrays do not accommodate higher angular momenta.
        - When a shell contains an integer kappa and kappa != 0, the function issues a runtime warning: "For basis with kappa != 0, the uncontract basis might be wrong. Please double check the resultant attribute mol._basis". This documents a known limitation: uncontracting for nonzero kappa shells may not preserve all special contraction semantics and should be manually verified in the caller's molecular object (mol._basis).
        - Duplicate primitive exponents are removed using numpy.array and numpy.unique after rounding exponents to 9 decimal places. Users should be aware that exponents that differ by less than 1e-9 (relative to the exponent scale) will be treated as identical and deduplicated; this is intended to avoid numerical duplicates introduced by formatting/precision differences.
        - The function sets the contraction coefficient of every resulting primitive to 1. This is the practical meaning of "uncontracted" here: each primitive is represented explicitly with unit contraction weight, which is suitable for lower-level operations that expect primitives rather than contracted combinations.
        - The function relies on numpy being available (it uses numpy.array and numpy.unique) and on the standard warnings module to emit the nonzero-kappa warning.
        - The function returns a new list and does not modify the input _basis in place. Callers should inspect the returned list or the molecule attributes (e.g., mol._basis in PySCF workflows) to confirm correctness after uncontracting.
    """
    from pyscf.gto.mole import uncontract
    return uncontract(_basis)


################################################################################
# Source: pyscf.gto.moleintor.ascint3
# File: pyscf/gto/moleintor.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_moleintor_ascint3(intor_name: str):
    """pyscf.gto.moleintor.ascint3 converts a legacy cint2-style integral routine name into the cint3-style name used by PySCF's molecular integral layer.
    
    This function is used in the molecular integrals subsystem of PySCF (Python-based Simulations of Chemistry Framework) to adapt older cint2 naming conventions to the cint3 naming conventions expected by the moleintor code paths that dispatch spinor, spherical, cartesian, or spin-specific integral implementations. In practice, callers supply the textual identifier of an integral routine (for example, a string used to look up a C-accelerated integral kernel) and ascint3 returns a normalized name suitable for selecting the corresponding cint3 kernel.
    
    Behavior and transformation rules:
    - If the input string begins with the prefix 'cint', the leading 'c' is removed (e.g., 'cint2e' -> 'int2e'). This mirrors the transition from cint2-prefixed identifiers to cint3 identifiers within the PySCF integrals naming scheme.
    - If the resulting name does not already end with one of the recognized suffixes '_sph', '_cart', '_spinor', or '_ssc', the function appends the suffix '_spinor'. This ensures the returned name refers to a spinor-capable cint3 kernel when the original name did not explicitly specify spherical/cartesian/spinor/ssc variants.
    - No other parts of the name are modified.
    
    Side effects:
    - This function has no side effects on program state; it returns a new string and does not mutate external objects.
    
    Failure modes and notes:
    - The function expects intor_name to be a Python str as used throughout PySCF's integral name handling. If a non-string object is passed, attribute lookup for startswith/endswith will fail (raising an AttributeError), and such misuse should be avoided by callers.
    - An empty string input will result in '_spinor' being returned per the transformation rules (empty does not start with 'cint' and does not end with any recognized suffix).
    - The function does not validate that the returned name corresponds to an actually implemented kernel; it only performs syntactic normalization.
    
    Args:
        intor_name (str): The original integral routine name string to convert. In the PySCF domain this is typically a cint2-style identifier used to reference C-integral implementations (for example 'cint2e_sph' or 'cint2e'). The function uses this value to produce a cint3-compatible identifier by removing a leading 'c' if present and ensuring a spinor/suffix is present.
    
    Returns:
        str: The normalized cint3-style integral routine name. This string is derived from the input by removing a leading 'c' when the input starts with 'cint' and by appending '_spinor' if the name does not already end with one of the recognized suffixes ('_sph', '_cart', '_spinor', '_ssc'). The returned name is intended for use by PySCF's moleintor dispatch logic to select the appropriate cint3 kernel.
    """
    from pyscf.gto.moleintor import ascint3
    return ascint3(intor_name)


################################################################################
# Source: pyscf.gto.mole.sph2spinor_kappa
# File: pyscf/gto/mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_mole_sph2spinor_kappa(kappa: int, l: int = None):
    """pyscf.gto.mole.sph2spinor_kappa returns the real-spherical-to-spinor transformation matrices for a specified relativistic quantum number kappa used in PySCF angular-momentum / spinor basis construction. The function obtains the full transformation matrices from pyscf.symm.sph.sph2spinor(l) and then selects the subset of columns corresponding to the spinor block associated with the requested kappa. This transformation is used in PySCF to convert basis functions expressed in real spherical harmonics into the two-component spinor blocks (commonly needed when building spinor-adapted integrals or working with relativistic/special spin-coupled basis representations).
    
    Args:
        kappa (int): The relativistic quantum number that identifies the spinor block to extract. For positive kappa the function treats l = kappa and returns the first 2*l columns of the full transformation matrices; for negative kappa it computes l = -kappa - 1 and returns the columns starting at index 2*l (i.e., ua[:, 2*l:] and ub[:, 2*l:]). If kappa is 0, the function does not compute l from kappa and instead requires an explicit l argument (see below). The value must be an integer; invalid integer values may cause exceptions from the underlying pyscf.symm.sph.sph2spinor call or from the subsequent slicing operations.
        l (int): Orbital angular momentum quantum number used to call pyscf.symm.sph.sph2spinor(l) and, when kappa == 0, to select which angular-momentum block to return. Default None. Behavior specifics:
            - If kappa != 0, the provided l value is effectively ignored for determining which block to extract because l is computed from kappa (l = kappa for kappa > 0; l = -kappa - 1 for kappa < 0). The function still calls pyscf.symm.sph.sph2spinor(l) with the original l argument (which may be None) to obtain the full matrices before slicing.
            - If kappa == 0, l must be provided (not None) and the implementation asserts that l <= 12; failing to provide l or providing l > 12 triggers an AssertionError. In this case the function returns the full transformation matrices as produced by pyscf.symm.sph.sph2spinor(l) without additional slicing.
            - If l is None and kappa != 0, the behavior depends on pyscf.symm.sph.sph2spinor(None) and the returned full matrices; the function will then slice those matrices according to the computed l. Any errors raised by pyscf.symm.sph.sph2spinor for an invalid or unsupported l propagate to the caller.
    
    Behavior, side effects, defaults, and failure modes:
        - The function calls pyscf.symm.sph.sph2spinor(l) at the start to obtain two transformation matrices (ua, ub). The exact behavior and shapes of those matrices are determined by pyscf.symm.sph.sph2spinor for the given l argument.
        - After obtaining ua and ub, the function slices columns to isolate the spinor block corresponding to kappa as described above. For kappa > 0 it keeps columns [:, :2*l]; for kappa < 0 it keeps columns [:, 2*l:]; for kappa == 0 it returns ua and ub unchanged (subject to the l assertions).
        - No in-place modification of external state occurs; the function has no side effects beyond returning the sliced matrices and possibly raising exceptions.
        - The function raises AssertionError if kappa == 0 and l is None, or if kappa == 0 and l > 12, as enforced by the code. Other exceptions (for example IndexError or errors raised by pyscf.symm.sph.sph2spinor) may propagate if l or kappa lead to invalid indexing or unsupported arguments in the underlying routine.
        - Default: l defaults to None. When l is None and kappa != 0, the function relies on the underlying pyscf.symm.sph.sph2spinor(None) behavior to provide a matrix large enough to slice the required block.
    
    Returns:
        tuple: (ua, ub) where ua and ub are the two transformation matrices returned by pyscf.symm.sph.sph2spinor(l) after selecting the column block associated with the specified kappa. The returned matrices have the same data types and array-like structure as produced by pyscf.symm.sph.sph2spinor and represent the mapping from real spherical-harmonic basis functions to the spinor components (commonly interpreted as the spin-up and spin-down blocks) restricted to the requested kappa block.
    """
    from pyscf.gto.mole import sph2spinor_kappa
    return sph2spinor_kappa(kappa, l)


################################################################################
# Source: pyscf.gw.gw_ac.AC_pade_thiele_diag
# File: pyscf/gw/gw_ac.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gw_gw_ac_AC_pade_thiele_diag(sigma: numpy.ndarray, omega: numpy.ndarray):
    """Analytic continuation to the real axis using a Pade approximation constructed by Thiele's reciprocal difference method. This function is intended for use in the GW module of PySCF to transform self-energy data sampled on an imaginary-frequency axis (e.g., Matsubara frequencies) into a compact set of Pade coefficients that can be evaluated on the real-frequency axis for each orbital. The implementation follows Thiele's reciprocal difference algorithm (see J. Low Temp. Phys. 29, 179 (1977)). For each orbital the function selects subsets of input frequency and self-energy points, builds a Pade approximant via the helper routine thiele, and returns the complex Pade coefficients together with the corresponding subset of input frequency points used to construct the approximant.
    
    Args:
        sigma (numpy.ndarray): 2D array containing input self-energy (or other complex-valued frequency-dependent quantity) sampled on an imaginary-frequency grid. The array is interpreted with shape (norbs, nw) where norbs is the number of orbitals (rows) and nw is the number of sampled frequency points (columns). Values are read per-orbital and copied internally before processing so the input array is not modified in-place. sigma provides the data that the Pade approximation will represent on the real axis for GW analytic continuation.
        omega (numpy.ndarray): 2D array of frequency points corresponding to the columns of sigma, with the same shape convention (norbs, nw). Each row supplies the frequency grid for the matching row of sigma. The function selects a subset of these frequency points to build the Pade approximant; the returned omega array contains precisely the subset used. Passing omega that does not align with sigma by shape will raise a ValueError when shapes are inconsistent.
    
    Returns:
        tuple: A pair of numpy.ndarray objects (coeff, omega_subset).
            coeff (numpy.ndarray): 2D complex128 array of Pade coefficients with shape (ncoeff, norbs), where ncoeff = 2 * npade and npade = (nw // 2) computed from the number of columns in the input sigma. Each column holds the complex coefficients for the Pade approximant of the corresponding orbital. These coefficients are intended to be used to evaluate the analytically continued self-energy on the real-frequency axis in GW calculations.
            omega_subset (numpy.ndarray): 2D array with shape (norbs, ncoeff) containing the subset of input omega frequency points that were used to construct the Pade coefficients. The ordering corresponds to the columns used to form coeff (i.e., the same ncoeff columns for each orbital).
    
    Behavior and side effects:
        - The function copies selected columns of the input arrays (sigma and omega) internally before constructing the Pade approximant; the provided input arrays are not modified in-place.
        - The implementation selects columns according to fixed index patterns and then uses nw // 2 to determine npade; therefore the effective number of points used per orbital is ncoeff = 2 * (nw // 2). If nw is odd, the last column is ignored because only an even number of points (2*npade) is used.
        - The function calls the helper routine thiele for each orbital to compute the Pade coefficients; thiele must accept 1D arrays of matched sigma and omega values and may raise exceptions for ill-conditioned inputs.
    
    Failure modes and warnings:
        - If sigma and omega do not have the same shape or are not 2D arrays, a ValueError will be raised when shapes are inconsistent or when unpacking sigma.shape.
        - If the input arrays contain too few columns for the fixed index selection strategy (the code selects columns starting from indices defined internally), the function may raise an IndexError or produce empty intermediate arrays that result in a subsequent ValueError when stacking or calling thiele.
        - Non-finite values (NaN or Inf) in sigma or omega may produce undefined or unstable Pade coefficients and may cause thiele to raise numerical or linear-algebra-related exceptions.
        - The returned coeff array has dtype numpy.complex128; downstream code should expect complex coefficients.
    
    Reference:
        Thiele's reciprocal difference Pade approximation: J. Low Temp. Phys. 29, 179 (1977).
    """
    from pyscf.gw.gw_ac import AC_pade_thiele_diag
    return AC_pade_thiele_diag(sigma, omega)


################################################################################
# Source: pyscf.gto.moleintor.getints_by_shell
# File: pyscf/gto/moleintor.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gto_moleintor_getints_by_shell(
    intor_name: str,
    shls: list,
    atm: numpy.ndarray,
    bas: numpy.ndarray,
    env: numpy.ndarray,
    comp: int = 1
):
    """For given 2, 3 or 4 atomic-orbital shells, call the underlying libcint/libcgto
    integral routines to compute one-electron, two-electron, two-center-two-electron
    or three-center two-electron integrals for the specified shells. This function
    is an internal PySCF interface that (1) converts the atom/basis/environment
    arguments into the C-compatible numpy arrays expected by libcint, (2) determines
    the number of contracted Gaussian-type orbitals (CGTOs) in each shell from the
    bas array, (3) allocates a Fortran-ordered buffer, and (4) invokes the C
    integral kernel named by intor_name via libcgto. It is used throughout PySCF
    where low-level per-shell integrals are needed (for example, building ERI
    blocks, 3-center Coulomb integrals for density fitting, or 1e operator blocks).
    
    Args:
        intor_name (str): Name of the integral kernel to invoke in libcgto. See
            getints for a list of supported intor_name values. The prefix of
            intor_name (e.g. 'int1e', 'int2e', 'int3c', 'int4c', 'int2c') and its
            suffixes (e.g. '_cart', '_sph', '_ssc') determine which branch of the
            implementation is executed and how many shells must be provided in
            shls. The function will select a real dtype (numpy.double) when the
            name ends with '_cart' or '_sph', and complex128 for spinor integrals
            (other names). If the named C function is not available on the
            libcgto object, an AttributeError will be raised when attempting to
            call it.
        shls (list): List of AO shell indices (integers) that specify which shells
            the integrals are evaluated for. The required length of shls depends
            on intor_name: length 2 for 1e / 2c / ECP kernels, length 3 for
            3-center (int3c) kernels, and length 4 for 2e / 4-center kernels.
            Assertions in the implementation will raise AssertionError if the
            provided shls length does not match the expectation for the selected
            intor_name.
        atm (numpy.ndarray): Atom table in the libcint format supplied as a C
            contiguous numpy.ndarray of dtype numpy.int32. This array encodes the
            atomic coordinates and other per-atom metadata used by libcint. The
            function converts the provided atm to dtype int32 and order 'C' and
            passes a pointer to the C kernel.
        bas (numpy.ndarray): Basis table in the libcint format supplied as a C
            contiguous numpy.ndarray of dtype numpy.int32. This array encodes per-
            shell parameters (angular momentum, number of primitives/contracted
            functions, kappa for spinors, etc.). The function converts bas to
            dtype int32 and order 'C', and uses bas entries (ANG_OF, NCTR_OF,
            KAPPA_OF) to compute the number of contracted GTOs per shell. The
            computed numbers (di, dj, dk, dl) determine the buffer shape.
        env (numpy.ndarray): Environment array required by libcint provided as a C
            contiguous numpy.ndarray of dtype numpy.double (float64). This array
            contains floating-point data used by the C integral routines (exponents,
            precomputed factors, etc.). The function converts env to dtype
            float64 (numpy.double) and order 'C' before passing it to the C kernel.
        comp (int): Number of components of the integral to compute. Many integral
            kernels that represent vector or tensor quantities provide multiple
            components; for example, dipole-type integrals such as int1e_ipovlp have
            comp=3. Default is 1. When comp == 1 the returned array has no leading
            component axis; when comp > 1 the result is returned with the component
            index as the leading axis (the implementation allocates an F-ordered
            buffer with a trailing comp axis and transposes it to put comp first).
    
    Returns:
        numpy.ndarray: A numpy ndarray containing the requested integrals. The
        returned array dimensionality and dtype depend on intor_name and comp:
        - For int3c kernels (intor_name starting with 'int3c') the internal buffer
          shape is (di, dj, dk, comp), where di, dj, dk are the numbers of CGTOs
          in the three shells computed from bas. If comp == 1 the function returns
          an array of shape (di, dj, dk). If comp > 1 it returns an array of shape
          (comp, di, dj, dk).
        - For two-electron or four-center kernels (intor_name starting with
          'int2e' or 'int4c') the internal buffer shape is (di, dj, dk, dl, comp).
          If comp == 1 the function returns an array of shape (di, dj, dk, dl).
          If comp > 1 it returns an array of shape (comp, di, dj, dk, dl).
        - For two-center kernels, one-electron kernels, or ECP kernels (intor_name
          starting with 'int2c' or containing '1e' or 'ECP') the internal buffer
          shape is (di, dj, comp). If comp == 1 the function returns an array of
          shape (di, dj). If comp > 1 it returns an array of shape (comp, di, dj).
        The numeric dtype is numpy.double for real (Cartesian or spherical)
        integrals (intor_name ending with '_cart' or '_sph') and numpy.complex128
        for spinor integrals (other cases where spinor information is present).
        The arrays are produced by allocating a Fortran-ordered buffer and calling
        the C kernel via ctypes; when comp > 1 a transpose is performed so that
        the component axis is the leading axis in the returned array.
    
    Behavior, side effects, defaults, and failure modes:
        - The function converts atm, bas and env to the expected C-compatible
          dtypes and memory order (atm and bas to numpy.int32, env to numpy.double,
          all with order='C'). natm and nbas are created as ctypes.c_int values
          from the array sizes and passed to the C kernel.
        - The number of contracted GTOs for each shell is determined from bas
          entries (ANG_OF, NCTR_OF, and KAPPA_OF for spinors) and used to size
          the output buffer. If bas contents are inconsistent the computed sizes
          will be incorrect and the C kernel may produce invalid output or crash.
        - The function asserts that len(shls) matches the requirement implied by
          intor_name; violation raises AssertionError. If intor_name does not
          match any recognized pattern the function raises RuntimeError('Unknown
          intor %s' % intor_name). If the corresponding C function is missing on
          libcgto, attempting to look it up with getattr will raise AttributeError.
        - The function allocates a Fortran-ordered numpy buffer (order='F') and
          fills it by calling the C kernel (via libcgto and ctypes). This can
          consume significant memory for large shells (di, dj, dk, dl may be large)
          and can be a performance hotspot in tight loops.
        - Default comp is 1; when comp > 1 the function rearranges axes so that
          the returned array places the component index as the first axis.
        - No in-place modification of the input atm, bas, env arrays is performed;
          only copies with the requested dtype/order are created if needed.
        - This function is a thin wrapper over compiled C code; any crashes,
          segmentation faults, or low-level errors originating in the C kernel are
          propagated and will typically terminate the Python process.
    
    Note:
        - This function is intended for low-level use within PySCF and other code
          that manipulates libcint-style atom/basis/env arrays. Higher-level users
          should prefer helper routines such as getints that accept PySCF Mole or
          basis specifications and perform the necessary table construction.
    """
    from pyscf.gto.moleintor import getints_by_shell
    return getints_by_shell(intor_name, shls, atm, bas, env, comp)


################################################################################
# Source: pyscf.gw.gw_ac.get_rho_response
# File: pyscf/gw/gw_ac.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gw_gw_ac_get_rho_response(
    omega: float,
    mo_energy: numpy.ndarray,
    Lpq: numpy.ndarray
):
    """Compute the electronic density response (polarizability) in the auxiliary basis at a (typically imaginary) frequency omega for use in GW screening and self-energy calculations.
    
    This function is used in the pyscf.gw.gw_ac module to build the density response matrix in an auxiliary basis from molecular orbital energies and auxiliary-projected three-index integrals. The computed response Pi(P,Q) is the matrix representation of the independent-particle density response (sum over occupied->virtual transitions) evaluated at frequency omega. The implementation returns the response including both spin channels; the multiplicative factor of 4 in the code accounts for the two electronic spins and the combined contribution from the occupied->virtual transition amplitude and its complex-conjugate pair in the sum-over-states expression. Typical usage is within GW screening (W) construction and related many-body perturbation theory routines in PySCF.
    
    Args:
        omega (float): Frequency at which the response is evaluated. In the original code this is intended as the magnitude of an imaginary frequency (i*w) used in frequency-dependent screening; the function uses omega only via omega**2 in the denominator. A caller should pass a real scalar; passing omega == 0 is allowed but can produce infinite or NaN elements if any transition energy difference is exactly zero (see Failure modes).
        mo_energy (numpy.ndarray): One-dimensional array of molecular orbital energies. The function expects the first nocc entries to be occupied orbital energies and the remaining entries to be virtual energies (i.e., mo_energy has length nocc + nvir). This ordering is required because the code constructs transition energies eia = mo_energy[:nocc, None] - mo_energy[None, nocc:], representing occupied minus virtual orbital energy differences used in the independent-particle response denominator.
        Lpq (numpy.ndarray): Three-dimensional array of auxiliary-basis projected three-index integrals with shape (naux, nocc, nvir). Here naux is the number of auxiliary basis functions, nocc is the number of occupied orbitals, and nvir is the number of virtual orbitals. Lpq[P,i,a] are the integrals (projected amplitudes) coupling auxiliary function P to occupied orbital i and virtual orbital a; these amplitudes enter the transition contributions to the auxiliary-basis response.
    
    Returns:
        numpy.ndarray: Pi, a two-dimensional numpy.ndarray of shape (naux, naux). Pi[P,Q] is the density response matrix in the auxiliary basis evaluated at the supplied omega and constructed as
        Pi = 4 * sum_{i,a} Lpq[P,i,a] * ( (e_{i}-e_{a}) / (omega**2 + (e_{i}-e_{a})**2) ) * Lpq[Q,i,a],
        where e_i and e_a are occupied and virtual orbital energies from mo_energy and the prefactor 4 accounts for both spin channels. The returned array has the same dtype as the input arrays (subject to NumPy promotion rules).
    
    Behavior, side effects, and failure modes:
        This function is purely functional and has no external side effects (it does not modify inputs or global state). It determines naux, nocc, nvir from Lpq.shape and slices mo_energy accordingly; if mo_energy has fewer entries than nocc+nvir the code will raise an IndexError. The denominator uses omega**2 + (e_i-e_a)**2; if omega == 0 and any occupied and virtual orbital energies are identical (e_i == e_a) the denominator becomes zero and NumPy will produce inf or NaN values for the corresponding elements rather than raising a Python exception. Callers should ensure mo_energy ordering and values are consistent with their physical system and handle or regularize near-zero denominators if needed. The function assumes Lpq and mo_energy are NumPy arrays and will follow NumPy broadcasting and dtype rules; passing other array-like types may work if they are convertible to numpy.ndarray.
    """
    from pyscf.gw.gw_ac import get_rho_response
    return get_rho_response(omega, mo_energy, Lpq)


################################################################################
# Source: pyscf.gw.gw_ac.AC_twopole_diag
# File: pyscf/gw/gw_ac.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gw_gw_ac_AC_twopole_diag(
    sigma: numpy.ndarray,
    omega: numpy.ndarray,
    orbs: numpy.ndarray,
    nocc: int
):
    """pyscf.gw.gw_ac.AC_twopole_diag: Analytic continuation of GW self-energy to the real frequency axis using a two-pole fit applied independently to each orbital.
    
    Fits a two-pole model to complex self-energy data sigma sampled on a frequency mesh omega for each orbital. The function loops over orbitals (leading dimension of sigma), constructs an orbital-dependent initial guess for the 10 fit parameters, and calls scipy.optimize.least_squares with finite-difference Jacobian, trust-region-reflective method, and tight tolerances to obtain the best-fit parameters for that orbital. This routine is used in the GW analytic-continuation workflow in PySCF to produce a compact, analytic representation of the orbital self-energy on the real axis from sampled data (typically obtained on the imaginary or Matsubara axis). The fitted parameters can be used downstream to evaluate the self-energy at real frequencies, to locate quasiparticle peaks, or to build spectral functions.
    
    Args:
        sigma (numpy.ndarray): Complex-valued self-energy samples for all orbitals on a discrete frequency grid. In the implementation this array is indexed as sigma[p] for orbital p and unpacked as norbs, nw = sigma.shape, so the array must be two-dimensional with leading dimension equal to the number of orbitals (norbs). Each row sigma[p] contains the sampled self-energy values corresponding to the frequencies provided in the matching row of omega. The practical significance is that sigma provides the target data that the two-pole model is fitted to for analytic continuation in GW calculations.
        omega (numpy.ndarray): Frequency grid values corresponding to the samples in sigma. The code accesses omega[p] for each orbital p, so omega must be indexable along the same leading dimension as sigma (typically shape (norbs, nw)). Each row omega[p] supplies the frequency points at which sigma[p] is evaluated. In GW workflows these are the (imaginary or Matsubara) frequencies at which the self-energy was computed; they determine the abscissa of the fit.
        orbs (numpy.ndarray): Array describing orbitals used to decide an orbital-specific initial guess for the fit. The function compares orbs[p] < nocc to decide whether orbital p is occupied or unoccupied and sets the initial parameter vector accordingly. In practice orbs typically contains orbital indices or orbital occupation indicators indexed by p; its leading dimension must equal norbs. Its role is purely to choose a sensible starting guess for the nonlinear fit depending on occupation, which can improve convergence and fit quality in GW analytic-continuation tasks.
        nocc (int): Number of occupied orbitals used as the threshold to classify orbitals in orbs. Orbitals with orbs[p] < nocc are treated as occupied and use a different initial guess than unoccupied orbitals. This integer therefore controls which initial parameter vector is chosen for each orbital's two-pole fit and is typically set from the mean-field calculation that produced the input self-energy.
    
    Behavior and side effects:
        The function performs an independent nonlinear least-squares fit for each orbital p using scipy.optimize.least_squares called as least_squares(two_pole_fit, x0, jac='3-point', method='trf', xtol=1e-10, gtol=1e-10, max_nfev=1000, verbose=0, args=(omega[p], sigma[p])). The initial guess x0 has 10 entries and differs for occupied versus unoccupied orbitals (determined by the orbs vs nocc comparison). For each orbital the optimizer returns an object xopt; if xopt.success is False the function prints a warning message "WARN: 2P-Fit Orb %d not converged, cost function %e" with the orbital index and cost but continues and stores xopt.x in the output array. The routine does not compute analytic gradients (TODO in source), and uses finite-difference Jacobians internally. The function assumes proper alignment of sigma and omega leading dimensions; mismatched shapes or insufficient dimensions will raise standard NumPy indexing or broadcasting errors. The function relies on the external helper two_pole_fit and scipy.optimize.least_squares being available and behaving as expected; errors raised by these will propagate.
    
    Defaults and numerical settings:
        The nonlinear solver tolerances and limits are fixed in the implementation: xtol=1e-10, gtol=1e-10, max_nfev=1000, Jacobian approximated with '3-point' finite differences, and method='trf'. These settings aim for a tight fit but may increase runtime or cause non-convergence for noisy or ill-conditioned input data; in that case a warning is printed and the best-found parameters are still returned for that orbital.
    
    Failure modes:
        If least_squares fails to converge for an orbital, the function prints a warning and still stores the optimizer's returned parameter vector xopt.x for that orbital in the result. If input arrays have incompatible shapes (for example, sigma not two-dimensional or omega not indexable by orbital), a NumPy IndexError or ValueError will be raised. If two_pole_fit or scipy.optimize.least_squares are missing or raise exceptions, those exceptions propagate to the caller. The function does not validate that sigma contains complex values; it will operate on real arrays (treating imaginary parts as zero) but the quality of analytic continuation may be degraded.
    
    Returns:
        numpy.ndarray: 2D array of fitted two-pole model parameters with shape (10, norbs). Each column coeff[:, p] contains the 10 fit parameters returned by least_squares for orbital p (in the same order produced by the two_pole_fit routine). The practical significance is that these parameter columns provide a compact analytic representation of the self-energy for each orbital that can be evaluated at real frequencies for spectral analysis, quasiparticle extraction, or subsequent GW post-processing.
    """
    from pyscf.gw.gw_ac import AC_twopole_diag
    return AC_twopole_diag(sigma, omega, orbs, nocc)


################################################################################
# Source: pyscf.gw.gw_cd.get_rho_response
# File: pyscf/gw/gw_cd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gw_gw_cd_get_rho_response(
    omega: float,
    mo_energy: numpy.ndarray,
    Lpq: numpy.ndarray
):
    """Compute density response function in the auxiliary basis at (imaginary) frequency omega.
    
    This function is used in the GW module (pyscf.gw.gw_cd) to build the density response (screening) matrix in a density-fitting / auxiliary basis representation from molecular orbital energies and three-index Cholesky/auxiliary tensors. The computed response matrix Pi encodes how the electronic density (from both spin channels) responds at frequency omega and is suitable for use in GW screening and polarizability constructions where auxiliary-basis representations are employed.
    
    Args:
        omega (float): Frequency at which the response is evaluated. The code treats this as the imaginary-frequency argument "iw" (omega may represent an imaginary-frequency value); it enters the denominator as omega**2 + (epsilon_i - epsilon_a)**2. Practical significance: omega controls frequency-dependent screening; non-finite or NaN omega will lead to NaN or invalid results.
        mo_energy (numpy.ndarray): 1-D array of molecular orbital energies ordered with occupied orbitals first then virtual orbitals (length nocc + nvir). The function slices mo_energy[:nocc] for occupied energies and mo_energy[nocc:] for virtual energies and constructs energy differences e_i - e_a. If the length or ordering does not match Lpq's nocc and nvir dimensions, indexing or broadcasting errors will occur. The array dtype determines the dtype of intermediate and returned arrays.
        Lpq (numpy.ndarray): 3-D array with shape (naux, nocc, nvir) containing three-index auxiliary/Cholesky vectors that couple auxiliary basis functions (P index) to occupied (i) and virtual (a) molecular orbital indices. In practical GW/CD workflows, Lpq represents the factorized electron repulsion integrals in the auxiliary basis. This array is used to form P_{P,ia} * (e_i - e_a) / (omega^2 + (e_i - e_a)^2) and then contracted to produce the auxiliary-basis response. A wrong dimensionality or ordering will raise an error.
    
    Behavior, side effects, and failure modes:
        The function computes eia = epsilon_i - epsilon_a, rescales it by 1/(omega**2 + eia**2), multiplies elementwise with Lpq along the (i,a) indices to form Pia, and then contracts Pia with Lpq to form the auxiliary response matrix Pi. A spin multiplicative factor of 4 is applied to include contributions from both spin-up and spin-down densities (two spins and a factor of 2 from particle-hole symmetry as implemented here), so the returned Pi equals 4 * sum_{i,a} Pia_P * Lpq_Qia, resulting in a (naux, naux) array. There are no external side effects (the function does not modify inputs). If mo_energy length or Lpq shape are inconsistent, Python indexing or broadcasting errors (IndexError or ValueError) will be raised. If omega is non-finite, denominators may produce NaNs or Infs.
    
    Returns:
        numpy.ndarray: Square auxiliary-basis density response matrix Pi with shape (naux, naux). This array contains the frequency-dependent density response evaluated at the provided omega and is ready for use in GW screening or related auxiliary-basis operations. The returned array dtype follows from the input arrays' dtype.
    """
    from pyscf.gw.gw_cd import get_rho_response
    return get_rho_response(omega, mo_energy, Lpq)


################################################################################
# Source: pyscf.gw.gw_slow.kernel
# File: pyscf/gw/gw_slow.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gw_gw_slow_kernel(
    imds: str,
    orbs: list = None,
    linearized: bool = False,
    eta: float = 0.001,
    tol: float = 1e-09,
    method: str = "fallback"
):
    """Calculates GW quasiparticle (corrected) orbital energies for a set of molecular orbitals using GW intermediates provided by an AbstractIMDS object from the PySCF GW module. This function is used in the context of many-body perturbation theory (the GW approximation) implemented in PySCF to find corrected energies that include electron-electron correlation beyond mean-field (SCF) orbital energies. It evaluates the quasiparticle equation for each requested orbital (or orbital block), finds a root of the quasiparticle equation using a numerical root-finder, and returns the resulting corrected energies in an array whose shape corresponds to the orbital index layout in imds.entire_space. Practical significance: these corrected energies are the GW estimates of electronic excitation energies or electron addition/removal energies used in post-SCF analyses and comparisons with experiment.
    
    Args:
        imds (AbstractIMDS): GW intermediates container. Must implement the interface expected by this routine: provide the property entire_space (a list describing the full orbital index layout), the integer attribute orb_dims (number of orbital index dimensions), the method quasiparticle_eq(p, eta=...) that returns a callable representing the quasiparticle equation for orbital index p and imaginary broadening eta, and the method initial_guess(p) that supplies an initial energy guess for root finding. The function reads imds.entire_space and imds.orb_dims to validate shapes, uses imds.quasiparticle_eq to create the function whose root is sought, and may call imds.initial_guess. If imds.entire_space is not a list of length imds.orb_dims, the function raises a RuntimeError describing the mismatch.
        orbs (Iterable): Index specification for molecular orbitals to correct. If None (the default), the function uses imds.entire_space. The argument may be a single index, an iterable of per-dimension sizes/indices, or a list following the conventions of imds.entire_space. The routine normalizes this argument to a list and, if the provided list has fewer entries than imds.orb_dims, prepends entries from imds.entire_space so that the final orbit indexing matches the dimensionality expected by the GW intermediates. The final layout determines the shape of the returned ndarray.
        linearized (bool): If True, request a single-step linearized quasiparticle correction (a linearized evaluation of the quasiparticle equation around the mean-field energy). Default False. Note: the linearized branch is not implemented in this function and will raise NotImplementedError if linearized=True. Users should expect NotImplementedError for that option until an analytic sigma derivative or linearized implementation is provided.
        eta (float): Imaginary energy (broadening) used when evaluating the Green's function and the quasiparticle equation (passed to imds.quasiparticle_eq). This small positive number regularizes poles and stabilizes numerical evaluation of the self-energy; default is 1e-3. Choose eta consistent with the energy resolution and numerical stability required by the system; overly large eta smooths spectral features, overly small eta can make root finding less stable.
        tol (float): Convergence tolerance for the root-finding procedure used to solve the quasiparticle equation (absolute tolerance on the energy root). Default is 1e-9. This tolerance controls when the numerical solver considers a root converged; tighter tolerances increase computational work and potential sensitivity to numerical noise.
        method (str): Root-finding strategy. Must be one of 'newton', 'bisect', or 'fallback' (default 'fallback'). Behavior:
            'newton' uses a Newton iteration starting from imds.initial_guess(p) to find a root near the provided initial guess; it is fast and accurate when convergent but may fail to converge or raise exceptions for difficult functions.
            'bisect' uses a bisection-based search that will find a root within a bracketing interval but can return a root that is not the physically relevant quasiparticle solution if multiple roots exist; it is more robust but less selective.
            'fallback' attempts 'newton' first and, if Newton raises a RuntimeError (failure to converge), falls back to 'bisect' using the x-range observed during function probing (min(debug.x), max(debug.x)). If method is not one of these three strings, a ValueError is raised immediately. The function also logs a warning and switches to bisect in the fallback path when Newton fails.
    
    Returns:
        numpy.ndarray: Array of corrected orbital energies (float). The array shape is tuple(len(i) for i in orbs) after the function normalizes orbs as described above; entries correspond to GW quasiparticle energies for the requested orbitals in the same index order used to construct p when calling imds.quasiparticle_eq. The dtype is float. Side effects and failure modes:
            - Raises ValueError if method is not one of 'newton', 'bisect', or 'fallback'.
            - Raises RuntimeError if imds.entire_space is not a list of length imds.orb_dims.
            - Raises NotImplementedError if linearized=True because the linearized correction is not implemented in this routine.
            - In the 'newton' path, exceptions raised by the Newton solver are augmented with context about the orbital index p and re-raised after plotting call history via debug.plot_call_history; callers should be prepared to catch exceptions from failed Newton iterations.
            - In the 'fallback' path, a RuntimeError from Newton causes a logger warning and a bisect call over the debug.x interval; bisect may converge to a root that is not the physically intended quasiparticle solution if multiple roots exist.
            - The function may call imds.quasiparticle_eq and imds.initial_guess; those methods should be stable and consistent with the expected energy ranges.
    """
    from pyscf.gw.gw_slow import kernel
    return kernel(imds, orbs, linearized, eta, tol, method)


################################################################################
# Source: pyscf.gw.ugw_ac.AC_pade_thiele_diag
# File: pyscf/gw/ugw_ac.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gw_ugw_ac_AC_pade_thiele_diag(sigma: numpy.ndarray, omega: numpy.ndarray):
    """Analytic continuation to the real axis using a Pade approximation constructed
    with Thiele's reciprocal difference method. This function is intended for use
    in GW analytic-continuation workflows within PySCF (pyscf.gw.ugw_ac), where
    sigma and omega contain self-energy (or related Green's function) samples on
    an imaginary Matsubara-frequency grid. The implementation follows the
    Thiele reciprocal-difference Pade construction (see J. Low Temp. Phys. 29,
    179 (1977)) and returns the complex Pade coefficients for each orbital along
    with the subset of frequency points actually used to build the approximant.
    
    Args:
        sigma (numpy.ndarray): 2-D array of self-energy (or related) samples on
            the imaginary-frequency (Matsubara) axis. The array is expected to be
            laid out with shape (norbs, nw), where norbs is the number of orbitals
            (each column corresponds to one orbital's frequency-dependent values)
            and nw is the number of sampled frequency points. The routine selects
            a subset of columns from this array (using the index pattern implemented
            in the function: idx = range(1, 40, 6) plus every 4th column after
            idx[-1]+4) and copies those columns; the original sigma array is not
            modified. If sigma does not have a sufficient number of frequency
            columns for the expected selection, downstream operations (including
            the internal thiele routine) may raise exceptions or produce invalid
            results.
    
        omega (numpy.ndarray): 2-D array of frequency values corresponding to
            sigma, with the same layout and shape convention (norbs, nw). Each
            row/column orientation must match sigma so that omega[:, j] is the
            frequency at which sigma[:, j] was sampled. The function applies the
            same column-selection pattern to omega and returns the subset actually
            used to construct the Pade approximant. If omega and sigma shapes do
            not match exactly, the function will raise an error when attempting to
            index or stack slices.
    
    Returns:
        coeff (numpy.ndarray): 2-D complex128 array of Pade coefficients with
            shape (ncoeff, norbs). In the implementation ncoeff == npade*2 where
            npade is computed as nw_selected // 2 (nw_selected is the number of
            columns retained after the internal column-selection). Each column of
            coeff contains the complex coefficients produced by Thiele's reciprocal
            difference algorithm for the corresponding orbital; these coefficients
            can be used to evaluate the analytic continuation of that orbital's
            self-energy onto the real-frequency axis.
    
        omega (numpy.ndarray): 2-D array of the subset of input frequency values
            actually used to construct the Pade approximant, with shape
            (norbs, ncoeff). This returned omega is the same data as the input
            omega but restricted to the columns used for the approximation
            (the first ncoeff columns after the internal selection and truncation).
            Users should use this returned omega together with coeff when
            evaluating the Pade approximant on the real axis.
    
    Notes and failure modes:
        - The function internally constructs two column subsets (sigma1/omega1 and
          sigma2/omega2) using a sparse sampling pattern (idx = range(1, 40, 6)
          and subsequent every-4th-point sampling) and concatenates them. It then
          truncates to an even number of points and sets npade = nw_selected // 2.
        - The helper routine thiele(...) is invoked per orbital to produce the
          coefficient vector; errors or singularities in thiele (for example due
          to insufficient or linearly dependent data points) will propagate up and
          raise exceptions here.
        - Inputs are not modified in-place; slices are copied before further use.
        - This function assumes that the input arrays represent Matsubara-axis
          samples commonly produced in GW/self-energy calculations; using inputs
          that do not follow this convention (wrong axis ordering, missing points)
          will lead to incorrect approximants or runtime errors.
    """
    from pyscf.gw.ugw_ac import AC_pade_thiele_diag
    return AC_pade_thiele_diag(sigma, omega)


################################################################################
# Source: pyscf.gw.ugw_ac.AC_twopole_diag
# File: pyscf/gw/ugw_ac.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gw_ugw_ac_AC_twopole_diag(
    sigma: numpy.ndarray,
    omega: numpy.ndarray,
    orbs: numpy.ndarray,
    nocc: int
):
    """pyscf.gw.ugw_ac.AC_twopole_diag: Perform analytic continuation of orbital self-energy data onto the real-frequency axis using a two-pole fit, returning the per-orbital optimized two-pole model coefficients used by the GW analytic-continuation routines.
    
    Args:
        sigma (numpy.ndarray): Complex-valued 2D array with shape (norbs, nw). Each row sigma[p] contains nw sampled complex self-energy values for orbital p on the input frequency grid. In the GW analytic-continuation context used by this module, sigma holds the frequency-dependent self-energy data to be approximated by a two-pole model for each orbital. The function requires sigma to be two-dimensional and indexed by orbital first; a shape mismatch with omega or non-2D input will raise a Python exception when shapes are unpacked or when per-orbital slices are accessed.
        omega (numpy.ndarray): Real (or complex) 2D array or array-like with the same first dimension as sigma (norbs). Each element omega[p] is the frequency grid (length nw) corresponding to sigma[p]. omega supplies the independent variable for the two-pole fit (frequency points at which sigma was sampled). The function expects omega[p] and sigma[p] to have matching lengths; mismatched lengths will cause the underlying optimizer or model-evaluation routine to raise an error.
        orbs (numpy.ndarray): 1D array of orbital identifiers (e.g., integer orbital indices or labels) with length norbs. This array is used to classify each orbital as occupied or virtual by comparing orbs[p] with nocc (orbs[p] < nocc is treated as occupied). That classification controls the sign and initial guess of certain two-pole parameters so the fit starts from physically motivated initial values for occupied versus virtual orbitals. Passing an orbs array with incompatible length or meaningless values will not change the function signature but may produce poor fits or warnings.
        nocc (int): Number of occupied orbitals used to decide occupied versus virtual classification. The comparison orbs[p] < nocc determines which initial guess vector is used for that orbital (occupied initial guess differs in the sign of certain pole parameters from the virtual initial guess). nocc must be a non-negative integer consistent with how orbs is constructed; an incorrect nocc value will produce incorrect initial guesses and can degrade fit quality.
    
    Behavior and practical significance:
        This routine iterates over norbs orbitals (norbs inferred from sigma.shape[0]) and for each orbital calls scipy.optimize.least_squares to fit a predefined two-pole model (implemented in two_pole_fit) to the sampled self-energy sigma[p] at frequencies omega[p]. The purpose in the GW workflow of the pyscf.gw.ugw_ac module is to obtain a compact, analytic two-pole representation of the frequency-dependent self-energy for each orbital so the self-energy can be analytically continued from the input sampling (typically on an imaginary or discrete grid) to real frequencies for extraction of spectral properties and quasiparticle energies. The returned coefficients are intended to be consumed by other functions in the same module that evaluate the two-pole model on real-frequency points.
    
    Initial guesses and optimizer settings:
        For each orbital, an initial parameter vector x0 of length 10 is chosen. If orbs[p] < nocc (occupied), x0 is set to [0, 1, 1, 1, -1, 0, 0, 0, -1.0, -0.5]; otherwise (virtual) x0 is [0, 1, 1, 1, -1, 0, 0, 0, 1.0, 0.5]. These initial guesses reflect the module's heuristic for occupied versus virtual orbitals and affect convergence and the physical character of the fitted poles. The least_squares optimizer is invoked with jac='3-point', method='trf', xtol=1e-10, gtol=1e-10, max_nfev=1000, and verbose=0; these tolerances and method choices are fixed in the implementation and intended to produce accurate fits while limiting function evaluations.
    
    Side effects and failure modes:
        The only intended side effect is that, when an individual orbital fit fails to converge (xopt.success is False), the function prints a single-line warning to standard output of the form "WARN: 2P-Fit Orb %d not converged, cost function %e" with the orbital index and final cost. Regardless of convergence, the optimizer's final parameter vector xopt.x is copied into the output coefficient array for that orbital, so callers receive a coefficient set even if the optimizer reported non-convergence. Other failure modes include Python exceptions raised due to invalid input shapes (e.g., sigma not being two-dimensional, omega and sigma having incompatible per-orbital lengths), missing dependencies (scipy.optimize.least_squares not importable), or catastrophic numeric issues inside the user-supplied two_pole_fit; these will propagate as regular Python exceptions.
    
    Returns:
        numpy.ndarray: 2D real-valued array coeff with shape (10, norbs). Each column coeff[:, p] contains the length-10 parameter vector produced by the least_squares optimizer for orbital p. The ten parameters are the internal two-pole model parameters consumed by the module's analytic-continuation and evaluation routines (their ordering and detailed physical interpretation correspond to the parameterization used by two_pole_fit; callers should consult the two_pole_fit implementation in this module for the exact meaning of each entry). The array is fully populated for all orbitals; in cases where a fit did not converge, the corresponding column contains the optimizer's final parameter vector and a warning will have been printed.
    """
    from pyscf.gw.ugw_ac import AC_twopole_diag
    return AC_twopole_diag(sigma, omega, orbs, nocc)


################################################################################
# Source: pyscf.gw.ugw_ac.get_rho_response
# File: pyscf/gw/ugw_ac.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_gw_ugw_ac_get_rho_response(
    omega: float,
    mo_energy: numpy.ndarray,
    Lpqa: numpy.ndarray,
    Lpqb: numpy.ndarray
):
    """Compute the density response function in the auxiliary (resolution-of-identity) basis at an imaginary frequency iw for unrestricted GW (ugw) AC screening.
    
    This function is used in the PySCF GW module (pyscf.gw.ugw_ac) to form the auxiliary-basis representation of the frequency-dependent density response (polarizability) needed when evaluating screened interactions or polarizability on the imaginary frequency axis. The implementation assumes an unrestricted (spin-separated) molecular orbital basis and builds the response by summing contributions from alpha and beta spin single excitations using the provided auxiliary couplings Lpqa and Lpqb.
    
    Args:
        omega (float): Magnitude of the (imaginary) frequency argument iw. The code uses omega**2 in the denominator, so omega should be a real float representing the absolute value of the imaginary frequency. Physically, this is the frequency at which the density response/polarizability is evaluated for AC (adiabatic connection) or frequency-dependent screening computations.
        mo_energy (numpy.ndarray): Orbital energies array for both spins. The function expects mo_energy to be a 2D NumPy array with shape (2, nmo) where row 0 contains alpha-spin orbital energies and row 1 contains beta-spin orbital energies. Within each row, orbital energies must be ordered with all occupied orbitals first followed by virtual orbitals; the split between occupied and virtual counts is inferred from the shapes of Lpqa and Lpqb. The function indexes mo_energy as mo_energy[spin, :nocc] and mo_energy[spin, nocc:] to form occupied-virtual energy differences e_i-a.
        Lpqa (numpy.ndarray): Auxiliary coupling array for alpha spin with shape (naux, nocca, nvira). naux is the number of auxiliary basis functions, nocca is the number of alpha occupied orbitals, and nvira is the number of alpha virtual orbitals. Each element Lpqa[P, i, a] is the coupling between auxiliary basis function P and the single excitation from occupied alpha orbital i to virtual alpha orbital a. These couplings determine the weight of each excitation in the auxiliary-basis response.
        Lpqb (numpy.ndarray): Auxiliary coupling array for beta spin with shape (naux, noccb, nvirb). naux must match the first dimension of Lpqa. noccb and nvirb are the number of beta occupied and beta virtual orbitals. Each element Lpqb[P, i, a] is the coupling between auxiliary basis function P and a beta-spin single excitation. The function uses both Lpqa and Lpqb to form the total (spin-summed) response.
    
    Returns:
        numpy.ndarray: The auxiliary-basis density response matrix Pi with shape (naux, naux). Pi[P, Q] is the frequency-dependent response between auxiliary functions P and Q evaluated at the supplied imaginary frequency iw (omega). Numerically, Pi is constructed as twice the sum of alpha and beta contributions:
            Pi = 2 * ( sum_{i,a} Lpqa[P,i,a] * Lpqa[Q,i,a] * eia_a/(omega**2 + eia_a**2)
                     + sum_{i,a} Lpqb[P,i,a] * Lpqb[Q,i,a] * eia_b/(omega**2 + eia_b**2) )
        where eia_{a,b} are occupied-minus-virtual orbital energy differences for alpha and beta spins respectively. The returned array is a NumPy ndarray; its dtype follows from the arithmetic on the input arrays (typically float64).
    
    Behavior and important implementation details:
        - The function computes occupied-to-virtual energy differences for each spin from the provided mo_energy rows. For alpha: eia_a = mo_energy[0, :nocca][:, None] - mo_energy[0, nocca:][None, :]; similarly for beta using noccb and nvirb from Lpqb.shape.
        - Each eia is transformed to eia/(omega**2 + eia**2) before contracting with the corresponding Lpq* arrays via Einstein summation. The factor of 2 multiplies the total spin-summed contribution, matching conventions in this part of the ugw AC implementation.
        - The function is pure (no side effects) and returns the computed Pi array.
    
    Failure modes and edge cases:
        - If array shapes are inconsistent (for example, the first dimension of Lpqa and Lpqb differ, or mo_energy does not have the expected two rows with sufficient length to index occ/vir partitions implied by Lpqa/Lpqb), the function will raise standard NumPy/IndexError or ValueError exceptions due to invalid indexing or mismatched shapes.
        - If omega and one or more eia values are both zero, the denominator omega**2 + eia**2 can be zero, causing division-by-zero and producing inf or runtime warnings. Users should avoid evaluating exactly at omega = 0 when any eia is zero, or handle such degeneracies externally.
        - The function assumes real-valued orbital energies and real-valued auxiliary couplings. If complex inputs are supplied, the elementwise arithmetic will proceed but the physical interpretation and symmetry assumptions may not hold.
    
    Performance:
        - Computational cost scales with naux * (nocc * nvir) per spin for the contractions; memory usage is dominated by storing intermediate Pia arrays of shape (naux, nocc*nvir) in the einsum-based contraction. This function is intended for use inside GW screening routines where these dimensions are moderate or treated with additional performance strategies in PySCF.
    """
    from pyscf.gw.ugw_ac import get_rho_response
    return get_rho_response(omega, mo_energy, Lpqa, Lpqb)


################################################################################
# Source: pyscf.hessian.thermo.rotation_const
# File: pyscf/hessian/thermo.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_hessian_thermo_rotation_const(
    mass: numpy.ndarray,
    atom_coords: numpy.ndarray,
    unit: str = "GHz"
):
    """Compute rotational constants for a molecular geometry to characterize rotational spectra.
    
    This function pyscf.hessian.thermo.rotation_const computes the three principal rotational constants of a molecule from atomic masses and Cartesian coordinates. It is used in molecular spectroscopy and thermochemical analyses (as in PySCF) to convert the principal moments of inertia of the mass-distributed nuclear framework into spectroscopically relevant rotational constants. The routine forms the center-of-mass, constructs the 3×3 moment of inertia tensor in atomic units (Bohr for coordinates, atomic mass units for masses), diagonalizes it to obtain principal moments, and converts those moments to the requested unit using PySCF’s physical constants (pyscf.nist). The returned values correspond to the three principal axes used to characterize rotational spectra.
    
    Args:
        mass (numpy.ndarray): 1-D array of length N containing the masses of the N atoms. Masses are interpreted as atomic mass units (u, unified atomic mass) consistent with pyscf.nist. The mass array determines the center-of-mass position and weights the inertia tensor; mass.sum() must be nonzero or a division-by-zero will occur when computing the center of mass. Negative or non-physical masses will produce invalid inertia and rotational constants.
        atom_coords (numpy.ndarray): 2-D array with shape (N, 3) containing Cartesian coordinates of the N atoms. Coordinates are interpreted in atomic units (Bohr) consistent with the conversion factors used in the code. The function computes coordinates relative to the center of mass, constructs the inertia tensor from these shifted coordinates and the provided masses, and diagonalizes the inertia tensor to obtain principal moments of inertia.
        unit (str): Unit for the returned rotational constants. Case-insensitive accepted values are 'GHz' (default) to return rotational constants in gigahertz, and 'wavenumber' to return rotational constants in reciprocal centimeters (cm^-1). The default is 'GHz'. Any other string raises a RuntimeError('Unsupported unit ' + unit). The implementation uses pyscf.nist constants and applies the conversion formula B = ħ / (4π I) with appropriate unit conversion factors; for 'wavenumber' an additional division by the speed of light is applied and results are scaled to cm^-1.
    
    Returns:
        numpy.ndarray: 1-D array of three floating-point rotational constants in the requested unit. The array has length 3 and corresponds to the three principal axes obtained from diagonalizing the inertia tensor. The inertia eigenvalues are sorted in ascending order before conversion, so the returned rotational constants correspond to those ascending principal moments of inertia (i.e., the first returned constant corresponds to the smallest principal moment of inertia and therefore the largest rotational constant). Values may be infinite or NaN when a principal moment of inertia is zero (e.g., for linear molecules or degenerate coordinates) or when non-physical inputs are provided.
    
    Behavior and failure modes:
        The function performs no in-place modification of the input arrays and has no external side effects. It suppresses floating-point divide warnings during the inversion step, so division-by-zero yields NumPy infinities rather than raising warnings. It raises RuntimeError for unsupported unit strings. If mass.sum() == 0 the center-of-mass computation divides by zero producing invalid results. Non-physical inputs (negative masses, incorrect atom_coords shape, mismatched lengths between mass and atom_coords) will lead to incorrect results or NumPy shape/linear-algebra errors; callers should ensure mass.shape == (N,) and atom_coords.shape == (N, 3). The function relies on pyscf.nist physical constants for unit conversions; results are therefore consistent with PySCF’s documented unit conventions.
    """
    from pyscf.hessian.thermo import rotation_const
    return rotation_const(mass, atom_coords, unit)


################################################################################
# Source: pyscf.lib.chkfile.load_mol
# File: pyscf/lib/chkfile.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_chkfile_load_mol(chkfile: str):
    """pyscf.lib.chkfile.load_mol loads a pyscf.gto.Mole object from a PySCF checkpoint file (chkfile). This function is used to deserialize a Mole previously saved by pyscf.lib.chkfile.save_mol so the molecular specification (atomic coordinates, basis sets, charge, spin, and other metadata) can be reused in subsequent PySCF quantum-chemistry workflows such as SCF, DFT, and post-HF methods.
    
    Args:
        chkfile (str): Path to the checkpoint file (chkfile) to read. In practice this is the filename of an HDF5 file created by pyscf.lib.chkfile.save_mol. The function opens this file with h5py and looks for a dataset named 'mol' that contains the serialized Mole data.
    
    Returns:
        pyscf.gto.mole.Mole: An initialized/built Mole object. The returned Mole is reconstructed from the serialized representation and is ready for use in PySCF calculations (it contains the molecule geometry, basis, and other attributes required by methods such as SCF and post-HF). If the modern HDF5 serialization is present, gto.loads is used to recreate the Mole. If gto.loads fails, a legacy-compatibility path evaluates the stored representation to rebuild and then calls mol.build(False, False, **moldic) to initialize the Mole before returning it.
    
    Behavior and side effects:
    - Primary behavior: open the file at chkfile using h5py.File(..., 'r') and read the dataset 'mol'. If the dataset contains the current serialized form, gto.loads(...) is used to deserialize it into a pyscf.gto.mole.Mole instance.
    - Compatibility fallback: if deserialization raises an exception, the function attempts to support an older serialization format by reading a Python representation from the same 'mol' dataset, calling eval(...) on that string to obtain a dictionary (moldic), removing legacy keys ('mass', 'grids', 'light_speed') if present, creating a fresh gto.Mole(), setting mol.output = '/dev/null', and calling mol.build(False, False, **moldic). This legacy-compatibility path is explicitly for backward compatibility and is marked in the source as intended for future removal.
    - Side effects in the fallback path: mol.output is set to '/dev/null' before building to suppress file output during reconstruction. Other than creating and returning the Mole instance, the function does not write to chkfile.
    
    Failure modes and cautions:
    - File errors: If chkfile does not exist or is not a readable HDF5 file, h5py will raise an IOError/OSError.
    - Missing dataset: If the 'mol' dataset is not present, reading will fail with a KeyError or similar error from h5py.
    - Deserialization errors: gto.loads may raise exceptions if the serialized content is corrupted or incompatible; in that case the legacy fallback is attempted.
    - Legacy fallback security risk: the compatibility path uses eval(...) on file contents. Evaluating untrusted files is a security risk; do not load chkfiles from untrusted sources. Prefer checkpoint files produced by the same PySCF installation or trusted environments.
    - Dependency requirement: this function relies on h5py being available at runtime. If h5py is not installed, opening the chkfile will fail.
    - Deprecation: the legacy compatibility behavior exists to support older checkpoint formats and is planned for removal in a future PySCF release; relying on it is not recommended for long-term workflows.
    
    Practical significance:
    - This function provides a simple, reproducible way to restore molecular definitions across sessions, enabling workflows that save an expensive-to-construct Mole to disk and reuse it later without re-parsing input specifications. It is commonly used in scripting and automated quantum-chemistry pipelines built with the PySCF framework.
    """
    from pyscf.lib.chkfile import load_mol
    return load_mol(chkfile)


################################################################################
# Source: pyscf.lib.linalg_helper.cho_solve
# File: pyscf/lib/linalg_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_linalg_helper_cho_solve(
    a: numpy.ndarray,
    b: numpy.ndarray,
    strict_sym_pos: bool = True
):
    """pyscf.lib.linalg_helper.cho_solve solves the linear system a x = b for x, where a is expected to be a Hermitian (conjugate symmetric) positive-definite matrix commonly encountered in quantum chemistry linear algebra (for example overlap, metric, or density-related matrices in PySCF workflows). The implementation delegates to scipy.linalg.solve with assume_a='pos' to enable LAPACK paths optimized for positive-definite matrices, providing both performance and numerical behavior appropriate for PySCF computations.
    
    Args:
        a (numpy.ndarray): The square coefficient matrix a in the linear system a x = b. This array is expected to be a Hermitian (conjugate-transpose equal) and positive-definite matrix of shape (n, n). In the PySCF domain, such matrices arise for example as overlap or metric matrices in self-consistent-field (SCF) and correlated methods; treating a as positive-definite allows the solver to use optimized LAPACK kernels. The array must be a numpy.ndarray as required by scipy.linalg.solve.
        b (numpy.ndarray): Right-hand side array in the linear system a x = b. This should be a numpy.ndarray with a shape compatible with a: typically (n,) for a single right-hand side vector or (n, m) for multiple right-hand sides. The function returns the solution x with the same shape as b. The array type must be numpy.ndarray to match the scipy.linalg.solve API used internally.
        strict_sym_pos (bool): Default True. When True, the function enforces that a be strictly positive definite: it calls scipy.linalg.solve(a, b, assume_a='pos') and if that call raises numpy.linalg.LinAlgError (indicating that a is not strictly positive definite or numerical factorization failed), the exception is propagated to the caller. When False, the function downgrades strictness: upon catching numpy.linalg.LinAlgError it issues a runtime warning indicating the source file and line number where cho_solve was called and retries the solve using scipy.linalg.solve(a, b) without assume_a='pos'. Using strict_sym_pos=False can permit recovery from small numerical indefiniteness at the cost of disabling the optimized assume-a-positive code path and potentially exposing the solver to more expensive or different LAPACK routines. The warning is emitted via the warnings module and includes filename and line number obtained from inspect.stack() to aid debugging.
    
    Returns:
        numpy.ndarray: The solution x to the linear system a x = b. The returned array has the same shape as b and is computed by scipy.linalg.solve. If strict_sym_pos is True and the initial call with assume_a='pos' fails due to a not being strictly positive-definite, a numpy.linalg.LinAlgError is raised and no value is returned. If strict_sym_pos is False and the initial call fails, a RuntimeWarning is emitted and the function returns the result of scipy.linalg.solve(a, b) called without assume_a='pos'.
    
    Notes:
        Behavior and failure modes are determined by the underlying scipy.linalg.solve and LAPACK routines. This function does not perform explicit shape validation beyond what scipy.linalg.solve enforces; callers should ensure consistent matrix/vector dimensions. The use of assume_a='pos' is intended to improve performance for Hermitian positive-definite matrices common in PySCF computations.
    """
    from pyscf.lib.linalg_helper import cho_solve
    return cho_solve(a, b, strict_sym_pos)


################################################################################
# Source: pyscf.lib.chkfile.load
# File: pyscf/lib/chkfile.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_chkfile_load(chkfile: str, key: str):
    """pyscf.lib.chkfile.load: Load arrays or groups from a PySCF HDF5-format checkpoint file.
    
    Args:
        chkfile (str): Name or path of the checkpoint file to open. In the PySCF project this is typically a ".chk" file saved in HDF5 format by methods such as scf.RHF (for example mf.chkfile = 'He.chk'). The function opens this file read-only using h5py.File(chkfile, 'r') and closes it automatically on return. If the file does not exist or is not a valid HDF5 file, h5py will raise FileNotFoundError or OSError.
        key (str): HDF5 dataset name or group name to load from the opened file. If key names a dataset, the dataset is read into memory with h5py dataset slicing (val[()]) and returned (commonly producing a numpy.ndarray or numpy scalar). If key names a group, the group is loaded recursively into a Python dict following PySCF's on-disk conventions: subgroups or datasets are converted to dict entries; a group whose name ends with the suffix '__from_list__' is interpreted as a list container and is reconstructed as a Python list by loading its children in the order provided by h5py iteration. If the requested key is not present and no key+'__from_list__' variant is present, the function returns None.
    
    Returns:
        object: The Python object created from the HDF5 contents addressed by key. Typical return types are a numpy.ndarray or numpy scalar when key references a dataset, a dict when key references an HDF5 group (with nested dicts for nested groups), a list when a group uses the '__from_list__' convention, or None if the key is absent. The returned object is the in-memory representation of the stored checkpoint data (for example, scf/mo_coeff as an array or the entire 'scf' group as a dict containing keys like 'e_tot', 'mo_occ', 'mo_energy', 'mo_coeff'). No modification is made to the on-disk file; the operation is read-only.
    
    Behavior and failure modes:
        The function always opens the checkpoint file in read-only mode and closes it automatically. If the file cannot be opened as an HDF5 file, h5py raises FileNotFoundError or OSError. If key is present but an I/O or HDF5-level error occurs while reading a dataset or group, h5py will raise the corresponding exception. If key is not found (and key+'__from_list__' is also not found), the function returns None instead of raising an error. Large datasets are fully read into memory via val[()], so calling code should ensure sufficient memory for the returned arrays. This loader is intended for reading PySCF checkpoint files created by PySCF routines to retrieve data such as molecular orbital coefficients, occupations, and energies.
    """
    from pyscf.lib.chkfile import load
    return load(chkfile, key)


################################################################################
# Source: pyscf.lib.linalg_helper.make_diag_precond
# File: pyscf/lib/linalg_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_linalg_helper_make_diag_precond(
    diag: numpy.ndarray,
    level_shift: float = 0.001
):
    """Generate a diagonal preconditioner function for use in PySCF linear-algebra routines (e.g., iterative eigenvalue or subspace solvers). The returned function applies an elementwise division by a shifted diagonal to regularize the usual Jacobi-style preconditioner (Ax - x*e)/(diag(A) - e), breaking the correlation that can make basis vectors linearly dependent (see issue referenced in source). The implementation uses a fixed small cutoff (1e-8) to avoid exact division by zero after applying the level shift.
    
    Args:
        diag (numpy.ndarray): 1-D array of the diagonal elements of the matrix A used by the preconditioner. This array supplies diag(A) in the expression diag - (e - level_shift). The array is captured by closure when make_diag_precond is called; the returned preconditioner will compute a temporary shifted-diagonal array (diagd) as diag - (e - level_shift) and will not modify the original diag object. In the PySCF context, diag typically comes from the diagonal of a Hamiltonian or other operator and is used to form a cheap, elementwise preconditioner for iterative linear-algebra routines.
        level_shift (float): Small positive scalar (default 0.001) added to the eigenvalue shift inside the denominator to break correlations between the numerator (Ax - x*e) and the denominator (diag(A) - e). Practically, this reduces the chance of very small denominators that would produce instabilities or nearly linearly dependent correction vectors. The value is applied as diag - (e - level_shift). Extremely small or zero values of level_shift may fail to prevent correlation; excessively large values will bias the preconditioning and may slow convergence.
    
    Behavior and side effects:
        The returned function precond computes diagd = diag - (e - level_shift), then enforces a minimum magnitude by setting diagd[abs(diagd) < 1e-8] = 1e-8 before returning dx/diagd. The cutoff 1e-8 is fixed in the implementation and is used to prevent division-by-zero and to stabilize updates. The original diag array is not modified; a new temporary array is created for diagd. The returned preconditioner accepts an arbitrary trailing argument list (*args) and ignores it, allowing it to match common solver callback signatures used in PySCF.
    Failure modes:
        If diag is not a numeric numpy.ndarray, NumPy operations will raise TypeError. If dx and diag are not shape- or broadcast-compatible for elementwise division, NumPy will raise a ValueError or an appropriate broadcasting error when the preconditioner is called. The fixed cutoff (1e-8) may be inappropriate in extreme numeric regimes, and the function does not adapt that threshold.
    
    Returns:
        callable: A preconditioner function precond(dx, e, *args) that returns a numpy.ndarray computed as dx / diagd where diagd = diag - (e - level_shift) with entries of magnitude below 1e-8 replaced by 1e-8. The returned function is intended to be used in PySCF iterative solvers as the elementwise diagonal preconditioner; it captures the provided diag and level_shift by closure.
    """
    from pyscf.lib.linalg_helper import make_diag_precond
    return make_diag_precond(diag, level_shift)


################################################################################
# Source: pyscf.lib.chkfile.dump
# File: pyscf/lib/chkfile.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_chkfile_dump(chkfile: str, key: str, value: dict):
    """Save array(s) or nested Python containers into a checkpoint file (HDF5)
    used by the PySCF (Python-based Simulations of Chemistry Framework) code base.
    
    This function persistently stores numerical arrays, Python sequences (list/tuple),
    and mapping objects (dict) into an HDF5-formatted checkpoint file so that
    PySCF computations (for example, CI coefficients, symmetry metadata, density
    matrices, and other intermediate results) can be reloaded by later steps or
    by other PySCF modules. The function writes datasets and groups using the
    h5py/HDF5 storage model via pyscf.lib.H5FileWrap. When given a dict, keys are
    translated into HDF5 groups and datasets recursively; when given a list or
    tuple, elements are stored under a generated group named with the suffix
    "__from_list__" and numeric, zero-padded member names (format '%06d'). If a
    dataset cannot be written directly because it has an object dtype or cannot be
    broadcast into a single HDF5 dataset, the implementation falls back to saving
    each element individually as a group of datasets. Existing entries at the
    provided key (or its "__from_list__" variant) in the target file are deleted
    before writing the new content.
    
    Args:
        chkfile (str): Name or path of the checkpoint file to write. This is the
            filesystem path that will be opened by H5FileWrap/h5py. If the path
            already contains a valid HDF5 file (detected via h5py.is_hdf5), the
            file is opened in read-write mode ('r+') and the specified key is
            removed before writing. If the path does not point to an HDF5 file,
            a new HDF5 file is created (opened with mode 'w'), which replaces or
            creates the file at that path. The chkfile argument therefore controls
            the persistent storage location for PySCF checkpoint data.
        key (str): HDF5 key (name or path) to use for storing value inside the
            HDF5 hierarchy. This string may contain forward slashes '/' to
            indicate nested HDF5 group paths (for example 'symm/Ci/op'). Before
            writing, any existing entry with the same key or with the key appended
            by '__from_list__' will be deleted to ensure the new data replaces the
            old. The key determines where in the HDF5 file the dataset/group tree
            for value will appear and how it is later retrieved by pyscf.lib.chkfile
            read operations.
        value (array, vector, list or dict): The Python object to persist. If
            value is a dict, each key/value pair is saved recursively as HDF5
            groups/datasets, preserving the mapping structure so that nested
            dictionaries become nested HDF5 groups. If value is a list or tuple,
            it is saved under a group named key + '__from_list__' and each element
            is stored under a zero-padded numeric subkey ('%06d'). For plain
            array-like objects (NumPy arrays, vectors, etc.), value is written as
            an HDF5 dataset. If the array has an object dtype or cannot be written
            as a single dataset, the function falls back to storing elements
            individually in a generated '__from_list__' group. This parameter is
            the primary mechanism for persisting numerical and structured data
            produced by PySCF calculations.
    
    Returns:
        None: This function does not return a value. Its primary effect is a
        side effect: writing the provided value into the HDF5-formatted checkpoint
        file at the path given by chkfile, under the HDF5 key specified by key.
        On successful completion, the data can be opened and inspected with h5py
        or loaded back into PySCF with the corresponding chkfile read utilities.
    
    Behavioral notes, side effects, and failure modes:
        The function uses pyscf.lib.H5FileWrap as a context manager to open and
        close the HDF5 file. When the target key (or its '__from_list__' variant)
        already exists in the file, that existing entry is deleted before writing
        the new data, ensuring the stored structure matches the provided value.
        For list/tuple values, the function creates a group named with the suffix
        '__from_list__' to represent the ordered container; elements are named
        with six-digit zero-padded indices to preserve ordering when iterating
        over group members. If a direct assignment into an HDF5 dataset raises a
        TypeError or ValueError with messages indicating an object-dtype or
        broadcasting problem, the implementation falls back to element-wise
        storage inside a '__from_list__' group; other unexpected TypeError or
        ValueError messages are re-raised to the caller. Because the file is
        opened in write mode when it does not already contain an HDF5 structure,
        creating a new HDF5 file may replace an existing file at the same path.
        Users should ensure file paths and keys are chosen to avoid unintentional
        data loss.
    """
    from pyscf.lib.chkfile import dump
    return dump(chkfile, key, value)


################################################################################
# Source: pyscf.lib.diis.restore
# File: pyscf/lib/diis.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_diis_restore(filename: str):
    """pyscf.lib.diis.restore - Restore or construct a DIIS object from a saved DIIS file.
    
    Restore/construct a DIIS object (Direct Inversion in the Iterative Subspace) by
    reading a DIIS checkpoint file stored on disk. In the PySCF quantum chemistry
    framework, DIIS objects encapsulate the vectors, error vectors, coefficients,
    and internal parameters used to accelerate convergence of self-consistent field
    (SCF) and related iterative procedures. This convenience wrapper delegates the
    work to DIIS().restore(filename) in the same module and returns the reconstructed
    DIIS instance for reuse in continuing or analyzing an interrupted or previously
    saved electronic structure calculation.
    
    Args:
        filename (str): Path to the DIIS file on the filesystem. This string must
            be a valid filesystem path accessible to the Python process. The file
            is expected to contain a previously saved DIIS state (for example,
            vectors, error vectors, scalar coefficients, and any module-specific
            metadata) written by the corresponding DIIS save routine. The function
            will open and read this file to reconstruct the DIIS object's internal
            data structures. If the path is invalid, unreadable, or the file
            contents do not match the expected DIIS serialization format, the
            underlying restore implementation will raise an exception (for example,
            FileNotFoundError, OSError, or a format-specific parsing/ValueError).
    
    Returns:
        DIIS: A newly constructed and populated instance of the DIIS class defined
        in pyscf.lib.diis. The returned object contains the DIIS vectors, error
        vectors, and internal parameters loaded from filename and is ready to be
        used in subsequent DIIS.accumulate, DIIS.update, or other DIIS-driven
        SCF acceleration workflows. No global state in the pyscf.lib.diis module is
        required to be pre-initialized; all necessary state is created on the
        returned object. If the restore operation fails, an exception is raised and
        no DIIS object is returned.
    """
    from pyscf.lib.diis import restore
    return restore(filename)


################################################################################
# Source: pyscf.lib.linalg_helper.safe_eigh
# File: pyscf/lib/linalg_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_linalg_helper_safe_eigh(
    h: numpy.ndarray,
    s: numpy.ndarray,
    lindep: float = 1e-15
):
    """safe_eigh solves the generalized eigenvalue problem h v = w s v in a numerically stable two-pass procedure tailored for quantum-chemistry linear-algebra tasks (for example, solving Roothaan equations with an overlap metric that may contain near-linear dependencies). The function first diagonalizes the metric s to detect and remove linearly dependent directions below a threshold, then transforms h into the non-redundant subspace and diagonalizes the reduced problem to obtain the generalized eigenpairs. This preserves physical eigenpairs while avoiding numerical instabilities due to small eigenvalues of s.
    
    Args:
        h (numpy.ndarray): 2D complex Hermitian or real symmetric matrix representing the Hamiltonian or Fock-like operator in the original (possibly redundant) basis. In PySCF this is typically the core Hamiltonian or Fock matrix whose eigenproblem is solved in the presence of the metric s. The matrix must be square and consistent with s in dimension; if it is not a proper Hermitian/symmetric square matrix, the underlying linear-algebra routines (scipy.linalg.eigh) may raise an error.
        s (numpy.ndarray): 2D complex Hermitian or real symmetric metric matrix (for example, the overlap matrix in a molecular orbital basis). This matrix is diagonalized to obtain its eigenvalues (seig) and eigenvectors; eigenvalues below the lindep threshold are considered to indicate linear dependence and are removed from the active subspace used to solve the generalized eigenproblem.
        lindep (float): Linear-dependency threshold. Default is 1e-15. After diagonalizing s to obtain its eigenvalues seig, eigenvalues smaller than this threshold are treated as numerically zero and their corresponding eigenvector directions are excluded from the reduced subspace. This parameter therefore controls how aggressively near-linear dependencies in s are removed; increasing it will drop more directions, decreasing it will retain more. The function uses the masked eigenvectors scaled by 1/sqrt(seig[mask]) to construct the transformation into the orthonormalized reduced space.
    
    Returns:
        w (numpy.ndarray): 1D array of eigenvalues of the generalized problem h v = w s v found in the non-redundant subspace. The number of returned eigenvalues may be less than the matrix dimension if some eigenvalues of s fall below the lindep threshold and are excluded. The eigenvalues are real (within numerical precision) because h and s are Hermitian/symmetric.
        v (numpy.ndarray): 2D array whose columns are the eigenvectors corresponding to w, transformed back to the original basis. If linear dependency removal excludes all directions (no seig >= lindep), v will be an empty array consistent with t (the empty transformation) and w will be an empty 1D array of shape (0,).
        seig (numpy.ndarray): 1D array of eigenvalues of the metric s obtained from its diagonalization prior to thresholding. seig contains all eigenvalues (including those below lindep) in the same order returned by scipy.linalg.eigh(s). This allows the caller to inspect which directions were considered linearly dependent.
    
    Behavior and failure modes:
        The procedure is: (1) diagonalize s to obtain seig and eigenvectors t_full; (2) form mask = seig >= lindep and build t = t_full[:, mask] * (1/sqrt(seig[mask])); (3) compute the reduced effective Hamiltonian heff = t^H h t and diagonalize heff to obtain its eigenpairs (w, v_reduced); (4) reconstruct full-space eigenvectors v = t v_reduced. If no eigenvalues of s meet the threshold (t.size == 0), the function returns w as an empty 1D numpy.ndarray and v equal to t (empty). The function relies on scipy.linalg.eigh and will propagate exceptions from that call (for example, if inputs are not square or not treated as Hermitian by scipy). There are no external side effects; all outputs are returned and no in-place modification of the inputs is performed.
    """
    from pyscf.lib.linalg_helper import safe_eigh
    return safe_eigh(h, s, lindep)


################################################################################
# Source: pyscf.lib.linalg_helper.eigh_by_blocks
# File: pyscf/lib/linalg_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_linalg_helper_eigh_by_blocks(
    h: numpy.ndarray,
    s: numpy.ndarray = None,
    labels: list = None
):
    """Solve an ordinary or generalized eigenvalue problem by diagonalizing diagonal blocks
    of a Hermitian (or real symmetric) matrix. This function is used in the PySCF
    quantum chemistry framework to perform block-wise diagonalization when basis
    functions are partitioned (for example by symmetry irreducible representations,
    orbital symmetries, or other grouping labels). When labels are provided, the
    rows and columns with the same label are grouped into a block and each block is
    diagonalized independently; when labels is None, the full eigenproblem is
    delegated to scipy.linalg.eigh.
    
    Args:
        h (numpy.ndarray): 2D complex-Hermitian or real-symmetric matrix representing
            the operator to diagonalize (for example a Fock, Hamiltonian, or other
            molecular integral matrix). The function expects h.shape == (N, N).
            The dtype of h determines the dtype of the returned eigenvector array.
            This matrix is not modified in-place.
        s (numpy.ndarray): Optional 2D overlap (metric) matrix for solving the
            generalized eigenvalue problem h x = s x e. If provided, s must be a
            square numpy.ndarray with shape (N, N) and should correspond to the
            same basis as h (same ordering and size). If s is None (the default),
            an ordinary eigenvalue problem is solved. When labels is provided and s
            is given, each block uses the corresponding sub-block of s (s[idx][:,idx])
            to solve the generalized eigenproblem for that block.
        labels (list): Optional list providing a label for each basis function (each
            row/column of h and s). labels must have length N (the matrix dimension)
            and define the partitioning into blocks: all indices with the same
            label are collected into a single diagonal block that is diagonalized
            independently. Typical use in PySCF: labels are orbital symmetry names
            or irreducible representation identifiers (strings) returned by
            symmetry utilities (e.g., symm.label_orb_symm). If labels is None
            (default), no block partitioning is performed and the full matrix is
            diagonalized by scipy.linalg.eigh.
    
    Behavior and practical notes:
        - For each distinct value in labels the function extracts the submatrix of
          h (and s, if provided) corresponding to indices with that label and calls
          scipy.linalg.eigh on that submatrix. The eigenvectors for each block are
          placed into columns of an output matrix at positions determined by the
          order in which block eigenvalues are appended.
        - The final returned eigenvalue vector is formed by concatenating all block
          eigenvalues and then sorting them in ascending order; the eigenvector
          matrix columns are permuted to match this ascending eigenvalue order.
        - The output eigenvector array is allocated with numpy.zeros_like(h), so its
          shape equals h.shape and its dtype follows h.dtype. For blocks, eigenvector
          components are nonzero only on rows corresponding to that block; components
          corresponding to other blocks remain zero.
        - labels must accurately reflect a block-diagonal structure of h (and of s
          when s is provided). If h or s contain significant off-diagonal couplings
          between different labels, those couplings are ignored by this block-wise
          procedure and the results will not match a full (non-blocked)
          diagonalization.
        - If labels is None, this function simply returns the result of
          scipy.linalg.eigh(h, s) and behaves identically to that routine.
        - scipy.linalg.eigh may raise numpy.linalg.LinAlgError (or a similar
          exception) if the decomposition fails (for example if s is not positive
          definite for a generalized eigenproblem). Such exceptions propagate to the
          caller.
    
    Returns:
        tuple:
            w (numpy.ndarray): 1D array of eigenvalues (concatenated from block
                diagonalizations and sorted in ascending order). Length is N.
            v (numpy.ndarray): 2D eigenvector array with shape (N, N) (same shape as
                h). Columns of v are the eigenvectors corresponding to entries of w;
                within each block the eigenvectors are the orthonormal eigenvectors
                returned by scipy.linalg.eigh for that block.
    """
    from pyscf.lib.linalg_helper import eigh_by_blocks
    return eigh_by_blocks(h, s, labels)


################################################################################
# Source: pyscf.lib.linalg_helper.pick_real_eigs
# File: pyscf/lib/linalg_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_linalg_helper_pick_real_eigs(
    w: numpy.ndarray,
    v: numpy.ndarray,
    nroots: int,
    envs: dict
):
    """pyscf.lib.linalg_helper.pick_real_eigs selects eigenvalues whose imaginary parts are small (numerical noise) and converts complex-conjugate eigenpairs to real representations when appropriate. In the PySCF quantum-chemistry workflow, diagonalization routines can produce eigenvalues and eigenvectors with small nonzero imaginary components even when the underlying physical problem has real spectrum (for example, real-symmetric Hamiltonians, overlap matrices, or effective Fock/Kohn–Sham operators). This function is used by PySCF linear-algebra helpers to pick the eigenvalues that are effectively real (within a numeric tolerance) from arrays produced by general eigensolvers, warn when fewer than the requested number of "real" roots are found, and delegate conversion of complex conjugate pairs to _eigs_cmplx2real so downstream code (e.g., post-processing, state selection in SCF/CI routines) receives real-valued results when possible.
    
    Args:
        w (numpy.ndarray): One-dimensional array of eigenvalues as returned by an eigensolver. Typically a complex dtype array whose real parts are the computed eigenvalues and whose imaginary parts reflect numerical noise or small physically meaningful imaginary components. This argument provides the basis for selecting which eigenvalues are treated as real; its length determines how many roots are available to choose from.
        v (numpy.ndarray): Two-dimensional array of eigenvectors corresponding to w. v should be aligned with w such that v[:, i] is the eigenvector for w[i]. The function may pass v to the helper _eigs_cmplx2real for conversion of complex-conjugate eigenvectors into real representations; depending on envs['dtype'], real-valued eigenvectors may be returned.
        nroots (int): The number of requested "real" eigenvalues (roots) the caller intends to select for subsequent processing (for example, selecting the lowest N eigenstates in a quantum-chemistry calculation). The function uses nroots to compute a tolerance cutoff for acceptable imaginary parts and to decide whether to issue a warning when too few eigenvalues meet a strict imaginary-part threshold.
        envs (dict): Environment and metadata dictionary used by calling code (PySCF linear-algebra helpers). The implementation inspects envs.get('dtype') and compares it to numpy.double; if equal, the function requests conversion that yields real eigenvectors from the internal conversion helper (_eigs_cmplx2real) by passing real_eigenvectors=True, otherwise it requests the conversion without forcing real eigenvectors. envs is not mutated by this function.
    
    Behavior, defaults, and failure modes:
        The function computes the absolute magnitudes of the imaginary parts of entries in w and uses a fixed baseline threshold of 1e-3 to distinguish negligible imaginary components from significant ones. It then determines a tolerance max_imag_tol = max(1e-3, kth_smallest_abs_imag) where kth_smallest_abs_imag is the (nroots)-th smallest absolute imaginary part among available eigenvalues (or the largest available if fewer than nroots eigenvalues exist). All eigenvalues with absolute imaginary part <= max_imag_tol are considered "real" candidates and their indices are collected.
        The function counts how many of those candidates have absolute imaginary part strictly less than the baseline threshold (1e-3). If that count is less than nroots and at least nroots eigenvalues are present (w.size >= nroots), the function emits a runtime warning via warnings.warn indicating that only a smaller number of eigenvalues have imaginary part < 1e-3 out of the requested nroots. This warning is a side effect intended to notify callers that numerical noise prevented selection of the requested number of strictly real roots.
        The function then calls the internal helper _eigs_cmplx2real(w, v, real_idx, real_eigenvectors=...) to perform conversion of complex conjugate eigenpairs into a real-valued representation when appropriate. The real_eigenvectors flag passed to _eigs_cmplx2real is True when envs.get('dtype') == numpy.double, and False otherwise. The helper is responsible for constructing real eigenvectors and adjusting eigenvalues as needed; pick_real_eigs delegates that conversion and returns the converted arrays from the helper.
        The baseline threshold (1e-3) and the selection strategy implemented in this function reflect pragmatic choices for numerical linear algebra in PySCF; callers that require a different tolerance or selection policy should apply additional filtering before or after calling this function.
        If no eigenvalues satisfy the selection criterion, the index array returned by the helper may be empty and the returned eigenvalue/eigenvector arrays will reflect that; callers should handle empty results. The function does not raise an exception for too few "real" roots; it issues a warning when appropriate as described above. The function expects w and v to be consistent (matching sizes) and to contain at least one eigenvalue in normal use; behavior is undefined for grossly malformed inputs.
    
    Returns:
        tuple: A 3-tuple (w_sel, v_sel, idx) where w_sel (numpy.ndarray) is the array of selected eigenvalues after conversion by _eigs_cmplx2real, v_sel (numpy.ndarray) is the corresponding array of eigenvectors after conversion, and idx (numpy.ndarray) contains the indices of the selected eigenvalues relative to the original input array w. These return values are intended for immediate use in subsequent PySCF routines that expect real-valued eigenpairs when possible; if no eigenvalues met the selection criteria, the returned arrays may be empty.
    """
    from pyscf.lib.linalg_helper import pick_real_eigs
    return pick_real_eigs(w, v, nroots, envs)


################################################################################
# Source: pyscf.lib.misc.generate_pickle_methods
# File: pyscf/lib/misc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_misc_generate_pickle_methods(excludes: tuple = (), reset_state: bool = False):
    """pyscf.lib.misc.generate_pickle_methods generates a pair of functions implementing Python's pickle protocol methods (__getstate__ and __setstate__) that can be attached to user-defined classes. In the PySCF (Python-based Simulations of Chemistry Framework) context these generated methods are used to produce a compact, portable serialized representation of computational objects (for example SCF instances, integrals containers, or task/state objects) by omitting non-serializable or large transient attributes such as open streams and cached internal state. The returned methods are intended to be assigned on a class as "__getstate__, __setstate__ = generate_pickle_methods(...)" so pickle and other serialization tools will use them.
    
    Args:
        excludes (tuple): A tuple of attribute names (strings) that should be omitted from the serialized state produced by the generated __getstate__ and that should be reset/cleared by the generated __setstate__. The default value is an empty tuple, meaning no additional attributes beyond the built-in exclusion of 'stdout' are removed. Each name in excludes is treated as an attribute key; if a key is not present on the object during getstate it is ignored (no error), and during setstate the attribute named in excludes is explicitly set to None on the target object. Typical usage in PySCF is to list large caches, heavy data arrays, or other non-portable resources that must not be pickled.
        reset_state (bool): If True, after restoring attributes during __setstate__ the generated setter will attempt to call obj.reset() if that attribute exists; this allows restored objects to reinitialize internal transient state (for example recomputing derived caches) rather than relying on stale values from the saved state. The default is False, meaning no automatic reset is attempted. If obj.reset exists but raises an exception, that exception is propagated to the caller.
    
    Returns:
        tuple: A two-tuple (getstate, setstate) of callables. getstate(obj) returns a shallow copy of obj.__dict__ with the 'stdout' entry removed and with any keys listed in excludes removed; the removal uses a safe pop operation so missing keys do not raise errors. The dictionary returned is a shallow copy (references to the original objects are preserved) and is suitable for passing to pickle as the object's saved state. setstate(obj, state) restores state by setting obj.stdout = sys.stdout, updating obj.__dict__ with the provided mapping state (the mapping is typically the dictionary produced by getstate), then setting each attribute named in excludes to None, and finally invoking obj.reset() if reset_state was True and the object provides a reset method. Side effects: setstate will mutate obj.__dict__, create or overwrite attributes named in the state mapping, set excluded attributes to None, and always set obj.stdout to the current sys.stdout. Failure modes: if state is not a mapping acceptable to dict.update, a TypeError may be raised; if obj does not support attribute assignment via __dict__ (for example instances using __slots__ without __dict__), an AttributeError or TypeError may occur; if obj.reset exists and raises, that exception will propagate. The caller should provide excludes containing only string attribute names and should ensure state was produced by a compatible getstate to avoid inconsistent restoration.
    """
    from pyscf.lib.misc import generate_pickle_methods
    return generate_pickle_methods(excludes, reset_state)


################################################################################
# Source: pyscf.lib.misc.invalid_method
# File: pyscf/lib/misc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_misc_invalid_method(name: str):
    """pyscf.lib.misc.invalid_method creates a placeholder callable that indicates a method is invalid or intentionally unimplemented within the PySCF framework. It is used when a class, module, or API wants to de-register or replace an existing method with a sentinel that consistently signals "not implemented" at runtime, aiding clear error reporting and API maintenance.
    
    Args:
        name (str): The canonical name to assign to the generated placeholder callable. This string is used in two practical ways within the PySCF codebase: it becomes the returned function's __name__ attribute (so tools, tracebacks, and introspection report the given name), and it is interpolated into the NotImplementedError message raised by the placeholder. The caller must provide a descriptive name for the method being de-registered; providing a non-str value is not supported and may produce a TypeError or unexpected diagnostics when the function is created or invoked.
    
    Returns:
        function: A callable with signature (obj, *args, **kwargs) that ignores its positional and keyword arguments and always raises NotImplementedError with a message of the form "Method {name} invalid or not implemented". Practical significance: assigning the returned callable to a class attribute or instance attribute (for example, MyClass.method = invalid_method('method')) effectively de-registers the original implementation and makes any subsequent call to that method fail fast with a clear, consistent error. Side effects: the returned function's __name__ is explicitly set to the provided name to improve readability in tracebacks and debugging. Failure modes: calling the returned function will always raise NotImplementedError; it performs no fallback behavior.
    """
    from pyscf.lib.misc import invalid_method
    return invalid_method(name)


################################################################################
# Source: pyscf.lib.misc.finger
# File: pyscf/lib/misc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_misc_finger(a: numpy.ndarray):
    """pyscf.lib.misc.finger computes a deterministic scalar "fingerprint" for a numpy.ndarray by taking the dot product of the array flattened in row-major order with a fixed cosine-based weight vector. In the PySCF (Python-based Simulations of Chemistry Framework) codebase this routine is used to produce compact numeric signatures of numerical arrays (for example, molecular integrals, orbital coefficient arrays, density matrices, or intermediate tensors) for quick equality checks, lightweight caching keys, logging, or debugging comparisons where a full elementwise comparison would be expensive.
    
    Args:
        a (numpy.ndarray): Input numeric array whose compact signature is to be computed. The array is interpreted in row-major order and flattened via ravel() before weighting. The function expects a numeric numpy.ndarray containing the raw floating-point or integer data produced by PySCF computations; non-numeric dtypes or arrays that cannot be converted to a numeric ndarray may cause numpy to raise an exception. The routine does not modify the input array in-place (it calls numpy.asarray(a) which may or may not make a copy depending on the input), and the calculation is performed on the flattened view of the array so the original shape does not affect which elements contribute, only their order.
    
    Returns:
        float: A scalar fingerprint (numpy scalar such as numpy.float64) computed as numpy.dot(numpy.cos(numpy.arange(a.size)), a.ravel()). This single numeric value serves as a compact, deterministic projection of the input array for quick comparisons or bookkeeping. The value is not a cryptographic hash: it is a linear projection and therefore collisions (different arrays producing the same fingerprint) are possible. Behavior for edge cases: an empty array (a.size == 0) yields 0.0; very large element magnitudes can lead to typical floating-point overflow or precision loss; and numerical results may vary across different floating-point environments or numpy builds due to rounding behavior. Exceptions from numpy (TypeError, ValueError) can be raised if the input cannot be treated as a numeric ndarray.
    """
    from pyscf.lib.misc import finger
    return finger(a)


################################################################################
# Source: pyscf.lib.misc.flatten
# File: pyscf/lib/misc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_misc_flatten(lst: list):
    """Flatten a sequence of first-level iterables into a single list used by PySCF for assembling collections (e.g., lists of basis-function descriptors, integrals, or other per-component lists) when building larger data structures in the Python-based Simulations of Chemistry Framework.
    
    Args:
        lst (list): A list whose elements are themselves iterable containers (for example, lists or tuples) that should be concatenated in order. In the PySCF codebase this function is used to combine per-component lists produced by chemistry workflows into a single list. The function expects a Python list as the top-level container; each element of that list must be iterable. If an element is not iterable (for example, a bare int), a TypeError will be raised when attempting to iterate over that element. Note that iterable scalars such as strings will be iterated character-by-character (which is often undesirable), so callers should wrap such items in a non-iterable container or avoid passing raw strings.
    
    Returns:
        list: A new list containing the concatenation of the elements of lst, in the same order as they appear in lst. Only the top-level iterables in lst are concatenated (one-level flattening); deeper nested lists are preserved as elements of the resulting list. The input lst is not modified; a fresh list is constructed (memory usage and run time are proportional to the total number of items produced by iterating the elements of lst). Example behavior (from the original documentation): flatten([[0, 2], [1], [[9, 8, 7]]]) returns [0, 2, 1, [9, 8, 7]]. Failure modes include TypeError if an element of lst is not iterable.
    """
    from pyscf.lib.misc import flatten
    return flatten(lst)


################################################################################
# Source: pyscf.lib.misc.index_tril_to_pair
# File: pyscf/lib/misc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_misc_index_tril_to_pair(ij: numpy.ndarray):
    """pyscf.lib.misc.index_tril_to_pair maps a flattened lower-triangular (tril) linear index used in PySCF to the corresponding pair of row and column indices (i, j).
    
    Given a linear index or array of linear indices ij that encodes positions in a packed lower-triangular layout using the convention
    ij = i * (i + 1) / 2 + j,
    this function computes the pair indices i and j (zero-based, consistent with NumPy/Python) such that each returned pair satisfies the above relation. In PySCF and quantum chemistry codes, this mapping is commonly used when compactly storing symmetric matrices (for example overlap, density, or two-electron integrals) in a 1D array containing only the lower triangle; index_tril_to_pair recovers the original matrix coordinates used to reconstruct or address elements.
    
    Args:
        ij (numpy.ndarray): A NumPy array of non-negative integer tril indices encoded with the convention ij = i*(i+1)/2 + j. ij must represent valid packed lower-triangular positions: i >= 0 and 0 <= j <= i for each element. The function expects a NumPy ndarray (typically integer dtype) and returns arrays of the same shape. Passing values that are negative, non-integer, or otherwise not representing valid tril indices will lead to undefined or incorrect results: negative values typically produce NaNs from the square-root step and then cause a conversion error when casting to integers.
    
    Returns:
        tuple of numpy.ndarray: A pair (i, j) of NumPy arrays of integer type and the same shape as the input array ij. i contains the row indices (the larger index in the pair, since the storage is lower-triangular) and j contains the column indices (the smaller or equal index). Each returned pair satisfies ij = i*(i+1)//2 + j using integer arithmetic. There are no side effects; the function performs a numeric computation and returns new arrays. Failure modes: for out-of-range or invalid ij entries (negative values, non-integer encodings, or extremely large values that cause floating-point instability) the intermediate square-root will produce NaN or Inf and the subsequent cast to integer may raise a ValueError or produce incorrect indices. The implementation adds a small positive tolerance (1e-7) before casting to int to reduce errors from floating-point rounding when recovering i.
    """
    from pyscf.lib.misc import index_tril_to_pair
    return index_tril_to_pair(ij)


################################################################################
# Source: pyscf.lib.misc.num_threads
# File: pyscf/lib/misc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_misc_num_threads(n: int = None):
    """pyscf.lib.misc.num_threads controls and queries the number of OpenMP (OMP) threads used by PySCF and dependent native libraries (for example, NumPy or BLAS backends) in parallel numerical workloads. When called with an integer argument, it requests the runtime to set the process-wide OMP thread count to that value using the PySCF internal numpy_helper C interface. When called without an argument, it returns the currently available OMP thread count as observed through the same internal interface.
    
    This function is used in the PySCF codebase and by PySCF users to manage parallelism for CPU-bound linear algebra and other OpenMP-enabled kernels. It is recommended over directly setting the environment variable OMP_NUM_THREADS at runtime because many native libraries read that environment variable when they are imported/initialized; changing os.environ['OMP_NUM_THREADS'] after import does not reliably change the runtime thread count for those libraries. Internally this function delegates to pyscf.lib.numpy_helper._np_helper.set_omp_threads and pyscf.lib.numpy_helper._np_helper.get_omp_threads via ctypes, so the observed behavior depends on that C helper and the availability of OpenMP support in the build.
    
    Args:
        n (int): The desired number of OpenMP threads to set for the current process. If n is None (the default), the function does not attempt to change the thread count and instead queries and returns the current number of OMP threads. When provided, n is converted to an integer with int(n) before being passed to the underlying C helper; therefore, n should be an integer or a value safely convertible to int. Calling with a numeric n causes a side effect: the process-wide OMP thread count is updated (subject to the underlying OpenMP/BLAS library behavior and availability). If OpenMP is not available in the runtime, the underlying C call returns 0 and the function emits a warning indicating that setting threads has no effect.
    
    Returns:
        int: When n is None, the current number of available OpenMP threads as reported by the internal C helper. When n is provided, the integer returned by the underlying set_omp_threads call (typically the new thread count); a return value of 0 indicates that OpenMP is not available and that the attempted change had no effect.
    
    Behavior notes and failure modes:
        - Use this function to reliably change the effective thread count at runtime for PySCF workflows; changing the OMP_NUM_THREADS environment variable after modules have been imported is not sufficient.
        - If n cannot be converted to int, a Python TypeError or ValueError from int(n) will propagate.
        - The exact semantics of setting negative values, zero, or very large integers are determined by the underlying OpenMP runtime and the pyscf.lib.numpy_helper implementation; this function does not impose additional validation beyond int(n).
        - The function calls into ctypes wrappers around a C helper; if those symbols are missing or the helper is not available, calling this function may raise an exception from the ctypes call or return values reflecting missing OpenMP support.
    """
    from pyscf.lib.misc import num_threads
    return num_threads(n)


################################################################################
# Source: pyscf.lib.misc.make_class
# File: pyscf/lib/misc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_misc_make_class(bases: tuple, name: str = None, attrs: dict = None):
    """Construct and return a Python class object composed from the given base classes, with optional explicit name and attribute dictionary. This function is used in PySCF to dynamically build composite classes from mixins and base classes (for example when combining functionality from multiple modules, extensions, or plugin mixins in the Python-based Simulations of Chemistry Framework), and to cache and reuse identical class combinations so that the same (name, bases) pair yields the same class object across the process.
    
    Args:
        bases (tuple): A tuple of base class objects to use as the class bases. Each element must be a Python class (type). The tuple order determines method resolution order; different orders produce different classes. If bases is empty (an empty tuple), the constructed class will have no base classes. Practical significance: callers supply mixin and implementation classes from PySCF modules to compose a new class that aggregates behavior needed for a particular quantum-chemistry data structure or algorithm.
        name (str): Optional explicit name for the constructed class. If None (the default), a deterministic name is synthesized by concatenating, in order, each base's __name_mixin__ attribute if present or else its __name__ attribute; this provides a readable identifier for cached composite classes used throughout PySCF. The name is passed verbatim to type() as the class name; supplying a non-string value will cause type() to raise a TypeError. Naming affects cache lookup: classes are cached by the tuple (name, bases).
        attrs (dict): Optional mapping of attribute names to values to use as the class namespace when creating the class. If None (the default), an empty dict is used. The dict is passed to type(name, bases, attrs) as the class namespace, so callers should supply a standard dict of attribute definitions (methods, class variables, descriptors) when adding behavior at class-creation time. Supplying a non-dict value will cause type() to raise a TypeError.
    
    Behavior and side effects:
        The function looks up a module-level cache (_registered_classes) keyed by (name, bases). If a class for that key already exists, the cached class is returned and no new class is created. If no cached class exists, the function creates a new class with type(name, bases, attrs), sets the new class attribute __name_mixin__ to the chosen name, stores the new class in _registered_classes under the key (name, bases), and returns it. This caching avoids creating duplicate classes for the same combination of name and bases, which is important in PySCF to ensure consistent types and reduce memory/identity duplication when composing many small mixin combinations across the codebase.
        The function mutates module-level state by inserting entries into _registered_classes and by setting the __name_mixin__ attribute on newly created classes. These are intentional side effects that enable reuse and introspection of mixin-composed classes.
        The synthesized default name depends on base-class attributes (__name_mixin__ or __name__), so renaming or altering base classes can change the generated name and therefore the cache key; callers should be aware that logically identical base tuples with different names produce distinct cached classes.
    
    Failure modes and edge cases:
        TypeError will be raised by type() if bases contains non-class objects, if name is not a str, or if attrs is not a dict. Supplying bases with differing order or contents will produce distinct classes; callers must ensure consistent ordering when they expect reuse from the cache. The function does not perform explicit thread synchronization on the cache; concurrent calls from multiple threads that create the same (name, bases) key can race and produce redundant class objects or overwrite entries in _registered_classes.
    
    Returns:
        type: The class object (a Python type) that was returned from the cache or newly constructed. The returned class aggregates the behavior of the provided base classes and includes attributes from attrs; it also has a __name_mixin__ attribute set to the chosen name and will be stored in the module-level _registered_classes for reuse.
    """
    from pyscf.lib.misc import make_class
    return make_class(bases, name, attrs)


################################################################################
# Source: pyscf.lib.misc.prange_split
# File: pyscf/lib/misc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_misc_prange_split(n_total: int, n_sections: int):
    """Generate a sequence of index ranges that splits n_total elements into n_sections parts using the same split convention as numpy.array_split. This function is used in PySCF to partition a linear index range (for example, indices of basis functions, matrix rows/columns, or integrals) into contiguous, load-balanced sections for parallel loops or chunked processing. The splitting follows the rule that the first (n_total % n_sections) sections receive one extra element (size floor(n_total/n_sections) + 1) and the remaining sections receive floor(n_total/n_sections) elements. Each returned pair (start, end) represents a half-open interval [start, end) of integer indices that together cover 0..n_total without overlap.
    
    Args:
        n_total (int): Total number of elements to split. In the quantum-chemistry domain of PySCF this typically represents the total number of items to iterate over (for example, orbitals, atomic basis function indices, or integrals). Must be an integer; typical and intended use is with n_total >= 0. The algorithm guarantees that the sum of the sizes of all returned sections equals n_total for valid non-negative n_total.
        n_sections (int): Number of contiguous sections to produce. In practice, this corresponds to the number of parallel tasks or chunks to distribute work to (for example, number of worker processes or threads). Must be a positive integer (n_sections >= 1) for meaningful splits. The function implements the numpy.array_split convention so that the first (n_total % n_sections) sections are one element larger to spread any remainder evenly.
    
    Behavior and practical notes:
        The function computes integer division and remainder via divmod(n_total, n_sections) to determine base section size and how many sections receive the extra element. It constructs cumulative division points and returns an iterator of (start, end) index pairs produced by zip(div_points[:-1], div_points[1:]). Each pair is a half-open interval [start, end) using zero-based indexing, suitable for slicing Python sequences or for specifying ranges of indices in numerical kernels.
        There are no side effects: the function does not modify input data or global state. The implementation produces ranges in increasing order that partition the interval [0, n_total) without overlap.
        The function follows numpy.array_split semantics for load balancing: when n_total is not divisible by n_sections, earlier sections are larger by one element. This choice is practical in PySCF workflows to avoid creating many tiny final chunks and to distribute work more evenly across workers.
    
    Returns:
        iterator of tuple of int: An iterator (zip object) that yields tuples (start, end). Each tuple contains two ints giving the start (inclusive) and end (exclusive) indices of a section. For valid inputs these satisfy 0 <= start < end <= n_total (except when a section size is zero, in which case start == end may occur if n_sections > n_total). Consuming the iterator yields exactly n_sections tuples that together cover all indices from 0 up to n_total.
    
    Raises:
        ZeroDivisionError: If n_sections == 0, divmod will raise ZeroDivisionError. The caller should ensure n_sections is a positive integer.
        TypeError: If non-integer types are passed for n_total or n_sections, operations inside may raise TypeError. Callers should pass integers.
        ValueError/Undefined behavior: Negative n_total or negative n_sections are not supported by the typical usage in PySCF; passing negative values may produce unexpected or meaningless ranges.
    """
    from pyscf.lib.misc import prange_split
    return prange_split(n_total, n_sections)


################################################################################
# Source: pyscf.lib.misc.prange
# File: pyscf/lib/misc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_misc_prange(start: int, end: int, step: int):
    """pyscf.lib.misc.prange splits an integer index interval into contiguous, non-overlapping fragments of a given maximum length and yields the boundaries for each fragment. In the PySCF (Python-based Simulations of Chemistry Framework) codebase, this helper is used to partition linear index ranges (for example, ranges of atomic orbital or molecular orbital indices, integral blocks, or other loop indices) into smaller chunks for batched processing, memory-limited loops, or parallel work distribution.
    
    The function is a generator: for a given integer interval from start up to end, it produces successive tuples (p0, p1) that define half-open subintervals [p0, p1) covering the original range without overlap. Each yielded tuple gives the inclusive start index and the exclusive end index of a fragment; the final fragment may be shorter than step if (end - start) is not an exact multiple of step.
    
    Args:
        start (int): The inclusive starting integer index of the full interval to split. In PySCF use this is typically the first index of a set of indices to iterate over (for example, 0 for indexing into arrays of basis functions). If start >= end, no fragments are yielded.
        end (int): The integer end boundary of the full interval. This value is exclusive: the generated fragments will cover indices up to but not including end. In practice this corresponds to the upper limit for indexing in a loop or the length of a collection in PySCF tasks.
        step (int): The maximum length of each fragment, expressed as a positive integer. This controls how many indices are grouped into each yielded fragment and therefore affects memory and work granularity for batched or parallel operations in PySCF workflows.
    
    Behavior and failure modes:
        The function yields tuples (p0, p1) where p0 and p1 are integers with start <= p0 < p1 <= end, and successive fragments are contiguous so that the union of all yielded half-open intervals [p0, p1) equals the original interval [start, end). If (end - start) is not divisible by step, the last yielded fragment will have length less than step to terminate exactly at end. If start < end is false (start >= end), the generator yields no values. If step is zero, range(...) will raise ValueError; therefore step must be a non-zero integer and is expected to be positive for the function to produce fragments when start < end. If non-integer types are passed, Python's built-in range will raise TypeError; callers in PySCF should pass integers to avoid those exceptions. The function has no side effects: it does not modify inputs or global state and performs no I/O.
    
    Returns:
        iterator of tuple(int, int): A generator that yields successive tuples (p0, p1). Each tuple specifies a fragment of the original interval such that p0 is the fragment start (inclusive) and p1 is the fragment end (exclusive). These tuples are intended to be used to drive batched loops, block-wise computations, or partitioned parallel work in PySCF code paths.
    """
    from pyscf.lib.misc import prange
    return prange(start, end, step)


################################################################################
# Source: pyscf.lib.misc.square_mat_in_trilu_indices
# File: pyscf/lib/misc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_misc_square_mat_in_trilu_indices(n: int):
    """pyscf.lib.misc.square_mat_in_trilu_indices returns an n x n integer matrix that maps the unique elements of a flattened lower-triangular (tril) vector to positions in a full symmetric square matrix. This function is used in PySCF (the Python-based Simulations of Chemistry Framework) to convert a compact storage of unique symmetric matrix elements (commonly used for symmetric operators, density matrices, and pairwise interaction tensors in quantum chemistry) back into a full symmetric index structure that can be used to reconstruct or address the full matrix.
    
    The function constructs the mapping by enumerating the lower-triangular indices in the same order as numpy.tril_indices(n), assigning each unique tril element a consecutive integer index from 0 to n*(n+1)//2 - 1, and mirroring those indices across the diagonal so that the output matrix is symmetric. The result is independent of any external state (no side effects) and uses O(n^2) time and memory to produce an (n, n) integer array.
    
    Args:
        n (int): The dimension of the square matrix to construct. n must be a non-negative integer representing the number of rows and columns of the square matrix. In practical PySCF usage, n corresponds to the size of a one-particle basis or the dimension of any symmetric operator whose unique lower-triangular elements have been vectorized. Passing a non-integer type or a negative integer will result in errors from the underlying numpy calls (TypeError or ValueError) and is not supported.
    
    Returns:
        numpy.ndarray: An integer numpy array of shape (n, n) and dtype int. Each element of this array is an index in the range [0, n*(n+1)//2 - 1] that identifies which entry of the compact tril-vector corresponds to that matrix position. Entries on and below the diagonal are assigned indices in the order produced by numpy.tril_indices(n); entries above the diagonal contain the mirrored indices so the returned matrix is symmetric. This mapping enables reconstructing a full symmetric matrix A from a compact tril-vector v by setting A[i, j] = v[result[i, j]] for all i, j.
    """
    from pyscf.lib.misc import square_mat_in_trilu_indices
    return square_mat_in_trilu_indices(n)


################################################################################
# Source: pyscf.lib.misc.with_doc
# File: pyscf/lib/misc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_misc_with_doc(doc: str):
    """pyscf.lib.misc.with_doc is a small decorator factory used in the PySCF (Python-based Simulations of Chemistry Framework) codebase to attach or replace the documentation string of a function. This utility is used throughout PySCF to provide authoritative docstrings for functions that are generated dynamically, wrapped by higher-order functions, or otherwise lack an inline literal docstring, thereby improving introspection (help(), IPython tooltips) and Sphinx-generated documentation for quantum chemistry routines and utilities.
    
    Args:
        doc (str): The documentation text to assign as the target function's __doc__ attribute. In the PySCF domain this string typically contains usage notes, descriptions of numerical behavior (for example, which approximations or integral conventions are used), parameter meanings, and references relevant to chemical simulation routines. The argument is required and must be a Python str; passing a non-str value is not a supported usage and may lead to downstream problems in tools that expect __doc__ to be a string.
    
    Returns:
        callable: A decorator function fn_with_doc that accepts a single parameter fn (a function or any callable) and returns the same callable after setting fn.__doc__ = doc. The returned decorator performs an in-place mutation of the callable's __doc__ attribute as its side effect; it does not create a wrapper, copy metadata, or otherwise modify attributes such as __name__ or __module__. If the target callable already has a docstring, it will be overwritten. No exceptions are raised by this factory itself; however, supplying a non-string doc may cause documentation tools or type checkers used in the PySCF project to behave incorrectly.
    """
    from pyscf.lib.misc import with_doc
    return with_doc(doc)


################################################################################
# Source: pyscf.lib.numpy_helper.broadcast_mul
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_broadcast_mul(
    a: numpy.ndarray,
    b: numpy.ndarray,
    out: numpy.ndarray = None
):
    """Broadcasted entrywise multiplication specialized for PySCF tensor operations.
    
    Args:
        a (numpy.ndarray): 3D input array in C order. In the PySCF context this is typically a stack of 2D blocks or tensor slices (for example, a collection of matrices indexed by a leading index used in electronic-structure routines). The function requires a.ndim == 3, a.shape[1:] == b.shape, and a.dtype to match b.dtype. The memory layout must satisfy the stride constraint checked in code (the last axis must be contiguous: a.strides[2] == a.itemsize). This array supplies the per-slice values that are multiplied by the 2D factor b for each leading index and participates in the elementwise multiplication out[:, :, :] += a[:, :, :] * b[None, :, :].
        b (numpy.ndarray): 2D input array in C order. In PySCF usage this represents the 2D multiplier applied to every 2D slice of a (for example, a matrix of coefficients or scaling factors common across the leading dimension). The function requires b.ndim == 2, b.shape == a.shape[1:], and b.dtype to match a.dtype. The memory layout must satisfy b.strides[1] == b.itemsize (contiguous last axis). The first stride (b.strides[0]) is interpreted as the leading-dimension stride and is passed through to the low-level helper.
        out (numpy.ndarray, optional): Optional output array in C order with the same shape and dtype as a. If provided, out is modified in place and receives the accumulated result (out[:, :, :] is incremented by the broadcasted product). If out is None, the function allocates and returns a new zero-initialized ndarray with the same shape and dtype as a. When supplied, out must satisfy out.shape == a.shape, out.dtype == a.dtype, and the same last-axis contiguity constraint as a (out.strides[2] == out.itemsize).
    
    Behavior and side effects:
        This routine computes the broadcasted, entrywise multiplication corresponding to the expression out[:, :, :] += a[:, :, :] * b[None, :, :] using an optimized C helper implementation from the module-level _np_helper (the implementation selects NPomp_dmul_12 for numpy.double and NPomp_zmul_12 for numpy.complex128). The function modifies and returns the array referenced by out; if out was None a new zeroed ndarray is allocated and returned. The operation preserves dtype and shape: the returned array has the same dtype and shape as a.
        The function enforces specific memory-layout and dtype constraints for performance: inputs must be C-ordered with contiguous last axis (as asserted in the source). The C helper expects the provided strides (in units of elements) and dimensions; incorrect strides or noncontiguous layouts will trigger assertion failures. The routine does not create copies to satisfy these stride requirements; callers should ensure arrays meet the required layout.
    
    Failure modes and exceptions:
        The function uses assertions to validate inputs and will raise AssertionError if a.ndim != 3, b.ndim != 2, a.shape[1:] != b.shape, a.dtype != b.dtype, or if the stride contiguity conditions on a, b, or out are not met. If a.dtype (and therefore b.dtype and out.dtype) is not numpy.double or numpy.complex128, the function raises NotImplementedError because only these dtypes have corresponding low-level helper implementations. Passing non-numpy array objects will result in attribute errors when the function attempts to access ndarray attributes (e.g., .ndim, .strides); therefore inputs must be numpy.ndarray.
    
    Performance note:
        This function is intended for use in PySCF computational-chemistry code paths where many small 2D multiplications are applied across a leading index (for example, scaling batches of integrals, density-matrix slices, or block matrices). It delegates the inner loop to a compiled helper (NPomp_* functions) for performance; callers should respect the required memory layout and dtype to obtain optimal speed and avoid additional copies.
    
    Returns:
        numpy.ndarray: The array receiving the broadcasted elementwise product. If out was provided, the same out object is returned after being modified in place (it contains the original out plus the added a*b contributions). If out was None, a newly allocated, zero-initialized ndarray of the same shape and dtype as a is returned containing the computed result.
    """
    from pyscf.lib.numpy_helper import broadcast_mul
    return broadcast_mul(a, b, out)


################################################################################
# Source: pyscf.lib.numpy_helper.cartesian_prod
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_cartesian_prod(arrays: list, out: numpy.ndarray = None):
    """pyscf.lib.numpy_helper.cartesian_prod generates the Cartesian product of multiple one-dimensional input arrays and returns all ordered combinations as a two-dimensional NumPy array. This function is part of PySCF's numpy_helper utilities and is used in the PySCF (Python-based Simulations of Chemistry Framework) codebase to enumerate combinations of 1-D parameter arrays, for example when forming grids or combinatorial parameter lists required in electronic-structure workflows.
    
    This function accepts a sequence of 1-D array-like objects, converts them to NumPy arrays, determines a common result dtype using numpy.result_type, allocates or uses the provided output buffer, and arranges the data so that each row of the returned 2-D array is one combination (cartesian product) of the inputs. The number of rows in the result equals the product of the lengths of the input arrays and the number of columns equals the number of input arrays. If an output buffer is provided via the out parameter, the function will use it as the backing storage via numpy.ndarray(..., buffer=out), so the buffer must be compatible in size, dtype, and writable memory layout; otherwise a new array is allocated.
    
    Args:
        arrays (list of array-like): 1-D arrays to form the cartesian product of. Each element in this list is converted with numpy.asarray and therefore may be any array-like object accepted by numpy.asarray (for example Python lists or numpy arrays). The function assumes each converted element is one-dimensional; providing non-1-D arrays or arrays whose lengths or shapes are inconsistent with the required reshaping may raise an error from NumPy during reshape or assignment. The practical significance in PySCF is to enumerate all combinations of scalar parameters or indices (for example constructing parameter grids or enumerating combinations of component values for integrals or basis-related loops).
        out (ndarray): Array to place the cartesian product in. When supplied, this array is used as the backing buffer for the intermediate storage via numpy.ndarray(..., buffer=out). The provided array must therefore be compatible with the required total size and the computed dtype (numpy.result_type of the input arrays) and must expose a writable buffer. If out is None (the default), the function allocates and returns a new ndarray. Supplying an incompatible buffer typically results in NumPy raising TypeError or ValueError.
    
    Returns:
        out (ndarray): A 2-D NumPy array of shape (M, N) where N == len(arrays) and M == the product of the lengths of the input arrays. Each row corresponds to one element of the cartesian product, with the i-th column drawn from the i-th input array. The dtype of the returned array is determined by numpy.result_type applied to all input arrays. If an external buffer was provided via the out parameter, that buffer is used for storage and is returned (after being reshaped/filled); otherwise a newly allocated ndarray is returned.
    
    Behavior and failure modes: The function converts inputs with numpy.asarray and will therefore follow NumPy conversion rules (for example preserving numeric types where possible). It assumes 1-D inputs; non-1-D inputs or inputs whose lengths make the internal reshaping impossible will cause NumPy to raise errors (e.g., ValueError). If an out buffer is provided that is too small, has an incompatible dtype, or is otherwise not a suitable writable buffer, NumPy will raise an error when creating or writing into the intermediate ndarray. No other side effects occur beyond possible in-place modification of the provided out buffer.
    """
    from pyscf.lib.numpy_helper import cartesian_prod
    return cartesian_prod(arrays, out)


################################################################################
# Source: pyscf.lib.misc.prange_tril
# File: pyscf/lib/misc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_misc_prange_tril(start: int, stop: int, blocksize: int):
    """pyscf.lib.misc.prange_tril: Partition a contiguous integer range [start, stop) into subranges
    suitable for iterating over a lower-triangular (tril) index space so that the cumulative
    triangular count inside each subrange stays below a specified blocksize. This helper is
    used in PySCF to split the work of loops that enumerate pairs (i,j) with i<=j (lower
    triangular ordering) into blocks with bounded computational/memory cost, enabling
    batching or parallel dispatch of triangular-indexed workloads (for example, blocked
    generation or contraction of two-electron integrals and related tensor slices).
    
    Args:
        start (int): Inclusive start index of the first coordinate in the triangular index
            space. This is the first i value to be considered when enumerating lower-triangular
            pairs (i,j) with i in [start, stop). In PySCF code paths this typically denotes
            the initial row index of a matrix or tensor block over which tril-based looping
            is performed.
        stop (int): Exclusive stop index for the first coordinate. The generator partitions
            the half-open interval [start, stop). The final returned subrange always ends at
            stop (that is, the last p1 equals stop). If start >= stop the function returns an
            empty sequence (no subranges).
        blocksize (int): Upper bound (positive integer) on the cumulative triangular count
            assigned to each output subrange. For a returned subrange (p0, p1) the number of
            triangular-index pairs contributed by that subrange is measured by
            p1*(p1+1)/2 - p0*(p0+1)/2 and satisfies the strict inequality
            p1*(p1+1)/2 - p0*(p0+1)/2 < blocksize. In practice, blocksize controls the
            maximum work or memory footprint per block when batching lower-triangular loops
            in PySCF routines; choose it to reflect the desired per-block cost in your
            application.
    
    Behavior and side effects:
        The function returns an iterable of subrange boundaries that partition [start, stop)
        into contiguous subranges suitable for tril iteration. Each subrange is represented
        by a pair of integers (p0, p1) with start <= p0 < p1 <= stop and with the triangular
        cost for the block strictly less than blocksize. If start >= stop the function
        immediately returns an empty list. The function itself has no side effects (it does
        not modify global state or input values) and only computes the partitioning.
        Inputs are expected to be Python integers; passing non-integer types will lead to the
        usual Python TypeError or implicit conversion behavior.
    
    Failure modes and notes:
        The implementation relies on integer arithmetic of cumulative triangular counts; if
        blocksize is set extremely small relative to the range length, the partition will
        produce many small subranges. The function does not raise a custom error for invalid
        blocksize values; passing a non-positive blocksize or non-integer values may yield
        unexpected or implementation-specific behavior depending on the caller environment.
        The inequality that bounds each subrange is strict ("< blocksize") as required by
        downstream PySCF code that expects each block to be below the specified threshold.
    
    Returns:
        iterable of tuple[int, int]: An iterable (in Python 3, typically a zip iterator) that
        yields two-integer tuples (p0, p1). Each tuple denotes a subrange [p0, p1) of the
        original interval [start, stop). The tuples partition [start, stop) in order and
        satisfy start <= p0 < p1 <= stop and p1*(p1+1)/2 - p0*(p0+1)/2 < blocksize.
        If start >= stop the function returns an empty list instead of an iterator.
    """
    from pyscf.lib.misc import prange_tril
    return prange_tril(start, stop, blocksize)


################################################################################
# Source: pyscf.lib.misc.repo_info
# File: pyscf/lib/misc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_misc_repo_info(repo_path: str):
    """pyscf.lib.misc.repo_info obtains repository metadata for a PySCF source tree: it resolves the supplied path to an absolute repository location and, when a Git repository is detected, assembles a one- or two-line Git status string containing original HEAD, branch name, and commit ID. This information is used by PySCF to report the source repository location and commit identifiers for reproducibility, debugging, logging, and citation purposes.
    
    The function inspects the filesystem for a .git directory either at the given path or in its parent directory. If a Git repository is found, repo_info calls the internal git_info routine and formats its output into human-readable lines such as "GIT ORIG_HEAD <orig_head>" and "GIT HEAD (branch <branch>) <head>" (or "GIT HEAD      <head>" when no branch name is present). If no Git repository is found, only the canonical absolute path is returned. The function does not modify files on disk; it only reads filesystem metadata and delegates to git_info for Git-specific details. The implementation currently does not collect information about external libraries (for example BLAS, libcint, libxc, libxcfun, tblis), as indicated by the in-source TODO.
    
    Args:
        repo_path (str): Path to a directory that is the repository root or a subdirectory of the repository.
            The function converts this path to an absolute path (os.path.abspath) and, if a .git
            directory is not present at that location but is present in its parent directory,
            the parent directory is treated as the repository root. This parameter must be a
            filesystem path string; no validation is performed beyond os.path.isdir checks.
    
    Returns:
        dict: A dictionary containing repository metadata with the following keys:
            'path' (str): The absolute path used as the repository root. This is always present and
                is the value of os.path.abspath(repo_path) or its parent if a parent .git was used.
            'git' (str, optional): A formatted string with Git information when a Git repository was
                detected. The string may contain one or two newline-separated lines produced by the
                git_version helper: one line for ORIG_HEAD if present, and one line for HEAD which
                includes branch name when available. This key is omitted when no .git directory is
                found at the path or its parent.
    
    Behavior, side effects, defaults, and failure modes:
        - The function resolves repo_path with os.path.abspath and may treat the parent directory as
          the repository root if the supplied path is inside a working tree whose .git directory sits
          one level up.
        - No files are written or modified; only filesystem inspection and calls to the internal
          git_info helper occur.
        - If a Git repository is present, git_info is invoked and its return values are formatted by
          git_version; any exceptions raised by git_info or by underlying OS calls (for example,
          if permission is denied when reading directories) propagate to the caller.
        - If no .git directory is found at the path or its parent, the returned dictionary contains
          only the resolved 'path' key and no 'git' key.
        - The function does not probe or report details about external numerical libraries (BLAS,
          libcint, libxc, libxcfun, tblis); that functionality is intentionally not implemented
          here (see in-source TODO).
    """
    from pyscf.lib.misc import repo_info
    return repo_info(repo_path)


################################################################################
# Source: pyscf.lib.numpy_helper.cleanse
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_cleanse(a: numpy.ndarray, axis: int = 0, tol: float = 0):
    """Cleanse floating-point array values by grouping nearly identical numbers (within a specified tolerance) and setting each group to a single representative value. This reduces spurious differences caused by floating-point round-off so that numpy.round_ and numpy.unique behave as expected in numerical workflows used throughout PySCF (Python-based Simulations of Chemistry Framework), for example when stabilizing arrays of orbital energies, integrals, grid values, or other computed quantities before further comparison or grouping.
    
    Args:
        a (numpy.ndarray): Array to be cleansed. This input is the numeric array whose small floating-point discrepancies should be removed. The function expects a numeric ndarray (e.g., float dtype) that supports numpy.argsort, numpy.diff and element-wise assignment. The shape and dtype of the returned array will match this input. In PySCF, typical uses include cleansing 1-D or multi-dimensional results (energies, matrix elements, grid values) prior to applying rounding or uniqueness checks.
        axis (int or None): Axis along which values are compared and clustered. Default is 0 (the first axis), meaning values are compared along rows when a is 2-D (or along the leading axis for higher dimensions). If set to None, the array is flattened and the entire flattened 1-D sequence is processed as a single set of values. Invalid axis values will raise the same errors that numpy.moveaxis would raise (e.g., ValueError/IndexError).
        tol (float): Tolerance threshold for grouping values. Two values whose absolute difference is less than or equal to tol (i.e., diff <= tol after sorting) are treated as equal and set to the same representative value. The default tol is 0, which causes only exact-equal values to be merged. If tol is negative, no values will be merged in practice because numpy.diff on a sorted numeric array is non-negative; the code will therefore treat every value as its own cluster. Use tol to express the maximum permissible floating-point discrepancy to be ignored when consolidating values.
    
    Behavior, algorithm, side effects, and failure modes:
        The function operates by processing each 1-D slice determined by axis (or the entire flattened array when axis is None). For each 1-D sequence it:
        1) sorts the values and obtains sort indices,
        2) computes pairwise differences between adjacent sorted values (numpy.diff),
        3) identifies cluster boundaries where the difference is greater than tol (diff > tol),
        4) assigns every member of a cluster the value of the first element in that cluster (the lowest sorted value),
        and 5) restores the original ordering and shape.
        This approach preserves the input array's shape and dtype in the returned array. The function does not modify the original input array a; it returns a new ndarray containing the cleansed values.
        Complexity: sorting makes the per-slice cost roughly O(n log n) for n elements in the slice; memory cost is additional temporary arrays for sorting and reshaping.
        Numerical and dtype considerations: the function expects numeric types; non-numeric or structured dtypes may cause numpy.argsort/numpy.diff to raise errors. NaN values are not specially handled by the algorithm; their ordering and comparison behavior follow numpy semantics (e.g., NaNs may propagate into diffs or be ordered at the end depending on numpy version), which may result in NaNs forming separate clusters or preventing merges.
        Errors raised originate from underlying numpy operations (e.g., ValueError for an invalid axis, TypeError/ValueError for unsupported dtypes). The function does not perform explicit input validation beyond relying on numpy operations.
    
    Returns:
        numpy.ndarray: A new array with the same shape and dtype as the input a in which values that differ by no more than tol along the specified axis have been consolidated to a single representative value (the first element in sorted order for each cluster). The original input a is not modified.
    """
    from pyscf.lib.numpy_helper import cleanse
    return cleanse(a, axis, tol)


################################################################################
# Source: pyscf.lib.numpy_helper.base_repr_int
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_base_repr_int(number: int, base: int, ndigits: int = None):
    """pyscf.lib.numpy_helper.base_repr_int converts an integer or an array of integers into a sequence of base-N digits and returns those digits as Python lists for scalars or as a 2-D numpy.ndarray for array inputs. This helper is used in PySCF utilities that need an explicit digit-wise representation of integers (for example, encoding occupation patterns, indexing combinatorial objects, or other bit/base decompositions used in quantum-chemistry bookkeeping).
    
    Args:
        number (int or numpy.ndarray): The value(s) to convert to the given base. If a single Python integer is supplied, the function returns a Python list of integers representing the digits from most-significant to least-significant. If a numpy.ndarray is supplied, the array is flattened and each element is converted; the caller must provide ndigits in this case (the function asserts ndigits is not None). Negative integer values are treated by their absolute value (the sign is discarded) so the output always represents the non-negative magnitude.
        base (int): The integer base to use for the conversion. This is the radix of the target number system. Practical use in PySCF includes converting integer indices or bit-pattern encodings into digit sequences. The base must be an integer; base == 0 will raise a ZeroDivisionError and base == 1 leads to non-terminating behavior (the routine relies on integer division and modulo by base), so callers should provide base >= 2 for meaningful results.
        ndigits (int, optional): Number of digits to produce for each converted value. If provided, the result is left-padded with zeros so that the returned digit sequence has length exactly ndigits. When converting a numpy.ndarray, ndigits is required and the function will assert its presence. When ndigits is None (the default), no padding is applied and the minimal number of digits required to represent the magnitude is returned (except that zero is represented as a single digit [0]).
    
    Returns:
        list or numpy.ndarray: If the input number argument is a scalar int, returns a Python list of int where each element is one digit in the specified base, ordered from most-significant digit (index 0) to least-significant digit (last index). If the input number argument is a numpy.ndarray, returns a numpy.ndarray of dtype int with shape (N, ndigits) where N is the number of elements in number.flatten(); rows correspond to input elements in flattened order and columns correspond to digits from most-significant to least-significant. The returned digits represent the absolute value of the input integers.
    
    Behavior and failure modes:
        - Negative inputs are converted using their absolute value; the function does not preserve or return a sign bit.
        - For scalar inputs, the function computes digits by repeated modulo and integer division. For the scalar 0 the function returns [0] (and will left-pad to ndigits if ndigits is provided).
        - For numpy.ndarray inputs the array is flattened, and a 2-D integer array of shape (len(flattened), ndigits) is constructed by extracting each digit position; an AssertionError is raised if ndigits is None for array inputs.
        - Supplying base == 0 will raise a ZeroDivisionError; supplying base == 1 will produce incorrect, non-terminating behavior. Supply base >= 2 to obtain meaningful results.
        - The function assumes integer-typed input values; passing non-integer types may lead to TypeError or unexpected behavior from numpy operations.
        - No sign or two's-complement encoding is produced; the output is strictly the digit decomposition of the absolute value.
    """
    from pyscf.lib.numpy_helper import base_repr_int
    return base_repr_int(number, base, ndigits)


################################################################################
# Source: pyscf.lib.numpy_helper.direct_sum
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_direct_sum(subscripts: str, *operands):
    """Apply an einsum-like direct (outer) summation over multiple operand arrays to produce a combined tensor following a compact subscript notation.
    
    This function is a utility in the PySCF (Python-based Simulations of Chemistry Framework) code base used to build composite multi-index tensors from smaller arrays (for example when forming direct-sum or outer-sum combinations of orbital, integral, or index-space tensors). The calling convention mirrors NumPy einsum style with the following extensions implemented in this routine: each operand term may be prefixed by a '+' or '-' sign (default '+'); commas and spaces are treated as separators; an explicit output mapping may be provided after '->'; if no '->' is given the output subscript is the concatenation of the input subscripts. Operands are converted with numpy.asarray and are combined by repeated reshaping and elementwise addition/subtraction followed by a final einsum to reorder axes to the requested output.
    
    Args:
        subscripts (str): Einsum-like subscript specification describing how operand indices combine and the optional output ordering. The string may contain space characters and commas (commas are treated as '+' separators). Each operand term may be prefixed with '+' or '-' to indicate whether that operand is added to or subtracted from the running result; if the first term has no explicit sign, a leading '+' is assumed. To request an explicit output order, include '->' followed by the destination subscript (for example, 'ij,klm->ijklm'). If '->' is omitted, the destination subscript is the concatenation of the input subscripts in their (post-processed) order. This argument controls the shape and axis ordering of the returned numpy.ndarray and is parsed exactly as implemented in the source: signs are extracted in sequence corresponding to the operand order, repeated symbols within an operand are detected and transformed via an internal einsum step to yield unique symbols for that operand, and whitespace and commas are normalized prior to processing.
    
        operands (tuple): One or more array-like operands passed as separate positional arguments; each entry corresponds to one term in the left-hand side of subscripts in the same order. Each operand is converted to a numpy.ndarray via numpy.asarray() inside the function. The number of operand terms parsed from subscripts (after splitting) must match len(operands) exactly; otherwise the function raises AssertionError. For each operand the length of the corresponding subscript symbol string must equal the operand.ndim; if not, an AssertionError is raised. If a symbol repeats within a single operand's subscript, the function consolidates repeated symbols into unique symbols by invoking an internal einsum conversion for that operand (this can change that operand's shape before combining). Operands are combined by reshaping the accumulated result and the next operand to enable elementwise broadcasting and then adding or subtracting according to the parsed sign for that operand.
    
    Behavior and side effects:
        The function performs successive reshape and elementwise addition/subtraction operations to realize the direct-sum (outer-sum) across operands, followed by an internal einsum to permute axes to the destination ordering specified in subscripts. The implementation relies on an internal helper _numpy_einsum for both de-duplicating repeated symbols within an operand and for the final axis reordering. The returned array has its writeable flag explicitly set to True (out.flags.writeable = True) to avoid issues with older NumPy versions. This function may allocate intermediate arrays and can be memory-intensive for large inputs; some index/orderings (for example those that require explicit full broadcasting across many axes) can be slow and require significant temporary memory.
    
    Failure modes and errors:
        AssertionError is raised if the number of operand terms parsed from the subscripts does not equal the number of operands supplied, or if the length of a subscript string for a given operand does not match that operand's ndim after conversion to a numpy array. Supplying malformed subscripts (invalid characters or an impossible mapping) will lead to parsing errors or errors from the internal einsum calls. Because repeated symbols within an operand are handled by an internal einsum rewrite, behavior in those cases follows NumPy einsum semantics used by the helper; unexpected shapes or symbol repetitions may therefore lead to shape changes or errors originating from the internal einsum.
    
    Returns:
        numpy.ndarray: A new numpy array that is the direct-sum (outer-sum) combination of the provided operands following the einsum-like subscripts specification. The shape and axis order of the returned array are determined by the destination subscript (the right-hand side of '->' when present, or by concatenation of input subscripts when '->' is omitted). The returned array is writable (out.flags.writeable is set True).
    """
    from pyscf.lib.numpy_helper import direct_sum
    return direct_sum(subscripts, *operands)


################################################################################
# Source: pyscf.lib.numpy_helper.expm
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_expm(a: numpy.ndarray):
    """Equivalent to scipy.linalg.expm. Computes the matrix exponential exp(a) for a square numpy.ndarray using a truncated Taylor series with scaling and repeated squaring, as used in PySCF numerical linear-algebra routines (for example, orbital rotations, short-time propagators, and other matrix-exponential needs in quantum-chemistry algorithms).
    
    Args:
        a (numpy.ndarray): Square 2-D input matrix A whose exponential exp(A) is to be computed. The function reads a.shape[0] and a.shape elements and therefore requires a to be a 2-D square array (a.shape[0] == a.shape[1]). The argument is not modified by the function (a copy of a is used internally). The implementation assumes numeric entries; non-finite entries (NaN, Inf) will propagate through the computation and typically produce NaN/Inf in the result.
    
    Returns:
        numpy.ndarray: A new 2-D square numpy.ndarray of the same shape as a containing the matrix exponential exp(a). The element type follows NumPy's type-promotion rules and may differ from a.dtype. The returned matrix is computed by first forming a truncated Taylor series of a scaled matrix (powers of a up to a finite order chosen by a stopping criterion based on a machine-precision threshold), then undoing the scaling by repeated squaring. No in-place modification of the input is performed.
    
    Behavior and algorithmic details:
        The function builds successive powers of a (a, a^2, a^3, ...) and accumulates them into a list until a termination condition is met or a preset maximum expansion depth is reached. The termination criterion compares the maximum and minimum entries of the latest power to a radius threshold computed as (2**(n*(n+2)) * (n+2)! * 1e-16)^((n+1)/(n+2)) for candidate order n; this uses 1e-16 as a machine-precision proxy. If the criterion is met for some n in 1..13 the series truncation stops; otherwise the loop runs up to n=13. After truncation, the code forms the scaled Taylor sum y = I + sum_k c_k * a^k (with factorial scaling and additional 0.5**(...) factors determined by the chosen scaling level n). Finally the function performs n repeated squarings (matrix-matrix multiplications via ddot) to recover exp(a) from the scaled sum. The algorithm is therefore a variant of the scaling-and-squaring method combined with a truncated Taylor expansion.
    
    Performance and side effects:
        The routine uses explicit dense matrix products (ddot) and thus has the usual dense-matrix computational cost (roughly cubic scaling with matrix dimension for the dominant multiplications). It relies on NumPy/BLAS for inner products; performance depends on those libraries. There are no other side effects (no global state is modified). Intermediate memory is allocated for power matrices and temporary buffers; peak memory is larger than a single matrix of the same shape.
    
    Failure modes and numerical considerations:
        If a is not square, attempts to index or form the identity matrix will raise an exception. Extremely large norms or pathological spectra may cause loss of accuracy in the truncated Taylor approximation; the routine uses a conservative maximum expansion depth (n up to 13) and a machine-precision based stopping criterion, but for very ill-conditioned matrices the result can be inaccurate. Non-finite input entries will propagate. Users seeking guaranteed high-accuracy or specialized behavior (e.g., complex matrices with specific scaling) may prefer scipy.linalg.expm or other library routines that implement different parameter choices or higher-precision control.
    """
    from pyscf.lib.numpy_helper import expm
    return expm(a)


################################################################################
# Source: pyscf.lib.numpy_helper.condense
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_condense(
    opname: str,
    a: numpy.ndarray,
    loc_x: list,
    loc_y: list = None
):
    """Condense a 2D NumPy array into an array of block-wise reductions using a named reduction
    operator. This function is part of PySCF's numpy_helper utilities and is used to
    aggregate blocks of a 2-dimensional numerical array (for example, parts of a
    density matrix or integral arrays) into a smaller 2D array of reduced values
    (e.g., sums, maxima). The function accepts explicit block boundary indices along
    rows and columns (loc_x and loc_y) and applies the specified operator to each
    block, returning a condensed array with one entry per block pair.
    
    Args:
        opname (str): Name of the reduction operator to apply to each block. The
            string may be given in forms such as 'sum', 'numpy.sum', 'np.sum', or
            with an 'NP_' prefix; leading 'numpy.' or 'np.' prefixes are removed and
            a leading 'NP_' is ignored. For arrays with dtype numpy.double and for
            opname in ('sum', 'max', 'min', 'abssum', 'absmax', 'absmin', 'norm'),
            an optimized native implementation (_np_helper.NPcondense) is used.
            For boolean or numpy.int8 arrays and opname in ('any', 'all'), a
            specialized optimized implementation (_np_helper.NPbcondense) is used.
            For other dtype/opname combinations, the function falls back to the
            corresponding numpy.<opname> function. If opname is not available in
            the optimized helper or as a numpy attribute, an AttributeError will be
            raised. This parameter determines the per-block aggregation semantics
            (e.g., sum over elements, logical any over elements) and therefore
            directly controls the meaning of the condensed output in PySCF data
            processing.
        a (numpy.ndarray): A 2-dimensional NumPy array containing the data to be
            condensed. The function asserts that a.ndim == 2 and will raise an
            AssertionError if this condition is not met. Typical uses in PySCF
            include condensing large matrices (for example, density matrices,
            two-dimensional intermediate arrays) into coarser block summaries. The
            function may reorder or copy this array internally: if a is Fortran
            contiguous, it is transposed to facilitate a C-contiguous copy; then a
            C-order copy is created with numpy.asarray(a, order='C') before any
            optimized native routine is invoked. The dtype of a determines which
            optimized path (if any) is taken and influences the dtype of the
            returned array.
        loc_x (list): Sequence of integer indices that define the row block
            boundaries. This should be a list-like object that can be converted to
            a NumPy int32 array; internally loc_x is converted with
            numpy.asarray(loc_x, numpy.int32). The number of row blocks is
            nloc_x = len(loc_x) - 1, so loc_x must contain at least two entries.
            The i-th row block corresponds to rows loc_x[i]:loc_x[i+1] of a.
            Indices are passed through to optimized helpers or used for slicing in
            the fallback path, so they must be valid for a (out-of-range or
            non-monotonic indices can lead to IndexError, incorrect results, or
            undefined behavior in native helpers).
        loc_y (list): Sequence of integer indices that define the column block
            boundaries, analogous to loc_x. If loc_y is None (the default), loc_y
            is taken equal to loc_x so squared tilings are produced. Internally it
            is converted to a NumPy int32 array. The number of column blocks is
            nloc_y = len(loc_y) - 1 and loc_y must contain at least two entries
            when provided explicitly. The j-th column block corresponds to
            columns loc_y[j]:loc_y[j+1] of a. As with loc_x, invalid indices may
            raise exceptions or cause undefined behavior when native helpers are
            used.
    
    Returns:
        numpy.ndarray: A 2-dimensional NumPy array of shape (nloc_x, nloc_y) where
        nloc_x = len(loc_x) - 1 and nloc_y = len(loc_y) - 1. Each element out[i,j]
        is the result of applying the requested reduction operator to the subarray
        a[loc_x[i]:loc_x[i+1], loc_y[j]:loc_y[j+1]]. Return dtype depends on the
        input dtype and chosen operator:
        - When an optimized double-precision path is taken (a.dtype == numpy.double
          and opname in the listed optimized names), the returned array is a
          C-contiguous float64 array allocated with numpy.zeros((nloc_x, nloc_y)).
          This path uses a C helper (_np_helper.NPcondense) for performance.
        - When an optimized boolean/int8 path is taken (a.dtype in (bool, numpy.int8)
          and opname in ('any', 'all')), the returned array has the same dtype as
          a and is allocated with numpy.zeros((nloc_x, nloc_y), dtype=a.dtype).
          This path uses a specialized C helper (_np_helper.NPbcondense).
        - For all other dtype/opname combinations, the result dtype is the same as
          a.dtype and is produced by two staged numpy reductions: first reducing
          each vertical block into a temporary array of shape (nloc_x, a.shape[1])
          along axis=0, then reducing horizontally over axis=1 to produce the final
          (nloc_x, nloc_y) result.
        The returned array contains one aggregated value per block pair and is the
        primary output used by higher-level PySCF routines that need block-wise
        summaries of large 2D arrays.
    
    Behavior, side effects, and failure modes:
        - The function requires a to be 2-dimensional (assert a.ndim == 2).
        - If loc_y is None, it is set to loc_x to produce symmetric block tilings.
        - loc_x and loc_y are converted to numpy.int32 arrays internally; they must
          therefore be representable as int32.
        - For performance, certain dtype/operator combinations dispatch to C-level
          optimized routines in the _np_helper extension module; these routines
          expect C-contiguous arrays and may behave unpredictably or raise errors
          if provided with invalid indices or incompatible memory layout. To meet
          these requirements, a is converted to C order (with a possible transpose
          step if it is Fortran-contiguous) before calling the native helpers.
        - If opname corresponds to a numpy reduction (fallback path), the
          computation is performed in Python using numpy functions and may be less
          efficient but functionally equivalent for supported operators.
        - If opname is not recognized by the optimized helper and is not an
          attribute of numpy, an AttributeError will be raised when the code tries
          to look up the operator. If loc_x or loc_y contain out-of-range, non-
          integer, or non-monotonic values, slicing or native helper calls can
          raise IndexError or produce incorrect/undefined results; callers must
          ensure loc arrays correctly partition the dimensions of a.
        - The function allocates new arrays for intermediate and final results,
          so memory usage is proportional to the number of blocks times the inner
          dimension (for the temporary) plus the number of blocks squared (for the
          result). In large problems typical in PySCF workflows, ensure sufficient
          memory is available before calling.
    
    Examples of practical use in PySCF:
        - Condensing a large 2D density or integrals matrix into block sums to
          produce coarser-grained diagnostics or to build block-diagonal
          approximations.
        - Computing per-region maxima/minima of orbital overlap matrices by
          specifying appropriate loc_x/loc_y partition boundaries and opname='max'.
        - Performing logical any/all over blocks of boolean masks stored as an
          ndarray of dtype bool, using opname='any' or 'all' to produce a compact
          mask summary for downstream algorithms.
    """
    from pyscf.lib.numpy_helper import condense
    return condense(opname, a, loc_x, loc_y)


################################################################################
# Source: pyscf.lib.numpy_helper.entrywise_mul
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_entrywise_mul(
    a: numpy.ndarray,
    b: numpy.ndarray,
    out: numpy.ndarray = None
):
    """pyscf.lib.numpy_helper.entrywise_mul performs entrywise (element-wise) multiplication of two 2-D NumPy arrays (matrices). It is a low-level numerical helper used in the PySCF (Python-based Simulations of Chemistry Framework) codebase for elementwise combination of matrix-valued data such as density matrices, intermediate arrays in integral transformations, or other 2-D numerical tensors that arise in quantum-chemistry algorithms. The implementation enforces strict shape, dimensionality and dtype compatibility and dispatches to optimized C routines for double-precision real and double-precision complex data to accelerate performance-critical paths in PySCF.
    
    Args:
        a (numpy.ndarray): Left operand matrix. Must be a 2-D NumPy array (a.ndim == 2). In the PySCF context this typically represents a matrix such as a density or intermediate tensor. The function requires that a and b have identical shape and identical dtype; otherwise an AssertionError is raised. The dtype is significant because float64 (numpy.double) and complex128 (numpy.complex128) trigger optimized native C implementations.
        b (numpy.ndarray): Right operand matrix. Must be a 2-D NumPy array (b.ndim == 2) with the same shape and dtype as a. The elementwise product a * b is computed. As with a, b is expected to have a memory layout compatible with the internal leading_dimension_order check (see behavior below) so that optimized paths can be used.
        out (numpy.ndarray): Output matrix to store the result. If provided, it must be a NumPy ndarray whose canonical 2-D shape and leading-dimension information (as returned by leading_dimension_order) match those of a and b; otherwise an AssertionError is raised. If out is None (the default), a new array is allocated with numpy.empty_like(b) and returned. When provided, out is modified in-place and the same object is returned.
    
    Returns:
        numpy.ndarray: The array containing the entrywise product a * b. This is the out array (either the user-supplied out mutated in place, or a newly allocated array when out is None). The returned array has the same shape and (in the typical code paths) the same dtype as the inputs.
    
    Behavior, side effects and failure modes:
    - Dimensionality and shape checks: The function asserts that both a and b are 2-D and that a.shape == b.shape and a.dtype == b.dtype. Violating any of these checks raises AssertionError.
    - Memory-layout and leading-dimension requirement: The routine queries leading_dimension_order(a/b/out) to obtain leading-dimension and a canonical 2-D shape tuple (referred to in the code as a_cshape, b_cshape, out_cshape). It asserts that these canonical shapes are equal and not None. If any of these canonical shapes is None or they do not match, an AssertionError is raised. This ensures memory-layout compatibility required by the optimized native kernels.
    - Optimized dispatch: For arrays with dtype == numpy.double (float64) the code dispatches to the C helper _np_helper.NPomp_dmul; for dtype == numpy.complex128 it dispatches to _np_helper.NPomp_zmul. Those native functions are invoked via ctypes and expect the leading-dimension and raw data pointers returned by NumPy; they perform the elementwise multiply into out. For other dtypes the function falls back to numpy.multiply(a, b, out=out).
    - Side effects: If out is provided, it is overwritten with the result. If out is None, a new array is allocated and returned. The function always returns the array containing the result (the out object).
    - Undefined or unsafe usage: Providing an out array with an incompatible canonical shape or incompatible memory layout will trigger assertions. Providing an out array with a mismatched dtype relative to a and b is not checked explicitly in all code paths and can lead to incorrect results or undefined/native-kernel errors when the optimized C path is selected; therefore ensure out has the same dtype as a and b.
    - No broadcasting: The function requires identical shapes for a and b (no broadcasting is performed), aligning with its role as a strict elementwise matrix multiplier in PySCF numerical kernels.
    """
    from pyscf.lib.numpy_helper import entrywise_mul
    return entrywise_mul(a, b, out)


################################################################################
# Source: pyscf.lib.numpy_helper.ddot
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_ddot(
    a: numpy.ndarray,
    b: numpy.ndarray,
    alpha: float = 1,
    c: numpy.ndarray = None,
    beta: float = 0
):
    """Matrix-matrix multiplication for double-precision (float64) NumPy arrays used throughout PySCF for dense linear-algebra operations in quantum chemistry calculations.
    
    This function computes the BLAS-level DGEMM operation and is a thin wrapper around a low-level _dgemm implementation optimized for double precision. It implements the operation C_out = alpha * A @ B + beta * C_in (BLAS DGEMM semantics). The function handles common memory-layout cases for inputs (C-contiguous or Fortran-contiguous) by choosing an appropriate transpose flag and, when necessary, creating C-contiguous copies so that the underlying BLAS call receives data in an expected layout. If c is None, a new array of shape (m, n) is allocated and beta is forced to 0 (so the allocated contents are ignored). This function is intended for use in PySCF modules that require efficient double-precision matrix multiplications (for example, assembling density matrices, Fock matrices, or performing tensor contractions that have been reduced to matrix products).
    
    Args:
        a (numpy.ndarray): Left operand matrix A with shape (m, k). Must be a NumPy array of double precision (numpy.float64). The function reads A and may create a C-contiguous copy or use A.T when A is Fortran-contiguous; the original array object passed by the caller is not modified in-place by the function (local rebinding or copies may occur).
        b (numpy.ndarray): Right operand matrix B with shape (k, n). Must be a NumPy array of double precision (numpy.float64). Like A, B may be transposed locally or copied to C-contiguous memory for the BLAS call; the function requires that b.shape[0] == a.shape[1] and will assert if the inner dimensions do not match.
        alpha (float): Scalar multiplier for the matrix product A @ B. Default is 1. This floating-point scalar is applied as in the BLAS DGEMM formula C_out = alpha * A @ B + beta * C_in.
        c (numpy.ndarray): Optional input/output matrix C_in of shape (m, n) and dtype numpy.float64. If provided, its contents are scaled by beta and added to alpha * A @ B. If c is None, the function allocates a new uninitialized NumPy array of shape (m, n) (via numpy.empty) and forces beta to 0 so the uninitialized contents do not influence the result. If provided, c must have shape (m, n) or an AssertionError is raised.
        beta (float): Scalar multiplier for the input matrix C_in. Default is 0. If c is None, this argument is ignored because beta is set to 0 internally. If c is provided, its values are multiplied by beta and added to alpha * A @ B.
    
    Returns:
        numpy.ndarray: A NumPy array of shape (m, n) and dtype numpy.float64 containing the result of alpha * A @ B + beta * C_in. If c was provided, the returned array is the updated C (it may be the same object passed as c or a different array depending on internal handling). If c was None, a newly allocated array is returned.
    
    Raises and failure modes:
        AssertionError: If the inner dimensions do not match (a.shape[1] != b.shape[0]) or if c is provided but c.shape != (m, n).
        TypeError or AttributeError: If inputs are not numpy.ndarray objects (the code accesses .flags and .shape attributes); this function expects NumPy ndarray inputs.
        ValueError or system-level BLAS errors may propagate from the underlying _dgemm call in rare failure cases.
    
    Behavioral notes and side effects:
        - The function expects double-precision arrays (numpy.float64). Passing arrays of other dtypes may lead to unexpected behavior or implicit casts by numpy/asarray before the BLAS call.
        - For Fortran-contiguous inputs the function uses a transposition flag and binds a.T to the local variable to present data in a layout compatible with the BLAS wrapper. For other non-contiguous arrays the function copies them into a C-contiguous array using numpy.asarray(..., order='C'), which allocates new memory.
        - When c is None, a new array is allocated with numpy.empty((m, n)) and beta is overridden to 0; any beta value passed by the caller is ignored in that case.
        - The function is designed for performance in PySCF high-level routines and relies on an efficient low-level DGEMM backend exposed as _dgemm.
    """
    from pyscf.lib.numpy_helper import ddot
    return ddot(a, b, alpha, c, beta)


################################################################################
# Source: pyscf.lib.numpy_helper.inplace_transpose_scale
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_inplace_transpose_scale(a: numpy.ndarray, alpha: float = 1.0):
    """In-place parallel scaling and transposition of a square matrix used by PySCF linear-algebra routines to avoid extra memory allocations and accelerate matrix operations common in quantum chemistry computations. This function transposes the input square matrix a in-place and multiplies every element by the scalar factor alpha using a parallel C/OpenMP helper, preserving the original array object and shape while minimizing memory movement.
    
    Args:
        a (numpy.ndarray): Square matrix of shape (n, n) to be transposed and scaled in-place. The array does not need to be contiguous in memory; a "leading dimension" (lda) may exceed n and will be detected and passed to the underlying C helper. The function requires that a.shape[0] == a.shape[1] (square). Only arrays whose dtype is exactly numpy.double (float64) or numpy.complex128 are supported; other dtypes will cause a NotImplementedError. The function also relies on leading_dimension_order(a) to determine memory order and will assert that the detected order is either 'C' or 'F'.
        alpha (float): Real scalar multiplicative factor applied to every element during the transpose. Default is 1.0, which performs a pure in-place transpose with no scaling. For complex arrays (dtype numpy.complex128), this real alpha value is promoted to a complex128 scalar with zero imaginary part before calling the complex C helper.
    
    Returns:
        numpy.ndarray: The same numpy.ndarray object passed in as a, now containing the transposed and scaled values. The return is provided for convenience; the primary effect is the in-place mutation of the input array. The returned array has the same shape (n, n) and the same numpy dtype as the input.
    
    Behavior and side effects:
        This routine performs the transpose-and-scale operation in-place using C-level helpers (_np_helper.NPomp_d_itranspose_scale for numpy.double and _np_helper.NPomp_z_itranspose_scale for numpy.complex128) that use parallel OpenMP kernels for performance. Because the operation is performed in-place, no new array is allocated for the transposed result; callers relying on the original ordering or contents will observe those contents changed after the call. The function computes and passes a leading-dimension (lda) value determined by leading_dimension_order(a) to the C helper so non-contiguous layouts with padding are supported.
    
    Failure modes and errors:
        The function asserts that the input is square (a.shape[0] == a.shape[1]) and that the memory order detected by leading_dimension_order(a) is either 'C' or 'F'; violation of these assertions raises AssertionError. If a.dtype is not exactly numpy.double or numpy.complex128, the function raises NotImplementedError. Providing non-numeric arrays or arrays with incompatible memory descriptors may lead to failures in the underlying C helper.
    """
    from pyscf.lib.numpy_helper import inplace_transpose_scale
    return inplace_transpose_scale(a, alpha)


################################################################################
# Source: pyscf.lib.numpy_helper.hermi_triu
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_hermi_triu(
    mat: numpy.ndarray,
    hermi: int = 1,
    inplace: bool = True
):
    """pyscf.lib.numpy_helper.hermi_triu produces a Hermitian or anti-Hermitian square matrix by copying the elements from the lower triangular part of a square NumPy array into the upper triangular part, using optimized native helpers from the PySCF C extension. This function is used in PySCF linear-algebra workflows (quantum chemistry matrix construction and symmetrization) to ensure the full matrix satisfies Hermitian or anti-Hermitian symmetry expected by downstream algorithms (e.g., diagonalization, integral transformations).
    
    Args:
        mat (numpy.ndarray): A square NumPy array that will be symmetrized. The array must have shape (n, n) and dtype equal to numpy.double (float64) or numpy.complex128. The routine requires that mat be either C-contiguous (mat.flags.c_contiguous) or Fortran-contiguous (mat.flags.f_contiguous); if Fortran-contiguous the function operates on a C-contiguous transposed view internally. The array is modified in place when inplace is True (default); when inplace is False a copy of the input is made and the copy is modified and returned. The function asserts mat.size == n**2 which enforces squareness and will raise AssertionError if this condition is not met.
        hermi (int): Flag selecting the type of symmetry to enforce. This integer must equal the module constants HERMITIAN (value 1) or ANTIHERMI (value 2). When hermi == HERMITIAN the returned matrix satisfies a_ij = conj(a_ji) for complex matrices (or a_ij = a_ji for real matrices), i.e., the matrix is Hermitian (symmetric for real dtype). When hermi == ANTIHERMI the returned matrix satisfies a_ij = -conj(a_ji) for complex matrices (or a_ij = -a_ji for real matrices), i.e., the matrix is anti-Hermitian (skew-symmetric for real dtype). The default (1) produces a Hermitian/symmetric matrix. If hermi is not one of the supported constants the function asserts and raises AssertionError.
        inplace (bool): If True (default) the operation modifies the provided mat array (or the same underlying data if a transposed view is used for Fortran-contiguous inputs). If False the function first makes a copy of mat (mat.copy('A')) and then performs the symmetrization on that copy; the original input is left unchanged. In both cases the returned array has the same shape and dtype as the input.
    
    Returns:
        numpy.ndarray: The symmetrized square array. If inplace was True this is the same ndarray object passed in (or a view into its data for Fortran-contiguous inputs); if inplace was False this is a newly allocated ndarray copy containing the symmetrized result. The dtype is unchanged (numpy.double or numpy.complex128) and the shape is unchanged.
    
    Behavior, side effects, and failure modes:
        - The routine delegates the low-level element copying to PySCF C helpers (NPdsymm_triu for numpy.double and NPzhermi_triu for numpy.complex128) via ctypes for performance. These helpers expect a C-contiguous memory layout; to satisfy that requirement the function uses the original array when C-contiguous or a transposed view when Fortran-contiguous.
        - Only numpy.double and numpy.complex128 are implemented. If mat.dtype is neither of these types the function raises NotImplementedError.
        - If mat is neither C-contiguous nor Fortran-contiguous the function raises NotImplementedError because the implementation cannot obtain a suitable contiguous buffer to pass to the C helper.
        - The function requires a square array; if mat.size != n**2 (where n = mat.shape[0]) an AssertionError is raised.
        - The function asserts that hermi equals the module constants HERMITIAN or ANTIHERMI; otherwise an AssertionError is raised.
        - Because the implementation may operate on a transposed view for Fortran-contiguous inputs, callers should be aware that the identity of the returned object may be the original array or a view that shares the same underlying data; when inplace=True modifications are reflected in the original array memory.
        - No additional type promotion, casting, or shape changes are performed; callers must supply arrays with supported dtypes and correct shape.
    """
    from pyscf.lib.numpy_helper import hermi_triu
    return hermi_triu(mat, hermi, inplace)


################################################################################
# Source: pyscf.lib.numpy_helper.inv_base_repr_int
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_inv_base_repr_int(x: numpy.ndarray, base: int):
    """pyscf.lib.numpy_helper.inv_base_repr_int: Convert a sequence of base-digits into the integer(s) they represent (inverse of base_repr_int). This function is used in PySCF (the Python-based Simulations of Chemistry Framework) to map a positional-digit representation (for example, combinatorial indices, encoded occupation patterns, or multi-digit identifiers produced by lib.base_repr_int) back to standard integer indices; it accepts a numpy array of digits and a radix and returns the corresponding integer value(s).
    
    This function interprets elements of x as integer digits in the given base and computes the positional value by summing digit * base**position. For multi-dimensional inputs the last axis is treated as the digit axis (most-significant digit first along the last axis), and the function returns an array of integers shaped as the input shape with the last axis removed. For one-dimensional sequences it returns a scalar integer. The input is coerced to integer dtype using numpy.asarray(x, dtype=int) and the computation uses Python/numpy integer arithmetic; the function does not modify the caller's original object.
    
    Args:
        x (numpy.ndarray): Array of integer digits representing numbers in the specified radix. For a 1-D array, x is interpreted as a single sequence of digits ordered most-significant-digit first (for example, [d_n-1, ..., d_1, d_0] corresponds to sum d_i * base**(n-1-i)). For an N-D array, the last axis is the digit axis (length n) and each entry along the leading axes is converted to an integer; the function coerces x to dtype int via numpy.asarray(x, dtype=int). Note that 0-D (scalar) numpy inputs are not supported by the digit-slicing logic and will typically raise an exception; pass a 1-D sequence for single numbers or an N-D array with last axis as digits for batch conversion.
        base (int): Radix (base) used for the positional representation. This integer is used as the exponent base for positional weights (base**k). The function expects an integer-valued base (as per the signature); non-integer types for base are not supported by the implementation and will raise a TypeError or produce incorrect results if coerced implicitly.
    
    Returns:
        int or numpy.ndarray: The integer value(s) corresponding to the digit representation. If x is a 1-D sequence, a Python integer (or numpy scalar integer) is returned. If x is N-D with last axis of length n, a numpy.ndarray of integers with shape equal to x.shape[:-1] is returned, where each element is the integer computed from the digits along the removed last axis.
    
    Behavior and failure modes:
        - The function coerces x to integer dtype with numpy.asarray(x, dtype=int). Non-integer inputs will be truncated/converted according to numpy rules; if conversion cannot proceed, numpy will raise a TypeError or ValueError.
        - The last axis of x is treated as the digit axis; digits are assumed to be ordered most-significant-first. Supplying sequences with a different ordering will produce incorrect numeric results.
        - Zero-dimensional (scalar) numpy inputs are not handled by the slicing logic and will typically raise an exception; supply a 1-D sequence for a single number.
        - Very large bases or long digit sequences can produce very large integers; Python's arbitrary-precision integers avoid overflow in pure Python, but memory and performance may be impacted.
        - There are no in-place side effects on the caller's input; the function creates a new array via numpy.asarray and returns new integer objects/arrays.
        - The implementation uses explicit loops over digit positions; for extremely large arrays or high-performance needs, consider vectorized or specialized implementations.
    
    Relation to PySCF:
        This helper is intended as a low-level utility within pyscf.lib.numpy_helper and complements base_repr_int by performing the reverse mapping from a base-specific digit array back to an integer index, useful in PySCF workflows that encode combinatorial data or multi-digit identifiers for electronic structure bookkeeping.
    """
    from pyscf.lib.numpy_helper import inv_base_repr_int
    return inv_base_repr_int(x, base)


################################################################################
# Source: pyscf.lib.numpy_helper.hermi_sum
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_hermi_sum(
    a: numpy.ndarray,
    axes: tuple = None,
    hermi: int = 1,
    inplace: bool = False,
    out: numpy.ndarray = None
):
    """pyscf.lib.numpy_helper.hermi_sum computes the elementwise Hermitian sum a + a.T.conj() with improved memory efficiency compared to making an explicit transpose copy. In the PySCF quantum-chemistry workflow this is used when forming Hermitian matrices from general (possibly non-Hermitian) blocks or slices (for example when constructing symmetric contributions to Fock or density matrices, or accumulating blockwise results from tensor contractions). The function supports a 2-D square matrix or a stack of square matrices stored as a 3-D array with axes layout (0,2,1) and attempts to use a C-accelerated path for C-contiguous arrays of dtype numpy.double or numpy.complex128; otherwise a Python fallback performs the blockwise computation. The result is written into and returned via the out buffer (which may be the input array if inplace=True), avoiding an additional full-array transpose copy.
    
    Args:
        a (numpy.ndarray): Input array representing a single matrix (2-D, shape (N, N)) or a batch of matrices (3-D, shape (M, N, N)) when axes is (0,2,1). In PySCF this typically holds numeric linear-algebra objects such as Fock/density matrix blocks or intermediate arrays from integral transforms. The array must have the layout and shape described above: for 2-D the two dimensions must be equal; for 3-D the middle and last dimensions must be equal and axes must be (0,2,1). The function treats entries as complex when dtype is numpy.complex128; diagonal elements of the returned sum therefore have their imaginary parts canceled (they become twice the real part).
        axes (tuple): Layout descriptor for 3-D inputs. Must be None for the 2-D case. For a batch of matrices provided as a 3-D array, set axes to (0,2,1) to indicate that the first axis indexes separate square matrices and the remaining two axes are the matrix rows and columns. The C-accelerated path only accepts axes == (0,2,1) for 3-D inputs; the Python fallback also requires this axes value for 3-D processing. If axes is None, only 2-D input is supported.
        hermi (int): Integer flag forwarded to the low-level C helper (passed as ctypes.c_int). This parameter is used by the internal optimized routine to indicate which triangular convention or Hermitian-handling mode the C backend should apply. The default value 1 corresponds to the library constant used in the PySCF helper to request the standard Hermitian-sum behavior. The function does not validate numeric values beyond forwarding the integer to the C helper.
        inplace (bool): If True, the operation is performed in-place on the provided numpy.ndarray a and the input array is overwritten with the result. When inplace is True, a must be an instance of numpy.ndarray (an AssertionError is raised otherwise) and the out parameter is ignored. In-place use is convenient to reduce peak memory when the caller no longer needs the original array contents.
        out (numpy.ndarray): Optional preallocated numpy.ndarray serving as the buffer to receive the result. If inplace is False and out is provided, it is used as the backing buffer for the result allocation (via numpy.ndarray(..., buffer=out)), and must be compatible with the required shape and dtype; otherwise numpy will raise an error. If inplace is True, out is ignored because the input array a is used as the destination.
    
    Returns:
        numpy.ndarray: The array containing the Hermitian sum a + a.T.conj(). The returned array has the same shape and dtype as the input a and stores the blockwise results: for 2-D input the full matrix a + a.T.conj() is returned; for 3-D input with axes == (0,2,1) the operation is applied independently to each slice a[i] and the returned array has the same leading axis length. If inplace=True the returned object is the same array object as the input a (modified in-place); otherwise a new numpy.ndarray (or the provided out buffer) is returned.
    
    Behavior, side effects, and failure modes:
        - Memory and performance: For C-contiguous arrays with dtype numpy.double or numpy.complex128 and supported dimensionality, an internal C-accelerated routine is used to minimize temporary allocations and improve performance. For other dtypes or non-C-contiguous arrays, a Python blockwise implementation is used which still avoids creating a full transpose copy but is less performant.
        - Supported shapes: 2-D inputs must be square (N x N). 3-D inputs are supported only when axes == (0,2,1) and the per-slice matrices are square (M x N x N with middle and last dims equal). Other shapes or axes layouts raise NotImplementedError.
        - Assertions and errors: If inplace is True and a is not a numpy.ndarray, an AssertionError is raised. If the input layout or dtype prevents both the optimized and fallback code paths from handling the array (e.g., unsupported ndim or axes), a NotImplementedError is raised. If a custom out buffer is provided but is incompatible with the required allocation (size, alignment, or dtype), numpy will raise an error during buffer-based allocation.
        - Numerical note: For complex inputs, the diagonal of the returned matrix equals a_ii + conj(a_ii) = 2*Re(a_ii); imaginary parts on the diagonal cancel as a direct consequence of forming a + a.T.conj().
    """
    from pyscf.lib.numpy_helper import hermi_sum
    return hermi_sum(a, axes, hermi, inplace, out)


################################################################################
# Source: pyscf.lib.numpy_helper.isin_1d
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_isin_1d(
    v: numpy.ndarray,
    vs: numpy.ndarray,
    return_index: bool = False
):
    """Check whether a 1-D target vector v appears exactly as a row in a collection of vectors vs.
    This utility is used in the PySCF codebase to test membership of a specific flattened vector
    (e.g., a molecular orbital coefficient vector, a determinant bitstring represented as an
    integer vector, or any fixed-length parameter vector used in electronic-structure workflows)
    within a list/array of candidate vectors. The function performs an elementwise exact
    comparison (using absolute difference and integer/float equality) after flattening v and
    reshaping vs to have rows of the same length; it does not perform approximate or
    tolerance-based comparisons.
    
    Args:
        v (numpy.ndarray): The target vector to search for. The function flattens v with
            numpy.asarray(v).flatten() so any shape is accepted as long as the total number
            of elements equals the last dimension of vs after reshaping. In practice v
            represents a single configuration vector used in PySCF algorithms (for example,
            a coefficient vector). Flattening means that multi-dimensional input will be
            viewed as a one-dimensional sequence of elements in row-major order.
        vs (numpy.ndarray): A collection of vectors to search within. The implementation
            uses numpy.asarray(vs).reshape(-1, n) where n = len(v). Therefore the last
            dimension of vs must equal the length of the flattened v; otherwise numpy.reshape
            will raise a ValueError. vs is interpreted as a 2-D array with each row being a
            candidate vector; rows are compared to the flattened v by summing absolute
            differences across elements and checking for exact zero.
        return_index (bool): If False (the default), the function returns only a boolean
            indicating whether v is present in vs. If True, the function returns a tuple
            (present, idx) where present is the boolean membership result and idx provides
            the location(s) of matching rows in vs. The index behavior mirrors numpy.where:
            when there is exactly one matching row idx is returned as a Python int; when there
            are multiple matches idx is returned as a numpy.ndarray of integers; when there
            are no matches idx is returned as an empty numpy.ndarray. Default value is False.
    
    Returns:
        bool: If return_index is False, returns a single boolean value. True indicates that
        the flattened vector v exactly matches at least one row of vs after reshaping; False
        indicates no exact match.
        tuple: If return_index is True, returns a tuple (present, idx). present is the same
        boolean described above. idx is either a Python int (when exactly one match is found),
        a numpy.ndarray of integers (when multiple matches are found), or an empty numpy.ndarray
        (when no matches are found). The integer indices refer to the row positions of vs
        after numpy.asarray(vs).reshape(-1, len(v)) was applied.
    
    Behavior, side effects, defaults, and failure modes:
        The function performs an exact elementwise comparison by computing diff = sum(abs(v - vs_row))
        for each row and testing diff == 0. This means that floating-point rounding differences
        can cause false negatives; callers that require tolerance-based matching should apply a
        preprocessing step (for example, rounding or using numpy.isclose) before calling this
        function. There are no in-place side effects: inputs are converted via numpy.asarray and
        intermediate arrays are allocated; large arrays will therefore incur memory allocation costs.
        If vs cannot be reshaped to (-1, len(v)) a ValueError (raised by numpy.reshape) will occur.
        The default return_index is False to provide a simple membership test; setting it to True
        returns positional information at the cost of creating the index array.
    """
    from pyscf.lib.numpy_helper import isin_1d
    return isin_1d(v, vs, return_index)


################################################################################
# Source: pyscf.lib.numpy_helper.leading_dimension_order
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_leading_dimension_order(a: numpy.ndarray):
    """pyscf.lib.numpy_helper.leading_dimension_order determines the leading dimension (stride) and memory order of a 2D NumPy array and reports a C-compatible shape when possible. This helper is used throughout PySCF linear-algebra and integral routines to decide how to pass matrices to BLAS/LAPACK and other low-level kernels that are sensitive to row-major (C) or column-major (Fortran) memory layout.
    
    Args:
        a (numpy.ndarray): A 2-dimensional NumPy array representing a matrix in PySCF computations (for example, density matrices, orbital coefficient matrices, or integral slices). The function requires a.ndim == 2 and uses a.strides and a.itemsize to compute element strides. The array is not modified; the function only inspects its metadata.
    
    Returns:
        lda (int): Leading dimension of the array expressed in element units (not bytes). Computed as the maximum of the per-axis strides in elements (each stride is taken as s // a.itemsize). In PySCF this value is used as the leading-dimension parameter for routines that expect the number of elements to skip between consecutive rows or columns when interfacing with BLAS/LAPACK or custom C/Fortran kernels.
        order (str): A one-character code describing the dominant memory order: 'F' for column-major (Fortran-contiguous along columns), 'C' for row-major (C-contiguous along rows), and 'G' for neither (general/strided, neither strictly C- nor F-contiguous). This informs callers whether they can pass the array directly to code expecting a specific layout or must make a copy/transpose.
        a_cshape (tuple or None): A tuple giving a C-contiguous-compatible shape for the matrix when possible: if the array is row-major, this is a.shape; if the array is column-major, this is a.T.shape (the transposed shape, which corresponds to a C-contiguous view of the same data layout). If the array has neither pure C nor pure F layout ('G'), a_cshape is None. Callers use this to obtain a shape consistent with C-order conventions without forcing a copy when the memory layout already matches.
    
    Behavior and side effects:
        The function inspects only shape, strides, and itemsize; it does not allocate new arrays or modify the input. Leading-dimension is returned in units of array elements rather than bytes to match numerical-library conventions in PySCF. When order is 'F' or 'C', a_cshape provides a convenient C-order-compatible shape; when order is 'G' no such shape is returned and callers typically need to copy or reorder data before passing it to routines that require strict layout.
    
    Failure modes and notes:
        The function asserts that a.ndim == 2 and will raise an AssertionError if given an array with dimensionality other than 2. It assumes strides are meaningful in units of a.itemsize (NumPy normally guarantees strides are integer multiples of itemsize). For arrays with nonstandard or exotic buffer interfaces where strides are not interpretable in this way, results may be unexpected.
    """
    from pyscf.lib.numpy_helper import leading_dimension_order
    return leading_dimension_order(a)


################################################################################
# Source: pyscf.lib.numpy_helper.locs_to_indices
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_locs_to_indices(
    locs: numpy.ndarray,
    segement_list: numpy.ndarray
):
    """pyscf.lib.numpy_helper.locs_to_indices converts a list/array of segment boundary positions ("locs") and a specification of desired segment IDs ("segement_list") into a flat numpy.int32 array of contiguous integer indices that correspond to the union of those segments. This helper is used throughout the PySCF (Python-based Simulations of Chemistry Framework) codebase to translate segment/block specifications (for example, contiguous groups of atomic orbital or molecular orbital indices, integral blocks, or other contiguous index ranges) into a concrete 1-D index array suitable for array slicing, indexing, and assembly of block-wise data.
    
    Args:
        locs (numpy.ndarray): 1-D array of integer boundary positions that defines segments. By convention locs[i] and locs[i+1] give the start (inclusive) and end (exclusive) positions for the i-th segment. Practically in PySCF, locs is used to describe cumulative boundaries of contiguous blocks such as basis-function ranges per atom or block offsets for matrix/tensor partitions. The array must be indexable by integer positions and provide at least two elements for any referenced segment (i.e., for any segment id s referenced in segement_list, locs must contain entries at indices s and s+1).
        segement_list (numpy.ndarray): 1-D numpy array that specifies which segments to extract. The array may have integer dtype (segment ids) or boolean dtype (a mask). If boolean, it is converted with numpy.where to the integer indices of True entries. The entries in segement_list are interpreted in the given order; when multiple segment ids are present the function groups consecutive (adjacent) ids into runs and returns the combined contiguous index ranges for each run.
    
    Returns:
        numpy.ndarray: 1-D array of dtype numpy.int32 containing the concatenated integer indices selected from locs. For each requested segment id s the returned indices include the integers in the half-open range [locs[s], locs[s+1]). If segement_list is empty, an empty numpy.int32 array is returned. If segement_list contains a single id, the return is numpy.arange(locs[s], locs[s+1]) cast to numpy.int32. When multiple ids are provided, runs of consecutive ids are merged so that indices from the first start to the last end of each run are returned, and the final result is the horizontal concatenation (in the order implied by segement_list) of all such ranges.
    
    Behavior, defaults, and failure modes:
        - The function makes no in-place modifications to its inputs; it is side-effect free.
        - segement_list is converted internally with numpy.asarray. If segement_list.dtype is bool, it is replaced with numpy.where(segement_list)[0].
        - If segement_list.size == 0 the function returns an empty numpy.int32 array.
        - If segement_list.size == 1 the function returns the single contiguous range defined by locs[segement_list[0]:segement_list[0]+2].
        - If segement_list contains multiple ids, the function asserts that the largest referenced id is within the bounds of locs; specifically, the implementation requires that locs provide entries for all referenced segment ids and their following boundary. If this condition is violated the function will raise an AssertionError (or may raise an IndexError if locs is not long enough to supply the required boundary element).
        - The function assumes locs entries are integer-like positions in index space; it does not validate monotonicity of locs beyond relying on indexing semantics, so incorrect or non-monotonic locs may produce unexpected results.
        - Duplicate segment ids in segement_list will be processed in the given order; consecutive duplicate ids will be treated as a contiguous run and produce the same indices as a single occurrence of that id.
        - The returned array dtype is numpy.int32 to provide consistent, compact integer indices for downstream PySCF routines that expect 32-bit integer indexing.
    """
    from pyscf.lib.numpy_helper import locs_to_indices
    return locs_to_indices(locs, segement_list)


################################################################################
# Source: pyscf.lib.numpy_helper.ndarray_pointer_2d
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_ndarray_pointer_2d(array: numpy.ndarray):
    """pyscf.lib.numpy_helper.ndarray_pointer_2d returns a 1-D numpy.ndarray of pointer-sized unsigned integers that contain the memory addresses (byte offsets from address zero) of the first element in each row of the supplied 2-D, C-contiguous numpy.ndarray. This helper is intended for low-level interfacing in the PySCF computational-chemistry codebase where C/Fortran routines or ctypes-based APIs require an array of per-row pointers to contiguous row data.
    
    Args:
        array (numpy.ndarray): A 2-D numpy array representing a row-major (C-contiguous) block of numeric data used in PySCF low-level operations (for example, matrix data passed to C extensions). The function requires array.ndim == 2 and array.flags.c_contiguous to hold; these conditions ensure that rows are laid out sequentially in memory and that a simple stride-based offset calculation yields correct row addresses. The array content is not modified.
    
    Returns:
        numpy.ndarray: A 1-D numpy.ndarray of dtype numpy.uintp and shape (array.shape[0],). Each element is the unsigned integer memory address (pointer-sized, in bytes) of the first element of the corresponding row of the input array. The returned addresses are computed as array.ctypes.data + (i * array.strides[0]) where i indexes rows; array.strides[0] is used as the per-row byte offset.
    
    Behavior and side effects:
        The function performs no in-place modification of the input array; it computes and returns a new numpy.ndarray of addresses. It relies on the input being C-contiguous so that rows are sequential in memory; the per-row address computation uses array.strides[0] (the byte step between consecutive rows) and the base data pointer array.ctypes.data. The returned array is suitable for passing directly to C-level APIs that accept arrays of row pointers (for example, with ctypes or custom C extensions used in PySCF).
    
    Failure modes and exceptions:
        If the input array is not 2-D, an AssertionError is raised due to the internal assert array.ndim == 2. If the input array is not C-contiguous (row-major), an AssertionError is raised due to the internal assert array.flags.c_contiguous. The returned addresses are represented with dtype numpy.uintp (pointer-sized unsigned integers); on platforms where pointer size is smaller than needed to represent a particular address, overflow would follow numpy.uintp semantics, but numpy.uintp is chosen to match the platform pointer width used by ctypes.
    """
    from pyscf.lib.numpy_helper import ndarray_pointer_2d
    return ndarray_pointer_2d(array)


################################################################################
# Source: pyscf.lib.numpy_helper.pack_tril
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_pack_tril(
    mat: numpy.ndarray,
    axis: int = -1,
    out: numpy.ndarray = None
):
    """pyscf.lib.numpy_helper.pack_tril flattens the lower-triangular elements of one or a batch of square matrices into a contiguous packed representation used in PySCF for compact storage and faster linear-algebra operations common in quantum chemistry (for example, compressing symmetric matrices such as density matrices or two-electron integral slices).
    
    Args:
        mat (numpy.ndarray): Input array containing square matrices whose lower-triangular parts will be packed. For a 2-D array, mat is interpreted as a single square matrix with shape (nd, nd) and the result is a 1-D array of length nd*(nd+1)//2. For an N-D array with N >= 3 and axis == -1 (the default), mat is interpreted as a batch of matrices stored in the leading two axes: mat.shape[:2] == (count, nd) and the expected full matrix shape is (count, nd, nd); the result is a 2-D array with shape (count, nd*(nd+1)//2). The function treats mat.size == 0 specially and returns an empty-packed result with shape mat.shape + (0,) and the same dtype. The function assumes the matrices being packed are square along the two axes being packed (i.e., the two dimensions indexed by tril indices). Supplying non-square matrices may produce incorrect results or runtime errors because the implementation indexes using numpy.tril_indices(nd).
        axis (int): Axis selection flag controlling which two axes are interpreted as the matrix dimensions to pack. Default -1 selects packing of the last two dimensions (the common case for batches where matrices are in the trailing axes). The only other accepted value in the implementation is 0, which instructs the function to pack the leading two dimensions of mat; any other value will trigger the assertion in the code and raise an AssertionError. Use axis=-1 to pack along the final two axes of mat, or axis=0 to pack the first two axes.
        out (numpy.ndarray): Optional output buffer. When provided, out is used as the underlying buffer for the returned numpy.ndarray via numpy.ndarray(shape, mat.dtype, buffer=out). The buffer must be compatible with the computed output shape and mat.dtype; if out is None (the default) a new array is allocated and returned. If the provided buffer is incompatible in size, dtype, or memory layout, a ValueError or TypeError may be raised by numpy when constructing the output array.
    
    Returns:
        numpy.ndarray: A numpy array containing the packed lower-triangular elements.
        For a 2-D input mat of shape (nd, nd), the return is a 1-D array of length nd*(nd+1)//2 containing mat[numpy.tril_indices(nd)] in row-major order. For an N-D input with axis == -1, the return has shape (count, nd*(nd+1)//2) where count and nd are taken from mat.shape[:2]; rows correspond to the packed lower triangle of each matrix in the batch. For axis == 0, the implementation returns mat[numpy.tril_indices(nd)], which selects the lower-triangular indices from the leading two axes and therefore produces an array whose first dimension equals nd*(nd+1)//2 and whose remaining dimensions follow mat.shape[2:].
        The return array has the same dtype as mat. For inputs with dtype numpy.double or numpy.complex128, optimized C helper routines (_np_helper.NPdpack_tril_2d and _np_helper.NPzpack_tril_2d) are used to write into the output buffer for performance. For other dtypes, a pure-Numpy fallback using numpy.tril_indices is used.
    
    Behavior and failure modes:
        - Empty input: If mat.size == 0 the function returns numpy.zeros(mat.shape + (0,), dtype=mat.dtype).
        - Square-matrix expectation: The function is intended for square matrices. The code computes nd from one of the matrix dimensions and uses numpy.tril_indices(nd); supplying non-square matrices may lead to incorrect indexing or runtime errors.
        - axis support: Only axis values -1 and 0 are supported by the implementation; other values will raise an AssertionError.
        - dtype handling: For numpy.double and numpy.complex128, the function calls optimized C helpers to pack data into the output buffer. For other dtypes, the function falls back to numpy indexing. The caller should ensure mat.dtype matches the expected numeric types for best performance.
        - Out buffer: If out is provided it must be buffer-compatible and appropriately sized for the computed output shape; otherwise numpy.ndarray(...) with buffer=out will raise an error. When using out, the function writes into that buffer (side effect).
        - Exceptions: Possible exceptions include AssertionError for unsupported axis values, ValueError or TypeError when the provided out buffer is incompatible, and IndexError or unexpected behavior if mat does not conform to the assumed square-matrix shape.
    
    Practical significance in PySCF:
        This function is used in the PySCF (Python-based Simulations of Chemistry Framework) codebase to compress and manipulate symmetric matrices (for instance, slices of two-electron integrals or density matrices) so algorithms can operate on packed representations that reduce memory usage and improve data locality. The implementation chooses specialized C helpers for float64 and complex128 to maximize performance for common quantum-chemistry numeric types, and falls back to a numpy-based method for other dtypes.
    """
    from pyscf.lib.numpy_helper import pack_tril
    return pack_tril(mat, axis, out)


################################################################################
# Source: pyscf.lib.numpy_helper.takebak_2d
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_takebak_2d(
    out: numpy.ndarray,
    a: numpy.ndarray,
    idx: numpy.ndarray,
    idy: numpy.ndarray,
    thread_safe: bool = True
):
    """Reverse of take_2d: accumulate a small 2D block into a larger 2D array in-place.
    
    Performs the equivalent operation out[idx[:, None], idy] += a for a 2D block a, modifying out in-place and returning out. In the PySCF codebase this routine is used when assembling contributions computed on index subsets (for example, adding sub-blocks of integrals or density-matrix contributions back into a global 2D array). The function prefers C-optimized code paths for double and complex128 dtypes and falls back to NumPy advanced-index accumulation for other dtypes when thread_safe is True.
    
    Args:
        out (numpy.ndarray): Destination 2D array to be modified in-place. Must be C-contiguous (out.flags.c_contiguous is required). out holds the global quantity (for example, a global matrix of integrals or a density-like object) into which the block a will be accumulated. The function will assert that out is C-contiguous and will raise an AssertionError if this is not satisfied. Indices in idx and idy must be valid for the dimensions of out; otherwise an IndexError may be raised.
        a (numpy.ndarray): 2D source array whose values will be added into out at the positions specified by idx and idy. Practically, a represents a sub-block computed for the rows indexed by idx and columns indexed by idy (as in many PySCF routines that compute blocks of matrices). a is converted to a C-ordered numpy array internally (order='C'); if a.dtype differs from out.dtype it will be cast to out.dtype before accumulation.
        idx (numpy.ndarray): 1D integer index array (dtype numpy.ndarray) containing row indices into out. The length of idx determines the number of rows of the block to be added. Internally idx is converted to dtype numpy.int32 before calling the C helper. Values must be valid row indices for out; out-of-range values will produce an IndexError.
        idy (numpy.ndarray): 1D integer index array (dtype numpy.ndarray) containing column indices into out. The length of idy determines the number of columns of the block to be added. Internally idy is converted to dtype numpy.int32 before calling the C helper. Values must be valid column indices for out; out-of-range values will produce an IndexError.
        thread_safe (bool): Controls the accumulation implementation. Default True. When out.dtype is numpy.double or numpy.complex128, the function dispatches to a C-optimized helper (NPdtakebak_2d or NPztakebak_2d) and passes thread_safe as a flag to that helper. For other dtypes, if thread_safe is True the routine falls back to the NumPy advanced-index accumulation out[idx[:, None], idy] += a; if thread_safe is False and a C helper for the dtype is not available, NotImplementedError is raised. Use thread_safe=True when calling from multithreaded contexts where the fallback NumPy accumulation is acceptable; set thread_safe=False only when a C helper exists for the dtype and the caller specifically requires the non-thread-safe C path.
    
    Returns:
        numpy.ndarray: The same array object passed in as out, after in-place accumulation of a at rows idx and columns idy. The returned array is provided for convenience; the primary effect is the in-place modification of out. Failure modes include AssertionError if out is not C-contiguous, IndexError if idx or idy contain out-of-range indices, ValueError or broadcasting errors if the shape of a does not match (len(idx), len(idy)), and NotImplementedError when a dtype does not have a C helper and thread_safe is False.
    """
    from pyscf.lib.numpy_helper import takebak_2d
    return takebak_2d(out, a, idx, idy, thread_safe)


################################################################################
# Source: pyscf.lib.numpy_helper.tag_array
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_tag_array(a: numpy.ndarray, **kwargs):
    """pyscf.lib.numpy_helper.tag_array attaches arbitrary Python attributes to a NumPy array by returning a NPArrayWithTag view that holds the array data together with a dictionary of attributes. In the PySCF (Python-based Simulations of Chemistry Framework) codebase this function is used to carry metadata alongside numeric arrays (for example, attaching basis, symmetry, molecule, or other calculation metadata to intermediate arrays) so downstream code can access both numerical data and contextual information without separate containers.
    
    The function converts the provided input to a NumPy ndarray via numpy.asarray and then creates a NPArrayWithTag view of that ndarray. If the input is already an instance of NPArrayWithTag, its existing attributes are preserved and then updated with the provided keyword attributes. Attribute names and values are stored in the returned object's __dict__ and are intended to be used as metadata attached to the array in computational chemistry workflows handled by PySCF.
    
    Args:
        a (numpy.ndarray): Input array whose data will be carried by the returned NPArrayWithTag. The function calls numpy.asarray(a) to obtain an ndarray representation of the input; if the original input is not an ndarray it will be converted to one. If a is already an NPArrayWithTag, its attributes are copied into the returned object before applying new attributes. The numeric data of the returned object may share memory with the array produced by numpy.asarray(a), so modifications to the array data of the returned object can affect shared underlying memory if conversion did not create a copy.
        kwargs (dict): Keyword attribute name=value pairs to attach to the returned NPArrayWithTag. Each keyword name is used as the attribute name and the corresponding value is stored in the object's __dict__. Values may be arbitrary Python objects and are intended to carry metadata used by PySCF routines. If a given attribute name already exists on the copied attributes (when a is NPArrayWithTag), the value from kwargs overwrites the existing attribute.
    
    Returns:
        NPArrayWithTag: A NumPy ndarray subclass (NPArrayWithTag) that wraps the array data from numpy.asarray(a) and contains the attributes supplied via kwargs in its __dict__. If a was an NPArrayWithTag, its original attributes are first copied into the new object and then updated with kwargs, so kwargs take precedence. The function does not modify the __dict__ of the original input object; it returns a new view object carrying the merged attributes. Possible failure modes include providing attribute names that conflict with internal names used elsewhere in client code (which may lead to surprising attribute shadowing) and passing inputs that cannot be converted to an ndarray by numpy.asarray (which will raise the usual numpy conversion errors).
    """
    from pyscf.lib.numpy_helper import tag_array
    return tag_array(a, **kwargs)


################################################################################
# Source: pyscf.lib.numpy_helper.solve_lineq_by_SVD
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_solve_lineq_by_SVD(a: numpy.ndarray, b: numpy.ndarray):
    """Solves the linear system a * x = b using a truncated singular value decomposition (SVD).
    This function is used in PySCF (a Python-based simulations of chemistry framework) to obtain
    stable solutions for linear systems that arise in quantum-chemistry computations when the
    coefficient matrix a may be singular or nearly singular. The implementation computes the
    SVD of a, discards singular values smaller than the module-level constant LINEAR_DEP_THRESHOLD,
    and forms a solution x from the retained singular vectors and singular values. This produces
    a regularized least-squares solution (minimizing ||a x - b||_2 over the retained subspace)
    and avoids numerical instability caused by tiny singular values.
    
    Args:
        a (numpy.ndarray): The coefficient matrix in the linear system a * x = b. Expected to be
            a two-dimensional NumPy array with shape (M, N), where M is the number of rows
            (equations) and N is the number of unknowns. The function calls numpy.linalg.svd(a)
            and therefore accepts real or complex dtypes; complex values are handled using conjugate
            transposes where needed. In the PySCF domain, a typically represents matrices such as
            overlap or projection operators arising in electronic-structure routines, and ensuring
            numerical stability when inverting or solving with these matrices is important for
            correct physical results.
        b (numpy.ndarray): The right-hand side array in the linear system. It must have a first
            dimension equal to M (the number of rows of a): shape (M,) for a single right-hand side
            or shape (M, K) for K right-hand sides solved simultaneously. The dtype should be
            compatible with a (real or complex). In PySCF usage b often represents a vector or set
            of vectors of coefficients (for example, projections or residuals) that need to be
            mapped to solution coefficients x.
    
    Returns:
        numpy.ndarray: The solution array x such that a * x ≈ b within the subspace defined by
        retained singular values. If a has shape (M, N) and b has shape (M,) then x has shape (N,).
        If b has shape (M, K) then x has shape (N, K). The dtype of x follows the input arrays
        (real or complex) and the numerical values are computed from the retained SVD components
        as x = V[:, idx] @ ((U[:, idx].conj().T @ b) / s[idx]) where (U, s, Vh) = svd(a) and idx
        are indices of singular values s strictly greater than LINEAR_DEP_THRESHOLD.
    
        If no singular values exceed LINEAR_DEP_THRESHOLD (i.e., the matrix is considered fully
        linearly dependent under the chosen threshold), the function returns numpy.zeros_like(b).
        Note that in this fallback case the returned array has the same shape as b (not (N,) or
        (N, K)), which follows the exact behavior of the implementation and may not match the
        expected solution dimension; callers should handle this case explicitly if needed.
    
    Behavior and failure modes:
        - The function uses numpy.linalg.svd(a) to compute the full SVD. This can raise
          numpy.linalg.LinAlgError (or propagate other exceptions) if SVD computation fails for
          pathological inputs or memory constraints; callers should be prepared to catch such
          exceptions in long-running PySCF jobs.
        - Numerical regularization is controlled solely by the module-level constant
          LINEAR_DEP_THRESHOLD. The function does not accept a threshold parameter; to change
          truncation behavior the caller must modify that constant elsewhere in the module.
        - The function does not modify a or b in-place; it constructs intermediate arrays and
          returns a new NumPy array for x.
        - Computational cost scales with the cost of a full SVD on a (O(min(M,N)^2 * max(M,N)))
          which can be significant for large matrices encountered in electronic-structure
          calculations; use with awareness of performance implications.
        - The implementation preserves conjugation where appropriate (conjugate-transpose is
          used for complex inputs), so it is suitable for both real- and complex-valued linear
          systems typical in quantum-chemistry workflows.
    """
    from pyscf.lib.numpy_helper import solve_lineq_by_SVD
    return solve_lineq_by_SVD(a, b)


################################################################################
# Source: pyscf.lib.numpy_helper.split_reshape
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_split_reshape(a: numpy.ndarray, shapes: tuple):
    """Split a 1-D numpy.ndarray into one or more tensors described by a nested tuple of shapes.
    
    This function is used in the PySCF (Python-based Simulations of Chemistry Framework) codebase to convert a flattened parameter vector (for example, concatenated orbital coefficients, density matrix blocks, or other flattened model parameters commonly used in electronic structure codes) into structured tensor blocks. The argument shapes describes how to partition and reshape the flat array a into individual tensors or nested groups of tensors. The function never modifies the input array in-place; it constructs new numpy.ndarray objects for the returned tensors (these may be views or copies depending on NumPy's internal behavior).
    
    Args:
        a (numpy.ndarray): A 1-D numpy array containing a flattened sequence of elements to be partitioned. In PySCF this is typically a parameter vector produced by concatenating multiple tensor blocks. The function expects a to be indexable by standard 1-D slicing (a[p0:p1]) and to contain exactly the number of elements required by shapes; if a has additional dimensions they are ignored by this procedure, so the practical and intended use is as a flattened vector.
        shapes (tuple): A nested tuple structure that describes the desired output tensor shapes and grouping. Each entry of shapes must be either:
            - a tuple of ints describing a single target shape (for example (2, 3)), or
            - a nested tuple whose entries follow the same rule, enabling hierarchical grouping of tensors.
            If shapes[0] is itself a sequence of integers (i.e., shapes describes a single tensor shape), the function returns a.reshape(shapes). Otherwise shapes is interpreted as a sequence of shape descriptors; the function consumes elements from a in order and reshapes successive contiguous slices to the shape tuples given. The numeric entries in the shape tuples must be integers (or numpy.integer); numpy.prod is used internally to compute the number of elements required by each shape.
    
    Behavior, side effects, and defaults:
        - If shapes[0] is a tuple of integers (a single shape), the function returns a.reshape(shapes) and does not perform any further splitting.
        - For nested shapes, the function iteratively slices a, reshapes each slice to the requested shape, and returns a list whose elements are either numpy.ndarray tensors or nested lists of tensors reflecting the nesting in shapes.
        - The function does not modify the input array a; it returns newly constructed numpy.ndarray objects which may be views or copies depending on NumPy's memory layout and reshape semantics.
        - Numeric types and precisions are preserved from the input array a.
        - There is no default behavior to pad, trim, or broadcast data; shapes must exactly match the total number of elements present in a according to the partitioning described by shapes.
    
    Failure modes:
        - If the total number of elements implied by shapes does not equal a.size (for the flattened interpretation), NumPy operations such as reshape or slicing will raise an exception (for example ValueError from numpy.reshape or IndexError from slicing). The function does not attempt to validate or adjust sizes beyond relying on numpy.prod and slicing behavior.
        - If shapes contains non-integer entries or malformed nested structures (for example, a shape descriptor that is neither a tuple of ints nor a nested tuple of such descriptors), the function may raise a TypeError or behave unpredictably.
        - The function assumes shapes is indexable and that shape tuples contain integer types (Python int or numpy.integer); providing other types may lead to errors.
    
    Returns:
        numpy.ndarray or list: If shapes describes a single tensor shape (shapes[0] is a tuple of ints), returns a numpy.ndarray of shape shapes produced by a.reshape(shapes). Otherwise returns a list whose elements are numpy.ndarray objects or nested lists of numpy.ndarray objects that mirror the nesting of shapes. Each returned numpy.ndarray corresponds to a contiguous slice of the input vector a reshaped to the specified shape; in the PySCF domain these tensors represent the structured blocks (for example, blocks of coefficients or densities) reconstructed from a flattened parameter vector.
    """
    from pyscf.lib.numpy_helper import split_reshape
    return split_reshape(a, shapes)


################################################################################
# Source: pyscf.lib.numpy_helper.omatcopy
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_omatcopy(a: numpy.ndarray, out: numpy.ndarray = None):
    """pyscf.lib.numpy_helper.omatcopy copies a 2-D numpy.ndarray (matrix) while preserving its memory order (row-major or column-major). This routine is used in PySCF linear-algebra code paths where maintaining the original array order and leading-dimension semantics is important for correct and efficient interoperability with low-level C/Fortran routines and optimized copy kernels used in quantum-chemistry computations (for example, copying density, overlap, or Hamiltonian matrices before passing them to native libraries).
    
    Args:
        a (numpy.ndarray): Matrix to be copied. Must be a 2-D NumPy array whose memory order (C/row-major or F/column-major) is meaningful for subsequent low-level operations. The function preserves the order of a in the returned array. Internally the function queries the leading-dimension and canonical shape information (via leading_dimension_order) and requires that canonical column-major shape information is available; if that information is not available (leading_dimension_order returns None) an AssertionError will be raised. Only arrays with dtype numpy.double or numpy.complex128 are supported; other dtypes will raise NotImplementedError. This parameter is central in PySCF because many linear-algebra kernels expect specific memory layouts to maintain performance and correctness.
        out (numpy.ndarray): Matrix to be overwritten with the copy of a. If provided, out must be a NumPy array whose canonical column-major shape (as returned by leading_dimension_order) matches that of a; otherwise an AssertionError is raised. If out is None (the default), a new array is allocated using numpy.empty_like(a) and returned. Passing an existing out array is a side-effectful option used to avoid additional allocations in performance-critical PySCF code paths; when provided, its contents are overwritten.
    
    Returns:
        numpy.ndarray: The destination array containing a copy of a with the same memory order as the input. If out was provided, the same out object is returned (and is overwritten in place). If out was None, a newly allocated array (numpy.empty_like(a)) is returned. The returned array is suitable for use with the low-level copy kernels invoked by this function and for subsequent C/Fortran interop that depends on leading-dimension semantics.
    
    Behavior, side effects, defaults, and failure modes:
        - Order preservation: The function preserves the memory order (row- or column-major) of the input matrix a in the returned array; this is important for ABI compatibility and performance with BLAS/Fortran-style callers used in PySCF.
        - Allocation behavior: If out is None, a new array is allocated with numpy.empty_like(a). If out is provided, its contents are overwritten (in-place) with the copy of a.
        - Supported dtypes: Only numpy.double (float64) and numpy.complex128 are implemented. If a.dtype is neither of these, the function raises NotImplementedError.
        - Shape and layout validation: The function relies on leading_dimension_order to obtain canonical column-major shape information for both a and out. If leading_dimension_order returns None for a or out, or if canonical shapes do not match, an AssertionError is raised; this prevents incorrect copies when memory-layout metadata cannot be determined or does not match.
        - Low-level call: The implementation dispatches to C-level copy kernels (_np_helper.NPomp_dcopy or _np_helper.NPomp_zcopy) via ctypes, passing pointer addresses and leading-dimension values. Errors in those native calls (e.g., missing symbols or ABI mismatch) will propagate as runtime errors from the ctypes layer.
        - Performance note: This function is designed to minimize unnecessary reordering or temporary allocations in PySCF linear algebra workflows; use the out parameter to reuse buffers when possible to reduce memory pressure in large quantum-chemistry calculations.
    """
    from pyscf.lib.numpy_helper import omatcopy
    return omatcopy(a, out)


################################################################################
# Source: pyscf.lib.numpy_helper.transpose_sum
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_transpose_sum(
    a: numpy.ndarray,
    inplace: bool = False,
    out: numpy.ndarray = None
):
    """Compute the element-wise sum a + a.T (matrix plus its transpose) with improved memory
    efficiency compared to constructing the transpose and summing separately. This helper
    is provided in the PySCF library (Python-based Simulations of Chemistry Framework)
    to build symmetrized matrices commonly needed in quantum-chemistry workflows
    (e.g., symmetrizing density, overlap, Fock, or integral intermediate matrices)
    while reducing temporary memory allocations. The implementation forwards the call
    to hermi_sum(a, inplace=inplace, out=out) to perform the computation.
    
    Args:
        a (numpy.ndarray): Input array representing the matrix to be symmetrized.
            Practically, callers pass a 2-D square matrix (for example, a density or
            Fock matrix in PySCF) whose element-wise sum with its transpose is desired.
            The function preserves the numeric dtype of a in the returned result.
            This argument is required and must be a NumPy ndarray; if it is not a
            valid array type or has incompatible shape for a transpose-based sum,
            the underlying hermi_sum implementation will raise an exception that
            propagates to the caller.
        inplace (bool): If False (default), the function will produce the sum without
            guaranteeing modification of the input array a. If True, the function
            may perform the operation in-place to save memory, modifying the contents
            of a to contain the result a + a.T. Using inplace=True reduces peak memory
            usage but has the side effect of mutating the provided input array, which
            may be undesirable if a is needed unchanged later. If a is not writable
            or not suitable for in-place updates, the underlying hermi_sum call may
            raise an exception (for example, ValueError or TypeError), which is
            propagated to the caller.
        out (numpy.ndarray): Optional output array into which the result will be
            placed. If provided, out must be a NumPy ndarray with shape and dtype
            compatible with the result a + a.T so it can store the summed values.
            When out is given, the function writes the result into out and returns
            that object. Supplying out can avoid an additional allocation; if out is
            the same object as a and writable, the operation may be performed in-place.
            If out is not provided (None, the default), the function returns a newly
            allocated array unless an in-place update of a is performed (in which
            case a itself may be returned).
    
    Returns:
        numpy.ndarray: The array containing the element-wise sum a + a.T. The returned
        array has the same numeric dtype as the input a and a shape compatible with
        a and its transpose. If out was provided, the same out object is returned
        after being filled with the result. If inplace=True and the operation was
        performed in-place, the original array a may be modified and returned.
        Errors from incompatible shapes, non-writable arrays, or other invalid input
        conditions are raised by the underlying hermi_sum implementation and will
        propagate to the caller.
    """
    from pyscf.lib.numpy_helper import transpose_sum
    return transpose_sum(a, inplace, out)


################################################################################
# Source: pyscf.lib.numpy_helper.transpose
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_transpose(
    a: numpy.ndarray,
    axes: tuple = None,
    inplace: bool = False,
    out: numpy.ndarray = None
):
    """Transposing an array with improved memory efficiency for PySCF tensor operations.
    
    This function is used throughout the PySCF (Python-based Simulations of Chemistry Framework) codebase to transpose arrays and small tensors encountered in quantum-chemistry workflows (for example, transposing density matrices, orbital coefficient matrices, or 3-index/two-electron integral tensors) while minimizing additional memory allocations and exploiting optimized C kernels for common dtypes and layouts. The implementation chooses different algorithms depending on array dimensionality, memory contiguity, dtype, and the requested axes to offer an in-place path where safe and fast out-of-place paths when needed.
    
    Args:
        a (numpy.ndarray): Input array to transpose. In PySCF this typically represents a matrix or small tensor (e.g., 2D matrices or 3D tensors with shape (d0, n, n)). The function inspects a.ndim, a.flags.c_contiguous, a.flags.f_contiguous, and a.dtype to select optimized code paths. Providing a C-contiguous array of dtype numpy.double or numpy.complex128 enables the most memory- and CPU-efficient paths.
        axes (tuple): Axis permutation for transposition. Default None means use the default numpy.transpose semantics. A special optimized path exists for 3D arrays when axes == (0, 2, 1) (commonly used to swap the last two indices of a stack of square matrices). For other axes on non-contiguous arrays the function falls back to numpy.asarray(a.transpose(axes), order='C').
        inplace (bool): If True, attempt to transpose the input array in place and return the same array object. Practical significance: in-place transpose avoids allocating a full new array which reduces peak memory usage during large quantum-chemistry calculations. In-place is implemented for 2D arrays, for 3D arrays when axes == (0, 2, 1) and the inner two dimensions are equal, and for general square 2D blocks via a blocking algorithm. If in-place cannot be performed for the provided combination of ndim, dtype, and axes, the function will either raise or take a different path (see Failure modes and Behavior).
        out (numpy.ndarray): Optional output array whose memory will be used as the result buffer for the transposed data. When provided, the function constructs a numpy.ndarray view with the appropriate result shape backed by this buffer (for 2D result shape (acol, arow), for 3D with axes == (0,2,1) result shape (d0, acol, arow)). The buffer must be large enough and compatible with a.dtype. If out is None, a new numpy.ndarray is allocated for the result. Providing out is useful to recycle pre-allocated memory and reduce allocations during repeated transpositions in PySCF workflows.
    
    Returns:
        numpy.ndarray: The transposed array. Behavior depends on the selected code path:
            - If inplace is True and an in-place transpose path is taken, the original array object a is modified and returned (same object identity as the input).
            - If a new array is required (non-inplace path or when out is None), a newly allocated numpy.ndarray in C-contiguous order is returned containing the transposed data.
            - If out is provided and used as the backing buffer, the returned numpy.ndarray will be constructed using that buffer and contain the transposed data.
        The returned array will have dtype equal to a.dtype and shape equal to the transposed shape (e.g., for 2D input of shape (m, n), the result shape is (n, m); for 3D input with axes (0,2,1) and shape (d0, n, n), the result shape is (d0, n, n) with the inner two dims swapped).
    
    Behavior and implementation notes:
        - Optimized C kernels and ctypes calls are used when possible. For C-contiguous arrays with dtype numpy.double the function calls a double-precision C transpose routine; for dtype numpy.complex128 it calls the corresponding complex128 routine. These paths expect C-contiguous memory layout and may construct the output with buffer=out when an output buffer is provided.
        - For inplace=True:
            - 2D arrays: an optimized in-place routine (inplace_transpose_scale) is called.
            - 3D arrays with axes == (0, 2, 1): an optimized in-place tensor transpose is attempted; this requires the inner two dimensions to be equal (square matrices) and supports only numpy.double and numpy.complex128; the implementation asserts these shape conditions and uses specialized C functions.
            - Other square-2D-block cases: a blocking algorithm (using a temporary block of size BLOCK_DIM x BLOCK_DIM) swaps off-diagonal blocks and transposes diagonal blocks to achieve in-place transpose; this allocates a small temporary block (tmp) as workspace.
        - For arrays that are not C-contiguous or for dtypes other than numpy.double or numpy.complex128, the function chooses safe out-of-place paths:
            - For 2D arrays that are Fortran-contiguous, it returns a.T.copy() to get a C-contiguous result.
            - For general non-contiguous 2D arrays, it performs a blocked copy into an output array with shape (acol, arow) and dtype equal to a.dtype, minimizing temporary allocations per block.
            - For non-2D arrays (and when the specialized 3D path is not taken), it falls back to numpy.asarray(a.transpose(axes), order='C') to ensure a C-ordered result.
        - When the C-contiguous optimized final path is taken, the function constructs a numpy.ndarray for out (using buffer=out if provided) and calls the appropriate compiled helper (_np_helper.NPdtranspose_021 for double or _np_helper.NPztranspose_021 for complex128). These helper functions are tailored for common shapes in PySCF and provide efficient memory access patterns.
    
    Failure modes and exceptions:
        - AssertionError: The function uses assert statements to validate shape conditions for in-place 3D transposes (e.g., that the two inner dimensions are equal) and assumptions about strides; failing these assertions raises AssertionError.
        - NotImplementedError: Raised when an attempted optimized in-place path encounters an unsupported dtype or an unhandled combination of ndim/axes in paths that expect specific layouts (for example, unsupported dtype in the specialized 3D in-place branch, or when an optimized contiguous path does not support the requested axes).
        - Errors from ctypes/C helpers: If the underlying compiled helper functions are unavailable or fail, ctypes-related exceptions may propagate.
        - ValueError or unexpected behavior may occur if out is provided but does not supply a compatible buffer of sufficient size for the expected result shape and dtype.
    
    Practical significance in PySCF:
        - Minimizes peak memory usage and temporary allocations when transposing matrices and small tensors encountered in electronic structure computations (e.g., transforming integrals, permuting tensor indices for contractions).
        - Provides both safe and high-performance code paths tailored to the common data layouts and dtypes used in PySCF (C-contiguous, numpy.double, numpy.complex128), with fallbacks that preserve correctness for other layouts and dtypes.
    """
    from pyscf.lib.numpy_helper import transpose
    return transpose(a, axes, inplace, out)


################################################################################
# Source: pyscf.lib.numpy_helper.unpack_row
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_unpack_row(tril: numpy.ndarray, row_id: int):
    """pyscf.lib.numpy_helper.unpack_row extracts a single full row from a packed lower-triangular representation of a square matrix. The function is used in PySCF to access one row of symmetric or Hermitian matrices that are stored in compact (packed) form to save memory (for example, packed density matrices or two-electron integral blocks). It is equivalent to calling unpack_tril(tril)[row_id] but avoids allocating the entire unpacked matrix when only one row is needed.
    
    Args:
        tril (numpy.ndarray): One-dimensional NumPy array containing the lower-triangular elements of an nd-by-nd matrix stored in row-major packed form. The expected length is nd*(nd+1)//2 for some integer nd; the function computes nd as int(sqrt(tril.size*2)). The array may be copied to ensure it is contiguous (numpy.ascontiguousarray is applied). The dtype of tril is preserved in the returned row; when tril.dtype is numpy.double an optimized C routine (_np_helper.NPdunpack_row) is used, and when tril.dtype is numpy.complex128 _np_helper.NPzunpack_row is used. For other dtypes a Python/Numpy fallback is used.
        row_id (int): Zero-based index of the row to extract from the implied full nd-by-nd matrix. Valid values are 0 <= row_id < nd, where nd is computed from the length of tril. The function does not perform explicit range checks; passing an out-of-range row_id leads to undefined behavior (it may raise an IndexError or cause a low-level memory access error when the C helper is invoked).
    
    Returns:
        numpy.ndarray: One-dimensional NumPy array of length nd and the same dtype as tril containing the full row corresponding to row_id (columns 0 through nd-1) of the unpacked matrix. The returned array is newly allocated and contiguous. This allows efficient retrieval of a single matrix row from packed lower-triangular storage without unpacking the entire matrix.
    
    Behavior and failure modes:
        The function infers the matrix dimension nd from tril.size; if tril.size is not a triangular number (nd*(nd+1)//2) the computed nd will be int(sqrt(tril.size*2)) and the result will be incorrect or may trigger out-of-bounds access. The function makes tril contiguous with numpy.ascontiguousarray, which may copy data. For numpy.double and numpy.complex128 dtypes an internal C routine fills the output buffer; for other dtypes the function constructs the row with NumPy indexing and numpy.append. Because there are no explicit input validations, callers must ensure tril length and row_id are valid to avoid incorrect results or runtime errors.
    """
    from pyscf.lib.numpy_helper import unpack_row
    return unpack_row(tril, row_id)


################################################################################
# Source: pyscf.lib.numpy_helper.zdot
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_zdot(
    a: numpy.ndarray,
    b: numpy.ndarray,
    alpha: float = 1,
    c: numpy.ndarray = None,
    beta: float = 0
):
    """pyscf.lib.numpy_helper.zdot: Matrix-matrix multiplication for double-complex (numpy.complex128) arrays using a BLAS zgemm backend. This function is used within the PySCF (Python-based Simulations of Chemistry Framework) code path for high-performance complex linear-algebra operations common in quantum-chemistry workflows (for example, transforming complex orbital coefficient matrices or contracting complex integral blocks). It implements the operation C := alpha * A @ B + beta * C with explicit handling of memory layout to call the BLAS _zgemm routine efficiently.
    
    Args:
        a (numpy.ndarray): Left matrix A with shape (m, k). Must be a two-dimensional numpy.ndarray representing double-precision complex numbers (numpy.complex128). The function inspects a.flags to determine memory layout: if C-contiguous, A is used as-is (no transpose); if Fortran-contiguous, A is passed as its transpose view and the BLAS transpose flag is set accordingly. If a is neither C- nor F-contiguous, the function raises ValueError with a message showing a.flags. The shape m and k are inferred from a.shape and are used to validate b and c.
        b (numpy.ndarray): Right matrix B with shape (k, n). Must be a two-dimensional numpy.ndarray representing double-precision complex numbers (numpy.complex128). Similar to a, the function checks b.flags: C-contiguous arrays are used without transpose, Fortran-contiguous arrays are used as their transpose view and the BLAS transpose flag is set. If b is neither C- nor F-contiguous, ValueError is raised. The leading dimension k must match a.shape[1]; an AssertionError is raised if they differ.
        alpha (float): Scalar multiplier for the matrix product A @ B. Defaults to 1. It is passed directly to the underlying BLAS _zgemm call and scales the computed product. Use this to scale the contribution of A @ B in the combined update C := alpha * A @ B + beta * C.
        c (numpy.ndarray): Optional output buffer C with shape (m, n) and dtype numpy.complex128. If supplied, this array is used as the destination for the result and may be overwritten in-place by the call; the function asserts that c.shape == (m, n). If c is None (the default), the function allocates and returns a new numpy.empty array of shape (m, n) with dtype numpy.complex128 and forces beta to 0 (so no prior content of C is used).
        beta (float): Scalar multiplier for the existing contents of C. Defaults to 0. When c is provided, beta scales the existing contents of c before adding alpha * A @ B. If c is None, beta is ignored and set to 0 internally because a fresh output array is allocated.
    
    Returns:
        numpy.ndarray: The output array C of shape (m, n) and dtype numpy.complex128 containing the result of alpha * A @ B + beta * C. If a caller provided the c argument, that array is used as the output buffer and is returned (its contents are overwritten). If c was None, a newly allocated numpy.complex128 array is returned.
    
    Behavior, side effects, and failure modes:
        The function performs memory-layout checks on the inputs and sets BLAS transpose flags rather than copying data when possible. For Fortran-contiguous inputs, it rebinds local variables to transpose views (A.T or B.T) so that BLAS sees a C-contiguous layout; these are local view objects and the original numpy arrays passed by the caller are not modified in-place. If either a or b is neither C- nor F-contiguous, a ValueError is raised containing the offending array.flags string. If the inner dimensions do not match (a.shape[1] != b.shape[0]) an AssertionError is raised. If c is provided with a shape not equal to (m, n), an AssertionError is raised. The function expects double-complex arrays (numpy.complex128); passing arrays with other dtypes is not supported by the underlying BLAS routine and may produce incorrect results or runtime errors. The routine delegates the numeric work to an internal _zgemm BLAS wrapper for performance, so numerical results follow BLAS semantics (including floating-point rounding and complex arithmetic behavior).
    """
    from pyscf.lib.numpy_helper import zdot
    return zdot(a, b, alpha, c, beta)


################################################################################
# Source: pyscf.lib.numpy_helper.einsum
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_einsum(subscripts: str, *tensors, **kwargs):
    """Perform an einsum-style tensor contraction optimized for common quantum-chemistry tensor patterns by reshaping operands to matrix multiplies when possible. This function is a drop-in, more efficient variant used throughout PySCF for multi-tensor contractions (for example, contracting molecular orbital and integral tensors in post-Hartree–Fock methods). It preserves the semantics of an einsum expression while applying an internal contraction path and specialized two-operand contraction routine to reduce work and memory when the expression meets the function's assumptions.
    
    This implementation differs from numpy.einsum in two important, documented ways inherited from PySCF usage patterns: it assumes that any repeated index in the subscripts is a summation index (i.e., the pattern 'i,i->i' is not supported) and that every repeated index appears exactly twice (i.e., patterns such as 'ij,ik,il->jkl' are not supported). It also requires the output indices to be explicitly specified in the subscripts string (for example, use 'ij,j->i' rather than the implicit 'ij,j').
    
    Args:
        subscripts (str): Einstein summation subscripts string that specifies the contraction pattern. This must follow numpy.einsum-style notation (letters for indices and '->' for an explicit output); it must not rely on implicit output index inference. In PySCF, subscripts commonly describe contractions of multi-dimensional arrays of orbital or integral data; their meaning is the mapping between input tensor axes and the desired output tensor axes used in quantum chemistry algorithms.
        tensors (tuple): Positional variadic input operands to be contracted. Each element is a tensor-like object accepted by numpy.einsum (typically numpy.ndarray in PySCF). The order of tensors must correspond to the order of input terms in subscripts. When a single tensor or a subscripts string containing an ellipsis ('...') is supplied, this function forwards the call to numpy.einsum. For two-tensor cases it uses an internal optimized two-operand routine (contract). For more than two operands it computes an optimized contraction path with _einsum_path and executes the sequence of pairwise (or small-group) contractions, reshaping to matrix multiplies where applicable to improve performance for common PySCF tensor operations.
        kwargs (dict): Additional keyword arguments forwarded to the underlying contraction routines. Recognized and consumed keys are:
            '_contract': optional callable to override the module-level two-operand contraction function used for binary contractions; if absent, an internal default contract implementation is used. This key is popped from kwargs and therefore not forwarded further.
            'optimize': optional bool controlling whether to compute an optimized contraction path when more than two tensors are provided; defaults to True and is popped from kwargs. Any other keys in kwargs are forwarded to the underlying numpy.einsum or contract calls as applicable. Note that _contract and optimize are removed from the kwargs passed deeper into the implementation.
    
    Behavior and side effects:
        - For len(tensors) <= 1 or if the subscripts string contains '...', the function directly calls numpy.einsum(subscripts, *tensors, **kwargs) and returns that result. This preserves compatibility for these cases but bypasses the matrix-reshaping optimization.
        - For exactly two operand tensors (len(tensors) == 2), the function calls the module-level _contract routine (or the callable supplied via kwargs['_contract']) to perform an optimized two-operand contraction, and returns that result.
        - For more than two operands, the function computes a contraction sequence using _einsum_path(subscripts, *tensors, optimize=optimize, einsum_call=True)[1]. It then iterates over the returned contraction list; for each contraction it pops the specified operand indices from a local list of tensors, performs either a numpy.einsum or a two-operand contract depending on the group size, and appends the intermediate result to the operand list. The final value of the variable out is returned.
        - The function removes (pops) the keys '_contract' and 'optimize' from the local kwargs; these removals affect only the arguments forwarded to inner routines and do not alter caller-side variables passed via **kwargs in the normal Python calling convention.
        - Intermediate temporaries are created during multi-step contractions; these may increase peak memory usage relative to a single-call numpy.einsum when the chosen contraction path produces large intermediates. The optimize flag attempts to minimize such costs by choosing a favorable path.
    
    Failure modes and limitations:
        - If the subscripts violate the function's assumptions (repeated index not intended as a summation index, repeated indices appearing more than twice, or implicit output indices), the result may be incorrect or numpy.einsum may raise an error. Validate subscripts against the documented assumptions before use in PySCF tensor code.
        - Unsupported or malformed subscripts are passed to numpy.einsum for evaluation in certain branches and will produce whatever exceptions numpy.einsum would raise (for example, ValueError on invalid index labels or mismatched operand shapes).
        - If an overriding callable is provided via kwargs['_contract'], it must implement the same calling convention expected by the internal code (subscrips string then operand arrays) or a runtime TypeError/ValueError may occur.
        - Performance and memory behavior depend on the shapes of the input tensors and the chosen contraction path; while this function often reduces cost for common PySCF patterns by reshaping to matrix multiplies, pathological index patterns or very unbalanced shapes can still be expensive.
    
    Returns:
        numpy.ndarray: The result of performing the Einstein summation contraction described by subscripts on the provided tensors. The output shape corresponds exactly to the explicit output indices in subscripts. In PySCF, the returned array typically represents contracted quantities such as reduced-dimensional integrals or amplitude updates used in electronic-structure algorithms.
    """
    from pyscf.lib.numpy_helper import einsum
    return einsum(subscripts, *tensors, **kwargs)


################################################################################
# Source: pyscf.lib.numpy_helper.zdotNN
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_zdotNN(
    aR: numpy.ndarray,
    aI: numpy.ndarray,
    bR: numpy.ndarray,
    bI: numpy.ndarray,
    alpha: float = 1,
    cR: numpy.ndarray = None,
    cI: numpy.ndarray = None,
    beta: float = 0
):
    """zdotNN computes the non-conjugated complex matrix product c = alpha * (a * b) + beta * c where a and b are provided as separate real and imaginary parts. This routine is part of PySCF's low-level numpy_helper linear-algebra utilities and is used in quantum-chemistry workflows inside PySCF to assemble complex-valued matrices (for example intermediate products of density matrices, Fock/Kohn–Sham matrices, or complex integrals) while avoiding explicit complex dtype arithmetic by operating on real and imaginary components.
    
    Args:
        aR (numpy.ndarray): Real part of the left operand a. This array supplies the real component of the complex matrix a used in the product a*b. In PySCF linear algebra contexts aR typically represents the real part of a block or full matrix (e.g., a density or transform matrix). The array must be a numpy.ndarray; shape and exact dtype are validated implicitly by the underlying ddot operations and must be compatible with bR and bI for matrix multiplication.
        aI (numpy.ndarray): Imaginary part of the left operand a. Supplies the imaginary component of a. aI must be a numpy.ndarray with shapes compatible with aR and the b* arrays; when a is purely real the caller should pass an array of zeros of matching shape.
        bR (numpy.ndarray): Real part of the right operand b. Supplies the real component of the complex matrix b used in the product a*b. In PySCF, bR often represents the real part of transformation or integral blocks. Must be a numpy.ndarray compatible for multiplication with aR/aI.
        bI (numpy.ndarray): Imaginary part of the right operand b. Supplies the imaginary component of b. If b is real, pass an array of zeros of matching shape.
        alpha (float): Scalar multiplier applied to the product a*b. The function computes alpha * (a*b) where a and b are reconstructed from their real/imaginary parts. Default is 1. This parameter is commonly used in linear-algebra kernels within PySCF to scale contributions (for example, when accumulating scaled intermediates).
        cR (numpy.ndarray): Optional real part of an existing accumulator matrix c that will be updated. If provided, the final cR returned equals alpha*Re(a*b) + beta*cR_initial (subject to shape compatibility). If None, the routine relies on the underlying ddot implementation to allocate and return a newly created numpy.ndarray for the real part of the result. Passing an existing array lets callers avoid allocations and reuse memory for performance in iterative chemistry algorithms.
        cI (numpy.ndarray): Optional imaginary part of an existing accumulator matrix c that will be updated analogously to cR. If provided, the final cI equals alpha*Im(a*b) + beta*cI_initial. If None, a new numpy.ndarray will be allocated by the underlying ddot calls. Use this to control memory reuse in performance-critical PySCF code paths.
        beta (float): Scalar multiplier applied to the initial accumulator c (cR and cI). The final returned c equals alpha*(a*b) + beta*c_initial when cR and/or cI are provided. Default is 0, which ignores any initial accumulator content. This is consistent with common BLAS-style scaling semantics used across PySCF's numeric kernels.
    
    Behavior and side effects:
        The function reconstructs the real and imaginary parts of the complex matrix product without using complex-valued arrays by performing four real-valued ddot calls:
        cR <- alpha * dot(aR, bR) + beta * cR_initial, then cR <- cR - alpha * dot(aI, bI)
        cI <- alpha * dot(aR, bI) + beta * cI_initial, then cI <- cI + alpha * dot(aI, bR)
        This implements c = alpha*(a*b) + beta*c using only real ddot operations and corresponds to non-conjugated multiplication (neither a nor b is conjugated). If cR or cI is provided they may be overwritten in-place and returned; if they are None, the routine (via ddot) will allocate and return new numpy.ndarray objects. The implementation preserves BLAS-like scaling semantics; use alpha and beta to control accumulation and memory reuse in PySCF workflows.
    
    Failure modes and validation:
        The function does not perform explicit Python-level shape broadcasting checks beyond those enforced by the underlying ddot implementation. If the input arrays have incompatible shapes for matrix multiplication or are not numpy.ndarray instances, the underlying ddot or numpy operations will raise an exception (for example ValueError or TypeError). Inputs must represent real-valued components (floating dtypes) compatible with ddot; supplying arrays with unsupported dtypes or non-array objects will lead to errors. The routine does not perform complex conjugation; callers requiring conjugated products should use a different helper.
    
    Returns:
        tuple: A pair (cR, cI) of numpy.ndarray objects containing the real and imaginary parts of the resulting complex matrix c = alpha*(a*b) + beta*c_initial. Both arrays are the computed results suitable for further PySCF matrix operations; if cR/cI were provided, the returned arrays will be those same objects updated in-place (subject to the behavior of the underlying ddot), otherwise they will be newly allocated numpy.ndarray instances.
    """
    from pyscf.lib.numpy_helper import zdotNN
    return zdotNN(aR, aI, bR, bI, alpha, cR, cI, beta)


################################################################################
# Source: pyscf.lib.scipy_helper.pivoted_cholesky
# File: pyscf/lib/scipy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_scipy_helper_pivoted_cholesky(
    A: numpy.ndarray,
    tol: float = -1.0,
    lower: bool = False
):
    """pyscf.lib.scipy_helper.pivoted_cholesky computes a pivoted Cholesky factorization of a symmetric (Hermitian) positive semidefinite matrix A, returning a triangular factor (lower or upper), the pivot permutation vector, and the numerical rank. This routine is used within the PySCF (Python-based Simulations of Chemistry Framework) codebase to obtain robust low-rank decompositions of matrices that arise in quantum-chemistry workflows (for example, compression of integral or covariance-like matrices), and it wraps a LAPACK-style implementation with full pivoting to handle singular or near-singular cases.
    
    Args:
        A (numpy.ndarray): The input matrix to be factorized. A is expected to be a real symmetric (Hermitian) matrix representing a positive semidefinite operator (for example, an overlap, density, or integral-derived matrix in PySCF). The function relies on LAPACK behavior and on A being square; providing a non-square or strongly non-symmetric array may lead to incorrect results or runtime errors propagated from the underlying numerical library.
        tol (float): The stopping tolerance controlling the numerical rank determination and pivoted Cholesky truncation. This value is passed to the underlying LAPACK routine (see dpstrf) to decide when remaining pivots are negligible. The default is -1.0, which preserves the wrapped implementation's default LAPACK behavior; users can supply a nonnegative tolerance to force earlier truncation and obtain a lower-rank approximation. Smaller tol values lead to higher-rank factorizations (closer to full factorization), while larger tol values cause earlier termination (smaller rank) but larger approximation error.
        lower (bool): Controls the form of the returned triangular factor. If True, return a lower-triangular factor L satisfying P.T * A * P = L * L.T. If False, return an upper-triangular factor U satisfying P.T * A * P = U.T * U. The boolean mirrors conventional Cholesky conventions and lets downstream PySCF routines consume the factor in the expected orientation; there are no in-place modifications of A performed by this function.
    
    Returns:
        tuple: A tuple of three items:
            factor (numpy.ndarray): The triangular factor (L or U) returned by the pivoted Cholesky procedure. This ndarray is the matrix factor such that when combined with the pivot permutation it reconstructs A in the factored form P.T * A * P = factor * factor.T if lower was True, or P.T * A * P = factor.T * factor if lower was False. The factor is produced by the LAPACK-style routine and reflects any truncation implied by tol.
            piv (numpy.ndarray): The pivot vector (integer ndarray) indicating the column/row permutation P applied during factorization. The pivot vector uses 0-based indexing (starts with 0) and records the ordering of original indices into the permuted matrix P; applying this permutation yields the relation documented above. This vector enables reconstruction of the permuted matrix and mapping between original and permuted degrees of freedom in PySCF algorithms.
            rank (int): The numerical rank determined by the stopping tolerance tol. This integer indicates the number of pivot columns effectively used by the factorization and therefore the effective column dimension of the low-rank factor. rank may be less than the matrix dimension for positive semidefinite or singular inputs.
    
    Notes and failure modes:
        - This routine is intended for positive semidefinite (possibly singular) matrices; for strictly positive definite matrices, a standard Cholesky factorization (without pivoting) may be more efficient.
        - The function forwards most numerical decisions to the underlying LAPACK implementation; tol governs termination but negative tol (the default -1.0) defers to the wrapped routine's default behavior.
        - If A is not symmetric/Hermitian, not square, or contains NaNs/Infs, the underlying numerical library may raise errors or return invalid factors; callers should validate inputs when necessary.
        - There are no in-place side effects on Python-visible objects beyond returning the factor, pivot vector, and rank.
    """
    from pyscf.lib.scipy_helper import pivoted_cholesky
    return pivoted_cholesky(A, tol, lower)


################################################################################
# Source: pyscf.lo.cholesky.cholesky_mos
# File: pyscf/lo/cholesky.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lo_cholesky_cholesky_mos(mo_coeff: numpy.ndarray):
    """Calculates localized molecular orbitals (MOs) by performing a pivoted Cholesky
    factorization of a density-matrix-like quantity constructed from a provided
    block of MO coefficients. This function is part of PySCF's localized-orbital
    toolset and is used in computational chemistry workflows (for example, to
    generate localized orbitals for local correlation methods or integral
    factorizations). It factors the matrix D = mo_coeff @ mo_coeff.T using a
    pivoted Cholesky routine, permutes the Cholesky factors back to the original
    atomic-orbital (AO) ordering, and returns a block of localized MOs spanning
    the same MO subspace as the input.
    
    Args:
        mo_coeff (numpy.ndarray): A 2-dimensional array containing a contiguous
            block of molecular-orbital coefficients to be localized. The expected
            shape is (nao, nmo) where nao is the number of atomic-orbital (AO)
            basis functions and nmo is the number of molecular orbitals in the
            block. Each column represents an MO expansion in the AO basis. The
            function asserts that mo_coeff.ndim == 2; if this assertion fails an
            AssertionError is raised. The mo_coeff array is used to build a
            density-like matrix D = mo_coeff @ mo_coeff.T that the pivoted
            Cholesky factorization operates on.
    
    Returns:
        numpy.ndarray: A 2-dimensional array of localized MOs with the same shape
        (nao, nmo) as the input mo_coeff. The columns of the returned array span
        the same subspace as the input block of MOs but are transformed to be
        localized according to the pivoted Cholesky procedure. No in-place
        modification of the input array occurs; the function constructs and
        returns a new array (mo_loc) computed by permuting and cropping the lower
        triangular Cholesky factor L produced by pivoted_cholesky.
    
    Behavior, side effects, defaults, and failure modes:
        The function constructs the symmetric matrix D = mo_coeff @ mo_coeff.T and
        calls pivoted_cholesky(D, lower=True) to obtain a lower-triangular Cholesky
        factor L, a pivot index vector piv, and an integer rank. The pivot vector
        encodes a permutation of AO indices chosen during factorization; the code
        builds a permutation matrix P so that the Cholesky factors are returned to
        the original AO ordering. Only the first nmo columns of L are retained
        (superfluous columns are cropped) to produce the localized MO block.
        If pivoted_cholesky reports a rank smaller than nmo, the function raises a
        RuntimeError('rank of matrix lower than the number of orbitals') because
        the Cholesky factor does not provide enough independent columns to span
        the requested MO block. Aside from these exceptions (AssertionError for
        incorrect dimensionality and RuntimeError for insufficient rank), any
        exceptions raised by the underlying pivoted_cholesky routine propagate to
        the caller. The function has no external side effects; it does not modify
        global state or its input array.
    """
    from pyscf.lo.cholesky import cholesky_mos
    return cholesky_mos(mo_coeff)


################################################################################
# Source: pyscf.lib.numpy_helper.zdotCN
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_zdotCN(
    aR: numpy.ndarray,
    aI: numpy.ndarray,
    bR: numpy.ndarray,
    bI: numpy.ndarray,
    alpha: float = 1,
    cR: numpy.ndarray = None,
    cI: numpy.ndarray = None,
    beta: float = 0
):
    """Compute the complex conjugate dot product c = conj(a) * b from separate real and imaginary parts.
    
    This function implements the complex inner product used throughout PySCF where complex arrays are stored as separate real and imaginary numpy.ndarray buffers for performance and BLAS-like accumulation. The operation performed is, in mathematical form,
        c = alpha * (conj(a) · b) + beta * c_initial,
    with conj(a) the complex conjugate of a, and the dot (·) denoting the sum-over-products (inner product) performed by the internal ddot routine. The result is returned as two numpy.ndarray objects holding the real and imaginary parts of c. This routine is commonly used in quantum chemistry workloads inside PySCF to compute overlaps, contractions of complex-valued vectors/matrices, and other linear-algebra kernels where explicit complex number storage is avoided for efficiency.
    
    Args:
        aR (numpy.ndarray): Real part of the complex array a. This array represents Re(a) in the complex vector/matrix whose conjugate is taken; it must have a shape compatible with bR and bI for the inner-product semantics provided by ddot. In PySCF this typically corresponds to the real component of a wavefunction, density matrix, or intermediate tensor.
        aI (numpy.ndarray): Imaginary part of the complex array a. This array represents Im(a) and must have the same shape and dtype compatibility as aR; it participates in computing conj(a) so that conj(a) = aR - i*aI.
        bR (numpy.ndarray): Real part of the complex array b. This array represents Re(b) and must be shape-compatible with aR and aI for the dot products. In PySCF contexts b often represents another vector/matrix such as a basis-projected quantity or integrals.
        bI (numpy.ndarray): Imaginary part of the complex array b. This array represents Im(b) and must match bR in shape and numeric dtype.
        alpha (float): Scalar multiplier applied to the computed conj(a)·b contribution. Default is 1.0. The implementation uses alpha to scale the complex product before adding (see formula above); using alpha allows the caller to scale the result (for example, when accumulating scaled contributions in iterative algorithms).
        cR (numpy.ndarray or None): Optional output buffer for the real part of the result. If provided, it will be used to store and may be overwritten in place with the computed real part; its shape must be compatible with the reduction result expected from ddot. If None (the default), a new numpy.ndarray will be allocated and returned. When provided, its prior contents are incorporated via the beta parameter (see behavior below).
        cI (numpy.ndarray or None): Optional output buffer for the imaginary part of the result. If provided, it will be overwritten in place with the computed imaginary part; if None, a new numpy.ndarray will be allocated and returned. Prior contents are incorporated according to beta.
        beta (float): Scalar multiplier applied to the initial contents of cR and cI before adding the new contribution. Default is 0.0. The final result implements c_final = alpha * conj(a)·b + beta * c_initial, so setting beta != 0 enables in-place accumulation with an existing buffer.
    
    Returns:
        tuple (numpy.ndarray, numpy.ndarray): A pair (cR_out, cI_out) containing the real and imaginary parts of the resulting complex array c = alpha * conj(a)·b + beta * c_initial. Each element is a numpy.ndarray of the same numeric dtype as the inputs. If cR/cI arguments were provided they may be returned as the same objects (mutated in place); otherwise new arrays are allocated and returned. The returned arrays are suitable for further use in PySCF linear-algebra kernels that work with separated real/imaginary buffers.
    
    Behavior, side effects, and failure modes:
        - The function delegates to an internal ddot routine that computes scaled dot products and accumulates results; the semantics are c_buf = alpha * dot(x, y) + beta * c_buf for each ddot call. This function composes four ddot calls to produce the real and imaginary parts of conj(a)·b.
        - If cR or cI is provided, they will be overwritten (mutated) to contain the result; callers should not assume original contents are preserved unless beta is chosen to maintain them.
        - Default alpha=1 and beta=0 yield c = conj(a)·b with no contribution from prior c buffers.
        - Input arrays must be numpy.ndarray objects. If non-ndarray types are supplied, or if shapes are incompatible for the inner-product semantics, underlying numpy or ddot operations will raise TypeError or ValueError; these exceptions propagate to the caller.
        - Numeric overflow, underflow, or precision loss follow standard numpy floating-point behavior and are not intercepted here.
        - This routine is optimized for the common PySCF pattern of representing complex data as separate real/imag arrays; it does not accept complex numpy arrays in a single buffer form.
    """
    from pyscf.lib.numpy_helper import zdotCN
    return zdotCN(aR, aI, bR, bI, alpha, cR, cI, beta)


################################################################################
# Source: pyscf.lib.numpy_helper.zdotNC
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_zdotNC(
    aR: numpy.ndarray,
    aI: numpy.ndarray,
    bR: numpy.ndarray,
    bI: numpy.ndarray,
    alpha: float = 1,
    cR: numpy.ndarray = None,
    cI: numpy.ndarray = None,
    beta: float = 0
):
    """zdotNC computes the complex-valued product c = alpha * (a * conj(b)) + beta * c where a and b are provided as separate real and imaginary numpy arrays.
    
    This function is a low-level helper in PySCF's numpy_helper module used to perform complex linear-algebra operations by working on real and imaginary parts separately. In the PySCF quantum-chemistry context, the inputs a and b typically represent complex-valued matrices or vectors such as molecular-orbital coefficients, density-matrix blocks, or other complex intermediate tensors; this routine computes the product of a with the complex conjugate of b using real arithmetic (via the internal ddot calls) and optionally accumulates the result into provided output buffers. The implementation mirrors BLAS-style scaling and accumulation: the computed product is scaled by alpha and any provided output buffers are scaled by beta and added.
    
    Args:
        aR (numpy.ndarray): Real part of the complex input array a. This array supplies the real components of the left operand a in the product a * conj(b). In PySCF numerical workflows, aR would typically contain the real components of coefficient matrices or intermediate arrays used in electronic-structure computations. Its shape and memory layout must be compatible with the underlying ddot operations; if it is not, the underlying numeric routines will raise an error.
        aI (numpy.ndarray): Imaginary part of the complex input array a. This array supplies the imaginary components of the left operand a. Together with aR, it defines the complex values of a = aR + 1j*aI used in the product. Must be a numpy.ndarray with shape compatible with aR and the operations performed by ddot.
        bR (numpy.ndarray): Real part of the complex input array b. This array supplies the real components of the right operand b, whose complex conjugate is used in the product. In PySCF usage, bR often represents real components of orbitals or other complex-valued matrices. Must be a numpy.ndarray compatible with bI and the ddot operations.
        bI (numpy.ndarray): Imaginary part of the complex input array b. This array supplies the imaginary components of the right operand b. The function computes with conj(b) = bR - 1j*bI, so bI enters with the appropriate sign in the imaginary-part accumulation. Must be a numpy.ndarray compatible with bR and the ddot operations.
        alpha (float): Scalar multiplier applied to the computed product a * conj(b). The routine computes alpha * (a * conj(b)) before adding any contribution from provided output buffers. Default is 1. Use this to scale the computed complex product in the same manner as BLAS-style routines used throughout PySCF for linear-algebra assemblies.
        cR (numpy.ndarray): Optional real part of an existing output/accumulator array. If provided (not None), this array will be used as the destination buffer for the real part of the result and will be updated in-place according to the formula: cR_out = alpha * Re(a * conj(b)) + beta * cR. If None, a new numpy.ndarray will be allocated and returned. When provided, its shape must be compatible with the computed product; otherwise underlying numeric routines will raise an error.
        cI (numpy.ndarray): Optional imaginary part of an existing output/accumulator array. If provided (not None), this array will be used as the destination buffer for the imaginary part of the result and will be updated in-place according to the formula: cI_out = alpha * Im(a * conj(b)) + beta * cI. If None, a new numpy.ndarray will be allocated and returned. When provided, its shape must be compatible with the computed product.
        beta (float): Scalar multiplier applied to the provided accumulator arrays cR and cI before adding the newly computed product. The full update follows c_out = alpha * (a * conj(b)) + beta * c_in. Default is 0, which means any provided cR/cI are ignored and only the computed product (scaled by alpha) is returned (or stored in newly allocated arrays if cR/cI is None).
    
    Returns:
        cR (numpy.ndarray): Real part of the resulting complex array c = alpha * (a * conj(b)) + beta * c_in. This is either the same object passed in as the cR argument (if provided) after in-place update, or a newly allocated numpy.ndarray when cR was None. The returned array contains the real-component values needed by downstream PySCF routines that expect separate real/imaginary arrays.
        cI (numpy.ndarray): Imaginary part of the resulting complex array c = alpha * (a * conj(b)) + beta * c_in. This is either the same object passed in as the cI argument (if provided) after in-place update, or a newly allocated numpy.ndarray when cI was None. The returned array contains the imaginary-component values needed by downstream PySCF routines.
    
    Notes:
        - The function implements the complex multiply-with-conjugation entirely via real-valued ddot operations: the real part is accumulated from dot(aR, bR) + dot(aI, bI) and the imaginary part from dot(aI, bR) - dot(aR, bI), with appropriate alpha and beta scalings. This avoids constructing complex dtypes when callers provide separate real/imaginary arrays.
        - No additional type coercion is performed; inputs must be numpy.ndarray instances containing numeric types acceptable to the underlying ddot routine. Passing other types will result in an exception from the numeric backend.
        - If array shapes are incompatible for the underlying ddot operations, the function will raise an error propagated from ddot or numpy.
        - This routine is intended as a performance-oriented primitive within PySCF for assembling complex products; callers should prefer providing preallocated cR/cI buffers when performing many repeated updates to avoid frequent memory allocation.
    """
    from pyscf.lib.numpy_helper import zdotNC
    return zdotNC(aR, aI, bR, bI, alpha, cR, cI, beta)


################################################################################
# Source: pyscf.lo.ibo.MakeAtomIbOffsets
# File: pyscf/lo/ibo.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lo_ibo_MakeAtomIbOffsets(Atoms: list):
    """pyscf.lo.ibo.MakeAtomIbOffsets: Calculate atom-wise starting offsets for the valence minimal basis (IB) orbitals and return supporting per-element orbital counts and labels used by intrinsic bond orbital (IBO) construction.
    
    Args:
        Atoms (list): Sequence of atom identifiers in the molecular geometry, provided in the same order as the atoms appear in the calculation. Each entry is expected to be a string (for example "C", "O", "H1", "Fe2+"); non-alphabetic characters in each entry are removed internally (so "C1" -> "C") to derive the chemical element symbol. The function uses these derived element symbols to look up per-element orbital counts and labels from the MakeAtomInfos() helper. Supplying non-iterable objects or entries that are not string-like will raise a TypeError when the function attempts to iterate characters; supplying an element symbol that is not present in the data returned by MakeAtomInfos() will raise a KeyError.
    
    Returns:
        tuple: A 4-tuple (iBfAt, nCoreX, nAoX, AoLabels) containing information required by valence-minimal-basis/IBO routines.
            iBfAt (list of int): Cumulative offsets for the index of the first IB (valence minimal basis) orbital of each atom. The list begins with 0 and has length len(Atoms) + 1; the offset for atom k is iBfAt[k], and the orbitals for atom k occupy indices iBfAt[k] through iBfAt[k+1]-1. This mapping is used to locate per-atom orbitals inside global orbital arrays when assembling or partitioning IBOs.
            nCoreX (dict): Mapping keyed by element symbol (string) that gives the number of core orbitals for that element as returned by MakeAtomInfos(). These core counts are used by higher-level routines to separate core and valence contributions when building minimal bases and IBOs.
            nAoX (dict): Mapping keyed by element symbol (string) that gives the number of atomic orbitals in the valence minimal basis (IB) for that element as returned by MakeAtomInfos(). nAoX is used to compute the per-atom increments added to iBfAt.
            AoLabels (dict): Mapping keyed by element symbol (string) providing the AO label information for the valence minimal basis as returned by MakeAtomInfos(). AoLabels supplies human- and program-readable orbital labels that higher-level code uses for indexing, diagnostics, and output.
    
    Behavior and side effects:
        This function calls MakeAtomInfos() to obtain the canonical per-element core and valence-minimal-basis orbital counts and labels used in the pyscf.lo.ibo module. It does not modify global state; it returns freshly constructed data structures. Atom identifiers supplied in Atoms are normalized by stripping all non-alphabetic characters before lookup. The returned iBfAt list encodes contiguous indexing of IB orbitals per atom and is suitable for indexing into global orbital arrays produced elsewhere in PySCF.
    
    Failure modes and notes:
        If an atom string, after stripping non-alphabetic characters, does not match any element key in the mappings returned by MakeAtomInfos(), a KeyError will be raised. If Atoms is not an iterable of string-like objects, iteration or character access will raise a TypeError. The function assumes MakeAtomInfos() returns consistent mappings (nCoreX, nAoX, AoLabels) compatible with the expected per-element minimal-basis counts; inconsistent or malformed data from MakeAtomInfos() may cause unexpected exceptions.
    """
    from pyscf.lo.ibo import MakeAtomIbOffsets
    return MakeAtomIbOffsets(Atoms)


################################################################################
# Source: pyscf.lib.numpy_helper.unpack_tril
# File: pyscf/lib/numpy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_numpy_helper_unpack_tril(
    tril: numpy.ndarray,
    filltriu: int = 1,
    axis: int = -1,
    out: numpy.ndarray = None
):
    """Reconstruct a full square matrix (or a batch of square matrices) from a packed lower-triangular representation used in PySCF.
    
    This function performs the inverse of pack_tril: given an array that holds the lower-triangular elements (packed format), unpack_tril returns a full square array (or array of square arrays) by placing the packed elements into the lower triangle and optionally filling the upper triangle according to filltriu. In PySCF this is commonly used to reconstruct matrices such as density matrices or integral blocks stored in compact lower-triangular form to save memory and I/O cost.
    
    Args:
        tril (numpy.ndarray): Input array containing packed lower-triangular elements. Accepted shapes:
            - 1-D of length n*(n+1)/2 representing a single packed lower-triangular matrix;
            - 2-D where one axis has length n*(n+1)/2 and the other axis indexes multiple packed matrices. The axis parameter selects which axis corresponds to the packed elements (axis == 0 means the first/leading axis has length n*(n+1)/2; axis == -1 or axis == tril.ndim-1 means the last axis has length n*(n+1)/2). The function computes n from the packed length using n = int(sqrt(2*packed_length)). The input is converted to a C-contiguous numpy array internally. The packed representation must correspond to a triangular number (n*(n+1)/2) for an integer n; otherwise the computed n will be incorrect and the behavior is undefined (it may raise an error or produce an incorrect output).
        filltriu (int): Controls how the upper-triangular portion of the returned matrix is filled from the lower-triangular input. This integer flag has the following meanings, matching constants used in the PySCF codebase:
            - 0: Do not fill the upper triangular part (the upper triangle of the output may contain uninitialized or arbitrary values).
            - 1 (default): Transpose the lower-triangular elements to fill the upper triangle, producing a Hermitian/symmetric matrix for real inputs.
            - 2: Fill the upper triangle with the negative conjugate (or negative transpose for real types) of the lower triangle to produce an anti-Hermitian matrix.
            Note: the implementation also recognizes a SYMMETRIC mode when unpacking along the leading dimension in order to enforce exact symmetric layout, and other code paths test for HERMITIAN/ANTIHERMI; use the integer constants defined in the module when possible to avoid ambiguity.
        axis (int): Axis in a 2-D packed input that indexes the packed lower-triangular vectors. For tril.ndim == 1 this is ignored. For tril.ndim == 2:
            - axis == 0: the first axis has length n*(n+1)/2 and the second axis is the batch count; the output shape will be (n, n, count) before being transposed/organized to (count, n, n).
            - axis == -1 or axis == tril.ndim - 1 (default): the last axis has length n*(n+1)/2 and the first axis is the batch count; the output shape will be (count, n, n).
            For higher-dimensional inputs (ndim > 2) the function raises NotImplementedError.
        out (numpy.ndarray): Optional writable buffer to use as the backing store for the output array. If provided, this object is passed as the buffer argument to numpy.ndarray(...) and must be compatible with the required output shape and dtype (otherwise numpy will raise an error). If out is None (default) a new numpy.ndarray is allocated and returned. When provided, the function returns a numpy view backed by the provided buffer.
    
    Returns:
        numpy.ndarray: Full square matrix or batch of full square matrices reconstructed from the packed lower-triangular input. The returned array dtype matches tril.dtype. Output shapes:
            - If tril is 1-D of length n*(n+1)/2: returns an array of shape (n, n).
            - If tril is 2-D and axis selects the packed dimension: returns an array of shape (count, n, n) where count is the number of packed vectors (i.e., number of matrices). For the special case where axis == 0 and unpacking is performed along the leading dimension, the returned shape is (n, n, ...) where ... corresponds to the remaining dimensions of tril after the packed dimension.
        The returned array contains the lower-triangular entries from tril placed into the lower triangle; the upper triangle is filled according to filltriu as described above. For float64 (numpy.double) and complex128 inputs, optimized native C helpers are used for the common last-axis / 1-D cases for performance; for other dtypes a numpy-based fill is used.
    
    Raises:
        NotImplementedError: If tril.ndim > 2.
        ValueError or other numpy errors: If the provided tril length is not compatible with any n*(n+1)/2 triangular number or if the provided out buffer is not compatible with the required shape/dtype. Behavior is undefined if tril does not encode a valid packed triangular size (the function computes n = int(sqrt(2*packed_length)) without an explicit integer check).
    """
    from pyscf.lib.numpy_helper import unpack_tril
    return unpack_tril(tril, filltriu, axis, out)


################################################################################
# Source: pyscf.lib.scipy_helper.pivoted_cholesky_python
# File: pyscf/lib/scipy_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lib_scipy_helper_pivoted_cholesky_python(
    A: numpy.ndarray,
    tol: float = -1.0,
    lower: bool = False
):
    """pyscf.lib.scipy_helper.pivoted_cholesky_python performs a pedestrian (pure-Python) pivoted Cholesky factorization with full column pivoting of a positive semidefinite matrix. It is intended for use within the PySCF quantum-chemistry framework to produce a low-rank Cholesky factor (for example, when decomposing positive semidefinite matrices that appear in density fitting or integral decompositions). This implementation should be used only when a LAPACK-optimized routine is unavailable, as it is significantly slower than optimized library calls.
    
    This routine constructs a triangular factor L by greedily selecting pivot indices and updating the residual diagonal D. The algorithm stops when the largest remaining diagonal element falls below the provided tolerance, producing a numerical rank and a permutation vector that records the pivot ordering. The returned factor and permutation can be used to form an approximate reconstruction of A after applying the permutation (see Returns).
    
    Args:
        A (numpy.ndarray): The input matrix to be factorized. Must be a square (N, N) numpy.ndarray and should represent a positive semidefinite (Hermitian) matrix arising in PySCF workflows (for example, overlap matrices, density-like matrices, or two-electron integral kernels represented on a grid or auxiliary basis). The implementation reads A but does not modify it in-place. The algorithm uses only the real part of A's diagonal to initialize the residual diagonal estimator.
        tol (float): Stopping tolerance for the pivoted Cholesky procedure. If tol < 0 (the default -1.0), the function sets tol = N * machine_epsilon * max(diag(A)) where machine_epsilon is numpy.finfo(numpy.double).eps and N is the matrix dimension. This default makes the stopping criterion scale with matrix size and the largest diagonal element, providing a relative numerical threshold appropriate for typical PySCF linear-algebra tasks. A smaller tol forces more pivots (larger numerical rank); a larger tol yields a lower-rank approximation.
        lower (bool): If True, return the lower-triangular Cholesky factor L (shape (N, N) with only the first `rank` columns typically nonzero). If False (default), return the conjugate transpose of that factor (an upper-triangular matrix). Choosing lower=True is the conventional Cholesky form; lower=False can be convenient when code expects an upper-triangular factor.
    
    Returns:
        factor (numpy.ndarray): A triangular factor with the same shape as A (N, N). If lower is True, this is the lower-triangular factor L produced by the algorithm such that the permuted matrix A[piv][:, piv] ≈ L @ L.conj().T up to the specified tolerance. If lower is False, this is L.conj().T (an upper-triangular factor) so that A[piv][:, piv] ≈ factor.conj().T @ factor. Only the first `rank` columns (for lower) or rows (for upper) are generally nonzero and contain the Cholesky basis.
        piv (numpy.ndarray): A one-dimensional numpy.ndarray of length N containing integer indices that record the pivot permutation applied to rows and columns of A. The permutation piv describes the order in which columns/rows were selected; applying this permutation to A (A[piv][:, piv]) yields the matrix that is approximated by the returned factorization.
        rank (int): The numeric rank determined by pivoting and the stopping tolerance. This is the number of pivots performed (0 <= rank <= N) and indicates how many columns/rows of the returned factor contain meaningful (non-negligible) information. In PySCF contexts, `rank` determines the effective low-rank size used to represent the original PSD matrix.
    
    Behavior and failure modes:
        - The function asserts that A is square and will raise an AssertionError if A.shape is not (N, N).
        - The algorithm assumes A is positive semidefinite (PSD) and numerically Hermitian. If A is not PSD or contains significant negative diagonal residuals, the internal residual diagonal D can become nonpositive, and the computation of a square root may produce NaNs or raise a runtime warning; results are then undefined.
        - No in-place modification of A is performed; internal temporary arrays are allocated (D, L, piv).
        - Because this is a pure-Python implementation using numpy operations, it is not optimized for large-scale problems; prefer LAPACK-based routines or library-provided Cholesky with pivoting for production-scale PySCF calculations.
    """
    from pyscf.lib.scipy_helper import pivoted_cholesky_python
    return pivoted_cholesky_python(A, tol, lower)


################################################################################
# Source: pyscf.lo.ibo.shell_str
# File: pyscf/lo/ibo.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lo_ibo_shell_str(l: int, n_cor: int, n_val: int):
    """pyscf.lo.ibo.shell_str constructs a space-separated label string that defines which atomic shells of a given angular momentum l are treated as core (bracketed) and which are treated as valence (unbracketed). This helper is used in the PySCF lo.ibo (localized / intrinsic bond orbital) context to build textual shell specifications for partitioning atomic orbitals into core and valence shells when preparing localization, orbital analysis, or shell-based selections in quantum-chemistry workflows within the PySCF framework.
    
    Detailed behavior: The function uses an internal pattern table (cor_shell) that maps angular momentum l to a template string (for example, l=0 -> "[{n}s]", l=1 -> "[{n}px] [{n}py] [{n}pz]", l=2 -> d-shell templates, l=3 -> f-shell templates). Core shell labels are formatted using these templates and remain enclosed in square brackets to mark them as "core" in downstream parsers; valence shell labels are the same templates but with the brackets removed. Principal quantum numbers are assigned sequentially beginning at n = l + 1; the function first emits n_cor core shells (in increasing principal quantum number order) and then n_val valence shells, joining all formatted labels with single spaces. The function does not modify external state and returns the constructed string.
    
    Args:
        l (int): Angular momentum index of the shell type to label. This integer selects which template in the internal pattern table to use (0 => s, 1 => p, 2 => d, 3 => f, etc., as available in the hard-coded table). The index must be a valid index into the internal pattern table; providing an l outside the table's range will raise an IndexError.
        n_cor (int): Number of core shells to produce for the selected angular momentum. Core shells are produced with principal quantum numbers n = l+1, l+2, ..., l+n_cor and are formatted using the core templates (kept in square brackets, e.g. "[4s]"). Supplying n_cor <= 0 yields no core entries (the function will simply omit core labels).
        n_val (int): Number of valence shells to produce for the selected angular momentum. Valence shells follow immediately after the core shells in principal quantum number, i.e. n = l+1+n_cor, ..., l+n_cor+n_val, and are formatted using the same templates with square brackets removed (e.g. "5s"). Supplying n_val <= 0 yields no valence entries.
    
    Returns:
        str: A single space-separated string containing the formatted core labels (bracketed) first, followed by the formatted valence labels (unbracketed). Example: shell_str(0, 1, 1) -> "[1s] 2s". Raising conditions: IndexError is raised if l is not a valid index into the internal pattern table; the function expects integer arguments for l, n_cor, and n_val. Negative n_cor or n_val do not raise exceptions in the implementation but result in omitted entries (no core/val shells produced for non-positive counts).
    """
    from pyscf.lo.ibo import shell_str
    return shell_str(l, n_cor, n_val)


################################################################################
# Source: pyscf.lo.orth.lowdin
# File: pyscf/lo/orth.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lo_orth_lowdin(s: numpy.ndarray):
    """Compute the Löwdin (symmetric) orthonormalization matrix for a basis with overlap matrix s.
    
    This function implements the Löwdin (symmetric) orthogonalization commonly used in quantum chemistry and in the PySCF framework to transform a non-orthogonal atomic-orbital (AO) basis into an orthonormal basis. Given the overlap matrix s (S_mu,nu = <mu|nu>), the function diagonalizes s, discards eigencomponents with eigenvalues at or below a numerical threshold (1e-15) to avoid division by (near) zero, and constructs the matrix c_lowdin = V_diag(1/sqrt(e)) V^H restricted to the retained subspace. The returned matrix c_lowdin can be used as the column matrix of new basis vectors so that the new basis |i> = sum_mu |mu> c_lowdin[mu,i] satisfies c_lowdin^H s c_lowdin = I on the retained subspace. In PySCF this is used during basis orthonormalization steps such as constructing orthonormal molecular orbitals from AO coefficients.
    
    Args:
        s (numpy.ndarray): Square overlap matrix S of the basis functions (S_mu,nu = <mu|nu>). This must be a numeric NumPy array; in practice it is the AO overlap matrix produced by PySCF routines. The function expects s to be Hermitian (s == s.conj().T) and positive semi-definite within numerical precision. The code diagonalizes s with scipy.linalg.eigh and therefore will raise an error if s is not square or if the underlying LAPACK call fails. Very small or zero eigenvalues (<= 1e-15) are treated as linear dependencies and are excluded from the returned transformation to avoid dividing by zero.
    
    Returns:
        numpy.ndarray: The Löwdin orthonormalization matrix c_lowdin (matrix of shape (n, m) where n is s.shape[0] and m is the number of eigenvalues > 1e-15). This matrix is formed as V[:,idx] / sqrt(e[idx]) @ V[:,idx].conj().T (equivalently V[:,idx] * diag(1/sqrt(e[idx])) * V[:,idx]^H). Practical properties: it is Hermitian on the retained subspace, and it satisfies c_lowdin^H @ s @ c_lowdin = I_m where I_m is the identity of size equal to the number of retained eigenvalues. There are no side effects; the input array s is not modified. Failure modes: if s is not square or not a valid Hermitian overlap matrix, scipy.linalg.eigh will raise an exception; if s has many eigenvalues below or near the 1e-15 threshold, the function will return a rank-reduced transformation (m < n), effectively discarding near-linear-dependent directions — users requiring a different regularization should post-process the eigenvalues or modify the threshold before constructing an orthonormal basis.
    """
    from pyscf.lo.orth import lowdin
    return lowdin(s)


################################################################################
# Source: pyscf.lo.nao.set_atom_conf
# File: pyscf/lo/nao.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lo_nao_set_atom_conf(element: str, description: list):
    """Change the default atomic core and valence shell configuration for an element in the NAO (numerical atomic orbital) AOSHELL mapping used by PySCF.
    
    This function is used by PySCF's localized-orbital / NAO utilities to override the default per-element core and core+valence shell counts stored in the data/elements.py AOSHELL table. It resolves the provided element to a nuclear charge using mole.charge(element) and updates AOSHELL[charge] in-place so subsequent NAO/basis logic uses the new core and valence shell counts. The update is also reported to standard error.
    
    Args:
        element (str or int): Element symbol (e.g. "C", "Fe") or nuclear charge (atomic number).
            This argument determines which row of the global AOSHELL table (data/elements.py)
            will be modified. mole.charge(element) is used to convert symbols to a charge;
            if the element cannot be resolved to a valid nuclear charge, mole.charge may
            raise an error (e.g. ValueError), and no modification will occur. Supplying the
            atomic number directly bypasses symbol lookup but must be a valid index into AOSHELL.
        description (str or a list of str): New configuration descriptor(s) that control
            how many core and valence shells of each angular momentum (s, p, d, f) are kept.
            When a single string is passed, it is interpreted as a valence-only modification
            and the existing core configuration is preserved. When a two-element list-like
            object is passed, the first entry specifies the core configuration and the
            second specifies the core+valence configuration. Recognized textual forms include:
                "double p", "double d", "double f"  -> increase the corresponding shell by a factor of two (mapped internally to "2p", "2d", "2f").
                "polarize"                         -> add one polarized shell (the function inspects the existing AOSHELL entry to determine which angular momentum to increment).
                explicit forms such as "1s1d"       -> set explicit counts (keep core unchanged then set specified valence shells).
                paired tuple examples like ("3s2p","1d") -> first element sets core (3 s, 2 p), second sets valence (1 d).
            The function normalizes description strings by removing spaces, hyphens, and underscores and lowercasing before interpretation. If a list-like description does not contain exactly two elements, or if the strings do not match the expected compact shell syntax, the function may raise IndexError or produce unintended results. The code expects AOSHELL entries in the format of digit-letter pairs for s, p, d, f (for example "2s1p0d0f"); if AOSHELL has a nonconforming format, integer parsing or indexing may fail.
    
    Returns:
        None: This function does not return a value. Instead, it has side effects: it updates the global AOSHELL mapping in data/elements.py (in-memory) at index AOSHELL[charge] to a two-element list [core_conf, core_plus_valence_conf], where each conf is a string formatted as "%ds%dp%dd%df". It also writes an informational message to standard error reporting the element and the new core and core+valence configurations. Possible failure modes include errors from mole.charge for unrecognized elements, IndexError when a provided description list lacks two entries, and ValueError or other exceptions if AOSHELL has unexpected formatting that prevents integer conversion.
    """
    from pyscf.lo.nao import set_atom_conf
    return set_atom_conf(element, description)


################################################################################
# Source: pyscf.lo.orth.vec_lowdin
# File: pyscf/lo/orth.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lo_orth_vec_lowdin(c: numpy.ndarray, s: numpy.ndarray = 1):
    """vec_lowdin(c, s=1)
    Performs Löwdin (symmetric) orthogonalization of the column space of a coefficient
    matrix c with respect to a metric s and returns the orthonormalized coefficient matrix.
    This routine is used in the PySCF electronic-structure context (for example in the
    lo.orth module and orbital localization routines) to transform a set of basis
    coefficients so that their columns are orthonormal with respect to the overlap/metric
    matrix S. Concretely, the routine forms the small metric M = c.conj().T @ s @ c,
    computes the Löwdin symmetric orthonormalization matrix X = lowdin(M), and returns
    c @ X. The implementation uses the conjugate transpose of c to support complex-valued
    coefficients and the identity scalar default for s for convenience when the metric is
    the standard Euclidean inner product.
    
    Args:
        c (numpy.ndarray): Coefficient matrix whose column vectors define the subspace to be
            orthonormalized. In electronic-structure usage this is typically a 2-D array of
            shape (n_basis, n_vectors) containing molecular-orbital or atomic-orbital
            expansion coefficients. The columns of c span the subspace that will be
            orthonormalized; the function does not change that subspace, only produces a
            transformed set of orthonormal vectors that span it. Complex-valued entries are
            supported; the routine uses the conjugate transpose c.conj().T when forming the
            metric in the subspace.
        s (numpy.ndarray): Metric (overlap) matrix with respect to which orthonormality is
            defined. In quantum-chemistry applications this is typically the atomic-orbital
            overlap matrix S of shape (n_basis, n_basis). The default value 1 (the scalar
            integer provided in the function signature) is treated as the identity metric,
            i.e., c.conj().T @ 1 @ c reduces to the usual Euclidean inner product in the
            coefficient space. When provided as a numpy.ndarray, s must be compatible with c
            for matrix multiplication (s should have shape (n_basis, n_basis) when c has
            shape (n_basis, n_vectors)). For physically meaningful Löwdin orthonormalization,
            the metric that enters the small subspace matrix M = c.conj().T @ s @ c should be
            Hermitian (s ≈ s.conj().T) and positive definite (or at least positive
            semidefinite with care); if M is singular or numerically ill-conditioned the
            orthonormalization can fail or produce unstable results.
    
    Returns:
        numpy.ndarray: The transformed coefficient matrix cX = c @ X where X is the Löwdin
            symmetric orthonormalization matrix computed from M = c.conj().T @ s @ c.
            The returned array has the same shape as c and its columns are orthonormal with
            respect to the metric s (i.e., (cX).conj().T @ s @ (cX) ≈ I within numerical
            tolerance). The function has no side effects on the input arrays c or s; it
            allocates and returns a new numpy.ndarray. Possible failure modes include shape
            mismatches for matrix multiplication and numerical failures when the subspace
            metric M is singular or ill-conditioned; such conditions typically raise errors
            from the underlying linear-algebra routines (e.g., in lowdin or numpy).
    """
    from pyscf.lo.orth import vec_lowdin
    return vec_lowdin(c, s)


################################################################################
# Source: pyscf.lo.orth.weight_orth
# File: pyscf/lo/orth.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_lo_orth_weight_orth(s: numpy.ndarray, weight: numpy.ndarray):
    """pyscf.lo.orth.weight_orth: Construct weight-scaled Lowdin-orthonormalization coefficients for a given overlap matrix.
    
    This function constructs a new set of basis-coefficient vectors c_{mu,i} that define orthonormal basis functions under the original atomic-orbital overlap matrix s, after applying a multiplicative weight per basis function. It implements the transformation
    c = w * [ (w s w)^{-1/2} ],
    where w is the diagonal weighting defined by the 1D array weight, s is the square overlap matrix, and (w s w)^{-1/2} is obtained by the Lowdin symmetric orthonormalization of the weighted overlap matrix s1 = w s w. In PySCF this routine is used in localized orbital and basis-transformation utilities to produce a new basis |mu> c_{mu i} whose columns are orthonormal with respect to the original quantum-chemical overlap s (i.e., c^T s c = I), enabling downstream procedures that require an orthonormal representation (for example, population analysis, projector construction, or subsequent orthogonal transformations in electronic structure workflows).
    
    Args:
        s (numpy.ndarray): Square overlap matrix of the original non-orthogonal basis. This is the atomic-orbital overlap matrix used in electronic-structure calculations; it must be a two-dimensional square array with shape (n, n) where n is the number of basis functions. The routine treats s as the metric for inner products: the output coefficients satisfy c.T @ s @ c = I when Lowdin orthogonalization succeeds. If s is not symmetric positive-definite (for example, if it has zero or negative eigenvalues), the underlying Lowdin procedure may fail or produce non-physical results.
        weight (numpy.ndarray): One-dimensional array of multiplicative weights w applied to basis functions. This must have length n and real entries; it defines a diagonal scaling matrix W with W_{mu,mu} = weight[mu]. The function forms the weighted overlap s1 = W @ s @ W by elementwise multiplication weight[:,None] * s * weight, then orthonormalizes s1 and finally multiplies the orthonormalization matrix by W to return the final coefficients. The weights are typically used in PySCF to bias, scale, or normalize basis functions prior to orthogonalization (for example, to impose atomic-centered damping or population-derived scaling).
    
    Returns:
        numpy.ndarray: Coefficient matrix c of shape (n, n) giving new basis vectors expressed in the original basis and scaled by weight. Each column i corresponds to a new basis vector |i> = sum_mu |mu> c_{mu,i}. When the weighted overlap s1 = W s W is suitable for Lowdin orthogonalization, the returned c satisfies c.T @ s @ c = I, i.e., the columns are orthonormal with respect to s. No in-place modification of the inputs is performed.
    
    Behavior, side effects, and failure modes:
        The function computes s1 = weight[:,None] * s * weight, calls the Lowdin orthogonalization routine on s1 to obtain X = (s1)^{-1/2} in the symmetric Lowdin sense, and returns weight[:,None] * X. There are no other side effects (no global state changes). Typical failure modes include:
        - Shape mismatch: if weight.shape[0] != s.shape[0] or s is not square, numpy broadcasting or matrix operations will raise an error (ValueError or IndexError).
        - Non-positive-definite s1: if the weighted overlap s1 has zero or negative eigenvalues, the Lowdin procedure may raise a linear-algebra error or produce numerically unstable/complex results; callers should ensure s and weight produce a physically meaningful, positive-definite s1 for reliable orthonormalization.
        - Non-symmetric s: if s is numerically non-symmetric, results may be incorrect; s should represent a symmetric overlap matrix from a quantum-chemical calculation.
    
    Practical significance:
        In the context of PySCF (a Python-based electronic-structure framework), weight_orth is a small utility used by localization and orthogonalization routines to obtain orthonormal orbital representations after applying per-basis-function scalings. The output can be directly used as transformation coefficients to convert density matrices, Fock matrices, or other operators into the new orthonormal basis for further electronic-structure computations.
    """
    from pyscf.lo.orth import weight_orth
    return weight_orth(s, weight)


################################################################################
# Source: pyscf.mcpdft._dms.dm2_cumulant
# File: pyscf/mcpdft/_dms.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_mcpdft__dms_dm2_cumulant(dm2: numpy.ndarray, dm1s: numpy.ndarray):
    """pyscf.mcpdft._dms.dm2_cumulant computes the spin‑summed two‑body cumulant reduced density matrix (cm2) used in PySCF's multiconfiguration pair-density functional theory (MCPDFT) code paths. The cumulant isolates correlated two‑particle contributions by removing the disconnected (mean‑field) product of one‑particle density matrices from the spin‑summed two‑particle reduced density matrix (2‑RDM). This routine is used in quantum chemistry workflows implemented in the PySCF framework (see project README) wherever a two‑body cumulant is required for correlation analysis, on‑top pair density evaluation, or input to MCPDFT energy expressions.
    
    Args:
        dm2 (ndarray of shape [norb,]*4): Contains the spin‑summed two‑particle reduced density matrix (2‑RDM) with orbital index ordering [p, q, r, s]. Each axis corresponds to one orbital index in the conventional chemists' notation. This array provides the full spin‑summed 2‑RDM from which the cumulant is formed; its dtype is typically float or complex depending on how the 2‑RDM was produced. The function treats dm2 as immutable and operates on a copy internally, so the passed array is not modified by the call.
        dm1s (ndarray (or compatible) of overall shape [2,norb,norb]): Contains spin‑separated one‑particle reduced density matrices (1‑RDMs) as two blocks: dm1s[0] for alpha spin and dm1s[1] for beta spin, each with indices [p,s] consistent with dm2 indexing. As a convenience, if a two‑dimensional spin‑summed 1‑RDM of shape [norb,norb] is supplied instead (len(shape) < 3), the function interprets it as the spin‑summed 1‑RDM and splits it equally into two spin blocks by dividing by two and stacking to form an effective shape [2,norb,norb]. The input may be any array‑like object convertible to numpy.asarray; the function will copy or reinterpret this data as needed but does not modify the original object provided by the caller.
    
    The routine implements the elementwise relation used in MCPDFT and related many‑body formulations:
    cm2[p,q,r,s] = dm2[p,q,r,s] - dm1[p,q]*dm1[r,s] + dm1s[0][p,s]*dm1s[0][r,q] + dm1s[1][p,s]*dm1s[1][r,q]
    where dm1 = dm1s[0] + dm1s[1] is the spin‑summed 1‑RDM. Internally, outer products and transposes are used to construct the required four‑index tensors efficiently. No side effects occur on the input arrays; a new ndarray is returned.
    
    Behavior and failure modes: The function assumes consistent orbital dimensions: dm2 must have four axes of equal length (norb) and dm1s must either be shape [2,norb,norb] or shape [norb,norb] (in which case it will be interpreted as the spin‑summed 1‑RDM and split). If dm1s has fewer than 2 spin blocks (shape[0] < 2) or if the orbital dimensions are inconsistent between dm2 and dm1s, numpy indexing, broadcasting, or arithmetic operations will raise IndexError or ValueError. TypeErrors may be raised if inputs cannot be converted to numeric ndarray objects. The function preserves numeric dtype where possible but operations such as division by 2 (when a spin‑summed dm1 is supplied) may promote integer types to floating point.
    
    Returns:
        cm2 (ndarray of shape [norb,]*4): The computed spin‑summed two‑body cumulant reduced density matrix with the same orbital index ordering [p, q, r, s] as dm2. This returned array is a new object (a copy) and contains the correlated two‑particle contributions used downstream in MCPDFT and other PySCF routines.
    """
    from pyscf.mcpdft._dms import dm2_cumulant
    return dm2_cumulant(dm2, dm1s)


################################################################################
# Source: pyscf.mcpdft._dms.dm2s_cumulant
# File: pyscf/mcpdft/_dms.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_mcpdft__dms_dm2s_cumulant(dm2s: numpy.ndarray, dm1s: numpy.ndarray):
    """pyscf.mcpdft._dms.dm2s_cumulant computes the spin-summed two-body cumulant reduced density matrices (cm2s) from spin-separated one- and two-particle reduced density matrices. This routine is used in the mcpdft (multiconfiguration pair-density functional theory) workflow within PySCF to extract the non-separable (cumulant) part of the two-particle RDM required for constructing correlation/energy contributions that go beyond the mean-field separable product of 1-RDMs.
    
    Args:
        dm2s (ndarray of shape [norb,]*4): Contains the spin-separated 2-RDMs used as input for the cumulant evaluation. Practically this argument provides the two-particle reduced density information for the system resolved into spin components (conventionally ordered as aa, ab, bb). Each component is a 4-index array with orbital indices ordered p, q, r, s. The values represent expectation values <a_p^† a_q^† a_s a_r> (or equivalent ordering used in the surrounding code) and are required to compute the non-separable two-body correlations. The function will iterate over this container and makes a copy of each component; the original dm2s arrays passed by the caller are not modified by this function.
    
        dm1s (ndarray (or compatible) of overall shape [2,norb,norb]): Contains the spin-separated 1-RDMs used to form the separable (product) part to be subtracted from dm2s. The two spin blocks correspond to spin-up (alpha) and spin-down (beta) one-particle density matrices and have orbital index order p, q. In common use within mcpdft, dm1s supplies the marginal one-electron densities used to form outer products that approximate the separable piece of the 2-RDM. If dm1s is provided as a lower-rank array (for example a spin-summed 2D 1-RDM of shape [norb,norb]), the function will interpret that array as the total 1-RDM, divide it by 2, and duplicate it to form two identical spin blocks (np.stack((dm1/2, dm1/2), axis=0)). The input is converted with np.asarray; if shapes are inconsistent with dm2s (mismatched orbital dimension or incompatible broadcasting), a NumPy exception will be raised.
    
    Behavior and algorithmic details:
        The function constructs the cumulant components cm2s from dm2s and dm1s by removing the separable product contributions of the 1-RDMs and adding the exchange term for like-spin channels. Concretely (using index notation p,q,r,s and spin components aa, ab, bb):
        cm2s[0][p,q,r,s] = dm2s[0][p,q,r,s] - dm1s[0][p,q]*dm1s[0][r,s] + dm1s[0][p,s]*dm1s[0][r,q]
        cm2s[1][p,q,r,s] = dm2s[1][p,q,r,s] - dm1s[0][p,q]*dm1s[1][r,s]
        cm2s[2][p,q,r,s] = dm2s[2][p,q,r,s] - dm1s[1][p,q]*dm1s[1][r,s] + dm1s[1][p,s]*dm1s[1][r,q]
        In the implementation, the separable terms are formed with outer products (np.multiply.outer) of the 1-RDM spin blocks and the like-spin exchange contributions are added by transposing the outer product with axes (0, 3, 2, 1). The function copies the dm2s components before modification to avoid in-place changes to caller data.
    
    Side effects and defaults:
        The function calls np.asarray on dm1s and will create temporary arrays when dm1s is spin-summed (auto-divides by 2 and stacks to two spin blocks). It creates copies of the dm2s components via .copy() and returns new arrays; inputs are not modified. No global state or external resources are changed.
    
    Failure modes and errors:
        If dm2s is not an iterable of three 4-index arrays or its contained arrays do not have the expected four orbital indices, the code will raise an IndexError or TypeError when attempting to copy/index components. If the orbital dimension (norb) implied by dm2s components and dm1s do not match, NumPy broadcasting or shape-mismatch errors will be raised during the outer-product operations or arithmetic. Passing non-numeric or non-array-like objects that cannot be converted by np.asarray may raise a TypeError.
    
    Returns:
        tuple of ndarrays: A length-3 tuple (cm2s_aa, cm2s_ab, cm2s_bb) where each element is an ndarray of shape [norb,]*4 containing the cumulant (non-separable) part of the two-particle reduced density matrix for the corresponding spin channel. The components are returned in the order aa, ab, bb and are suitable for use in subsequent mcpdft energy and property evaluations that require the two-body cumulant.
    """
    from pyscf.mcpdft._dms import dm2s_cumulant
    return dm2s_cumulant(dm2s, dm1s)


################################################################################
# Source: pyscf.mcpdft._libxc.split_x_c_comma
# File: pyscf/mcpdft/_libxc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_mcpdft__libxc_split_x_c_comma(xc: str):
    """Split an xc code string into two separate identifiers: one for exchange and one for
    correlation, used by the PySCF mcpdft._libxc plumbing that maps user-specified
    XC identifiers to LibXC exchange/correlation components. The function locates a
    comma in the input string or in any alias/lookup it resolves, upper-cases the
    input for alias matching, consults module tables for numeric LibXC codes and
    aliases (XC_ALIAS, XC_CODES, XC_KEYS, INTCODES_TYPES, INTCODES_HYB), and enforces
    a recursion limit when expanding aliases. This is used when parsing an
    xc specification passed to higher-level MCPDFT/DFT routines so that the exchange
    and correlation parts can be handled separately by LibXC or other backends.
    
    Args:
        xc (str): The user-supplied XC code string to split. In practical PySCF
            use this is the textual identifier for a density-functional
            approximation (for example a LibXC name, an alias, or a numeric code
            mapped to a LibXC functional). The function treats an empty string
            specially (returns two empty strings), converts the input to upper
            case for alias/code lookup, and accepts strings that already contain a
            comma separating exchange and correlation. The parameter is read-only;
            no other parameters are modified.
    
    Returns:
        tuple[str, str]: A two-element sequence (exchange, correlation) where each
            element is the substring extracted for the exchange (first element)
            and correlation (second element) components respectively. Typical
            return values are the result of splitting the (possibly aliased)
            input on a single comma. For an empty input string this returns ('', '').
            The returned strings are the identifiers to be passed to LibXC lookup
            or further parsing in MCPDFT workflows.
    
    Raises:
        XCSplitError: Raised when the input cannot be resolved to a distinct
            exchange/correlation pair. Specific failure modes that raise this
            error (with contextual message) include: encountering a LibXC built-in
            hybrid (INTCODES_HYB), encountering a LibXC built-in combined X+C
            functional, encountering a kinetic-energy-only functional (type 'K'),
            encountering an unknown functional type for a numeric code, an unknown
            code or alias that is not present in XC_ALIAS/XC_CODES/XC_KEYS, or
            exceeding the maximum alias-recursion depth. The exception object is
            extended with the intermediate values tried during alias/code expansion,
            which aids debugging in MCPDFT code paths.
    
    Behavioral notes and side effects:
        - If xc already contains a comma, the function returns the result of
          splitting that string on the comma (typically yielding two substrings).
        - If xc is empty (len(xc) == 0) the function returns ('', '') immediately.
        - The function converts xc to upper case before alias and code lookups to
          support case-insensitive aliases defined in XC_ALIAS and XC_KEYS.
        - The function attempts up to five recursive alias/code expansions (the
          module-level constant max_recurse = 5). If no comma is produced within
          that depth, XCSplitError is raised with message 'Maximum XC alias recursion depth'.
        - The function consults module tables and helper lib.isinteger to decide
          how to place a comma when a numeric LibXC code is encountered (INTCODES_*).
        - No external state is mutated by this function other than the contents of
          the XCSplitError instance used for error reporting; it performs only
          lookups and string transformations.
    """
    from pyscf.mcpdft._libxc import split_x_c_comma
    return split_x_c_comma(xc)


################################################################################
# Source: pyscf.mcpdft.mspdft.get_diabfns
# File: pyscf/mcpdft/mspdft.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_mcpdft_mspdft_get_diabfns(obj: str):
    """Return a pair of callables (diabatizer, diabatize) appropriate for the requested
    MS-PDFT method name. The pair implements (1) evaluation of the MS-PDFT
    objective function and its first and second derivatives (the second-order power
    series used by Newton-like optimizers) and (2) the transformation/optimization
    that produces CI vectors in the optimized intermediate-state (diabatic) basis.
    This helper is used in the MS-PDFT (multistate pair-density functional theory)
    components of PySCF to select method-specific implementations: for "CMS" the
    function returns the Coulomb-energy-based diabatizer and a local Newton solver
    for intermediate-state optimization; for "XMS" the function returns the
    state-averaged Fock-based diabatizer and its corresponding solver.
    
    Args:
        obj (str): Name of the MS-PDFT method to select. This string controls which
            implementation pair is returned. The comparison is case-insensitive.
            Currently supported values (exactly as implemented in the source code)
            are "CMS" and "XMS". When obj.upper() == "CMS", the function returns
            pyscf.mcpdft.cmspdft.e_coul as the diabatizer and the local si_newton
            solver as diabatize; these callables are intended to: take model-space
            CI vectors given in a trial intermediate-state basis, evaluate the
            CMS-specific objective function (energy-like quantity) and provide its
            first and second derivatives (diabatizer), and perform Newton-style
            optimization to produce CI vectors in the optimized intermediate-state
            basis (diabatize). When obj.upper() == "XMS", the function returns
            pyscf.mcpdft.xmspdft.safock_energy as the diabatizer and
            pyscf.mcpdft.xmspdft.solve_safock as diabatize; these are the XMS
            equivalents used to evaluate the state-averaged Fock objective and to
            compute the optimized intermediate-state CI vectors. The function
            performs dynamic imports of the selected implementation modules as a
            side effect.
    
    Returns:
        tuple: A pair (diabatizer, diabatize) of callables selected for the
            requested MS-PDFT method. diabatizer (callable) takes model-space CI
            vectors expressed in a trial intermediate-state basis and returns the
            objective function value together with its first and second
            derivatives required to form the second-order power series used by
            optimizers. diabatize (callable) takes model-space CI vectors (typically
            in the original or trial basis) and returns CI vectors transformed into
            the optimized intermediate-state (diabatic) basis. These callables are
            the primary interfaces used elsewhere in the PySCF MS-PDFT code path to
            evaluate method-specific objective functions and to perform the
            intermediate-state optimization/diabatization.
    
    Raises:
        RuntimeError: If obj does not correspond to a supported MS-PDFT type
            (i.e., not "CMS" or "XMS" when compared case-insensitively). In that
            case no callables are returned and the caller must handle the error.
    """
    from pyscf.mcpdft.mspdft import get_diabfns
    return get_diabfns(obj)


################################################################################
# Source: pyscf.mcpdft.otfnal.unregister_otfnal
# File: pyscf/mcpdft/otfnal.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_mcpdft_otfnal_unregister_otfnal(xc_code: str):
    """Unregister an on-top functional previously registered for MC-PDFT calculations.
    
    This function removes a custom on-top functional from PySCF's module-level registry and from the underlying libxc custom functional registry so that the functional will no longer be available to subsequent multiconfiguration pair-density functional theory (MC-PDFT) calculations. In the PySCF MC-PDFT workflow, on-top functionals encode pair-density–dependent contributions to the total energy; unregistering is used when a previously registered custom functional (for example, added via a corresponding registration API) must be removed to avoid name collisions or to revert to built-in behavior.
    
    Args:
        xc_code (str): The identifier (name/code) of the on-top functional to be unregistered. The function performs a case-insensitive lookup by uppercasing this value (xc_code.upper()) and uses that uppercased code as the key into the module-level REG_OT_FUNCTIONALS registry. xc_code must match exactly the identifier used when the functional was registered.
    
    Behavior and side effects:
        If the uppercased xc_code is present in REG_OT_FUNCTIONALS, the function calls libxc.unregister_custom_functional_(libxc_unregister_code) using the uppercased code and then deletes the entry REG_OT_FUNCTIONALS[xc_code.upper()]. These operations mutate module-level state (REG_OT_FUNCTIONALS) and interact with the external libxc library to remove the custom functional definition. If the uppercased code is not present in REG_OT_FUNCTIONALS, the function performs no action (no-op) and returns normally. Callers should be aware that the function is not synchronized for concurrent access; concurrent modifications to REG_OT_FUNCTIONALS from multiple threads or processes may lead to race conditions.
    
    Returns:
        None: This function does not return a value. Its effect is performed via side effects: removing the specified functional from the REG_OT_FUNCTIONALS dictionary and unregistering it from libxc's custom functional registry.
    
    Raises:
        RuntimeError: If unregistration fails for any reason (for example, if libxc.unregister_custom_functional_ raises an exception or if deletion from REG_OT_FUNCTIONALS fails), the function catches the original exception and raises a RuntimeError with a message of the form "Failed to unregister functional '<xc_code>': <original error>" and chains the original exception for debugging.
    """
    from pyscf.mcpdft.otfnal import unregister_otfnal
    return unregister_otfnal(xc_code)


################################################################################
# Source: pyscf.mcpdft.otfnal.make_scaled_fnal
# File: pyscf/mcpdft/otfnal.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_mcpdft_otfnal_make_scaled_fnal(
    xc_code: str,
    hyb_x: float = 0,
    hyb_c: float = 0,
    fnal_x: float = None,
    fnal_c: float = None
):
    """make a new libxc-style exchange-correlation code string that scales and mixes
    wavefunction and density-functional components for use in PySCF MCPDFT
    (on-top functional) workflows.
    
    This function constructs an xc_code string that represents a functional of the
    form
    Exc = hyb_x * E_x[Psi] + fnal_x * E_x[rho] + hyb_c * E_c[Psi] + fnal_c * E_c[rho],
    where E_x[Psi]/E_c[Psi] are exchange/correlation energy contributions obtained
    from a wave function (Psi) and E_x[rho]/E_c[rho] are exchange/correlation
    density functionals evaluated by libxc (rho). This is used in the PySCF
    mcpdft.otfnal context to build mixed functionals that combine explicit
    wavefunction exchange/correlation (e.g., HF exchange or multiconfigurational
    wave function components) with density-functional contributions provided by
    libxc. The decomposition of any wavefunction energy E[Psi] into exchange (E_x)
    and correlation (E_c) parts is arbitrary and must be consistent with how the
    caller interprets those components.
    
    Args:
        xc_code (str): libxc-style xc identifier string as used by pyscf.dft.libxc.
            This string must represent a non-hybrid density functional and must
            not include a kinetic-energy functional component. The function will
            parse xc_code into separate exchange and correlation formulas using
            libxc helpers (split_x_c_comma and parse_xc_formula). If xc_code is
            already a hybrid according to libxc, a RuntimeError is raised.
        hyb_x (float): fraction of the exchange contribution taken from the
            wavefunction (E_x[Psi]). Typical values are in [0,1] but the function
            does not enforce numeric bounds beyond Python float semantics. Default
            is 0. A nonzero hyb_x causes an 'HF' term with coefficient hyb_x to be
            appended to the assembled exchange formula.
        hyb_c (float): fraction of the correlation contribution taken from the
            wavefunction (E_c[Psi]). Typical values are in [0,1] but the function
            does not enforce numeric bounds beyond Python float semantics. Default
            is 0. A nonzero hyb_c causes an 'HF' term with coefficient hyb_c to be
            appended to the assembled correlation formula.
        fnal_x (float or None): fraction of the exchange contribution taken from
            the density functional (E_x[rho]). If None (the default) it is set to
            1 - hyb_x. When fnal_x != 1, all parsed exchange factor coefficients
            from xc_code are multiplied by fnal_x before any HF term for hyb_x is
            appended. This scales the contribution of the libxc exchange functional
            relative to the wavefunction exchange fraction hyb_x.
        fnal_c (float or None): fraction of the correlation contribution taken
            from the density functional (E_c[rho]). If None (the default) it is
            set to 1 - hyb_c. When fnal_c != 1, all parsed correlation factor
            coefficients from xc_code are multiplied by fnal_c before any HF term
            for hyb_c is appended. This scales the contribution of the libxc
            correlation functional relative to the wavefunction correlation
            fraction hyb_c.
    
    Behavior and side effects:
        The function uses libxc helper routines in pyscf.dft.libxc to
        (1) split the input xc_code into exchange and correlation components,
        (2) parse each component into numeric coefficients and term identifiers,
        (3) scale the numeric coefficients for the density-functional parts by
        fnal_x/fnal_c when those are not 1, and (4) append HF terms with
        coefficients hyb_x/hyb_c when the corresponding hybrid fractions are
        nonzero. The assembled exchange and correlation formulas are reconstituted
        with libxc. The final return value is the concatenation "exchange_code,correlation_code".
        The function does not modify global state or external files; its only side
        effect is that it may call libxc parsing/assembly utilities. The caller is
        still responsible for any additional prefixes required by downstream code:
        in existing PySCF conventions the caller often needs to prepend 't' or
        'ft' to the returned string when building on-top functionals for MCPDFT.
    
    Defaults:
        If fnal_x is None it is computed as 1 - hyb_x. If fnal_c is None it is
        computed as 1 - hyb_c. hyb_x and hyb_c default to 0.
    
    Failure modes (exceptions and error conditions):
        RuntimeError is raised if pyscf.dft.libxc reports that xc_code is already a
        hybrid functional (the function refuses to re-hybridize an already hybrid
        libxc identifier). Parsing and assembly operations may also raise exceptions
        propagated from pyscf.dft.libxc or NumPy if the input xc_code cannot be
        parsed or if non-numeric operations fail (for example, incompatible list
        lengths returned by libxc parsers). The function does not validate numeric
        ranges for hyb_x/hyb_c/fnal_x/fnal_c beyond using them in arithmetic; the
        caller should ensure these fractions are appropriate for their physical
        model.
    
    Returns:
        str: A libxc-style xc code string representing the scaled/mixed functional.
        The format is 'exchange_formula,correlation_formula' where each formula has
        been assembled by libxc routines and may contain coefficients and term
        identifiers (for example an appended 'HF' term when hyb_x or hyb_c is
        nonzero). Note that the returned string is the raw formula; callers that
        integrate this into PySCF MCPDFT workflows may need to prepend 't' or 'ft'
        or otherwise wrap the string per the calling convention used elsewhere in
        PySCF.
    """
    from pyscf.mcpdft.otfnal import make_scaled_fnal
    return make_scaled_fnal(xc_code, hyb_x, hyb_c, fnal_x, fnal_c)


################################################################################
# Source: pyscf.mcpdft.tfnal_derivs.contract_vot
# File: pyscf/mcpdft/tfnal_derivs.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_mcpdft_tfnal_derivs_contract_vot(
    vot: tuple,
    rho: numpy.ndarray,
    Pi: numpy.ndarray
):
    """Evalute the product of unpacked vot with perturbed density, pair density, and their derivatives on numerical integration grids used by the MC-PDFT tfnal_derivs workflow in PySCF. This function is used in multi-configuration pair-density functional theory (MC-PDFT) derivative code to form the grid-wise scalar contraction between the functional derivative arrays (vot) and the local electron density and on-top pair density (and their spatial/auxiliary derivatives) required by TF-NAL style functional derivative expressions.
    
    Args:
        vot ((ndarray of shape (*,ngrids), ndarray of shape (*, ngrids))): format is (vrho, vPi). vrho and vPi are the unpacked functional derivative arrays with respect to the electron density (rho) and the on-top pair density (Pi), respectively. Each of vrho and vPi has a leading index enumerating the scalar component (index 0) and, when present, derivative components (indices 1:4 correspond to up to three derivative components used by gradient-dependent functionals). The documented formats used by callers are: ftGGA: a=4, b=4 (vrho has 4 rows, vPi has 4 rows); tGGA: a=4, b=1 (vrho has 4 rows, vPi has 1 row); *tLDA: a=1, b=1 (vrho and vPi each have 1 row). The second axis length must equal ngrids, the number of integration grid points. This argument is the primary input representing how the energy functional responds to perturbations in rho and Pi and their derivatives on each grid point.
        rho (ndarray of shape (*,ngrids)): containing density [and derivatives]. The leading axis indexes the scalar density and, if present, its derivative components (same convention as vot). If the caller provides two spin components stacked on the leading axis (shape[0] == 2), the function sums them (rho.sum(0)) to form the total density before contraction; this implements the routine's expectation of total density input for the TF-NAL contraction. If rho is one-dimensional (ndim == 1), it is treated as a single scalar row and promoted to shape (1, ngrids). The entries represent the local electron density and its derivatives on the integration grid to be contracted with vrho.
        Pi (ndarray of shape (*,ngrids)): containing on-top pair density [and derivatives]. The leading axis indexes the scalar on-top pair density and, if present, its derivative components (same convention as vot and rho). If Pi is one-dimensional (ndim == 1), it is promoted to shape (1, ngrids). The entries represent the local on-top pair density and its derivatives on the integration grid to be contracted with vPi.
    
    Behavior and side effects:
        The function normalizes input shapes so that rho and Pi have a leading component-axis and a grid-axis: single-row inputs are promoted to shape (1, ngrids); two-row rho inputs are interpreted as spin components and summed to form total density. The contraction performed is elementwise on the grid axis: the scalar (index 0) contributions vrho[0]*rho[0] and vPi[0]*Pi[0] are included, and if derivative components are present (vrho and/or vPi have length > 1), the function adds the sum over derivative components (indices 1:4) of the elementwise products (vrho[1:4,:] * rho[1:4,:]).sum(0) and (vPi[1:4,:] * Pi[1:4,:]).sum(0). The output is a new ndarray; inputs are not modified in-place by this routine. The function assumes the second axis length (ngrids) is identical across vot components, rho, and Pi; mismatched grid lengths, insufficient component axes in vrho or vPi relative to the intended functional form, or incompatible array dimensionality will raise standard NumPy exceptions (IndexError or ValueError) from array operations.
    
    Returns:
        cvot (ndarray of shape (ngrids)): grid-wise scalar array equal to the sum of contractions of vrho with rho and vPi with Pi, including scalar and available derivative components as described above. This array is the quantity used by higher-level MC-PDFT derivative code to integrate the contribution of vot against the perturbed density and on-top pair density over numerical integration grids.
    """
    from pyscf.mcpdft.tfnal_derivs import contract_vot
    return contract_vot(vot, rho, Pi)


################################################################################
# Source: pyscf.mcpdft.otfnal.register_otfnal
# File: pyscf/mcpdft/otfnal.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_mcpdft_otfnal_register_otfnal(xc_code: str, preset: dict):
    """pyscf.mcpdft.otfnal.register_otfnal registers a new on-top (OT) density functional
    with the libxc backend so that the functional can be used by PySCF's
    multiconfigurational pair-density functional theory (MCPDFT) workflows.
    
    This function is used when developers or advanced users need to make a
    custom on-top functional available to PySCF (for example, to test new
    parameterizations or to expose a composite functional built from an
    underlying Kohn–Sham LibXC functional). The function delegates the actual
    registration to libxc.register_custom_functional_ and records hybrid
    mixing information in the module-level registry REG_OT_FUNCTIONALS so
    that subsequent MCPDFT code can query hybrid fractions for exchange and
    correlation.
    
    Args:
        xc_code (str): The user-facing name of the on-top functional to register.
            This string is the identifier used by calling code and is normalized
            to uppercase before calling libxc. Its practical role is to act as
            the registration key so that MCPDFT routines can request the
            corresponding on-top functional by name.
        preset (dict): A dictionary containing registration parameters that
            describe the on-top functional. This dictionary must contain the
            following keys and may contain optional keys used by libxc:
                xc_base (str): The name of the underlying Kohn–Sham LibXC functional
                    (the base functional in libxc) on which the on-top functional
                    is built. This key is required and is passed unchanged to
                    libxc.register_custom_functional_ as the base functional name.
                ext_params (dict): A mapping whose keys are LibXC integer functional
                    IDs and whose values are array-like parameter vectors for those
                    LibXC sub-functionals. This key is required and is passed to
                    libxc.register_custom_functional_ as ext_params; it encodes
                    functional-specific numerical parameters required by the
                    custom functional.
                hyb (tuple, optional): Hybrid functional parameters. If present,
                    this tuple supplies hybrid mixing coefficients used by the
                    custom functional and is forwarded to libxc.register_custom_functional_
                    as hyb. If omitted, the code passes None to libxc and the
                    function uses a fallback of 0.0 when recording values in
                    REG_OT_FUNCTIONALS.
                facs (tuple, optional): Mixing factors forwarded to
                    libxc.register_custom_functional_. If omitted, None is passed
                    to libxc.
            Note: the original project documentation also mentions a possible
            kwargs dict of additional options; however, this function forwards
            only the named keys documented above to libxc. The preset dictionary
            is used only for registration metadata and does not itself become the
            runtime functional object.
    
    Behavior and side effects:
        The function converts xc_code to uppercase to form libxc_register_code
        and reads required values from preset ('xc_base' and 'ext_params').
        It calls libxc.register_custom_functional_(libxc_register_code,
        libxc_base_code, ext_params=ext_params, hyb=hyb, facs=facs) which performs
        the backend registration with the LibXC library used by PySCF. After a
        successful call to libxc, the function updates the module-level mapping
        REG_OT_FUNCTIONALS with an entry keyed by xc_code.upper(), storing
        'hyb_x' and 'hyb_c' both set to the first element of preset.get('hyb',
        [0])[0] (i.e., a fallback of 0.0 is used when 'hyb' is absent). These
        stored hybrid coefficients are later consulted by MCPDFT code that needs
        exchange/correlation mixing information for the registered on-top
        functional.
    
    Defaults:
        If preset does not contain 'hyb' or 'facs', the function forwards None to
        libxc.register_custom_functional_. When recording hybrid values in
        REG_OT_FUNCTIONALS, the function treats a missing 'hyb' as [0] and stores
        0 (zero) for both 'hyb_x' and 'hyb_c'.
    
    Failure modes and errors:
        If preset does not include the required keys 'xc_base' or 'ext_params',
        a KeyError will be raised when those keys are accessed. If the values
        provided have incorrect types (for example, ext_params is not a dict or
        hyb is not indexable), a TypeError or IndexError may be raised. The call
        to libxc.register_custom_functional_ can raise exceptions defined by the
        libxc Python wrapper (e.g., on invalid parameters or if the functional
        name collides with an existing registration and libxc does not permit
        re-registration). The function does not perform an explicit pre-check for
        existing registrations; behavior on duplicate registration is therefore
        determined by libxc.register_custom_functional_.
    
    Returns:
        None: The function does not return a value. Its effects are performed
        through side effects: registering the new functional with libxc and
        updating the module-level REG_OT_FUNCTIONALS registry so that the newly
        registered on-top functional is available to MCPDFT calculations within
        the PySCF framework.
    """
    from pyscf.mcpdft.otfnal import register_otfnal
    return register_otfnal(xc_code, preset)


################################################################################
# Source: pyscf.mcpdft.otfnal.make_hybrid_fnal
# File: pyscf/mcpdft/otfnal.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_mcpdft_otfnal_make_hybrid_fnal(xc_code: str, hyb: float, hyb_type: int = 1):
    """make_hybrid_fnal generates a PySCF-style hybrid exchange–correlation (XC) functional specification by combining a base libxc functional code (xc_code) with a small set of "hybridization" parameters (hyb) according to one of several predefined combination rules (hyb_type). This convenience wrapper is used in the mcpdft.otfnal code path of PySCF to produce hybrid functionals suitable for multiconfigurational pair-density functional theory workflows; it produces a functional specification that is ultimately passed to make_scaled_fnal and then consumed by PySCF's DFT machinery (pyscf.dft.libxc) for evaluation of exchange and correlation contributions.
    
    Args:
        xc_code (str): The base functional identifier as used by pyscf.dft.libxc. This string names the underlying semilocal functional (for example a libxc label) whose exchange and correlation parts will be combined with exact (Hartree–Fock) exchange according to the hybridization rule. The function will raise an exception if xc_code already denotes a hybrid-type functional or if it contains a kinetic-energy functional component (these checks are performed by downstream routines that validate the libxc specification).
        hyb (float): Parameter(s) defining the hybridization. By default this is documented as a float scalar value, and the implementation will accept a scalar or a sequence-like object. If a scalar is provided it is coerced to a single-element sequence internally. The entries of hyb control the weight of exact exchange (HF) and the scaling of the semilocal exchange and correlation components according to the chosen hyb_type. Different hyb_type values impose specific length requirements:
            - For hyb_type 0, 1, 2, or 3: len(hyb) must be 1 (a single float); the single value is denoted hyb[0] in the formulas below.
            - For hyb_type 4: len(hyb) must be 2; the first element hyb[0] is the primary mixing parameter a and hyb[1] is used to define an exponent for correlation scaling.
        hyb_type (int or str): The hybrid-construction rule to apply. The default is 1. hyb_type may be supplied as an integer code or as one of the string names below (case-sensitive, matched against the internal mapping). The implementation accepts the following codes and applies the corresponding construction; assertion failures will occur if the supplied hyb sequence length does not match the requirement of the selected type, a KeyError will occur if a string name is not recognized, and a RuntimeError is raised for an undefined numeric type outside the documented set.
            - 0 or 'translation': "translation" hybrid. Construction used: exchange part = hyb*HF + (1-hyb)*x_code; correlation part = hyb*HF + c_code. Implementation call: make_scaled_fnal(xc_code, hyb_x=hyb[0], hyb_c=hyb[0], fnal_x=(1-hyb[0]), fnal_c=1). Requires a single-element hyb.
            - 1 or 'average': "average" hybrid (default). Construction used: exchange part = hyb*HF + (1-hyb)*x_code; correlation part = hyb*HF + (1-hyb)*c_code. Implementation call: make_scaled_fnal(xc_code, hyb_x=hyb[0], hyb_c=hyb[0], fnal_x=(1-hyb[0]), fnal_c=(1-hyb[0])). Requires a single-element hyb. This choice is motivated by the idea that hyb = 1 should recover the underlying wave function energy.
            - 2 or 'diagram': "diagram" hybrid. Construction used: exchange part = hyb*HF + (1-hyb)*x_code; correlation part = c_code (no HF mixing in correlation). Implementation call: make_scaled_fnal(xc_code, hyb_x=hyb[0], hyb_c=0, fnal_x=(1-hyb[0]), fnal_c=1). Requires a single-element hyb.
            - 3 or 'lambda': "lambda" hybrid (as used in arXiv:1911.11162v1 / double-hybrid style constructions). Construction used: exchange part = hyb*HF + (1-hyb)*x_code; correlation part = hyb*HF + (1-hyb^2)*c_code. Implementation call: make_scaled_fnal(xc_code, hyb_x=hyb[0], hyb_c=hyb[0], fnal_x=(1-hyb[0]), fnal_c=(1-(hyb[0]*hyb[0]))). Requires a single-element hyb.
            - 4 or 'scaling': "scaling" hybrid motivated by density-scaling inequalities of Levy and Perdew. Let a = hyb[0] and define b = a**(1 + hyb[1]). Construction used: exchange part = a*HF + (1-a)*x_code; correlation part = a*HF + (1-b)*c_code. Implementation call: make_scaled_fnal(xc_code, hyb_x=a, hyb_c=a, fnal_x=(1-a), fnal_c=(1-b)). Requires two-element hyb (hyb[0] and hyb[1]) and implements an empirical correlation exponent 1+hyb[1].
    
    Behavior and side effects:
        - The function coerces a scalar hyb into a single-element sequence internally (it checks for the presence of __len__ and wraps non-sequence hyb as [hyb]).
        - If hyb_type is supplied as a string, it is mapped to its integer code using the internal mapping {'translation': 0, 'average': 1, 'diagram': 2, 'lambda': 3, 'scaling': 4}. Unrecognized strings will raise KeyError.
        - The function performs input-length assertions for hyb according to the selected hyb_type; if these assertions fail, an AssertionError is raised.
        - If hyb_type is not one of the documented integer codes (0–4), a RuntimeError('hybrid type undefined') is raised.
        - The function delegates the actual construction and validation of the final functional descriptor to make_scaled_fnal; any further validation errors (for example, detection that xc_code already describes a hybrid or contains kinetic-energy terms) will propagate as exceptions raised by downstream routines.
        - No global state is modified; the only observable effect is the returned hybrid functional specification (and any exceptions raised).
    
    Returns:
        str: A hybrid functional specification produced by make_scaled_fnal. The returned value is the functional descriptor that should be acceptable to PySCF's DFT/libxc interface (it encodes the exchange and correlation mixing produced by the selected hyb_type and hyb parameters). Exceptions from make_scaled_fnal or subsequent validation will propagate to the caller.
    """
    from pyscf.mcpdft.otfnal import make_hybrid_fnal
    return make_hybrid_fnal(xc_code, hyb, hyb_type)


################################################################################
# Source: pyscf.md.set_seed
# File: pyscf/md/__init__.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_md_set_seed(seed: int):
    """Sets the seed for the random number generator used by the md module in PySCF.
    
    This function initializes or replaces the module-level random number generator used by pyscf.md routines by creating a numpy.random.Generator backed by numpy.random.PCG64 initialized with the given integer seed. In the context of the PySCF (Python-based Simulations of Chemistry Framework) md submodule, this seed controls all subsequent pseudo-random behaviour that relies on the module's rng variable, for example random initial velocities, stochastic forces, Monte Carlo sampling, or other randomized procedures that may appear in molecular dynamics or related stochastic workflows within PySCF. Calling this function ensures deterministic, reproducible sequences of pseudo-random numbers for those md module operations when the same seed and the same numpy/PySCF environment are used.
    
    Args:
        seed (int): Integer seed value to initialize the underlying PCG64 pseudo-random number generator. This parameter must be an integer as required by numpy.random.PCG64; it is used directly to construct PCG64(seed) and therefore determines the exact pseudo-random sequence produced by the Generator. Choosing and documenting the seed is important for reproducibility of stochastic molecular-dynamics or sampling tasks performed with the md module.
    
    Returns:
        None: This function does not return a value. Its effect is a side effect: it creates or replaces the module-level global variable rng with a numpy.random.Generator instance constructed as numpy.random.Generator(numpy.random.PCG64(seed)). After calling set_seed, subsequent uses of the md module that read the global rng will draw reproducible pseudo-random numbers determined by seed until rng is changed again.
    
    Behavior and failure modes:
        The function sets the global variable rng in the md module namespace; any prior rng object is overwritten. If seed is not an integer or is otherwise unacceptable to numpy.random.PCG64, the underlying numpy constructor will raise a TypeError or ValueError; these exceptions are propagated to the caller. Reproducibility of numeric results across different machines or future runs requires using the same seed together with the same numpy and PySCF versions, since implementation details of PCG64 or Generator could affect cross-version or cross-platform behavior.
    """
    from pyscf.md import set_seed
    return set_seed(seed)


################################################################################
# Source: pyscf.pbc.cc.eom_kccsd_ghf.amplitudes_to_vector_ee
# File: pyscf/pbc/cc/eom_kccsd_ghf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_cc_eom_kccsd_ghf_amplitudes_to_vector_ee(
    r1: numpy.ndarray,
    r2: numpy.ndarray,
    kshift: numpy.ndarray,
    kconserv: numpy.ndarray
):
    """Transform 3- and 7-dimensional excitation-amplitude arrays used in k-point CCSD/EOM-EE (GHF, periodic boundary conditions) into a 1-dimensional vector containing only the unique amplitude elements according to the k-point and orbital-index ordering used by pyscf.pbc.cc.eom_kccsd_ghf.
    
    This routine is used in the periodic (pbc) k-point coupled-cluster singles-and-doubles (kCCSD) / equation-of-motion for excited states (EOM-EE) with a generalized Hartree–Fock (GHF) reference inside the PySCF framework. It packs the single-excitation amplitudes r1 and the independent double-excitation amplitudes r2 into a contiguous 1D numpy array in a deterministic order so downstream linear-algebra routines (diagonalization, iterative solvers, projections) operate on a vector of independent variables rather than full tensors.
    
    Args:
        r1 (numpy.ndarray): Single-excitation amplitude tensor with shape (nkpts, nocc, nvir). The tensor represents amplitudes t_{i k_i}^{a k_a} where the first axis indexes k-point of the occupied orbital (k_i), the second indexes occupied orbital index i within that k-point, and the third indexes virtual orbital index a within its k-point. nkpts is the number of k-points, nocc is the number of occupied orbitals per k-point, and nvir is the number of virtual orbitals per k-point. The dtype of the returned vector follows the dtype of r1 when possible. The function flattens r1 in row-major order and places these elements at the start of the output vector. Supplying an r1 with a different shape than (nkpts, nocc, nvir) will result in numpy indexing/reshape errors.
    
        r2 (numpy.ndarray): Double-excitation amplitude tensor in the original shape convention used by the calling code: (k_i, k_j, k_a, i, j, a, b). That is, r2[k_i, k_j, k_a, i, j, a, b] corresponds to t_{i k_i, j k_j}^{a k_a, b k_b} before any symmetry-based reduction. The function internally transposes r2 to group (k_i,i) and (k_j,j) into composite indices and to reshape into (nkpts*nocc, nkpts*nocc, nkpts, nvir, nvir). The routine then selects only the unique double amplitudes according to the lower-triangle ordering of the composite occupied-pair index ((k_i,i) > (k_j,j)) and the ordering/ momentum-conservation rule for virtual pairs ((a k_a) > (b k_b)); see kconserv for how k-point pairing is resolved. Passing an r2 that does not conform to the expected 7-dimensional layout will raise indexing/reshape errors.
    
        kshift (numpy.ndarray): Array of k-point shifts. Present for API compatibility with other packing/unpacking routines in the k-point CCSD/EOM code path and for potential external use, but this function does not read or mutate kshift. It must be provided (numpy.ndarray) to match the interface used by higher-level callers. Since kshift is unused here, invalid values for kshift will not be detected by this function, but callers should still supply the correct k-point shift information for consistency across the codebase.
    
        kconserv (numpy.ndarray): Integer array used to enforce momentum (k-point) conservation: expected to be indexable as kconserv[ki, ka, kj] and to return an integer kb such that ka and kb form the conserved virtual k-point partner for the occupied/composite indices ki and kj. In this function kconserv is used to compute kb = kconserv[ki, ka, kj] when iterating over composite occupied-pair indices and virtual k-point indices. The typical shape required is (nkpts, nkpts, nkpts) or any shape that supports the three-index access pattern used here. Incorrect shapes or values in kconserv will cause IndexError or incorrect packing of r2 amplitudes.
    
    Returns:
        numpy.ndarray: A one-dimensional numpy array containing the packed, independent excitation amplitudes. The returned vector begins with all entries of r1 flattened in row-major order (all single excitations), followed by a selection of r2 entries corresponding to unique double excitations. The selection rule implemented is:
        - Only composite occupied-pair indices (k_i,i) and (k_j,j) with (k_i,i) > (k_j,j) (lower-triangle in the composite index space) are included.
        - For each such occupied-pair, iterate over virtual k-point index ka and compute kb = kconserv[ki, ka, kj]. If ka == kb, include only the lower-triangle (a > b) of the virtual-orbital pair (to avoid double counting identical virtual-k pairs); if ka > kb, include all virtual pairs for that ka. The ordering used here is the same deterministic ordering expected by the pyscf.pbc.cc.eom_kccsd_ghf routines that consume these packed vectors.
        The dtype of the result follows the input arrays where possible. If r1 and r2 have mismatched dtypes or shapes, numpy operations may raise exceptions.
    
    Raises / Failure modes:
        ValueError / IndexError: If r1 or r2 do not have the expected dimensionalities or shapes (r1 not 3D with axes (nkpts, nocc, nvir), r2 not 7D in the expected ordering), numpy reshape/transpose/index operations will raise errors. If kconserv does not support kconserv[ki, ka, kj] lookups for the inferred nkpts values, an IndexError will occur. Because r2 is transposed and reshaped internally, extremely large tensors may trigger MemoryError or significant memory/copy overhead.
        Note: The function concatenates arrays iteratively using numpy.hstack in a loop; for very large systems this can be suboptimal in performance and memory usage. Callers may prefer to preallocate the output vector and fill it when performance or memory is critical.
    
    Side effects:
        None on input arrays: r1 and r2 are not modified in-place by this function. kshift is not used. The function returns a new numpy array containing the packed amplitudes.
    """
    from pyscf.pbc.cc.eom_kccsd_ghf import amplitudes_to_vector_ee
    return amplitudes_to_vector_ee(r1, r2, kshift, kconserv)


################################################################################
# Source: pyscf.pbc.cc.eom_kccsd_ghf.enforce_2p_spin_doublet
# File: pyscf/pbc/cc/eom_kccsd_ghf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_cc_eom_kccsd_ghf_enforce_2p_spin_doublet(
    r2: numpy.ndarray,
    kconserv: numpy.ndarray,
    kshift: int,
    orbspin: list,
    excitation: str
):
    """Enforces the two-particle (2p) spin-selection rule for EOM-KCCSD generalized-Hartree-Fock amplitudes in periodic boundary condition calculations so that the net spin change of the 2p excitation is limited to +/- 1/2. This function is used in the PySCF pbc.cc.eom_kccsd_ghf module to post-process or project EOM two-particle amplitude tensors (r2) for ionization-potential ('ip') or electron-affinity ('ea') excitation operators, zeroing amplitude components that correspond to forbidden net spin changes and enforcing the required antisymmetry under particle exchange across k-points according to the k-point conservation array.
    
    Args:
        r2 (numpy.ndarray): The 2-particle EOM amplitude tensor to be constrained. The array is multi-dimensional and its axis ordering is interpreted differently depending on the excitation type: for excitation == 'ip' the function reads nkpts, nocc, nvir from r2.shape[[1, 3, 4]] (i.e. r2 has at least 5 dimensions with occupancy and virtual dimensions at indices 3 and 4); for excitation == 'ea' it reads nkpts, nocc, nvir from r2.shape[[1, 2, 3]] (i.e. r2 has at least 4 dimensions with occupancy and virtual dimensions at indices 2 and 3). The tensor is modified in-place: amplitude components that would give net spin change of +/- 3/2 are set to zero and antisymmetry between paired k-point blocks is enforced. Passing an r2 array with shapes inconsistent with the expected indexing will raise IndexError or produce incorrect behavior.
        kconserv (numpy.ndarray): k-point momentum conservation integer array used to map pairs/triples of k-points into the third k-point that conserves crystal momentum. The function accesses elements like kconserv[ki, kshift, kj] or kconserv[kshift, ka, kj] to find partner k-point indices (named ka, kb, etc. in the source). kconserv must be shaped and populated consistently with the Brillouin-zone k-point indexing used in the rest of the periodic CC/EOM calculation; mismatched shapes or invalid indices will raise IndexError.
        kshift (int): Integer index of the shifted k-point relevant for momentum conservation in the particular 2p excitation channel. kshift is used as one index into kconserv and as the k-point at which single-particle spin occupation (alpha/beta) is checked when zeroing forbidden amplitudes. Out-of-range kshift will raise IndexError.
        orbspin (list): List of per-k-point 1D array-like objects (e.g., numpy arrays) that label the spin of each single-particle orbital at that k-point. Each orbspin[k] must contain integer spin labels where 0 denotes alpha (spin-up) and 1 denotes beta (spin-down). The function treats the first nocc entries of orbspin[k] as occupied orbitals and the remaining entries as virtual orbitals; these partitions are determined from nocc and nvir inferred from r2 as described above. If orbspin entries do not have length nocc + nvir, an IndexError or incorrect masking will result.
        excitation (str): Specifies the excitation type and must be either 'ip' (ionization potential, 2p-1h type amplitudes where two occupied indices appear) or 'ea' (electron affinity, 2p-1h type amplitudes where two virtual indices appear). The function asserts this choice at the start and will raise AssertionError if excitation is not one of the supported strings. The chosen branch determines how r2 is reshaped, which k-point conservation indices are used, and which sets of alpha/beta occupied/virtual combinations are zeroed.
    
    Returns:
        numpy.ndarray: The same r2 array that was passed in, after modification. The returned array has the same shape as the input r2 but with amplitude elements corresponding to net spin changes of +/- 3/2 set to zero and with antisymmetry enforced between k-point blocks: for each relevant pair of k-point blocks the function averages the block with the negative transpose of its partner and assigns the antisymmetric counterpart explicitly (r2[kj, ki] = -r2[ki, kj].transpose(1,0,2) in the 'ip' branch and analogous transposition in the 'ea' branch). This function mutates r2 in-place and also returns it for convenience.
    
    Behavioral notes, side effects, and failure modes:
        - The function is intended for use in periodic coupled-cluster EOM calculations (PySCF pbc.cc.eom_kccsd_ghf) where spin labeling per orbital and k-point conservation are available from the underlying periodic SCF/CC infrastructure described in the PySCF README. It enforces physical spin-selection rules appropriate for doublet-target states obtained by removing or adding a single electron.
        - The function uses numpy-based indexing, masking, and reshaping operations; it assumes contiguous and correctly shaped arrays for r2, kconserv, and orbspin entries. Supplying arrays with unexpected dimensionality or ordering relative to the documented axis interpretation will result in IndexError, ValueError from reshape operations, or incorrect enforcement.
        - The function begins with assert (excitation in ['ip', 'ea']) and will raise AssertionError for other strings; the source code also contains an else: raise NotImplementedError branch reachable only if the earlier logic is modified.
        - Antisymmetrization is applied with explicit loops over k-point indices and with checks (ki > kj or ka > kb) to avoid double-counting while assigning antisymmetric partners. The function therefore has O(nkpts^2) work in the number of k-points and may be expensive for large k-point meshes.
        - orbspin entries must use the exact integer labels 0 and 1 to represent alpha and beta spins respectively; other encodings are not recognized by this routine and will lead to incorrect masking.
        - No new data structures are returned; the routine relies on and mutates the input r2 tensor and returns it for chaining.
    """
    from pyscf.pbc.cc.eom_kccsd_ghf import enforce_2p_spin_doublet
    return enforce_2p_spin_doublet(r2, kconserv, kshift, orbspin, excitation)


################################################################################
# Source: pyscf.pbc.cc.eom_kccsd_ghf.spatial2spin_ip_doublet
# File: pyscf/pbc/cc/eom_kccsd_ghf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_cc_eom_kccsd_ghf_spatial2spin_ip_doublet(
    r1: tuple,
    r2: tuple,
    kconserv: numpy.ndarray,
    kshift: int,
    orbspin: numpy.ndarray = None
):
    """Convert R1/R2 amplitudes expressed in spatial-orbital blocks into R1/R2
    amplitudes in the spin-orbital representation for an ionization-potential
    (IP) doublet calculation in periodic (k-point) systems. This function is
    used in the PySCF pbc EOM-KCCSD GHF code path to assemble spin-resolved
    amplitudes required by spin-orbital EOM solvers from spatial-orbital
    components computed separately for alpha/alpha, beta/alpha, alpha/beta,
    and beta/beta spin combinations. The routine preserves numerical dtypes,
    respects k-point momentum conservation via kconserv, and supports a
    custom per-kpoint orbital-spin ordering via orbspin; when orbspin is
    None, an alternating alpha/beta ordering is assumed.
    
    Args:
        r1 (tuple): A length-2 tuple (r1a, r1b) of 1D numpy.ndarray objects.
            r1a and r1b are the spatial-orbital R1 amplitudes for the two
            spin sectors (conventionally "alpha" and "beta") used in the
            spatial representation of the IP doublet problem. Each array
            contains amplitudes for occupied orbitals at the k-point defined
            by kshift. The arrays' dtypes are preserved in the returned r1.
        r2 (tuple): A length-4 tuple (r2aaa, r2baa, r2abb, r2bbb) of
            numpy.ndarray objects containing spatial-orbital R2 amplitudes,
            with shapes and spin labeling as follows:
            r2aaa has shape (nkpts, nkpts, nocc_a, nocc_a, nvir_a) and holds
              amplitudes for alpha-alpha-alpha excitations (occupied i,j both
              alpha, virtual a alpha).
            r2baa has shape (nkpts, nkpts, nocc_b, nocc_a, nvir_a) and holds
              amplitudes for beta-alpha-alpha excitations (first occupied beta,
              second occupied alpha, virtual alpha).
            r2abb has shape (nkpts, nkpts, nocc_a, nocc_b, nvir_b) and holds
              amplitudes for alpha-beta-beta excitations (first occupied alpha,
              second occupied beta, virtual beta).
            r2bbb has shape (nkpts, nkpts, nocc_b, nocc_b, nvir_b) and holds
              amplitudes for beta-beta-beta excitations (occupied i,j both beta,
              virtual beta).
            The first two axes index the pair of occupied k-points (ki,kj).
            The routine reshapes and places these spatial blocks into the
            combined spin-orbital R2 tensor; the dtype of r2aaa (assumed
            consistent across r2 components) is preserved in the returned r2.
        kconserv (numpy.ndarray): Integer array encoding k-point momentum
            conservation used to map occupied k-point pairs (ki,kj) and the
            removal k-point kshift to the appropriate virtual k-point index.
            The function uses kconserv[ki, kshift, kj] to obtain the target
            virtual k-point index ka. The array must therefore have at least
            three axes and be indexed in the order consistent with the call
            (ki, kshift, kj). This conservation mapping is required for
            periodic-boundary EOM calculations in PySCF.
        kshift (int): Integer k-point index that identifies the k-point of
            the removed electron (the hole) in the IP calculation. This index
            selects which slice of r1 (r1a/r1b) is placed into the output
            spin-orbital r1 and is used as the middle index into kconserv to
            determine virtual k-point targets. kshift must be a valid index
            in the range [0, nkpts-1] where nkpts is the number of k-points
            implied by the first axes of the r2 arrays.
        orbspin (numpy.ndarray, optional): Integer array of shape
            (nkpts, nocc + nvir) that encodes the spin assignment (0 for
            alpha, 1 for beta) of spatial orbitals for each k-point and
            orbital index. The first nocc columns correspond to occupied
            orbitals and the remaining columns correspond to virtuals. If
            orbspin is None (default), a simple alternating alpha/beta
            ordering is constructed per k-point where even-indexed spatial
            orbital positions are alpha (0) and odd-indexed positions are
            beta (1). Providing orbspin allows mapping from arbitrary
            spatial-orbital ordering to spin-orbital blocks.
    
    Returns:
        tuple: A pair (r1_spin, r2_spin) with the following properties.
          r1_spin (numpy.ndarray): 1D array of length nocc where nocc =
              nocc_a + nocc_b (sum of occupied counts for alpha and beta
              spatial blocks). This is the spin-orbital R1 vector for the
              specified kshift. The dtype is the same as the input r1a/r1b.
          r2_spin (numpy.ndarray): 5D array with shape
              (nkpts, nkpts, nocc, nocc, nvir) where nocc = nocc_a + nocc_b
              and nvir = nvir_a + nvir_b. This array is the spin-orbital R2
              amplitude tensor assembled from the spatial blocks using the
              orbspin mapping and kconserv momentum conservation. The dtype
              is the same as the input spatial R2 blocks (r2aaa dtype).
        The returned r1_spin and r2_spin are ready for use by spin-orbital
        EOM routines in the PySCF periodic EOM-KCCSD/ GH F implementation.
    
    Behavior and side effects:
        The function constructs index maps for occupied and virtual orbitals
        per k-point from orbspin (or from the default alternating pattern)
        and places spatial-spin blocks into the corresponding locations of
        the spin-orbital arrays. It uses kconserv[ki, kshift, kj] to determine
        which virtual k-point block receives amplitudes originating from
        occupied k-points (ki,kj). For mixed-spin blocks that require sign
        changes due to antisymmetry when swapping occupied indices, the
        function inserts the appropriate negative sign (e.g., r2aba is
        -r2baa[kj,ki]). The routine allocates new numpy arrays for the spin
        outputs; it does not modify the input arrays r1, r2, kconserv, or
        orbspin.
    
    Failure modes and validation:
        The function assumes consistency between the shapes of r1 and r2:
          - r1 must be a length-2 tuple of 1D numpy arrays corresponding to
            the occupied-space amplitudes for the two spatial spin sectors.
          - r2 must be a length-4 tuple with shapes described above, and the
            implied nkpts, nocc_a, nocc_b, nvir_a, nvir_b must be mutually
            consistent.
          - kconserv must be indexable as kconserv[ki, kshift, kj] for all
            0 <= ki,kj < nkpts and 0 <= kshift < nkpts.
          - If provided, orbspin must be an integer array of shape
            (nkpts, nocc + nvir) with entries 0 or 1; incorrect shape or
            invalid spin labels will lead to incorrect mapping or an error.
        Typical exceptions raised by invalid inputs include IndexError for an
        out-of-range kshift or mismatched nkpts, ValueError for inconsistent
        shapes between r2 blocks, and TypeError if provided arrays are not
        subscriptable numpy.ndarray-like objects. The function does not
        perform extensive element-wise validation beyond these shape and
        indexing requirements.
    
    Examples of practical significance:
        In periodic EOM-KCCSD generalized-Hartree-Fock workflows within PySCF,
        spatial2spin_ip_doublet is called after solving for spatial R1/R2
        amplitude blocks (r2aaa, r2baa, r2abb, r2bbb) to produce the final
        spin-orbital amplitude tensors that are consumed by spin-orbital EOM
        diagonalization or iterative solvers for IP doublet excitation
        energies and properties. The mapping ensures correct placement of
        amplitudes across k-point and spin sectors and enforces antisymmetry
        sign conventions required by the many-body theory.
    """
    from pyscf.pbc.cc.eom_kccsd_ghf import spatial2spin_ip_doublet
    return spatial2spin_ip_doublet(r1, r2, kconserv, kshift, orbspin)


################################################################################
# Source: pyscf.pbc.cc.eom_kccsd_ghf.spin2spatial_ea_doublet
# File: pyscf/pbc/cc/eom_kccsd_ghf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_cc_eom_kccsd_ghf_spin2spatial_ea_doublet(
    r1: numpy.ndarray,
    r2: numpy.ndarray,
    kconserv: numpy.ndarray,
    kshift: int,
    orbspin: numpy.ndarray
):
    """Convert R1/R2 electron-attached (EA) amplitudes from a spin-orbital
    representation to a spatial-orbital representation separated into spin
    blocks for alpha/beta components, for use in k-point periodic boundary
    condition (PBC) EOM-KCCSD with generalized Hartree–Fock (GHF).
    
    This function is used in the pyscf.pbc.cc.eom_kccsd_ghf module to transform
    spin-orbital EA excitation amplitudes (R1, R2) into spatial-orbital blocks
    used by downstream routines that expect separate alpha and beta virtual
    subspaces per k-point and spin. The conversion observes momentum (k-point)
    conservation via kconserv and selects the amplitudes for a particular
    k-point shift given by kshift. The resulting arrays preserve the input
    dtype and are arranged to match the blocked spin structure produced from
    orbspin (0 for alpha, 1 for beta) described in the PBC orbital indexing
    used throughout the EOM-KCCSD implementation.
    
    Args:
        r1 (numpy.ndarray): Spin-orbital R1 electron-attachment amplitude vector
            for the selected k-point block. This 1-D array supplies the EA
            single-excitation amplitudes expressed in spin-orbital indexing for
            the virtual orbitals associated with the active k-point shift (kshift).
            The function slices r1 into alpha and beta virtual components using
            orbspin[kshift] (values 0 for alpha, 1 for beta). The dtype of r1 is
            preserved in the returned r1a/r1b arrays. Passing r1 with a length or
            index ordering inconsistent with orbspin for the chosen kshift will
            raise IndexError or produce incorrect slicing.
        r2 (numpy.ndarray): Spin-orbital R2 electron-attachment double-excitation
            amplitude tensor with shape (nkpts, nkpts, nocc, nvir, nvir). In the
            code this shape is assumed and used to infer nkpts, nocc, and nvir.
            r2[kj, ka] is expected to contain the amplitudes coupling occupied
            orbitals at k-point kj to two virtual spin orbitals distributed over
            k-point ka and the momentum-conserving partner. The function reshapes
            and partitions r2 into four spin-blocked spatial-orbital tensors:
            r2aaa, r2aba, r2bab, r2bbb (see Returns). The dtype and numeric values
            of r2 are preserved in the outputs. If r2 does not have the expected
            dimensionality, a ValueError or IndexError will be raised.
        kconserv (numpy.ndarray): Integer ndarray used to enforce momentum
            (k-point) conservation in PBC calculations. kconserv is indexed as
            kconserv[kshift, ka, kj] and must provide the partner k-point index
            kb that, together with kshift, ka, and kj, satisfies crystal momentum
            conservation for the two-virtual-orbital block. The array must be
            consistent with the nkpts inferred from r2; otherwise indexing errors
            will occur.
        kshift (int): Integer index of the target k-point shift (the active k-point
            where the single EA amplitude r1 is provided). This value selects the
            virtual-orbital subsets (via orbspin) and the appropriate slice of r1
            to produce r1a (alpha) and r1b (beta). kshift must be in the range
            [0, nkpts-1] where nkpts is derived from r2; out-of-range values will
            raise IndexError.
        orbspin (numpy.ndarray): Array-like object of length nkpts (or indexable
            by k-point) where orbspin[k] is an integer array labeling each spatial
            orbital at k-point k by spin: 0 for alpha and 1 for beta. The first
            nocc entries of orbspin[k] correspond to occupied-spin labels and the
            remaining entries correspond to virtual-spin labels. The function uses
            orbspin to build index lists (idxoa, idxob, idxva, idxvb) that define
            the mapping from spin-orbital ordering to spatial-orbital alpha/beta
            subspaces. orbspin must contain only 0 and 1 values and match the
            orbital ordering assumed by r1 and r2; inconsistent labels will lead
            to incorrect results or IndexError.
    
    Returns:
        list, list: A pair of lists [r1_list, r2_list] where:
            r1_list is [r1a, r1b], two numpy.ndarray objects containing the
            alpha (r1a) and beta (r1b) components of the input spin-orbital R1
            amplitudes after selection by orbspin at kshift. These arrays have
            the same dtype as r1 and contain the single-excitation EA amplitudes
            restricted to the spatial virtual orbitals of each spin for the given
            kshift.
            r2_list is [r2aaa, r2aba, r2bab, r2bbb], four numpy.ndarray objects
            containing the double-excitation amplitudes partitioned into spatial
            spin blocks. Their shapes are:
                r2aaa: (nkpts, nkpts, nocc_a, nvir_a, nvir_a)
                r2aba: (nkpts, nkpts, nocc_a, nvir_b, nvir_a)
                r2bab: (nkpts, nkpts, nocc_b, nvir_a, nvir_b)
                r2bbb: (nkpts, nkpts, nocc_b, nvir_b, nvir_b)
            where nkpts, nocc_a, nocc_b, nvir_a, and nvir_b are derived from r2
            and orbspin: nocc_a/nocc_b are the numbers of alpha/beta occupied
            spatial orbitals per k-point and nvir_a/nvir_b are the numbers of
            alpha/beta virtual spatial orbitals per k-point. The numeric dtype of
            r2 is preserved in these outputs. The returned arrays are newly
            allocated (no in-place modification of the input r2), so calling this
            function has no side effects on its input arrays.
    
    Raises:
        IndexError: If kshift or any computed index is out of range for the inputs,
            or if orbspin does not match the orbital indexing expected by r1/r2.
        ValueError: If r2 does not have the required number of dimensions or a
            shape incompatible with the indexing and reshaping operations used
            to partition spin blocks (expected shape compatible with
            (nkpts, nkpts, nocc, nvir, nvir)).
        TypeError: If inputs are not numpy.ndarray where arrays are required and do
            not support the indexing/reshaping operations used here.
    
    Notes:
        - The function implements a deterministic reshaping and index selection
          used in periodic EOM-KCCSD workflows in PySCF to convert between spin
          orbital and spatial-orbital blocked representations of EA amplitudes.
        - No in-place mutation of r1 or r2 occurs; all returned arrays are new
          numpy.ndarrays.
    """
    from pyscf.pbc.cc.eom_kccsd_ghf import spin2spatial_ea_doublet
    return spin2spatial_ea_doublet(r1, r2, kconserv, kshift, orbspin)


################################################################################
# Source: pyscf.pbc.cc.eom_kccsd_rhf.amplitudes_to_vector_singlet
# File: pyscf/pbc/cc/eom_kccsd_rhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_cc_eom_kccsd_rhf_amplitudes_to_vector_singlet(
    r1: numpy.ndarray,
    r2: numpy.ndarray,
    kconserv: numpy.ndarray
):
    """Transform 3- and 7-dimensional singlet EOM-CC amplitude arrays r1 and r2 for k-point periodic CCSD (EOM-KCCSD) into a 1-dimensional vector containing unique amplitude entries suitable for linear-algebra operations (for example, Davidson diagonalization). This function is used in the PySCF periodic coupled-cluster EOM module (pyscf.pbc.cc.eom_kccsd_rhf) to produce a compact vector of excitation amplitudes for singlet symmetry by flattening r1 and selecting only non-redundant elements of r2 according to a combined index ordering that enforces momentum conservation via the kconserv lookup table.
    
    r1 is expected to be the single-excitation amplitude array with shape (nkpts, nocc, nvir) corresponding to indices (k_i, i, a). r2 is expected to be the double-excitation amplitude array with k-point and orbital indices ordered as in the source code; the common convention in this module is r2 with seven axes for (k_i, k_J, k_a, i, J, a, B) before the internal transpose. kconserv is the integer k-point conservation table with shape (nkpts, nkpts, nkpts) that maps (ki, ka, kj) -> kb such that momentum is conserved for the four-index amplitude blocks.
    
    Args:
        r1 (numpy.ndarray): Single-excitation amplitudes for singlet EOM-KCCSD. The array shape must be (nkpts, nocc, nvir) where nkpts is the number of k-points, nocc the number of occupied orbitals per k-point, and nvir the number of virtual orbitals per k-point. Each element r1[ki, i, a] corresponds to the excitation amplitude t_{i k_i}^{a k_a} for the spin-adapted (singlet) excitation space. The function flattens r1 in C-contiguous order and places these entries first in the returned vector.
        r2 (numpy.ndarray): Double-excitation amplitudes for singlet EOM-KCCSD, supplied with the module's expected seven-dimensional ordering. In the implementation the array is transposed as r2.transpose(0,2,1,3,5,4,6) and reshaped into shape (nkpts**2, nkpts, nov, nov) where nov = nocc * nvir. After this transformation each 2D block r2ovov corresponds to combined indices (i,a) by (J,B) for a specific combined k-point index pair (k_i,k_a) and k_j. The function extracts either the full nov*nov block or only its lower-triangular unique entries depending on the combined k-point equality, to avoid double counting of equivalent amplitude entries under the singlet symmetry and k-point conservation.
        kconserv (numpy.ndarray): Integer array of shape (nkpts, nkpts, nkpts) that enforces momentum conservation among k-points. For indices (ki, ka, kj) the value kb = kconserv[ki, ka, kj] yields the k-point index required to satisfy momentum conservation for the fourth k-point. kconserv entries must be valid integer indices in the range [0, nkpts-1]. The function uses kconserv to determine whether a given r2 block corresponds to a self-pair (combined index equality) or a distinct pair, which controls whether the full block or only its lower-triangular part is appended to the output vector.
    
    Returns:
        numpy.ndarray: One-dimensional array containing the flattened singlet excitation amplitudes. The returned vector begins with r1.ravel() (C-order flattening of the (nkpts, nocc, nvir) array) followed by selected elements from r2 arranged according to the internal loop order over k-point triples (ki, ka, kj) used by kpts_helper.loop_kkk. For each combined pair of k-points (k_i,k_a) and k_j the corresponding (i,a)-(J,B) block is appended either as the full nov*nov block (when the combined index for the second block is lexicographically smaller: kika > kjkb) or as its lower-triangular unique elements (nov*(nov+1)//2) when the combined indices are equal (kika == kjkb). The dtype of the returned vector matches the dtype of the input amplitude arrays.
    
    Raises/Failure modes:
        ValueError, IndexError, or RuntimeError may occur if input array shapes do not match the expected conventions: r1 must have three axes (nkpts, nocc, nvir), r2 must be compatible with the internal transpose/reshape into (nkpts**2, nkpts, nov, nov), and kconserv must index valid k-point integers. If the shapes are inconsistent the transpose/reshape will fail (ValueError) or indexing into kconserv/r2 will raise IndexError. Supplying non-integer or out-of-range values in kconserv will result in incorrect indexing or IndexError. The function does not modify the caller's arrays (it rebinds local names and creates intermediate views/copies as required) and produces a new numpy.ndarray as output.
    
    Notes:
        This conversion is necessary for forming the compact vector representation of singlet EOM-KCCSD amplitudes in periodic systems with k-point sampling; the returned vector is intended for use in iterative eigensolvers or matrix-vector product routines within the pyscf.pbc.cc.eom_kccsd_rhf implementation. The ordering and uniqueness selection follow the combined-index convention implemented in the source code: combined index kika = ki * nkpts + ka and kjkb = kj * nkpts + kb, where kb is obtained from kconserv.
    """
    from pyscf.pbc.cc.eom_kccsd_rhf import amplitudes_to_vector_singlet
    return amplitudes_to_vector_singlet(r1, r2, kconserv)


################################################################################
# Source: pyscf.pbc.cc.eom_kccsd_ghf.spin2spatial_ip_doublet
# File: pyscf/pbc/cc/eom_kccsd_ghf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_cc_eom_kccsd_ghf_spin2spatial_ip_doublet(
    r1: numpy.ndarray,
    r2: numpy.ndarray,
    kconserv: numpy.ndarray,
    kshift: int,
    orbspin: numpy.ndarray
):
    """Convert R1/R2 vectors from a spin-orbital representation into a spatial-orbital
    (alpha/beta separated) representation for the ionization-potential (IP)
    doublet case in k-point, generalized Hartree–Fock (GHF) EOM-CCSD calculations.
    
    This utility is used in the PySCF pbc.cc.eom_kccsd_ghf implementation to
    transform EOM-IP excitation vectors that are expressed in spin-orbital
    indexing into the spatial (alpha / beta) blocks that downstream routines
    expect for spin-adapted or block-structured processing. The function preserves
    the input dtype and produces new arrays whose shapes reflect the per-kpoint
    counts of occupied/virtual alpha and beta orbitals. It assumes the same number
    of occupied and virtual orbitals for every k-point and that orbspin encodes
    spin labels as 0 (alpha) and 1 (beta).
    
    Args:
        r1 (numpy.ndarray): Spin-orbital R1 vector for the IP problem. In the
            EOM-IP context this is the one-hole (1h) amplitude vector defined on
            spin-orbital occupied indices for the kshift where the electron is
            removed. The function indexes r1 with the occupied alpha/beta index
            lists extracted from orbspin for the specified kshift to produce the
            spatial R1 blocks r1a and r1b. The array dtype is preserved in the
            returned r1 blocks. If r1 does not have indexing compatible with the
            occupied index arrays derived from orbspin, an IndexError may be
            raised.
        r2 (numpy.ndarray): Spin-orbital R2 tensor defined on two k-point indices
            followed by two occupied and one virtual spin-orbital indices. The
            expected shape is (nkpts, nkpts, nocc, nocc, nvir) where nkpts is the
            number of k-points, and nocc/nvir are the numbers of occupied and
            virtual spin-orbitals per k-point (the code assumes these counts are
            identical for every k-point). The function reshapes and slices r2
            entries for each pair of k-points (ki,kj) to build spatial spin-block
            tensors r2aaa, r2baa, r2abb, r2bbb. If r2 has an unexpected shape or
            inconsistent per-kpoint dimensions the routine will raise an
            IndexError or ValueError when attempting to reshape or index.
        kconserv (numpy.ndarray): Integer array that encodes momentum (k-point)
            conservation. For each pair of k-points (ki, kshift, kj) the entry
            kconserv[ki, kshift, kj] yields the k-point index ka used to select
            the appropriate virtual orbital block when converting a spin-orbital
            R2 slice into spatial blocks. This mapping is required by periodic
            boundary (k-point) implementations in PySCF and must be consistent
            with the ordering of orbitals provided in orbspin and the first two
            axes of r2. Mismatches in kconserv will produce incorrect indexing.
        kshift (int): Integer k-point index that specifies the momentum (k-point)
            of the removed electron in the EOM-IP calculation. The function uses
            kshift to select the occupied alpha and beta index subsets from
            orbspin and to look up the conserved virtual k-point ka via kconserv.
            kshift must be a valid index in the range [0, nkpts-1]; otherwise an
            IndexError will be raised.
        orbspin (numpy.ndarray): Integer array of shape (nkpts, nspin_orb) giving
            the spin label for each orbital at each k-point: use 0 for alpha and 1
            for beta. The first nocc entries per k-point correspond to occupied
            spin-orbitals, and the remaining entries correspond to virtual
            spin-orbitals (this is the convention used by the calling code). The
            function derives per-kpoint index lists idxoa/idxob (occupied alpha /
            occupied beta) and idxva/idxvb (virtual alpha / virtual beta) from
            orbspin and uses them to split the spin-orbital amplitudes into
            spatial alpha/beta blocks. If orbspin contains values other than 0 or
            1, or has inconsistent lengths across k-points, indexing errors or
            incorrect outputs will result.
    
    Returns:
        list: A two-element list whose first element is [r1a, r1b] and second
        element is [r2aaa, r2baa, r2abb, r2bbb].
        r1a (numpy.ndarray): 1D array containing the R1 amplitudes for alpha
            occupied spatial orbitals at the specified kshift. Extracted as
            r1[idxoa[kshift]] where idxoa is derived from orbspin; dtype matches r1.
        r1b (numpy.ndarray): 1D array containing the R1 amplitudes for beta
            occupied spatial orbitals at the specified kshift. Extracted as
            r1[idxob[kshift]]; dtype matches r1.
        r2aaa (numpy.ndarray): Array of shape (nkpts, nkpts, nocc_a, nocc_a, nvir_a)
            holding R2 amplitudes with both hole indices alpha and the particle
            index alpha (alpha-alpha-alpha block). Here nocc_a/nvir_a are the
            numbers of occupied/virtual alpha spatial orbitals per k-point as
            determined from orbspin. Each (ki,kj) slice is filled from the
            corresponding spin-orbital r2[ki,kj] entries using kconserv to select
            the appropriate virtual index set.
        r2baa (numpy.ndarray): Array of shape (nkpts, nkpts, nocc_b, nocc_a, nvir_a)
            holding R2 amplitudes with the first hole index beta and the second
            hole index alpha and particle alpha (beta-alpha-alpha block).
        r2abb (numpy.ndarray): Array of shape (nkpts, nkpts, nocc_a, nocc_b, nvir_b)
            holding R2 amplitudes with hole indices alpha/beta and particle beta
            (alpha-beta-beta block).
        r2bbb (numpy.ndarray): Array of shape (nkpts, nkpts, nocc_b, nocc_b, nvir_b)
            holding R2 amplitudes for beta-beta-beta combinations.
        The returned arrays are newly allocated (no in-place modification of r1 or
        r2) and preserve the dtype of the input r2 for the R2 blocks.
    
    Behavior and failure modes:
        - The function assumes the same counts of occupied and virtual orbitals for
          every k-point (nocc/nvir uniform across k-points). This is a common
          convention in PySCF periodic k-point calculations; violating it will
          yield incorrect shapes or IndexError/ValueError when reshaping.
        - orbspin must use 0 for alpha and 1 for beta. Other values will lead to
          incorrect index selection.
        - kshift must be a valid k-point index; invalid values raise IndexError.
        - kconserv must correctly encode momentum conservation for the k-point
          grid used by r2; otherwise the wrong virtual blocks will be selected.
        - No global state or files are modified; the function has no side effects
          beyond allocating and returning new arrays.
        - Typical exceptions arising from inconsistent inputs include IndexError
          and ValueError during indexing or reshaping operations.
    """
    from pyscf.pbc.cc.eom_kccsd_ghf import spin2spatial_ip_doublet
    return spin2spatial_ip_doublet(r1, r2, kconserv, kshift, orbspin)


################################################################################
# Source: pyscf.pbc.cc.eom_kccsd_ghf.spatial2spin_ea_doublet
# File: pyscf/pbc/cc/eom_kccsd_ghf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_cc_eom_kccsd_ghf_spatial2spin_ea_doublet(
    r1: tuple,
    r2: tuple,
    kconserv: numpy.ndarray,
    kshift: int,
    orbspin: numpy.ndarray = None
):
    """Convert R1/R2 amplitude tensors from a spatial-orbital representation to a spin-orbital
    representation for the electron-attached (EA) doublet manifold in k-point,
    periodic-boundary-condition coupled-cluster (k-CCSD) calculations using a
    generalized Hartree–Fock (GHF) reference. This function is used in the PySCF
    pbc.cc.eom_kccsd_ghf module to translate spatial-spin-decomposed EA vectors
    (r1, r2) produced by spin-adapted or spatial-orbital routines into the full
    spin-orbital format required by downstream EOM-CCSD linear algebra (for
    example, assembling the spin-orbital right-hand vectors used in Davidson
    diagonalization or for residual/evaluation routines).
    
    Args:
        r1 (tuple): Two-element tuple (r1a, r1b) containing the spatial-orbital
            single-electron (1p) EA amplitude vectors for the two spin blocks.
            Each element is a numpy.ndarray: r1a has shape (nvir_a,) and r1b has
            shape (nvir_b,) where nvir_a and nvir_b are the numbers of virtual
            spatial orbitals of alpha-like and beta-like spin blocks respectively
            for a single k-point. These arrays carry the amplitude values for a
            single added electron at the k-point indexed by kshift; they are placed
            into the global spin-orbital virtual index at that k-point. The dtype
            of the returned r1 matches the dtype of these inputs. Supplying r1 in
            this spatial tuple form is the expected input when EA amplitudes were
            constructed in a spatial-orbital (spin-separated) representation.
    
        r2 (tuple): Four-element tuple (r2aaa, r2aba, r2bab, r2bbb) containing the
            spatial-orbital double-electron (2p) EA amplitude tensors for the
            different combinations of spin blocks. Each element is a
            numpy.ndarray with the k-point and orbital layout used in the source
            code:
            r2aaa: shape (nkpts, nkpts, nocc_a, nvir_a, nvir_a)
            r2aba: shape (nkpts, nkpts, nocc_a, nvir_b, nvir_a)
            r2bab: shape (nkpts, nkpts, nocc_b, nvir_a, nvir_b)
            r2bbb: shape (nkpts, nkpts, nocc_b, nvir_b, nvir_b)
            Here nkpts is the number of k-points; nocc_a/nocc_b are the numbers of
            occupied spatial orbitals in the two spin blocks; nvir_a/nvir_b are the
            numbers of virtual spatial orbitals in the two spin blocks. These
            spatial tensors encode EA double amplitudes resolved by the spin
            structure (alpha/alpha/alpha, alpha/beta/alpha, beta/alpha/beta,
            beta/beta/beta) and are mapped into the combined spin-orbital double
            amplitude tensor in the return value. The sign conventions and index
            placements used in the mapping follow the fermionic antisymmetry
            conventions implemented in the source code (including explicit sign
            flips for exchanged spin components).
    
        kconserv (numpy.ndarray): Integer array encoding crystal-momentum (k-point)
            conservation used to find the third k-point index given two others.
            The array is indexed as kconserv[kshift, ka, kj] to produce kb such
            that momentum conservation is satisfied for the tensor block that
            couples k-points kj and ka when the added electron carries momentum
            kshift. Typical shape is (nkpts, nkpts, nkpts) but the code only
            requires that indexing kconserv[kshift, ka, kj] yields a valid integer
            k-point index kb. This mapping is essential in periodic calculations
            to place spatial r2 blocks into the correct combined spin-orbital k-
            point blocks.
    
        kshift (int): Integer k-point index corresponding to the momentum of the
            added electron in the EA excitation. The function places the single-
            particle amplitudes r1a and r1b into the global spin-orbital virtual
            indices at this k-point and uses kshift as the first index when
            querying kconserv to obtain the momentum-conserving partner k-points
            (kb). kshift must be a valid index for the k-point grid used by r2 and
            kconserv; invalid kshift values will raise an IndexError.
    
        orbspin (numpy.ndarray, optional): Array that defines the spin label for
            each molecular orbital index at each k-point. The code expects orbspin
            to be indexable by orbspin[k] to yield an array of length nmo (number
            of spatial orbitals times spin multiplicity per k-point) whose first
            nocc entries correspond to occupied orbitals and the remaining entries
            to virtual orbitals. Each entry should be 0 or 1 to indicate alpha-like
            or beta-like spin assignment. Typical shape in practice is
            (nkpts, nmo) where nmo = nocc + nvir (in spatial orbital count) and the
            object contains integer 0/1 labels. If orbspin is None (the default),
            the function constructs a simple alternating-spin ordering (alpha,
            beta, alpha, beta, ...) for one k-point and uses that pattern as the
            assumed orbital spin ordering; in other words, it defaults to a
            conventional spin-alternating layout for occupied+virtual orbitals.
            If orbspin has an incompatible shape or contains values other than 0
            and 1, the function will raise IndexError or ValueError when it tries
            to build index lists from orbspin. Providing a correct orbspin is
            necessary when using nonstandard spin-ordering or symmetry-broken
            orbital layouts.
    
    Behavior, side effects, and failure modes:
        The function allocates and returns new numpy arrays and does not modify the
        input r1/r2 tuples. It computes index maps for occupied and virtual
        orbital subblocks for each k-point based on orbspin and then fills a new
        spin-orbital r1 (1D) and r2 (5D) array. The returned r1 has length nvir
        (the total number of spin-orbital virtuals across both spin labels for a
        single k-point) and contains contributions from r1a and r1b placed at the
        virtual indices corresponding to alpha- and beta-like orbitals at kshift.
        The returned r2 has shape (nkpts, nkpts, nocc, nvir, nvir) where nocc is
        nocc_a + nocc_b and nvir is nvir_a + nvir_b; it is built by inserting the
        spatial r2 blocks into the appropriate spin-orbital blocks and applying
        sign conventions for exchanged spin indices (matching the implementation
        in the source code, including explicit negations used for certain
        permutations). The dtype of the outputs follows the dtype of the provided
        spatial tensors (r1a/r1b and r2* inputs).
    
        Typical failure modes include:
        - IndexError when kshift or any k-point indices derived from kconserv are
          out of range for the provided r2 arrays.
        - ValueError or IndexError when orbspin does not have the expected shape or
          when the counts nocc_a/nocc_b/nvir_a/nvir_b inferred from r2 do not match
          orbspin-derived partitions.
        - Mismatched shapes in the r2 tuple elements (for example inconsistent
          nkpts or orbital counts) will lead to reshape or broadcasting errors.
    
    Returns:
        tuple: (r1, r2)
            r1 (numpy.ndarray): 1D spin-orbital EA single amplitude vector of
                length nvir (total spin-orbital virtuals for a single k-point).
                The array dtype matches the dtype of the input r1a/r1b arrays.
                The entries are placed so that virtual alpha and beta components
                at the k-point kshift are filled from r1a and r1b, respectively.
            r2 (numpy.ndarray): 5D spin-orbital EA double amplitude tensor with
                shape (nkpts, nkpts, nocc, nvir, nvir) where nocc = nocc_a + nocc_b
                and nvir = nvir_a + nvir_b. This array contains the assembled
                spin-orbital two-particle amplitudes produced by inserting the
                spatial r2 blocks (r2aaa, r2aba, r2bab, r2bbb) into the combined
                spin index space using orbspin-derived index maps and the
                momentum-conserving mapping given by kconserv. The dtype matches
                the dtype of the input r2 tensors.
    """
    from pyscf.pbc.cc.eom_kccsd_ghf import spatial2spin_ea_doublet
    return spatial2spin_ea_doublet(r1, r2, kconserv, kshift, orbspin)


################################################################################
# Source: pyscf.pbc.cc.eom_kccsd_rhf.join_indices
# File: pyscf/pbc/cc/eom_kccsd_rhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_cc_eom_kccsd_rhf_join_indices(indices: numpy.ndarray, struct: numpy.ndarray):
    """pyscf.pbc.cc.eom_kccsd_rhf.join_indices converts a multi-dimensional integer index vector into a single linear index using the per-dimension radices provided by struct. This routine is used in the PySCF periodic (pbc) coupled-cluster EOM k-CCSD RHF code to map tuples of indices (for example k-point, band, or orbital coordinates across dimensions) into a single array index for compact storage and lookup.
    
    Args:
        indices (numpy.ndarray): A one-dimensional numpy array of integer indices, one entry per dimension. Each element represents the coordinate in that dimension (for example, a k-point index or orbital index). In typical use within pbc.cc.eom_kccsd_rhf, indices encodes a multi-dimensional index that must be combined into a single linear index for array addressing. The array length (indices.size) must equal struct.size. Values are expected to be non-negative integers in conventional use; however, the function only explicitly checks types and sizes and performs elementwise numeric operations.
        struct (numpy.ndarray): A one-dimensional numpy array of positive integers giving the radix (range) for each corresponding dimension in indices. struct determines how indices are weighted when producing the linearized index: the element struct[i] is the base (number of distinct values) for dimension i. The array length defines the number of dimensions and must match indices.size. In the periodic CC/EOM code, struct typically encodes the size of each index range (for example number of k-points or orbitals along each axis) used to compute mixed-radix positional weights.
    
    Returns:
        int: A non-negative integer equal to the mixed-radix linear index computed as
            sum_{dim=0..D-1} indices[dim] * prod(struct[dim+1:]),
        where D == struct.size. This integer can be used as a single-array index corresponding to the multi-dimensional coordinate given by indices. For example, indices = [3, 4, 5] and struct = [10, 10, 10] produce 3*10*10 + 4*10 + 5 = 345. If indices and struct are both zero-length arrays, the function returns 0.
    
    Behavior, side effects, and failure modes:
        The function performs no in-place modification of its inputs and has no external side effects beyond returning the computed integer. It requires both arguments to be numpy.ndarray instances; if either argument is not a numpy.ndarray a TypeError is raised with a message indicating the offending arguments. If indices.size != struct.size a ValueError is raised indicating a structure shape mismatch. The implementation contains an explicit check for out-of-range indices that raises ValueError only when all elements satisfy indices >= struct (i.e., if every index is greater than or equal to its corresponding radix); therefore, a single out-of-range element does not by itself trigger that ValueError. Users should therefore ensure indices lie within 0 .. struct[i]-1 for each dimension to obtain a meaningful mixed-radix index. The computation assumes 0-based indexing for dimensions.
    """
    from pyscf.pbc.cc.eom_kccsd_rhf import join_indices
    return join_indices(indices, struct)


################################################################################
# Source: pyscf.pbc.cc.eom_kccsd_rhf.vector_to_amplitudes_singlet
# File: pyscf/pbc/cc/eom_kccsd_rhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_cc_eom_kccsd_rhf_vector_to_amplitudes_singlet(
    vector: numpy.ndarray,
    nkpts: int,
    nmo: int,
    nocc: int,
    kconserv: numpy.ndarray
):
    """Convert a packed 1-D excitation vector used in k-point (periodic) EOM-CCSD (singlet)
    calculations into orbital- and k-point-resolved singles and doubles amplitude arrays.
    
    This function is used in the pyscf.pbc.cc.eom_kccsd_rhf module to unpack a linearized
    vector of excitation amplitudes (the internal representation used by iterative
    solvers and linear-algebra routines) into the physical amplitude tensors required
    by the equations-of-motion coupled-cluster with k-point symmetry (k-CCSD) for
    restricted Hartree–Fock reference states. The input vector encoding is expected
    to follow the packing convention: all singles (r1) entries first, followed by
    packed doubles (r2) blocks that exploit momentum-conservation and permutation
    symmetries via the kconserv lookup. The routine preserves the input array dtype
    and produces new numpy.ndarray objects for r1 and r2; it does not modify the
    input vector in-place.
    
    Args:
        vector (numpy.ndarray): One-dimensional numpy array containing packed
            excitation amplitudes. The first nkpts * (nocc*(nmo-nocc)) entries
            correspond to the singles amplitudes r1 in k-point-major order and are
            reshaped to (nkpts, nocc, nvir) where nvir = nmo - nocc. The remaining
            entries encode the doubles amplitudes r2 in a packed format: for each
            triplet (ki, ka, kj) the conserving index kb = kconserv[ki, ka, kj] is
            looked up and either a lower-triangular nov-by-nov block (when the
            combined index kika == kjkb) or a full nov-by-nov block (when kika >
            kjkb) is read; here nov = nocc * nvir. The function expects that the
            vector length exactly matches the required count implied by nkpts, nmo,
            nocc, and kconserv; a mismatch will typically raise a numpy IndexError
            or a reshape error. The dtype of vector is used for the returned arrays.
        nkpts (int): Number of k-points sampled in the Brillouin zone. This integer
            determines the first three axes of the returned doubles tensor and is
            used to interpret combined k-point indices (e.g., kika = ki * nkpts + ka).
            nkpts must be consistent with the dimensions and values stored in kconserv.
        nmo (int): Total number of molecular orbitals per k-point. This integer is
            used to compute the number of virtual orbitals per k-point as nvir =
            nmo - nocc. If nmo <= nocc, the computed nvir will be non-positive and
            subsequent reshapes will fail.
        nocc (int): Number of occupied orbitals per k-point. This integer enters the
            computation of nov = nocc * nvir and the shapes of the returned amplitude
            arrays. It must be consistent with nmo.
        kconserv (numpy.ndarray): Integer array used to enforce crystal momentum
            conservation in k-point indexing. kconserv is indexed as kconserv[ki, ka, kj]
            to produce an integer kb in the range 0..nkpts-1 which identifies the
            partner k-point for each (ki, ka, kj) triplet. The array must support
            integer indexing with dimensions compatible with nkpts (typically shape
            (nkpts, nkpts, nkpts) or broadcastable to that shape). If kconserv
            contains out-of-range integers, an IndexError will be raised when used.
    
    Returns:
        list: Two-element list [r1, r2] containing unpacked excitation amplitudes.
            r1 (numpy.ndarray): 3-dimensional array of singles amplitudes with shape
                (nkpts, nocc, nvir) and dtype equal to vector.dtype. Elements are
                accessed as r1[k_i, i, a] and correspond to the singles amplitude
                r_{i k_i}^{a k_a} used in k-CCSD EOM formulations.
            r2 (numpy.ndarray): 7-dimensional array of doubles amplitudes with shape
                (nkpts, nkpts, nkpts, nocc, nvir, nocc, nvir) and dtype equal to
                vector.dtype. Elements can be accessed as
                r2[k_i, k_j, k_a, i, j, a, b] and correspond to the doubles amplitude
                r_{i k_i, j k_j}^{a k_a, b k_b} (with k_b determined by kconserv).
            The returned arrays are newly allocated and independent of the input
            vector (no in-place modification of the input occurs).
    
    Behavior and failure modes:
        - The function computes nvir = nmo - nocc and nov = nocc * nvir internally.
          If these values are not positive integers, numpy reshape operations will
          fail.
        - The r2 portion of vector is read blockwise following the loop over (ki, ka, kj)
          and using kb = kconserv[ki, ka, kj]. For blocks where the combined index
          kika == kjkb only the lower-triangular elements of the nov-by-nov block
          are stored in the packed input; these are expanded back to symmetric
          storage in the output r2 array. For kika > kjkb full nov-by-nov blocks are
          read and mirrored appropriately; entries for kika < kjkb are populated by
          symmetry and are not present separately in the packed input.
        - If the input vector length, the shape or contents of kconserv, or the
          supplied integers nkpts, nmo, nocc are inconsistent, the function will
          typically raise numpy IndexError, ValueError (from reshape), or other
          exceptions originating from invalid array indexing or slicing.
        - The function preserves the numeric dtype of the input vector and returns
          arrays with the same dtype.
    """
    from pyscf.pbc.cc.eom_kccsd_rhf import vector_to_amplitudes_singlet
    return vector_to_amplitudes_singlet(vector, nkpts, nmo, nocc, kconserv)


################################################################################
# Source: pyscf.pbc.cc.kccsd_t_rhf.check_read_success
# File: pyscf/pbc/cc/kccsd_t_rhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_cc_kccsd_t_rhf_check_read_success(filename: str, **kwargs):
    """Determine whether a dataset file for the k-point CCSD(T) restricted-HF (kccsd_t_rhf)
    workflow in the PySCF periodic-boundary-condition (pbc) module can be considered
    successfully written and therefore safe to read. In the PySCF project, routines
    that read intermediate or restart datasets (typically stored in HDF5-like files)
    use this predicate to avoid reading incomplete files produced by concurrent or
    interrupted write operations. The implementation is currently a stub that always
    returns False; the intended behavior is to inspect file metadata (for example a
    'completed' attribute set by the writer) to decide read readiness.
    
    Args:
        filename (str): Path to the dataset file that would be read by the
            pyscf.pbc.cc.kccsd_t_rhf reader. In practice this is the filesystem
            path to an HDF5 or HDF5-like file used by PySCF to store serialized
            correlated‑method intermediates and results for periodic calculations.
            The function is expected to examine metadata inside this file to
            determine whether a prior write completed successfully.
        kwargs (dict): Additional keyword arguments forwarded to the underlying
            file-inspection routine. The implementation inspects kwargs.get('mode',
            'r') to decide the file open mode and forwards kwargs to the file wrapper
            (the nested helper uses lib.H5FileWrap(filename, mode=mode, **kwargs)
            in the original source). Callers can pass options understood by that
            wrapper; if omitted, the default mode is 'r'. This parameter does not
            accept positional arguments and must be provided as standard Python
            keyword arguments when used.
    
    Returns:
        bool: True if the dataset is judged safe to read (for example, the file
        exists and contains a metadata flag such as a 'completed' attribute set by
        the writer), False otherwise. Note that in the current source, the function
        is a stub and unconditionally returns False; therefore callers should
        currently treat the dataset as not ready to read. Future implementations
        may open the file (via lib.H5FileWrap), check for existence, and inspect a
        'completed' attribute; such operations can raise I/O-related exceptions
        (e.g., file-not-found, permissions, or HDF5 read errors) when enabled.
    """
    from pyscf.pbc.cc.kccsd_t_rhf import check_read_success
    return check_read_success(filename, **kwargs)


################################################################################
# Source: pyscf.pbc.cc.kccsd_rhf.vector_to_nested
# File: pyscf/pbc/cc/kccsd_rhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_cc_kccsd_rhf_vector_to_nested(
    vector: numpy.ndarray,
    struct: list,
    copy: bool = True,
    ensure_size_matches: bool = True
):
    """pyscf.pbc.cc.kccsd_rhf.vector_to_nested reconstructs a nested array structure from a flattened 1-D numpy vector used by the k-point CCSD/RHF routines in PySCF. This function is used to map a single optimization or solver vector (flattened amplitudes and intermediates) back to the original nested collection of numpy arrays (tensors) described by struct so downstream coupled-cluster code can operate on arrays with original shapes and nesting.
    
    Args:
        vector (numpy.ndarray): A one-dimensional numpy array containing a flattened sequence of elements representing concatenated array data for a nested structure. In the PySCF kccsd_rhf context, this is typically a concatenated amplitude/intermediate vector produced by operations that flatten many tensors into a single vector for linear algebra or solver-based updates. The function requires vector.ndim == 1; otherwise a ValueError is raised.
        struct (list): A specification of the desired nested structure to reconstruct from vector. Each element of struct must be either a tuple describing an array shape (interpreted as numpy array shape, e.g., (n,m)), or a nested list following the same conventions for further nesting. When struct is a tuple (checked in the source), it is interpreted as a single array shape and the function will reshape the corresponding slice of vector into that shape. When struct is a list (checked in the source), the function recurses over elements, concatenating results in order. This parameter determines how many vector elements are consumed and the shapes of the returned numpy arrays; it directly corresponds to the shapes used in PySCF CCSD amplitude packing/unpacking.
        copy (bool): If True (the default), each array returned for a tuple-shaped element is a copy of the data extracted from vector (i.e., the function returns freshly allocated numpy arrays). If False, the function may return views into the original vector slice where possible. Use copy=True to avoid unexpected aliasing between the returned nested arrays and the input vector when the caller will modify arrays independently of the original vector.
        ensure_size_matches (bool): If True (the default), the function enforces that the total number of elements in vector exactly equals the total number required by struct. If this check fails a ValueError is raised. If False, the function is permissive: it returns the reconstructed nested structure plus the integer number of vector elements actually consumed (see Returns). Set ensure_size_matches=False when composing larger nested structures incrementally from a single long vector and you need the function to report how many elements it used.
    
    Returns:
        If ensure_size_matches is True: The reconstructed nested structure (list or numpy.ndarray) matching struct. For tuple-valued struct entries this is a numpy.ndarray with the requested shape (copied if copy=True). For list-valued struct entries this is a Python list whose elements are arrays or further nested lists following struct.
        If ensure_size_matches is False: A tuple (nested_structure, used_elements) where nested_structure is as described above and used_elements (int) is the number of elements consumed from the start of vector to build nested_structure. This mode is provided for incremental composition of nested structures from a larger vector (for example when unpacking multiple blocks in sequence).
    
    Behavior and side effects:
        The function requires a 1-D numpy.ndarray input. It interprets tuple entries of struct as shapes and list entries as sequences to be recursively processed in order. When struct is a tuple the function slices the first prod(struct) elements of vector, reshapes them to struct, and returns that array (copied if copy=True). When struct is a list the function processes each element in order, advancing an internal offset; the final returned list preserves the same nesting order as struct. When ensure_size_matches=True the function performs strict checks: for tuple struct it verifies vector.size equals the expected size; for list struct it verifies the sum of sizes equals vector.size; mismatches raise ValueError. When ensure_size_matches=False the function does not require vector to contain exactly the expected number of elements and instead returns the number of elements used. Passing copy=False may return views referencing the original vector memory and therefore modifying returned arrays may alter vector contents.
    
    Failure modes:
        Raises ValueError if vector is not one-dimensional.
        Raises ValueError if sizes mismatch when ensure_size_matches is True (either too few or too many elements).
        Raises ValueError if struct contains an unsupported type (neither tuple nor list) as determined by the function; struct elements must be tuples (array shapes) or lists (nested specifications).
    
    Practical significance in PySCF:
        In PySCF's periodic CCSD/RHF (kccsd_rhf) code paths, many internal routines pack multiple amplitude and intermediate tensors into a single flat vector for solvers and linear algebra. vector_to_nested reverses that packing, reconstructing the original tensor collection so that coupled-cluster tensor operations (contractions, updates, diagnostics) can be performed using the original shapes and nesting. Use this function when unpacking solver-produced or optimizer-produced vectors back into the structured tensors expected by the rest of the CCSD implementation.
    """
    from pyscf.pbc.cc.kccsd_rhf import vector_to_nested
    return vector_to_nested(vector, struct, copy, ensure_size_matches)


################################################################################
# Source: pyscf.pbc.cc.kccsd_t_rhf.zip_kpoints
# File: pyscf/pbc/cc/kccsd_t_rhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_cc_kccsd_t_rhf_zip_kpoints(kpt_indices: list):
    """pyscf.pbc.cc.kccsd_t_rhf.zip_kpoints converts and tiles k-point indices into integer index combinations suitable for assembling three-particle operator elements in k-point coupled-cluster (k-CCSD(T)) calculations for periodic systems. In the context of PySCF's pbc.cc.kccsd_t_rhf module, this function implements a Cartesian-product-like expansion specialized for the momentum-index bookkeeping required when forming triple-excitation (three-particle) amplitude or integral index combinations across k-points in periodic boundary condition (PBC) calculations. The function ensures all returned indices are integers and returns a flattened, tiled list of index tuples that downstream routines (integral contraction, amplitude updates) can iterate over deterministically.
    
    Args:
        kpt_indices (list): Input list of k-point indices to be processed. Each element may be an integer or a value that can be converted to an integer by the module's helper _convert_to_int; typical inputs are lists or arrays of k-point indices produced by k-point sampling routines in PBC HF/CC workflows. This parameter is the primary input used to enumerate all required index combinations for a 3-particle operator in k-point CC methods; the function does not modify the input object in place but returns a new list of tiled indices.
    
    Returns:
        list: A new list containing the tiled k-point index combinations prepared for a 3-particle operator. Each entry in the returned list is a sequence of integer indices (commonly a 3-tuple) representing one combination of k-points needed by k-CCSD(T) algebra. The integers have been normalized by the helper _convert_to_int and the full Cartesian-product-like tiling has been produced by the helper _tile_list so that the return value can be consumed directly by routines that assemble three-particle integrals or amplitudes.
    
    Behavior and side effects:
        This function is pure with respect to input mutation: it does not alter the provided kpt_indices object but returns a new list. It applies two internal helpers in sequence: _convert_to_int to coerce entries to Python integers, then _tile_list to produce the combination/tiling appropriate for three-particle operator index bookkeeping. There are no hidden side effects such as I/O or global state modification.
    
    Failure modes and errors:
        If any element of kpt_indices cannot be converted to an integer by the underlying _convert_to_int helper, the function will propagate an exception raised by that helper (for example, a TypeError or ValueError), indicating invalid input. Consumers should validate that kpt_indices contains integer-like values (or types convertible to int) before calling this function to avoid runtime errors.
    
    Practical significance:
        Use this function when preparing index lists for momentum-conserving contractions and amplitude updates in periodic coupled-cluster implementations (k-point CCSD(T))/restricted-HF reference contexts. It centralizes and standardizes the index normalization and tiling logic so downstream tensor contractions receive consistent, integer-indexed combinations.
    """
    from pyscf.pbc.cc.kccsd_t_rhf import zip_kpoints
    return zip_kpoints(kpt_indices)


################################################################################
# Source: pyscf.pbc.cc.kccsd_rhf.nested_to_vector
# File: pyscf/pbc/cc/kccsd_rhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_cc_kccsd_rhf_nested_to_vector(
    data: list,
    destination: numpy.ndarray = None,
    offset: int = 0
):
    """Puts a nested iterable of NumPy arrays into a one-dimensional vector. This function is used in the periodic coupled-cluster (kccsd_rhf) code path of PySCF to pack nested amplitude or intermediate arrays (for example, cluster amplitudes organized by k-points and excitation rank) into a contiguous 1D NumPy array for use in linear-algebra operations or I/O. When called without an explicit destination array, the function inspects the nested structure to compute the total storage required, allocates a 1D NumPy array of the appropriate dtype and size, and returns that array together with a structure descriptor that can be used to restore the flat vector back into the original nested layout.
    
    Args:
        data (Iterable): A nested structure composed of NumPy arrays and container types (the function recognizes numpy.ndarray, list, and tuple). Each leaf in the nesting must be a numpy.ndarray whose flattened data will be copied into the output vector. In the kccsd_rhf context, `data` typically contains arrays of cluster amplitudes or related tensor blocks organized by physical indexing (e.g., k-points, spin/orbital blocks). The order in which leaves are traversed and concatenated is the traversal order implemented in this function: arrays are ravelled and appended, and lists/tuples are iterated in their native order.
        destination (numpy.ndarray): A pre-allocated one-dimensional NumPy array used to receive the flattened contents of `data`. If None (the default), the function will compute the total required size (by calling describe_nested on `data`), allocate a new numpy.empty array of that size and the appropriate dtype, and write into it. If provided, the function writes into `destination` starting at index `offset`. The caller must ensure `destination` has sufficient length to receive the data; otherwise an IndexError or similar NumPy error may be raised.
        offset (int): Integer index within `destination` at which to begin writing the flattened data. Defaults to 0. When a pre-allocated `destination` is supplied, the function increments and returns the updated offset after writing the contents of `data`. When `destination` is None (so the function allocates a new vector), this parameter is ignored for allocation but the returned vector contains the packed data starting at index 0.
    
    Returns:
        If destination is None:
            tuple: A pair (vector, struct) where `vector` is a one-dimensional numpy.ndarray containing the concatenated, flattened data from `data` in traversal order, and `struct` is the nested-structure descriptor produced by describe_nested that encodes the layout (shapes, sizes, and dtype) necessary to restore the flat vector back into the original nested arrays. This return mode is intended for callers that want automatic allocation and later reconstruction of the nested form (for example, to save and later restore CC amplitude tensors).
        Otherwise:
            int: The new offset after writing the flattened contents of `data` into the provided `destination`. This allows iterative packing of multiple nested structures into different regions of a single pre-allocated vector.
    
    Behavior and side effects:
        When destination is None, the function calls describe_nested(data) to determine total_size and dtype, allocates a new numpy.empty(total_size, dtype=dtype), and writes the flattened contents. The function always writes into `destination` (mutating the provided array) and returns either (vector, struct) or the updated offset as described above. The dtype of the allocated array matches the dtype discovered by describe_nested, preserving numeric precision used in the nested arrays.
    Failure modes:
        A ValueError is raised if `data` contains an unsupported object type (i.e., a leaf that is not a numpy.ndarray and not contained within list/tuple containers). If a non-None `destination` does not have sufficient length to hold the flattened data starting at `offset`, NumPy will raise an IndexError or broadcast/assignment error. The function does not perform implicit type conversion of array elements beyond NumPy's assignment semantics; callers should ensure dtype compatibility if using a pre-allocated `destination`.
    Performance notes:
        Allocating a new vector (destination is None) incurs a memory allocation of size equal to the sum of all leaf array sizes. Using a pre-allocated `destination` with appropriate size avoids this allocation and can reduce peak memory usage in high-performance kccsd_rhf workflows.
    """
    from pyscf.pbc.cc.kccsd_rhf import nested_to_vector
    return nested_to_vector(data, destination, offset)


################################################################################
# Source: pyscf.pbc.cc.kccsd_t_rhf.create_eris_vooo
# File: pyscf/pbc/cc/kccsd_t_rhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_cc_kccsd_t_rhf_create_eris_vooo(
    ooov: numpy.ndarray,
    nkpts: int,
    nocc: int,
    nvir: int,
    kconserv: numpy.ndarray,
    out: numpy.ndarray = None
):
    """Creates vooo from ooov array for k-point periodic CCSD(T) computations in PySCF.
    
    This function converts a four-index two-electron integral block given in a physicist-like
    ordering (ooov) into a chemist-like vooo ordering used by the k-point restricted
    CCSD(T) implementation (kccsd_t_rhf). The conversion includes complex conjugation
    and a specific transpose of the orbital indices, and it uses the k-point momentum
    conservation mapping kconserv to place the transformed block at the correct k-point
    index kb = kconserv[ki,kj,ka]. This routine is typically used during the construction
    of intermediate electron-repulsion integrals for triples corrections in periodic
    quantum chemistry calculations with PySCF (k-point periodic boundary condition workflows).
    
    Args:
        ooov (numpy.ndarray): Input array of two-electron integrals in physicist-like
            ordering. The function expects an array with shape
            (nkpts, nkpts, nkpts, nocc, nocc, nocc, nvir) matching the k-point and
            orbital partitioning used in k-point RHF CCSD(T) code. The array is read
            and conjugated, so it is commonly a complex-valued array (dtype supporting
            .conj()), but the declared type must be numpy.ndarray.
        nkpts (int): Number of k-points in the Brillouin zone sampling. This integer
            determines the leading three dimensions of ooov and the allocated output.
            It must match the first three dimensions of ooov and the shape of kconserv.
        nocc (int): Number of occupied orbitals per k-point. This integer determines
            the occupied-orbital dimensions in ooov and controls how indices are
            interpreted during the transpose/conjugation. It must match the occupied
            dimensions embedded in ooov.
        nvir (int): Number of virtual orbitals per k-point. This integer determines
            the virtual-orbital dimension (last axis) of ooov and the virtual dimension
            of the returned vooo array.
        kconserv (numpy.ndarray): Integer array that enforces k-point momentum
            conservation for three k-point indices. The function uses kconserv[ki,kj,ka]
            to obtain kb such that (ki,kj,ka,kb) satisfy momentum conservation.
            kconserv must be indexable with three indices in the range [0, nkpts-1].
        out (numpy.ndarray, optional): Optional preallocated output array to store the
            transformed integrals in vooo ordering. If provided, it must have shape
            (nkpts, nkpts, nkpts, nvir, nocc, nocc, nocc) and a dtype compatible with
            ooov. If None (the default), a new numpy.ndarray with the required shape
            and ooov.dtype will be allocated and returned. When provided, this array
            will be overwritten in-place and also returned.
    
    Behavior, side effects, defaults, and failure modes:
        The function asserts that ooov.shape == (nkpts, nkpts, nkpts, nocc, nocc, nocc, nvir)
        and will raise an AssertionError if this condition is not met. For each triple
        of k-point indices (ki, kj, ka) the function computes kb = kconserv[ki, kj, ka]
        and assigns a conjugated and permuted slice of ooov into the out array at
        out[ki, kj, kb]. Concretely, the assignment performed is:
            out[ki, kj, kb] = ooov[kb, kj, ka].conj().transpose(3, 1, 0, 2)
        which applies complex conjugation and reorders the last four axes of the
        referenced ooov block using axis order (3,1,0,2). The semantics are to convert
        from a physicist-like ooov representation into a chemist-like vooo block
        consistent with the k-point CCSD(T) code path. If kconserv contains indices
        outside the valid range [0, nkpts-1] or is not shaped/indexable appropriately,
        indexing will raise an IndexError. If out is provided but has an incompatible
        shape or dtype, the assignment will raise an exception (for example ValueError
        or IndexError). The function performs no additional validation of kconserv beyond
        indexing and relies on the caller to provide consistent k-point bookkeeping.
    
    Returns:
        numpy.ndarray: Array containing the transformed integrals in vooo ordering with
        shape (nkpts, nkpts, nkpts, nvir, nocc, nocc, nocc). The returned array is the
        same object as the provided out argument when out is not None (and is overwritten),
        otherwise a newly allocated numpy.ndarray of dtype ooov.dtype is returned. This
        output is the representation expected downstream by k-point RHF CCSD(T) routines
        that consume vooo-style integral blocks for building CC intermediates and
        triples corrections.
    """
    from pyscf.pbc.cc.kccsd_t_rhf import create_eris_vooo
    return create_eris_vooo(ooov, nkpts, nocc, nvir, kconserv, out)


################################################################################
# Source: pyscf.pbc.cc.kccsd_t_rhf.create_eris_vvop
# File: pyscf/pbc/cc/kccsd_t_rhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_cc_kccsd_t_rhf_create_eris_vvop(
    vovv: numpy.ndarray,
    oovv: numpy.ndarray,
    nkpts: int,
    nocc: int,
    nvir: int,
    kconserv: numpy.ndarray,
    out: numpy.ndarray = None
):
    """Creates the vvop tensor from input two-electron integral blocks vovv and oovv (physicist notation) for k-point periodic CCSD(T) routines. This function is used in the PySCF periodic, restricted-HF k-point CCSD(T) implementation (pyscf.pbc.cc.kccsd_t_rhf) to assemble a combined tensor needed by downstream amplitude and energy routines that enforce crystal momentum conservation via the kconserv mapping. The routine preserves the dtype of vovv when allocating the output, applies complex conjugation and a specific axes permutation to convert the input block ordering into the output ordering, and writes into the provided output buffer or allocates one if out is None.
    
    Args:
        vovv (numpy.ndarray): 4-index two-electron integral blocks in physicist notation with asserted shape (nkpts, nkpts, nkpts, nvir, nocc, nvir, nvir). Here each k-point axis ranges over nkpts; the inner axes correspond to (v, o, v, v) where v indexes virtual orbitals (length nvir) and o indexes occupied orbitals (length nocc). The function asserts this exact shape and will raise an AssertionError if the array shape does not match. The values are typically complex in periodic calculations; the routine uses vovv.conj() during assembly.
        oovv (numpy.ndarray): Optional 4-index two-electron integral blocks in physicist notation expected to have shape (nkpts, nkpts, nkpts, nocc, nocc, nvir, nvir) corresponding to (o, o, v, v) ordering for each triplet of k-points. If oovv is None, the occupied-part of the output (first nocc entries along the last axis) is left untouched for those entries (not written by this function). If provided but with an incorrect shape, downstream indexing and the internal transpose will produce an error or an AssertionError may be raised elsewhere.
        nkpts (int): Number of k-points in the Brillouin zone sampling. This integer defines the range of the outer three k-point loops and the expected first three dimensions of vovv, oovv (if provided), kconserv, and out. Out-of-range values in kconserv will raise an IndexError during assembly.
        nocc (int): Number of occupied spin-orbitals per k-point used to interpret the occupied dimensions of vovv and oovv and to define the split point in the last axis of the output buffer. The function computes nmo = nocc + nvir and uses nocc to size and slice the output's last axis accordingly.
        nvir (int): Number of virtual spin-orbitals per k-point used to interpret the virtual dimensions of vovv and oovv and to size the allocated output buffer when out is None. This value combined with nocc sets the molecular-orbital count nmo used in the output shape.
        kconserv (numpy.ndarray): Integer array implementing crystal momentum conservation mapping with at least shape (nkpts, nkpts, nkpts). For each triple (ki, ka, kj) the routine reads kb = kconserv[ki, ka, kj] and uses kb to index into the input vovv and oovv blocks so that the assembled tensor respects k-point momentum conservation. Entries must be valid indices in 0..nkpts-1; invalid entries will raise IndexError.
        out (numpy.ndarray): Optional output buffer to hold the assembled tensor. If None, the function allocates a new numpy.ndarray with dtype matching vovv.dtype and shape (nkpts, nkpts, nkpts, nvir, nvir, nocc, nmo) where nmo = nocc + nvir. If provided, out must already have this exact shape; otherwise the function raises an AssertionError. When provided, out is overwritten in the slices assigned by this function. The function writes the contribtions from vovv into out[..., nocc:] (the virtual-part of the last axis) and, if oovv is not None, writes oovv contributions into out[..., :nocc] (the occupied-part of the last axis). The routine performs conjugation and axis permutation on the input blocks before assignment using .conj().transpose(3,2,1,0).
    
    Returns:
        numpy.ndarray: The assembled vvop tensor with shape (nkpts, nkpts, nkpts, nvir, nvir, nocc, nmo) where nmo = nocc + nvir and dtype equal to vovv.dtype. The returned array is either the provided out buffer (after in-place modification) or a newly allocated numpy.ndarray when out was None. Side effects include allocation of the output buffer when out is None and in-place modification of the provided out array. Failure modes include AssertionError if vovv or out do not have the expected shapes, IndexError if kconserv contains out-of-range indices, and indexing/shape errors if oovv is provided with an unexpected layout.
    """
    from pyscf.pbc.cc.kccsd_t_rhf import create_eris_vvop
    return create_eris_vvop(vovv, oovv, nkpts, nocc, nvir, kconserv, out)


################################################################################
# Source: pyscf.pbc.cc.kccsd_t_rhf.transpose_t2
# File: pyscf/pbc/cc/kccsd_t_rhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_cc_kccsd_t_rhf_transpose_t2(
    t2: numpy.ndarray,
    nkpts: int,
    nocc: int,
    nvir: int,
    kconserv: numpy.ndarray,
    out: numpy.ndarray = None
):
    """Creates a transposed copy of two-body cluster amplitudes t2 used by k-point CCSD(T) in periodic boundary condition (PBC) calculations, returning an array with k-point and orbital indices rearranged so the k-point axes are ordered as (ka, kb, kj) and the orbital axes are ordered as (nvir, nvir, nocc, nocc). This function is used in pyscf.pbc.cc.kccsd_t_rhf to convert stored T2 amplitudes into the layout expected by subsequent tensor contractions in k-CCSD(T) post-processing and (T) energy routines. It understands two storage conventions for t2: full storage across all k-point triples and lower-triangular storage that exploits symmetry (ki <= kj) to save memory.
    
    Args:
        t2 (numpy.ndarray): Input two-body excitation amplitudes. Accepted shapes (as enforced by the implementation) are either
            (nkpts, nkpts, nkpts, nocc, nocc, nvir, nvir) for full storage, or
            (nkpts*(nkpts+1)//2, nkpts, nocc, nocc, nvir, nvir) for lower-triangular (compressed) storage where the first axis indexes the pair (ki,kj) in a packed triangular ordering with ki <= kj. In both shapes the first three axes correspond to k-point indices used in the PySCF k-point CCSD(T) code and the remaining four axes correspond to occupied (nocc) and virtual (nvir) orbital index dimensions. The function reads t2.dtype to determine the dtype of a newly allocated output when out is None.
        nkpts (int): Number of k-points in the Brillouin zone sampling. This integer defines the expected ranges of k-point indices and is used to construct the output shape (nkpts, nkpts, nkpts, nvir, nvir, nocc, nocc) when out is None and to validate t2's leading dimensions in each supported storage convention.
        nocc (int): Number of occupied orbitals per k-point. This integer describes the size of the occupied-orbital index dimensions in t2 and in the returned array; it must match the occupied dimensions present in the input t2 array.
        nvir (int): Number of virtual orbitals per k-point. This integer describes the size of the virtual-orbital index dimensions in t2 and in the returned array; it must match the virtual dimensions present in the input t2 array.
        kconserv (numpy.ndarray): Integer array encoding momentum (k-point) conservation used by the periodic CC implementation. The array is indexed as kconserv[ki, ka, kj] and returns the k-point index kb that satisfies momentum conservation for the quartet (ki, kj, ka, kb). This mapping is used to place transposed blocks into the correct positions in the output array so that k-point conservation required by PBC tensor contractions is respected.
        out (numpy.ndarray, optional): Preallocated output array to receive the transposed amplitudes. If provided, this array is modified in-place and also returned. When None (the default), a new numpy.ndarray is allocated with shape (nkpts, nkpts, nkpts, nvir, nvir, nocc, nocc) and dtype equal to t2.dtype. If supplied, out must be writable and have a shape compatible with assignment to indices of the form out[ka, kb, kj] where ka, kb, kj run from 0..nkpts-1 and the trailing axes have sizes (nvir, nvir, nocc, nocc); providing an array with incompatible shape or dtype may raise broadcasting or assignment errors during execution.
    
    Behavior and side effects:
        For the full-storage input shape (len(t2.shape) == 7 and t2.shape[:3] == (nkpts, nkpts, nkpts)), the function loops over all triples of k-point indices (ki, kj, ka), computes kb = kconserv[ki, ka, kj], and assigns out[ka, kb, kj] = t2[ki, kj, ka].transpose(2, 3, 1, 0). The transpose(2, 3, 1, 0) call reorders the four orbital axes in each 4-D block so the returned block has ordering (nvir, nvir, nocc, nocc) required by downstream routines.
        For the lower-triangular (compressed) storage input (len(t2.shape) == 6 and t2.shape[:2] == (nkpts*(nkpts+1)//2, nkpts)), the function interprets the first axis as a packed triangular index for pairs (ki, kj) with ki <= kj. For each triple (ki, kj, ka) it computes tril_idx = (kj*(kj+1))//2 + ki when ki <= kj to access the packed block, applies the same transpose to produce a block in the (nvir, nvir, nocc, nocc) ordering, stores it at out[ka, kb, kj], and also fills the symmetric counterpart out[kb, ka, ki] by transposing that block with transpose(1, 0, 3, 2). This preserves the symmetry relationships implied by the compressed storage while producing a full output array indexed by explicit k-point triples.
        The function returns the array containing the transposed amplitudes. If out is provided, that array is modified in-place (side effect) and returned; if out is None, a new array is allocated and returned.
    
    Failure modes:
        If t2.shape does not match either supported storage convention, the function raises ValueError('No known conversion for t2 shape %s' % t2.shape). If out is supplied with an incompatible shape or is not writable, the function may raise numpy broadcasting/assignment errors or TypeError/ValueError during in-place assignment. If kconserv does not contain valid integer k-point indices in the range 0..nkpts-1, IndexError may be raised when indexing kconserv or assigning into out.
    
    Returns:
        numpy.ndarray: The transposed two-body amplitudes arranged with k-point axes ordered as (ka, kb, kj) and orbital axes ordered as (nvir, nvir, nocc, nocc). The returned array has shape (nkpts, nkpts, nkpts, nvir, nvir, nocc, nocc). If out was provided, the same array object passed as out is returned after in-place modification; if out was None, a newly allocated numpy.ndarray with dtype equal to t2.dtype is returned.
    """
    from pyscf.pbc.cc.kccsd_t_rhf import transpose_t2
    return transpose_t2(t2, nkpts, nocc, nvir, kconserv, out)


################################################################################
# Source: pyscf.pbc.dft.multigrid._backend_c.gradient_gs
# File: pyscf/pbc/dft/multigrid/_backend_c.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_dft_multigrid__backend_c_gradient_gs(f_gs: numpy.ndarray, Gv: numpy.ndarray):
    """pyscf.pbc.dft.multigrid._backend_c.gradient_gs computes the G-space (reciprocal-space) components of the spatial gradient ∇f(r) from the Fourier coefficients f(G) and the G-vectors G. This function is used in the plane-wave / periodic-boundary-condition (PBC) multigrid routines within PySCF's periodic DFT code to obtain the Cartesian components of the gradient in G-space for quantities represented by their Fourier transforms (for example, orbitals, density, or potential components in a multigrid/FFT-based solver). The implementation dispatches the computation to a C multithreaded routine (libdft.gradient_gs) for performance and is mathematically equivalent to performing numpy.einsum('np,px->nxp', f_gs, 1j*Gv) but with multithreading and explicit C-contiguous memory layout.
    
    Args:
        f_gs (numpy.ndarray): Complex-valued Fourier coefficients f(G) provided as an array that can be shaped (n, ng) or any shape that flattens to (-1, ng) on entry. Here ng is the number of G-vectors (the first dimension of Gv). Each row (or each flattening block) corresponds to a separate field/function whose gradient is to be computed. The function will reshape f_gs to shape (n, ng), convert it to dtype numpy.complex128, and ensure C-contiguous memory layout before calling the backend. The values represent f(G) (Fourier components) so they are complex in general.
        Gv (numpy.ndarray): Real-valued array of G-vectors with shape (ng, 3) and dtype convertible to numpy.double. The second dimension must be of size 3 (Cartesian components); an assertion in the code enforces this. Each row is a 3-component reciprocal-space vector G; ng (number of rows) must match the second dimension ng of the reshaped f_gs.
    
    Returns:
        numpy.ndarray: Complex-valued array with shape (n, 3, ng) and dtype numpy.complex128 containing the G-space components of the gradient. The second dimension of size 3 corresponds to the Cartesian components (x, y, z) in reciprocal space, so out[i, c, j] equals 1j * Gv[j, c] * f_gs[i, j] for each batch index i, Cartesian component c, and G-vector index j. The returned array is newly allocated (no in-place modification of the original inputs); the implementation ensures C-contiguous layout for efficient C-backend consumption.
    
    Behavior, side effects, and failure modes:
    - The function will assert that Gv.shape[1] == 3 and will raise an AssertionError if this is not met.
    - f_gs will be reshaped to (-1, ng) where ng == Gv.shape[0]; if the total number of elements in f_gs is not a multiple of ng the reshape will raise a ValueError.
    - Both inputs are converted to the backend dtypes (Gv -> numpy.double, f_gs -> numpy.complex128) and to C-contiguous memory order; copies will be made if necessary.
    - The heavy computation is performed by the C multithreaded routine libdft.gradient_gs via ctypes; errors or crashes in that native routine (for example, due to incompatible shapes or memory problems) will propagate as Python exceptions or may terminate the process depending on the underlying failure.
    - No global state in Python is modified; the only observable side effect is allocation of and return of the output array. Performance is improved over a pure-Python einsum by using the C backend and multithreading, which is relevant for large numbers of G-vectors (ng) in periodic DFT multigrid calculations.
    """
    from pyscf.pbc.dft.multigrid._backend_c import gradient_gs
    return gradient_gs(f_gs, Gv)


################################################################################
# Source: pyscf.pbc.dft.multigrid._backend_c.get_gga_vrho_gs
# File: pyscf/pbc/dft/multigrid/_backend_c.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_dft_multigrid__backend_c_get_gga_vrho_gs(
    v: numpy.ndarray,
    v1: numpy.ndarray,
    Gv: numpy.ndarray,
    weight: float,
    ngrid: int,
    fac: float = 2.0
):
    """Compute and update a generalized-gradient-approximation (GGA) density-related potential vector v in reciprocal (G) space used by the PySCF periodic-boundary-condition (PBC) multigrid DFT backend. This function wraps and calls the external C routine libdft.get_gga_vrho_gs to perform the complex arithmetic efficiently in C: it implements the operation
    v <- v - fac * 1j * einsum('px,xp->p', Gv, v1)
    followed by v <- v * weight.
    In the PySCF DFT workflow this routine is used to accumulate the GGA contribution to the potential (v) on a grid in reciprocal space, where Gv contains G-vector components and v1 encodes intermediate response-like quantities. The function ensures arrays are C-contiguous and cast to the dtypes required by the C backend before calling libdft.
    
    Args:
        v (numpy.ndarray): Complex-valued 1D array representing the potential vector in reciprocal-space grid coordinates. The code will convert v to a C-contiguous array of dtype numpy.complex128 before calling the C backend. Conceptually v is the target vector that will be updated according to the GGA-related formula above; on success the returned array contains the updated potential. If the original v is not already C-contiguous and complex128, a new array will be allocated, so the original Python object may or may not be modified in-place.
        v1 (numpy.ndarray): Complex-valued 2D array used in the contraction with Gv. The C wrapper casts v1 to C-contiguous numpy.complex128. The code uses the einsum pattern 'px,xp->p', so v1 must have dimensions compatible with that contraction (second index corresponding to the same grid dimension as v). In the PBC multigrid context v1 typically contains intermediate Fourier-space quantities from the GGA functional evaluation.
        Gv (numpy.ndarray): Real-valued 2D array (dtype coerced to numpy.double) containing G-vector components or related geometric factors arranged to match the einsum pattern 'px' in the contraction. Gv is interpreted as shape (p, x) so that the contraction with v1 ('xp') yields a length-p vector. In the multigrid/reciprocal-space domain these are the G-vector components used to form the gradient contribution to the potential.
        weight (float): Scalar multiplicative weight applied after the update. After performing the complex contraction and subtraction scaled by fac, the result is multiplied by this weight. In DFT workflows this represents a quadrature or grid weight factor used to scale contributions from this grid block.
        ngrid (int): Integer number of grid points (p in the einsum pattern) provided to the C backend as an explicit dimension. This value must be consistent with the first dimension of v and the corresponding dimensions of Gv and v1; mismatch can lead to incorrect results or undefined behavior in the C routine.
        fac (float): Scaling factor for the gradient contribution subtracted from v. Default is 2.0, matching the original implementation. In the mathematical update this appears as the multiplier of 1j times the contracted Gv·v1 term. This parameter controls the strength of the gradient-like correction contributed by the GGA kernel.
    
    Returns:
        numpy.ndarray: The updated complex-valued numpy.ndarray (dtype numpy.complex128, C-contiguous) corresponding to v after applying the operation v <- v - fac * 1j * einsum('px,xp->p', Gv, v1) and then scaling by weight. The function attempts to perform the update in-place on the provided v buffer when possible, but because inputs are coerced to specific dtypes and memory layout a copy may be made; therefore callers should use the returned array as the authoritative updated result.
    
    Behavior and side effects:
        The function casts inputs to the dtypes and C-contiguous memory layout required by the external C implementation (v and v1 -> numpy.complex128, Gv -> numpy.double). It then invokes libdft.get_gga_vrho_gs via ctypes, which modifies the memory of the converted v array. If the conversion produced a new array, the original Python array passed as v will not be updated; in that case the updated array is returned and should replace any references to the prior v. Because the function delegates work to an external C library via ctypes, incorrect shapes, inconsistent ngrid, or otherwise invalid memory layouts can cause the C routine to fail or the Python process to crash; callers must ensure array dimensions and ngrid are consistent. The operation implements the specific GGA-related update used in PySCF's PBC multigrid DFT backend and must be used in that context where Gv and v1 are prepared to match the expected contraction.
    """
    from pyscf.pbc.dft.multigrid._backend_c import get_gga_vrho_gs
    return get_gga_vrho_gs(v, v1, Gv, weight, ngrid, fac)


################################################################################
# Source: pyscf.pbc.df.rsdf_helper.remove_exp_basis
# File: pyscf/pbc/df/rsdf_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_df_rsdf_helper_remove_exp_basis(
    basis: list,
    amin: float = None,
    amax: float = None
):
    """Remove Gaussian primitive functions from a PySCF GTO basis whose exponents lie outside the open interval (amin, amax).
    
    This function operates on basis specifications used throughout PySCF (for molecular or periodic/ PBC calculations) in the GTO basis format (as stored in mol._basis or cell._basis). Each primitive exponent is a float that controls the radial extent of a Gaussian-type orbital (GTO) primitive; filtering primitives by exponent is useful in practice to remove very diffuse or very tight primitives that can cause numerical instability, near-linear dependence, or excessive computational cost in electronic structure calculations.
    
    Args:
        basis (list or dict): PySCF GTO basis format describing shells and primitives for one atom or for an entire system. This matches the format used in mol._basis or cell._basis. Examples of accepted shapes are a list of shells for a single atom, e.g. [[0, (1.5, 1.)], [1, (0.7, 1.)]], or a dictionary mapping atomic symbols to such lists, e.g. {"C": [[0, (1.5, 1.)], [1, (0.7, 1.)]], "H": [[0, (0.3, 1.)]]}. Each primitive exponent in these structures is a float and represents the Gaussian exponent of that primitive.
        amin (float): Lower exponent threshold. Primitives with exponents <= amin will be removed. If amin is not provided (None), the code treats amin as 0.0 by default, meaning no removal on the lower side except for non-positive exponents. Documented default in the function signature is None.
        amax (float): Upper exponent threshold. Primitives with exponents >= amax will be removed. If amax is not provided (None), the code treats amax as +infinity by default, meaning no removal on the upper side. Documented default in the function signature is None.
    
    Behavior and side effects:
        The filtering criterion is strict for the open interval (amin, amax): only primitives with exponent values strictly greater than amin and strictly less than amax are retained. Specifically, any primitive exponent x satisfying x <= amin or x >= amax is removed.
        If both amin and amax are None, the function returns the input basis object unchanged (same object reference); no copying or filtering is performed.
        If at least one of amin or amax is provided, the function produces and returns a new basis structure of the same high-level form as the input (a list for a single-atom basis or a dict mapping atom symbols to lists for a multi-atom basis). For dict inputs, a new dict is constructed mapping each atomic key to its filtered shell list.
        The function does not validate that amin < amax; if amin >= amax the filtering logic may remove all primitives (resulting in empty shell lists or shells with no primitives) without raising an error.
        The implementation delegates element-wise filtering to an internal helper (_remove_exp_basis_). If the input basis does not conform to the expected list-or-dict format, or if entries inside the structure are not in the expected GTO format, the helper or subsequent operations may raise TypeError or ValueError; such exceptions are not intercepted by this function.
    
    Returns:
        list or dict: A basis in the same PySCF GTO format as the input with primitives removed according to the exponent thresholds. If the input was a dict mapping atomic symbols to shell lists, a dict with the same keys and filtered shell lists is returned. If both amin and amax are None, the original input object is returned unchanged. The returned structure is intended for use in downstream PySCF operations (integral evaluation, SCF, post-HF methods) where removing extreme exponents can improve numerical stability and performance.
    """
    from pyscf.pbc.df.rsdf_helper import remove_exp_basis
    return remove_exp_basis(basis, amin, amax)


################################################################################
# Source: pyscf.pbc.grad.krhf.make_rdm1e
# File: pyscf/pbc/grad/krhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_grad_krhf_make_rdm1e(mo_energy: list, mo_coeff: list, mo_occ: list):
    """Construct energy-weighted one-particle density matrices for each k-point used in
    KRHF gradient evaluations in the periodic-boundary-conditions (pbc) module of PySCF.
    This function is a thin wrapper that dispatches per-k-point inputs to
    molgrad.make_rdm1e and stacks the results into a NumPy array for use in analytic
    gradient routines.
    
    Args:
        mo_energy (list): Per-k-point molecular orbital energies. Each element of this
            list corresponds to one k-point and should be the orbital energy array or
            sequence for that k-point as expected by molgrad.make_rdm1e. In the
            context of KRHF gradient calculations for periodic systems (pyscf.pbc.grad.krhf),
            these energies determine the energy-weighting applied when forming the
            one-particle density matrix used in computing analytic forces.
        mo_coeff (list): Per-k-point molecular orbital coefficient matrices. Each list
            element is the coefficient array (typically a 2D array) for the corresponding
            k-point and is passed directly to molgrad.make_rdm1e. In practical use within
            PySCF PBC KRHF gradients, these coefficients define the basis-transformed
            representation of orbitals needed to assemble the energy-weighted density.
        mo_occ (list): Per-k-point occupation numbers. The length of this list,
            nkpts = len(mo_occ), defines the number of k-points processed by this
            function. Each element holds the occupation numbers for the corresponding
            k-point and is used by molgrad.make_rdm1e to determine which orbitals
            contribute (and with what weight) to the energy-weighted density matrix.
    
    Returns:
        np.ndarray: A NumPy array obtained by stacking the per-k-point results from
        molgrad.make_rdm1e. The array has length nkpts along the first axis (nkpts is
        taken from len(mo_occ)), and each entry along that axis is the energy-weighted
        one-particle density matrix for the corresponding k-point as produced by
        molgrad.make_rdm1e. The element dtype and the inner matrix shape are inherited
        from the outputs of molgrad.make_rdm1e. This returned array is intended for
        direct use in KRHF analytic gradient assembly in pyscf.pbc.grad.krhf.
    
    Behavior and failure modes:
        The function determines the number of k-points from len(mo_occ) and iterates
        k in range(nkpts), calling molgrad.make_rdm1e(mo_energy[k], mo_coeff[k],
        mo_occ[k]) for each k. Therefore, mo_energy and mo_coeff must be indexable
        and must contain at least nkpts elements; otherwise an IndexError will occur.
        If the elements are of unexpected types or shapes, molgrad.make_rdm1e may raise
        TypeError or ValueError. There are no side effects (no global state is modified);
        this function simply returns the stacked array. The function relies on the
        presence and expected behavior of molgrad.make_rdm1e; any errors from that
        helper are propagated to the caller.
    """
    from pyscf.pbc.grad.krhf import make_rdm1e
    return make_rdm1e(mo_energy, mo_coeff, mo_occ)


################################################################################
# Source: pyscf.pbc.grad.kuhf.make_rdm1e
# File: pyscf/pbc/grad/kuhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_grad_kuhf_make_rdm1e(
    mo_energy: numpy.ndarray,
    mo_coeff: numpy.ndarray,
    mo_occ: numpy.ndarray
):
    """Compute the energy-weighted one-electron reduced density matrix for k-point
    unrestricted Hartree–Fock (KUHF) gradient calculations.
    
    This function is part of the PySCF periodic-boundary-condition gradient machinery (pyscf.pbc.grad.kuhf).
    It constructs the energy-weighted one-particle reduced density matrix (1-RDM) for an unrestricted
    (k-point) calculation by delegating the per-spin construction to the k-point restricted-HF
    gradient helper pyscf.pbc.grad.krhf.make_rdm1e and stacking the two spin components.
    The resulting array is used in analytic gradient evaluations to accumulate contributions
    that depend on orbital energies, coefficients, and occupations for each spin channel.
    
    Args:
        mo_energy (numpy.ndarray): Per-spin molecular orbital energies. This must be an indexable
            array-like object with two elements corresponding to the two spin channels
            (conventionally alpha at index 0 and beta at index 1). Each element is passed
            as the energy argument to pyscf.pbc.grad.krhf.make_rdm1e for that spin and therefore
            should have the shape and dtype expected by that helper (typically an array of
            orbital energies for the k-point/periodic calculation). The values determine the
            energy weighting applied to the occupied orbitals when forming the energy-weighted 1-RDM.
        mo_coeff (numpy.ndarray): Per-spin molecular orbital coefficient arrays. This must be an
            indexable array-like object with two elements (alpha at index 0, beta at index 1).
            Each element contains the MO coefficients for the corresponding spin and is forwarded
            to pyscf.pbc.grad.krhf.make_rdm1e. The coefficients define the transformation from
            atomic/basis representation to the molecular-orbital basis and thus determine the
            matrix representation of the energy-weighted 1-RDM in the chosen orbital basis.
        mo_occ (numpy.ndarray): Per-spin molecular orbital occupation numbers. This must be an
            indexable array-like object with two elements (alpha at index 0, beta at index 1).
            Each element supplies occupation information (typically 0, 1, 2 or fractional occupations
            for k-point sampling) to pyscf.pbc.grad.krhf.make_rdm1e so that only occupied MOs
            contribute to the energy-weighted 1-RDM. Occupation values control which orbitals
            are included and with what weight in gradient-related integrals.
    
    Returns:
        numpy.ndarray: A numpy array containing the energy-weighted one-particle reduced density
        matrices for both spin channels stacked along axis 0. The returned array has the first
        index selecting the spin channel (index 0 for the first supplied spin, index 1 for the
        second) and each slice is the energy-weighted 1-RDM produced by pyscf.pbc.grad.krhf.make_rdm1e.
        This return value is intended for use in KUHF gradient assembly routines; the function
        itself has no external side effects besides returning this array.
    
    Behavior, side effects, and failure modes:
        - The implementation delegates to pyscf.pbc.grad.krhf.make_rdm1e for each spin channel
          and then stacks the two resulting arrays with numpy.stack(..., axis=0).
        - The function expects mo_energy, mo_coeff, and mo_occ to be indexable with at least
          two elements. If any of these arguments are not indexable or have fewer than two entries,
          an IndexError or TypeError will be raised when accessing element [0] or [1].
        - Any shape, dtype, or semantic errors from the underlying krhf.make_rdm1e calls
          (for example, mismatched dimensions between mo_coeff and mo_occ) will propagate
          as exceptions from those routines.
        - There are no hidden defaults or in-place modifications performed by this function;
          it returns a newly allocated numpy.ndarray.
    """
    from pyscf.pbc.grad.kuhf import make_rdm1e
    return make_rdm1e(mo_energy, mo_coeff, mo_occ)


################################################################################
# Source: pyscf.pbc.gto.cell.fromfile
# File: pyscf/pbc/gto/cell.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_gto_cell_fromfile(filename: str, format: str = None):
    """Read a periodic Cell geometry from a file and construct a PySCF PBC Cell object.
    
    This function is part of the pyscf.pbc.gto.cell utilities and is used to create a pyscf.pbc.gto.Cell representing the periodic simulation cell (lattice vectors, atomic positions, basis/atom specifications as available in the source file). It is primarily intended for testing and simple file-based workflows where a user or test harness provides a file in a supported format; the returned Cell can then be used in downstream PySCF periodic-boundary-condition (PBC) electronic-structure calculations such as SCF, DFT, or correlated methods.
    
    Args:
        filename (str): Path to the input file containing the cell geometry or the literal string 'poscar'. If filename is an actual file path, the file is opened for reading and its full contents are passed to the internal parser. If filename equals the case-insensitive string 'poscar' it is treated specially to select the VASP POSCAR parser regardless of any file extension. The filename argument therefore controls both which file is read and, when format is omitted, how the parser attempts to infer the input format.
        format (str): Explicit format specifier for the input content. If provided, this string directs the internal parser which file format to use. If format is None (the default), the function attempts to guess the format from filename using the following logic: if filename.lower() == 'poscar' then format is set to 'poscar'; otherwise the lowercased file extension (text after the final dot in filename) is used. If the guessed/explicit format is one of 'poscar', 'vasp', or 'xyz' that format is used; otherwise the function falls back to the 'raw' parser. Accepted format identifiers used by this function are 'poscar' (VASP POSCAR), 'vasp' (alias for POSCAR), 'xyz' (extended XYZ with lattice information), and 'raw' (fallback). The format argument affects how the file contents are interpreted and therefore which lattice/atom/basis information is extracted into the Cell.
    
    Behavior and side effects:
        The function opens filename for reading using a text-mode file open. It reads the entire file content into memory and then delegates to fromstring(content, format) to parse the content and build the Cell. The function therefore has the side effect of reading a file from disk and may consume memory proportional to the file size. If format is None the function will perform the filename-based guessing described above before parsing. The function is designed for simple input files and testing workflows; it does not perform advanced validation beyond what the underlying parser (fromstring) implements.
    
    Failure modes and exceptions:
        If filename does not exist or is not accessible, built-in I/O exceptions such as FileNotFoundError or PermissionError (OSError) will be raised when attempting to open the file. If the file content cannot be parsed according to the selected format, the underlying parser (fromstring) will raise parsing-related exceptions (for example ValueError or other format-specific errors). Supplying an unsupported explicit format string does not raise here; instead the code will use the 'raw' fallback if the guessed/explicit format is not one of the recognized identifiers ('poscar','vasp','xyz').
    
    Returns:
        pyscf.pbc.gto.Cell: A Cell object representing the periodic simulation cell parsed from the input file. The returned Cell contains lattice vectors, atomic species and coordinates, and any additional cell-related metadata the parser extracts for use in PySCF PBC workflows (for example building basis sets and performing electronic-structure calculations).
    """
    from pyscf.pbc.gto.cell import fromfile
    return fromfile(filename, format)


################################################################################
# Source: pyscf.pbc.gto.cell.loads
# File: pyscf/pbc/gto/cell.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_gto_cell_loads(cellstr: str):
    """Deserialize a JSON document string into a pyscf.pbc.gto.cell.Cell instance representing a periodic Gaussian-type-orbital (GTO) cell used in PySCF periodic-boundary calculations.
    
    Args:
        cellstr (str): A JSON document encoded as a Python str that was produced by the matching serialization routine (the module's dumps function). The JSON must contain the Cell object's attribute dictionary (the serialized __dict__). This function expects fields that were serialized as Python literal strings for complex attributes: "atom", "basis", "pseudo", and "ecp" (these are re-evaluated with eval to reconstruct Python objects). The caller must provide a trusted JSON string created by the library's serialization routine; untrusted input is unsafe because eval() is used and will execute Python expressions embedded in those fields.
    
    Returns:
        Cell: A new pyscf.pbc.gto.cell.Cell instance reconstructed from the JSON. Practical effects performed during reconstruction: the JSON is parsed with json.loads into a Python dict and used to update the Cell instance via cell.__dict__.update(celldic); the string-valued fields cell.atom, cell.basis, cell.pseudo, and cell.ecp are evaluated with Python eval() to restore their original Python objects; internal storage arrays are converted to numpy arrays with explicit dtypes where required (cell._atm and cell._bas to numpy.int32, cell._env to numpy.double, cell._ecpbas to numpy.int32, cell._mesh to numpy.array without explicit dtype). If the deserialized cell has natm > 0 and the space_group_symmetry flag is true, the function invokes cell.build_lattice_symmetry() to recreate symmetry-related structures that are not serialized by dumps. Possible failure modes include json.JSONDecodeError for malformed JSON, exceptions raised by eval (e.g., SyntaxError, NameError) if the literal fields are not valid Python expressions, and TypeError/ValueError from numpy array conversions if numeric fields have incompatible shapes or types. The function returns the reconstructed Cell object and does not modify external state beyond constructing and returning that object.
    """
    from pyscf.pbc.gto.cell import loads
    return loads(cellstr)


################################################################################
# Source: pyscf.pbc.gto.cell.unpack
# File: pyscf/pbc/gto/cell.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_gto_cell_unpack(celldic: dict):
    """pyscf.pbc.gto.cell.unpack converts a packed Cell attribute dictionary into a new Cell object suitable for use as input to periodic-boundary (PBC) electronic-structure calculations.
    
    This function is used in the PySCF periodic (pbc) electronic-structure workflow to reconstruct a pyscf.pbc.gto.cell.Cell instance from a previously packed mapping of attributes (for example, a dictionary produced by serializing or saving cl.__dict__). It instantiates a fresh Cell via Cell(), then updates that instance's attribute dictionary with the entries from celldic so the returned object reflects the packed state and can be used to generate or reproduce input arguments for Cell-based PBC calculations.
    
    Args:
        celldic (dict): A mapping representing the packed attribute dictionary of a Cell object. This mapping is expected to contain keys and values corresponding to attributes that a pyscf.pbc.gto.cell.Cell instance would normally hold (geometry, basis, lattice vectors, k-point sampling parameters, internal caches, etc.). The function does not validate that required Cell attributes are present or that values have correct types; it applies the mapping by performing cl.__dict__.update(celldic). Practical significance: callers typically pass a dict produced by saving or serializing a Cell instance so that the same computational cell (geometry, basis, and PBC parameters) can be restored. Because the update operation assigns references, mutable objects in celldic (arrays, lists) are not deep-copied, so subsequent mutation of those objects will affect the returned Cell. If celldic is not a mapping compatible with dict.update, a TypeError or related exception will be raised by the underlying update call.
    
    Returns:
        Cell: A new pyscf.pbc.gto.cell.Cell instance whose attribute dictionary has been updated with the contents of celldic. The returned Cell is ready to be used as input to PySCF PBC routines only if the packed dictionary provided all necessary attributes with appropriate values; otherwise later operations on the returned Cell may raise AttributeError or type-related errors. Side effects: none external to the returned object, but the function does not perform validation or reconstruction logic beyond assigning attributes, so it may leave the Cell in an inconsistent state if celldic is incomplete or contains inappropriate keys. Use this function to quickly reconstruct Cell state from a trusted packed representation; avoid using it with untrusted input because arbitrary attribute injection can override internal attributes and lead to insecure or unstable behavior.
    """
    from pyscf.pbc.gto.cell import unpack
    return unpack(celldic)


################################################################################
# Source: pyscf.pbc.gto.pseudo.pp.Ylm
# File: pyscf/pbc/gto/pseudo/pp.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_gto_pseudo_pp_Ylm(l: int, m: int, theta: float, phi: float):
    """Spherical harmonic Y_l^m for use in PySCF PBC pseudopotential and angular-projection routines.
    
    This function evaluates the complex-valued spherical harmonic Y_l^m(theta, phi) using SciPy's scipy.special.sph_harm implementation and the same angle ordering/convention as SciPy. In the PySCF periodic-boundary-condition (pbc) gto.pseudo.pp code path, spherical harmonics are used to represent the angular dependence of pseudopotential projectors and to project atomic-like angular components; this function provides the atomic-centred angular factor that appears in those expansions. The implementation calls scipy.special.sph_harm(m, l, phi, theta) so the azimuthal angle phi is passed first to SciPy and the polar (colatitude) angle theta is passed second, matching SciPy's expected argument order.
    
    Args:
        l (int): Degree (nonnegative integer) of the spherical harmonic, corresponding to the total angular momentum quantum number l used in pseudopotential angular expansion. In practice l selects the angular frequency of the returned function; larger l yields more oscillatory angular dependence. Passing a non-integer or a negative value will be rejected by SciPy or produce a runtime error.
        m (int): Order (integer) of the spherical harmonic, with the mathematical requirement -l <= m <= l. m determines the azimuthal dependence and complex phase of the result and is used in PySCF to select a specific magnetic component of an angular projector. If m lies outside the allowed range or is not an integer, the underlying SciPy call may raise an exception.
        theta (float): Polar (colatitude) angle in radians, measured from the positive z-axis. This argument represents the standard spherical-coordinate polar angle used in atomic-centred expansions in the pbc.gto.pseudo.pp context. Typical values lie in the interval [0, pi]; values outside this range are allowed numerically but may be interpreted modulo 2*pi by trigonometric functions.
        phi (float): Azimuthal angle in radians, measured in the x-y plane from the positive x-axis. This argument is the standard spherical-coordinate azimuthal angle used by PySCF code that consumes Y_l^m; typical values lie in [0, 2*pi). Note that when calling SciPy, phi is passed as the first angular argument.
    
    Returns:
        complex: The complex value of the spherical harmonic Y_l^m evaluated at the specified angles (theta, phi). The returned complex number carries both amplitude and phase information necessary for constructing angular components of pseudopotential projectors and matrix elements in the pyscf.pbc.gto.pseudo.pp module. No other side effects occur. Runtime errors (TypeError, ValueError) may be raised by SciPy.sph_harm for invalid parameter types or out-of-range integer constraints on l and m, and ImportError will occur if SciPy is not available.
    """
    from pyscf.pbc.gto.pseudo.pp import Ylm
    return Ylm(l, m, theta, phi)


################################################################################
# Source: pyscf.pbc.gto.pseudo.pp.Ylm_real
# File: pyscf/pbc/gto/pseudo/pp.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_gto_pseudo_pp_Ylm_real(l: int, m: int, theta: float, phi: float):
    """Compute the real-valued spherical harmonic Y_lm(theta, phi) from the complex spherical harmonic Ylm used in PySCF's periodic-boundary-condition (pbc) gaussian-type-orbital (gto) pseudopotential code. This function is used when angular components of atomic orbitals, projector functions, or multipole expansions need real spherical harmonics rather than complex-valued harmonics; it converts the complex Ylm(l,|m|,theta,phi) returned by the internal Ylm routine into the standard real form by taking appropriate real or imaginary parts and scaling by sqrt(2) for |m|>0.
    
    Args:
        l (int): Angular momentum quantum number l. This non-negative integer sets the degree of the spherical harmonic (the number of angular nodes) and selects which angular channel is evaluated for pseudopotential/projector construction in PySCF's PBC/gto code. The function assumes l >= 0; values outside the domain expected by the internal Ylm implementation will cause that routine (and thus this function) to raise an exception.
        m (int): Magnetic quantum number m. This integer specifies the azimuthal order and must satisfy -l <= m <= l in the standard spherical-harmonic convention used throughout the pseudopotential and basis-function code. The sign of m determines the combination returned: for m < 0 the function returns sqrt(2) * Im[Y_l,|m|], for m > 0 it returns sqrt(2) * Re[Y_l,m], and for m == 0 it returns Re[Y_l,0]. Providing an m value outside the allowed range will be propagated to the underlying Ylm implementation and may raise an exception.
        theta (float): Polar (colatitude) angle in radians, measured from the positive z-axis (0 <= theta <= pi). This specifies the polar coordinate at which the real spherical harmonic is evaluated; it is required in the same units and convention used by the internal Ylm routine.
        phi (float): Azimuthal angle in radians about the z-axis (0 <= phi < 2*pi). This specifies the azimuthal coordinate for evaluation of the harmonic and must follow the same angular convention as the internal Ylm routine.
    
    Returns:
        float: The real-valued scalar value of the spherical harmonic Y_lm evaluated at the input angles (theta, phi). The returned value is the standard real combination used in quantum-chemistry pseudopotential and basis representations (sqrt(2)*Im for negative m, sqrt(2)*Re for positive m, and Re for m == 0). This function has no side effects and simply returns a numeric value; if the inputs are not finite or the (l,m) pair is invalid for the underlying Ylm implementation, the function may return NaN or propagate an exception from that routine.
    """
    from pyscf.pbc.gto.pseudo.pp import Ylm_real
    return Ylm_real(l, m, theta, phi)


################################################################################
# Source: pyscf.pbc.gto.cell.pgf_rcut
# File: pyscf/pbc/gto/cell.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_gto_cell_pgf_rcut(
    l: int,
    alpha: float,
    coeff: float,
    precision: float = 1e-08,
    rcut: float = 0,
    max_cycle: int = 10,
    eps: float = 0.001
):
    """pyscf.pbc.gto.cell.pgf_rcut estimates cutoff radii for primitive Gaussian functions used in real-space integral screening in periodic electronic structure calculations (PySCF PBC module). The routine solves for rcut from the asymptotic relation c * rcut^(l+2) * exp(-alpha * rcut^2) ~ precision, where c = log(coeff/precision), and returns a radius beyond which the primitive Gaussian amplitude falls below the requested precision. This cutoff is used to truncate Gaussian tails for efficient integral evaluation and grid-based operations in periodic simulations.
    
    Args:
        l (int): Angular momentum quantum number (non-negative integer) of the primitive Gaussian. In the PySCF PBC gto context, l determines the polynomial prefactor r^(l) of the real-space Gaussian; the function uses l+2 in the asymptotic estimate because the screened quantity scales as r^(l+2)*exp(-alpha*r^2). Practical significance: higher l increases the algebraic prefactor and typically requires a larger cutoff to reach the same amplitude threshold.
        alpha (float): Gaussian exponent controlling the exponential decay exp(-alpha * r^2). This parameter must be positive in practice; it sets the spatial extent of the primitive function. Larger alpha produces faster decay and thus smaller cutoffs for the same precision.
        coeff (float): Multiplicative coefficient of the asymptotic model for the primitive Gaussian tail. The routine computes c = log(coeff/precision), so coeff must be positive for the logarithm to be defined. In PySCF, coeff represents the prefactor amplitude of the primitive Gaussian contribution being screened.
        precision (float): Target amplitude threshold for the primitive Gaussian in real space. The routine finds rcut such that the tail amplitude is approximately at this level. Default is 1e-08 (the module constant INTEGRAL_PRECISION in the source), chosen as a typical numerical threshold for integral screening in PySCF. precision must be positive; smaller values yield larger rcut.
        rcut (float): Initial cutoff radius (in the same length units used by the cell) used as a lower bound or starting guess for the fixed-point iteration. Default is 0. If provided, the returned value will be at least this initial rcut. This parameter allows callers to enforce a minimum radius (for example, to ensure consistency across shells or grids).
        max_cycle (int): Maximum number of fixed-point iteration cycles to attempt when solving the nonlinear relation for rcut. Default is 10 (the module constant RCUT_MAX_CYCLE). If convergence is not reached within max_cycle iterations the routine emits a warning and returns the last iterate.
        eps (float): Convergence tolerance for the change in rcut between successive iterations. Default is 0.001 (the module constant RCUT_EPS). The code tightens eps relative to an analytic lower-bound rmin (eps := min(rmin/10, eps)) to avoid excessive early termination. eps is specified in the same length units as rcut.
    
    Returns:
        float: Estimated cutoff radius (same units as rcut and real-space coordinates) such that the primitive Gaussian tail amplitude is approximately at or below the requested precision according to the asymptotic model used. The returned value is computed by iterating the fixed-point relation rcut = sqrt(((l+2) * log(rcut) + log(coeff/precision)) / alpha) starting from a conservative lower bound rmin = sqrt(2*(l+2)/alpha) and the provided rcut initial guess. If the iteration converges (absolute change < eps), the converged rcut is returned. If the iteration fails to converge within max_cycle iterations, the function issues a runtime warning ("cell.pgf_rcut failed to converge in {max_cycle} cycles.") and returns the last computed rcut value; callers should check for this warning when strict guarantees are required.
    
    Behavior, side effects, defaults, and failure modes:
        The function uses a fixed-point iterative update based on the asymptotic estimate derived from c*rcut^(l+2)*exp(-alpha*rcut^2) ~ precision. An initial conservative lower bound rmin = sqrt(2*(l+2)/alpha) is computed to avoid unphysical small starting radii; eps is reduced to at most rmin/10 to prevent premature convergence at very small radii. The routine relies on logarithms and square roots; therefore alpha and coeff/precision must be positive to avoid domain errors or NaNs. If alpha <= 0 or coeff <= 0 or precision <= 0, the computation may raise runtime warnings or produce invalid results. The only side effect is that the function may emit a Python warning via warnings.warn when the fixed-point iteration does not converge within max_cycle iterations; no global state is modified. The default numeric parameters (precision=1e-08, rcut=0, max_cycle=10, eps=0.001) reflect typical choices for integral screening in PySCF periodic calculations.
    """
    from pyscf.pbc.gto.cell import pgf_rcut
    return pgf_rcut(l, alpha, coeff, precision, rcut, max_cycle, eps)


################################################################################
# Source: pyscf.pbc.gto.cell.fromstring
# File: pyscf/pbc/gto/cell.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_gto_cell_fromstring(string: str, format: str = "poscar"):
    """Convert a geometry string in a supported periodic-geometry file format into the internal lattice and atomic-coordinate string pair used by pyscf.pbc.gto.cell.
    
    This function is a small parser (marked “in testing” in the original implementation) intended for converting file contents from common periodic-geometry formats into the two-string internal representation returned here and used when constructing PySCF Cell objects for periodic calculations (pyscf.pbc.gto.cell). The recognized formats are case-insensitive and currently include POSCAR/ VASP ("poscar" or "vasp"), extended XYZ with Lattice information ("xyz"), and a simple "raw" layout. The returned pair is (a, atom) where a is a three-line string of cartesian lattice vectors and atom is a newline-separated string of atom lines with element and cartesian coordinates.
    
    Args:
        string (str): The full contents of a geometry file provided as a single string. For the "poscar" format this should be the exact multiline contents of a VASP POSCAR/CONTCAR file. For the "xyz" format this should be an extended XYZ text where the second line contains Lattice="..." with three lattice vectors concatenated inside the quotes. For the "raw" format this should be a multiline string where the first three lines are the lattice description and the atom block begins after the fourth line. This argument is the primary input parsed into lattice and atomic blocks for downstream creation of a pyscf.pbc.gto.cell.Cell for periodic electronic-structure calculations.
        format (str): The parser to apply to the input string. Case-insensitive accepted values are "poscar" or "vasp" (VASP POSCAR format), "xyz" (extended XYZ with Lattice information), and "raw" (simple raw layout). Defaults to "poscar". The chosen format determines how lines are interpreted: for "poscar" the second line is used as a global scale factor, lines 3–5 provide lattice vectors (scaled by the scale factor), line 6 lists element symbols, line 7 lists element counts, line 8 indicates coordinate type ("Direct" or "Cartesian"), and subsequent lines contain atomic coordinates; for "xyz" the first line must be an integer atom count and the second line must include Lattice="..."; for "raw" the function returns the first three lines as the lattice block and lines after the fourth as atoms. The format parameter controls parsing behavior and error checking.
    
    Returns:
        tuple: A pair of strings (a, atom). a is a three-line string where each line contains three space-separated floating-point numbers representing the cartesian lattice vectors (units preserved from the input; for POSCAR the scale factor is applied). atom is a newline-separated string with one atom per line. For the "poscar" branch each atom line is formatted as "Element x y z" with cartesian coordinates (formatted in the implementation with 17.8f precision). For the "xyz" branch atom lines are returned exactly as they appear in the input file lines 3..(natm+2). For "raw" atom lines are returned from line 5 onward. This pair is ready for further processing when building a pyscf.pbc.gto.cell.Cell.
    
    Behavior, side effects, defaults, and failure modes:
        The function is pure (no external side effects) and returns new strings derived from the input. For format "poscar"/"vasp" the function reads the global scale factor from the second line and multiplies the parsed lattice vectors and, where applicable, cartesian coordinates by this scale factor. If the POSCAR coordinate-type line is not recognizable as "Direct" or "Cartesian" (case-insensitive), the function raises a RuntimeError describing the unrecognized atom position type. If a format other than the supported values is requested, a NotImplementedError is raised. If numeric conversions fail (for example, the atom count line in "xyz" is not an integer or coordinate lines cannot be parsed as floats), the underlying int() or numpy.fromstring operations will raise ValueError or produce malformed results; such exceptions are not caught internally and will propagate to the caller. The function is intended for lightweight parsing in testing workflows; it does not perform exhaustive validation of chemical or crystallographic consistency beyond the parsing and coordinate conversion implemented in the code.
    """
    from pyscf.pbc.gto.cell import fromstring
    return fromstring(string, format)


################################################################################
# Source: pyscf.pbc.gw.krgw_ac.AC_pade_thiele_diag
# File: pyscf/pbc/gw/krgw_ac.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_gw_krgw_ac_AC_pade_thiele_diag(sigma: numpy.ndarray, omega: numpy.ndarray):
    """Analytic continuation to the real frequency axis for per-orbital self-energies using a Pade approximation constructed by Thiele's reciprocal difference method. This function is used in the pbc.gw.krgw_ac workflow of PySCF to convert Matsubara/imaginary-frequency self-energy data (sigma) sampled on a discrete frequency grid (omega) into a set of Pade coefficients that approximate the analytic continuation to real frequencies. The implementation subsamples the input frequency grid with a fixed pattern (indices 1, 7, 13, 19, 25, 31, 37 and then every 4th index from index 41 onward) to build the data points used by the Thiele algorithm implemented in thiele(), and processes each orbital (row) independently to produce complex Pade coefficients.
    
    Args:
        sigma (numpy.ndarray): 2D array containing self-energy values to be analytically continued. The array is interpreted as shape (norbs, nw) where norbs is the number of orbitals (rows) and nw is the number of input frequency points (columns). Each row sigma[p, :] provides the complex-valued self-energy sampled at the frequencies given in the corresponding row of omega. The function subsamples columns of sigma according to the fixed index pattern inside the routine; the subsampled columns are the data passed to thiele() for each orbital. Inputs must provide sufficient frequency sampling so that the subsampled column count is an even number >= 2; otherwise the routine will produce empty coefficient sets or errors propagated from thiele().
    
        omega (numpy.ndarray): 2D array of frequency values corresponding to sigma, interpreted as shape (norbs, nw) with the same norbs and nw as sigma. Each row omega[p, :] gives the frequency points (typically Matsubara or imaginary-frequency points) that match sigma[p, :]. The routine applies the same subsampling pattern to omega as to sigma and returns the subset of omega columns that were used to build the Pade approximation. The returned omega subset therefore identifies the frequency points used in constructing the Pade coefficients.
    
    Returns:
        tuple: A pair (coeff, omega_sub) where:
            coeff (numpy.ndarray): 2D complex128 array of Pade coefficients with shape (ncoeff, norbs). Here ncoeff equals twice the integer npade computed as nw_sub // 2, where nw_sub is the number of columns remaining after the routine's subsampling. coeff[:, p] contains the complex Pade coefficients computed by thiele() from the subsampled sigma[p, :ncoeff] and omega[p, :ncoeff]. These coefficients are the rational-function parameters that can be evaluated on the real-frequency axis to approximate the analytic continuation of the input self-energy for orbital p.
            omega_sub (numpy.ndarray): 2D array with shape (norbs, ncoeff) containing the subset of frequency points (from the input omega) that were used to build the Pade approximation. omega_sub[p, :] corresponds to the frequency values matched to the sigma data used to compute coeff[:, p].
    
    Behavior and side effects:
        - The function performs an in-place construction of subsampled views (via copy/hstack) but does not modify the caller's input arrays sigma and omega.
        - It selects frequency columns using the fixed index pattern idx = range(1, 40, 6) and then columns starting from idx[-1] + 4 with step 4. The concatenated subsampled arrays are used to compute npade = nw_sub // 2 and ncoeff = npade * 2.
        - For each orbital p the function calls thiele(sigma[p, :ncoeff], omega[p, :ncoeff]) to compute the Pade coefficients. Any exceptions or numerical failures raised by thiele() (for example, due to insufficient or ill-conditioned input points) will propagate to the caller.
        - The returned coeff array has dtype numpy.complex128 as allocated in the routine.
    
    Failure modes and requirements:
        - sigma and omega must have identical shapes (same norbs and nw); mismatched shapes will produce indexing errors.
        - The number of columns in sigma and omega must be sufficient that the subsampling yields at least two columns (ncoeff >= 2) and an even number of subsampled columns; otherwise thiele() may fail or return meaningless coefficients.
        - Numerical instabilities in the Thiele reciprocal-difference construction (e.g., caused by nearly singular interpolation points or duplicate frequency entries) can lead to large or nonphysical coefficients; such failures are not suppressed and will be visible as exceptions or as large/malformed complex values in coeff.
    
    Practical significance:
        - In the GW analytic-continuation context within pyscf.pbc.gw.krgw_ac, these Pade coefficients allow evaluating an approximation to the self-energy on the real-frequency axis (for spectral functions, quasiparticle energies, and lifetime estimates) starting from discrete imaginary-frequency data computed in many-body perturbation theory. The per-orbital handling makes the routine suitable for multi-orbital periodic calculations where each orbital's self-energy is continued independently.
    """
    from pyscf.pbc.gw.krgw_ac import AC_pade_thiele_diag
    return AC_pade_thiele_diag(sigma, omega)


################################################################################
# Source: pyscf.pbc.gw.krgw_ac.AC_twopole_diag
# File: pyscf/pbc/gw/krgw_ac.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_gw_krgw_ac_AC_twopole_diag(
    sigma: numpy.ndarray,
    omega: numpy.ndarray,
    orbs: numpy.ndarray,
    nocc: int
):
    """Analytic continuation to the real-frequency axis using a two-pole model for orbital self-energies in periodic GW calculations.
    
    This function is used in the pyscf.pbc.gw.krgw_ac module to fit a compact two-pole analytic model to orbital-resolved self-energy data sampled on the imaginary (Matsubara) frequency axis. The fitted model parameters can be evaluated on the real axis to obtain a continued self-energy for subsequent spectral analysis, quasiparticle energy estimation, or other post-processing steps in periodic-boundary-condition (PBC) GW workflows.
    
    Args:
        sigma (numpy.ndarray): Numeric array of self-energy samples on the imaginary-frequency axis. The function expects sigma to have shape (norbs, nw) where norbs is the number of orbitals (bands) and nw is the number of sampled frequencies per orbital. Each row sigma[p] contains the self-energy values for orbital p evaluated at the frequencies given by the corresponding row of omega. The values may be real or complex depending on upstream GW output. Sigma provides the target data that the two-pole model is fit to for analytic continuation.
        omega (numpy.ndarray): Frequency grid array that corresponds to sigma. omega must be indexable in the same way as sigma (typically shape (norbs, nw)), so that omega[p] gives the frequency samples associated with sigma[p]. Each omega[p] supplies the imaginary-axis frequencies (Matsubara points) used during the nonlinear least-squares fit for orbital p. The function uses these frequencies as the independent variable in the two-pole fitting procedure.
        orbs (numpy.ndarray): One-dimensional array of orbital indices or band labels (integer-like) with length equal to the number of orbitals (norbs). The routine uses orbs[p] in a simple occupancy test (orbs[p] < nocc) to choose an occupancy-dependent initial guess for the nonlinear fit. Practically, orbs distinguishes occupied from virtual orbitals so that the initial parameter guess is tailored to the orbital character, which improves robustness of the per-orbital fit.
        nocc (int): Integer threshold giving the number of occupied orbitals in the system. An orbital p is treated as occupied when orbs[p] < nocc. This occupancy decision controls the sign and magnitude choices in the initial parameter vector for the two-pole model fit and therefore affects convergence behavior and the fitted coefficients.
    
    Behavior and side effects:
        For each orbital p (0 <= p < norbs), the function constructs an initial guess vector x0 of length 10 that depends on whether the orbital is considered occupied (orbs[p] < nocc) or virtual. It then performs a nonlinear least-squares fit using scipy.optimize.least_squares to minimize the residual defined by the two_pole_fit function with respect to x. The solver is called with finite-difference Jacobian ('3-point'), method='trf', tolerances xtol=1e-10 and gtol=1e-10, and a maximum of 1000 function evaluations. The code currently uses finite-difference Jacobians (there is a TODO in source to add analytic gradients), which can make the fitting slower and sensitive to the initial guess. If a particular orbital fit does not converge (xopt.success is False), the function prints a warning to standard output indicating the orbital index and the final cost; the function nevertheless stores the optimizer's last parameter vector for that orbital in the output. If sigma and omega have incompatible shapes or are not indexable as required, NumPy or SciPy routines may raise IndexError or ValueError; such errors are not caught inside this function.
    
    Failure modes and diagnostics:
        Nonconvergence of the least-squares fit for a given orbital will produce a printed warning "WARN: 2P-Fit Orb %d not converged, cost function %e" and the returned coefficients for that orbital will be the optimizer's final (possibly non-optimal) parameter vector. Poor initial guesses, insufficient frequency sampling, highly noisy input sigma, or using finite-difference Jacobians can all reduce fit robustness. The function does not raise custom exceptions on nonconvergence; callers should inspect the printed warnings or validate the returned coefficients if strict convergence guarantees are required.
    
    Returns:
        numpy.ndarray: A 2D array of fitted two-pole model parameters with shape (10, norbs). Each column coeff[:, p] contains the 10 parameters (in the same ordering as returned by the internal two_pole_fit/least_squares optimizer) that define the two-pole analytic continuation model for orbital p. These parameters are intended to be used to reconstruct the self-energy on the real-frequency axis for each orbital in PBC GW post-processing.
    """
    from pyscf.pbc.gw.krgw_ac import AC_twopole_diag
    return AC_twopole_diag(sigma, omega, orbs, nocc)


################################################################################
# Source: pyscf.pbc.gw.kugw_ac.AC_twopole_diag
# File: pyscf/pbc/gw/kugw_ac.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_gw_kugw_ac_AC_twopole_diag(
    sigma: numpy.ndarray,
    omega: numpy.ndarray,
    orbs: numpy.ndarray,
    nocc: int
):
    """Analytic continuation to the real frequency axis for orbital-dependent self-energy data using a two-pole model fitted independently for each orbital. This routine is used in the periodic-boundary-condition (PBC) GW code path of PySCF (pyscf.pbc.gw) to convert frequency-dependent self-energy samples (sigma) defined on a discrete frequency grid (omega) into a compact set of fit parameters that parametrize an analytic two-pole approximation per orbital. The fitted parameters are intended for downstream evaluation of the real-axis self-energy or spectral functions in GW calculations and match the parameter vector expected by the two_pole_fit residual function used in the module.
    
    Args:
        sigma (numpy.ndarray): A 2D array containing the sampled self-energy values to be fitted. The code expects sigma.shape == (norbs, nw) where norbs is the number of orbitals and nw is the number of frequency points per orbital. Each row sigma[p] supplies the values to be fitted for orbital index p. These values are typically computed on an imaginary or discrete Matsubara frequency grid in GW calculations and are the target data for the two-pole analytic-continuation fit.
        omega (numpy.ndarray): A 2D array or array-like of frequency grid points that correspond to the samples in sigma. The implementation calls omega[p] together with sigma[p] when fitting orbital p, so omega must supply per-orbital frequency coordinates compatible with the shape and ordering of sigma (commonly omega.shape == sigma.shape or broadcastable in the same indexing scheme). omega provides the independent-variable locations (frequency points) for the two-pole fit.
        orbs (numpy.ndarray): A 1D array of orbital identifiers or indices used to determine occupation status relative to nocc. The implementation tests orbs[p] < nocc to decide the sign of certain initial-guess parameters for orbital p (occupied vs virtual), so orbs must contain values comparable with nocc (for example integer orbital indices or orbital ordering identifiers). The choice of initial guess affects convergence and physically encodes whether the orbital is occupied, which changes the starting sign of selected pole parameters in the two-pole model.
        nocc (int): The number of occupied orbitals (an integer) used as the occupation threshold. Orbitals with orbs[p] < nocc are treated as occupied and receive a different initial parameter sign than orbitals with orbs[p] >= nocc. This influences the optimizer initial guess and therefore the fitted solution for occupied versus virtual orbitals in GW analytic continuation.
    
    Behavior and side effects:
        The function performs an independent non-linear least-squares fit for each orbital p using scipy.optimize.least_squares to minimize the residual defined by two_pole_fit with respect to a 10-parameter two-pole model. The initial guess x0 is a length-10 numpy array; its ninth and tenth components differ in sign depending on whether the orbital is classified as occupied (orbs[p] < nocc) or virtual. The least_squares call uses jac='3-point', method='trf', xtol=1e-10, gtol=1e-10, and max_nfev=2000. If the least-squares solver does not report success (xopt.success is False), the function prints a warning message of the form "WARN: 2P-Fit Orb %d not converged, cost function %e" with the orbital index and final cost, but the function continues and stores the optimizer state vector xopt.x into the output array. If least_squares raises an exception (for example due to invalid inputs or failures internal to scipy), that exception propagates to the caller. The routine does not compute analytic gradients of the fit; the jacobian is approximated by finite differences as configured in the least_squares call.
    
    Defaults and practical notes:
        The function uses a fixed-length (10) parameter vector per orbital and returns these parameters for all orbitals. The returned parameters are exactly the raw optimizer solution vectors xopt.x produced by least_squares and follow the ordering and meaning expected by the module's two_pole_fit residual function. Because the initial guess differs for occupied and virtual orbitals, results may be sensitive to the provided orbs and nocc values. The routine assumes consistent ordering between sigma, omega, and orbs (index p corresponds across these arrays). Performance and convergence depend on the quality of the supplied data, the initial guess, and the nonlinear optimizer settings; very noisy or insufficient frequency sampling may lead to poor fits or non-convergence warnings.
    
    Failure modes and errors:
        A mismatch of shapes between sigma and omega or incorrect length of orbs relative to the number of orbitals will raise indexing or shape-related exceptions when iterating over norbs. If scipy.optimize.least_squares fails catastrophically it will raise an exception that is not caught by this function. Non-convergence of the nonlinear fit for an orbital does not abort the entire routine but produces a printed warning and the last optimizer parameter vector is still stored in the output. Numerical issues, poorly sampled frequency grids, or incorrect physical inputs may yield unphysical fit parameters; callers should validate fit quality (for example by inspecting residuals or the printed warning messages).
    
    Returns:
        numpy.ndarray: A 2D numpy array of fit coefficients with shape (10, norbs). Each column coeff[:, p] is the length-10 parameter vector produced by the nonlinear least-squares fit for orbital p. These parameters are the two-pole model coefficients (in the ordering expected by two_pole_fit) and are intended to be used for downstream reconstruction or evaluation of the analytic-continuation model on the real frequency axis.
    """
    from pyscf.pbc.gw.kugw_ac import AC_twopole_diag
    return AC_twopole_diag(sigma, omega, orbs, nocc)


################################################################################
# Source: pyscf.pbc.lib.chkfile.load_cell
# File: pyscf/pbc/lib/chkfile.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_lib_chkfile_load_cell(chkfile: str):
    """Load a pyscf.pbc.gto.cell.Cell object from a PySCF checkpoint file produced by scf.chkfile.save_cell.
    
    This function reads a checkpoint file (HDF5) containing a serialized representation of a periodic unit cell (Cell) used by PySCF's periodic-boundary-condition (PBC) modules. It restores the Cell object so the unit cell geometry, basis, lattice vectors, and other metadata can be reused to continue calculations (for example, restarting SCF) or to post-process results. The function opens the checkpoint file in read-only mode, attempts to deserialize the saved Cell using pyscf.pbc.gto.loads, and falls back to unpacking a legacy dictionary representation followed by a build call to finalize the Cell. The restored Cell is suitable for immediate use with pyscf.pbc.gto and pyscf.pbc.scf routines assuming compatibility between the file contents and the installed PySCF version.
    
    Args:
        chkfile (str): Path to the checkpoint file to load. This must be the filename of an HDF5-format checkpoint created by PySCF routines such as scf.chkfile.save_cell. The function opens this file read-only via h5py.File(chkfile, 'r') and expects to find a dataset named 'mol' containing a serialized Cell. Supplying an incorrect path, a file in a different format, or a file written by an incompatible PySCF version may cause errors described below.
    
    Behavior and side effects:
        - The function opens the specified file in read-only mode and does not modify the file contents.
        - It first attempts to reconstruct the Cell by calling pyscf.pbc.gto.loads on the contents of the 'mol' dataset.
        - If pyscf.pbc.gto.loads raises an exception (for example due to older/legacy serialization), the function falls back to evaluating the stored representation and unpacking it: it evaluates the 'mol' dataset string to obtain a dictionary, calls pyscf.pbc.gto.cell.unpack(celldic) to obtain a Cell-like object, and then calls cell.build(False, False) to finalize internal data structures. Because the fallback uses Python eval on file contents, only load checkpoint files from trusted sources; untrusted files may execute arbitrary code during evaluation.
        - No changes are written back to the checkpoint file; the only effect is to return an initialized Cell object in memory.
    
    Failure modes and compatibility notes:
        - If chkfile does not exist or cannot be opened, h5py/File I/O will raise an OSError or FileNotFoundError.
        - If the 'mol' dataset is missing from the HDF5 file, a KeyError or similar error will be raised.
        - If the serialized content is corrupted or incompatible, pyscf.pbc.gto.loads may raise exceptions; the fallback may also fail if the stored text cannot be safely evaluated or unpacked.
        - Because the function may use legacy unpacking paths, behavior depends on compatibility between the checkpoint file format and the installed PySCF release; failure to load may require regenerating the checkpoint with a compatible version.
    
    Returns:
        pyscf.pbc.gto.cell.Cell: An initialized and built Cell object representing the periodic unit cell (geometry, basis, lattice, and related metadata). The returned Cell is ready for use in PySCF PBC routines (for example, scf calculations or property evaluations) subject to compatibility of the serialized data with the current PySCF installation.
    """
    from pyscf.pbc.lib.chkfile import load_cell
    return load_cell(chkfile)


################################################################################
# Source: pyscf.pbc.lib.kpts.map_k_points_fast
# File: pyscf/pbc/lib/kpts.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_lib_kpts_map_k_points_fast(
    kpts_scaled: numpy.ndarray,
    ops: numpy.ndarray,
    tol: float = 1e-06
):
    """Find symmetry-related k-points in the Brillouin zone for periodic calculations.
    
    This function is used in PySCF's periodic-boundary-condition (PBC) workflows to build a mapping between k-points that are related by a set of point-group rotation operators. It is a performance-oriented wrapper (adapted from GPAW) that reshapes the input k-point array and delegates to the generic tuple-mapping routine with ntuple=1. The mapping is used to identify which k-point in the input grid corresponds to the rotated image of another k-point up to a reciprocal-lattice vector, which is essential when exploiting crystal symmetries to reduce k-point sampling and to transform quantities (for example, Hamiltonian or density matrices) under symmetry operations.
    
    Args:
        kpts_scaled (numpy.ndarray): Array of scaled k-points with shape (nkpts, 3). Each row is a k-point given in scaled (fractional) coordinates with respect to the reciprocal-lattice basis. These are the input k-points whose symmetry-related images will be identified. The routine expects a two-dimensional array with exactly three coordinates per k-point; providing a differently shaped array will raise an error.
        ops (numpy.ndarray): Array of rotation operators with shape (nop, 3, 3) and integer entries. Each ops[s] is a 3x3 integer rotation matrix that acts on k-point coordinates (matrix multiplication). The operators are interpreted as point-group rotations in the lattice reciprocal-space index basis; the routine tests ops[s] * kpts_scaled[k1] and searches for an input k-point equal to that rotated vector up to an integer reciprocal-lattice vector.
        tol (float): Numerical tolerance used to decide equality of k-points after rotation. Two k-points that differ by less than tol (in Euclidean norm, after reducing differences modulo integer translations corresponding to reciprocal-lattice vectors) are treated as equal. Default is 1e-6. A non-finite or negative tol is invalid and will typically raise an error; very small tolerances close to machine precision can make points that should be matched fail to match due to floating-point roundoff.
    
    Returns:
        numpy.ndarray: bz2bz_ks with shape (nkpts, nop) and integer dtype. Entry bz2bz_ks[k1, s] = k2 when applying rotation ops[s] to kpts_scaled[k1] yields kpts_scaled[k2] plus some reciprocal-lattice vector K (i.e. ops[s] * kpts_scaled[k1] = kpts_scaled[k2] + K). This mapping table lets calling code replace k-point indices by their symmetry-related partners; it does not modify its inputs. On failure (for example, incompatible input shapes, non-integer ops shape, or inability to find a matching k-point within tol due to inconsistent inputs), a ValueError or TypeError will be raised by validation code invoked before or during the mapping.
    """
    from pyscf.pbc.lib.kpts import map_k_points_fast
    return map_k_points_fast(kpts_scaled, ops, tol)


################################################################################
# Source: pyscf.pbc.lib.kpts.check_mo_occ_symmetry
# File: pyscf/pbc/lib/kpts.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_lib_kpts_check_mo_occ_symmetry(kpts: int, mo_occ: list, tol: float = 1e-05):
    """Check if molecular orbital (MO) occupation numbers provided for all k-points in the full Brillouin zone (BZ) are consistent with the k-point symmetry (stars) defined in the KPoints object, and return the occupations restricted to the irreducible Brillouin zone (IBZ) if the symmetry check passes. This function is used in periodic-boundary-condition (PBC) electronic structure workflows in PySCF to validate that occupations at symmetry-equivalent k-points are identical within a numerical tolerance before downstream processing (for example, band-structure analysis, total-energy evaluation, or post-Hartree–Fock treatments). If symmetry is broken according to the provided tolerance, a RuntimeError is raised to signal a likely inconsistent solution (common for KUHF with integer occupations); otherwise a list of MO occupations for the IBZ is returned.
    
    Args:
        kpts (KPoints object): A KPoints object describing the k-point sampling and symmetry information for the periodic system. The function uses kpts.stars to obtain groups of symmetry-equivalent k-points (each group is a list of indices in the full BZ), kpts.nkpts_ibz to determine the number of k-points in the IBZ, and kpts.ibz2bz to map IBZ indices to full-BZ indices. The KPoints object is central to the check because it encodes how k-points are grouped by symmetry; incorrect or incomplete KPoints data will make the check invalid.
        mo_occ (list of (nmo,) ndarray): A list whose length equals the number of k-points in the full BZ (nkpts). Each element is a one-dimensional numpy ndarray of length nmo containing MO occupation numbers for that full-BZ k-point. The function compares these arrays pairwise across the indices in each symmetry star to determine whether occupations are identical (within tol) for symmetry-equivalent k-points. The function does not modify the input list or its arrays.
        tol (float): Numerical tolerance for comparing occupation numbers. Two occupations are considered identical if the absolute difference for every orbital is strictly less than tol. Default is 1e-5. Choosing a too-large tol may mask genuine symmetry breaking; choosing a too-small tol may flag numerical noise as symmetry breaking.
    
    Returns:
        mo_occ_ibz (list of (nmo,) ndarray): A list of MO occupation arrays corresponding to the k-points in the irreducible Brillouin zone. The length of this list equals kpts.nkpts_ibz. Each element is taken from the input mo_occ according to the mapping kpts.ibz2bz (i.e., mo_occ_ibz[k] == mo_occ[kpts.ibz2bz[k]]). The returned list is a new list and the function does not alter the original mo_occ list or the KPoints object.
    
    Behavior, side effects, defaults, and failure modes:
        The function iterates over each symmetry star in kpts.stars and compares occupation arrays for all distinct pairs of k-point indices within the star. The comparison uses numpy absolute differences and the condition (abs(diff) < tol).all(). If any pair differs by at least tol for any orbital, the function raises a RuntimeError indicating symmetry is broken. This RuntimeError commonly arises for KUHF calculations that produce integer occupations distributed inconsistently across symmetry-equivalent k-points. The error message suggests remedies such as using electronic smearing or disabling symmetry. If all symmetry-equivalent k-points match within tol, the function constructs and returns the IBZ occupations via kpts.ibz2bz and completes without side effects. The default tol is 1e-5; adjust it if occupations are expected to differ by small numerical noise. The function assumes that mo_occ length matches the full-BZ k-point count implied by kpts and that each mo_occ entry is a one-dimensional ndarray of identical length; supplying mismatched shapes or a KPoints object missing the required attributes will result in standard Python attribute or index errors.
    """
    from pyscf.pbc.lib.kpts import check_mo_occ_symmetry
    return check_mo_occ_symmetry(kpts, mo_occ, tol)


################################################################################
# Source: pyscf.pbc.gw.kugw_ac.AC_pade_thiele_diag
# File: pyscf/pbc/gw/kugw_ac.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_gw_kugw_ac_AC_pade_thiele_diag(sigma: numpy.ndarray, omega: numpy.ndarray):
    """AC_pade_thiele_diag performs analytic continuation of frequency-dependent quantities (commonly the GW self-energy) from a Matsubara / complex-frequency grid to the real-frequency axis by constructing a Pade approximant using Thiele's reciprocal difference method (J. Low Temp. Phys. 29, 179 (1977)). This function is used in periodic-boundary-condition GW workflows (pyscf.pbc.gw.kugw_ac) to obtain a compact set of Pade coefficients per orbital that can be evaluated on the real axis to produce spectral information (quasiparticle energies, lifetimes, and spectral functions).
    
    Args:
        sigma (numpy.ndarray): 2D array containing the frequency-dependent quantity to be analytically continued (for example, the GW self-energy sampled on an imaginary or complex-frequency grid). The code treats sigma as having shape (norbs, nw) where norbs is the number of orbitals (rows) and nw is the number of sampled frequency points (columns). The practical role of sigma is to provide the function values at the sampling points used to construct the Pade approximant; values are typically complex and the output coefficients are computed from these values. The caller must ensure that sigma and omega have matching shapes and contain sufficient columns for the internal index selection (see behavior and failure modes).
    
        omega (numpy.ndarray): 2D array of the same shape as sigma that holds the frequency grid values corresponding column-by-column to sigma. The array is interpreted as omega[i, j] being the frequency coordinate at which sigma[i, j] was evaluated. In GW analytic-continuation usage this is typically the Matsubara (imaginary) frequency grid or a complex-frequency sampling; the function selects a subset of these points to build the Pade approximant. The practical significance is that the returned Pade coefficients are associated with the subset of frequencies returned by the function (see Returns).
    
    Returns:
        tuple: A pair of numpy.ndarray objects giving the Pade coefficients and the subset of frequency points actually used to construct them.
    
        coeff (numpy.ndarray): 2D complex128 array of shape (ncoeff, norbs) containing the Pade/Thiele coefficients for each orbital. Here ncoeff equals 2 * npade where npade is computed internally as half the number of selected frequency points (npade = nw_selected // 2). The coefficients are returned columnwise per orbital and are intended to be used to evaluate the Pade approximant on the real-frequency axis for spectral analyses in GW calculations.
    
        omega (numpy.ndarray): 2D numpy.ndarray of shape (norbs, ncoeff) that contains the subset of frequency points (columns) actually used to compute the returned coefficients. The returned omega columns correspond one-to-one with the rows of coeff and provide the frequency coordinates associated with the sigma samples used for the Thiele reciprocal difference construction.
    
    Behavior and implementation notes:
        The function first selects sampling indices from the input arrays (it uses idx = range(1, 40, 6) and then additional points every 4 columns after idx[-1]+4) and horizontally stacks these selections to form the working dataset. It then sets npade = nw_selected // 2 and allocates coeff with dtype numpy.complex128 and shape (2*npade, norbs). For each orbital (row) the function calls an internal thiele(...) routine to compute the reciprocal-difference (Thiele) form of the Pade approximant from the paired sigma and omega samples and stores the resulting coefficients in coeff[:, p]. Finally, the function returns the full coefficient array and the truncated frequency grid omega limited to the columns used (omega[:, :2*npade]).
    
    Side effects:
        The function has no external side effects (it does not modify files or global state). It makes copies of selected slices of the input arrays internally. The returned coeff array is explicitly complex128 regardless of the input dtype.
    
    Failure modes and preconditions:
        The inputs sigma and omega must be numpy.ndarray instances with identical shapes and with a sufficient number of columns to satisfy the internal index selection; otherwise an IndexError or ValueError may be raised. If nw_selected computed from the chosen indices leads to npade == 0 the function will produce an empty coefficient array. The underlying thiele routine may raise exceptions (for example, if supplied frequency points are not distinct or lead to ill-conditioned reciprocal differences); such exceptions propagate to the caller. The caller should validate the input sampling grid and, for stable Pade construction, provide a well-resolved and non-pathological set of sigma/omega samples.
    """
    from pyscf.pbc.gw.kugw_ac import AC_pade_thiele_diag
    return AC_pade_thiele_diag(sigma, omega)


################################################################################
# Source: pyscf.pbc.lib.kpts.make_kpts_ibz
# File: pyscf/pbc/lib/kpts.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_lib_kpts_make_kpts_ibz(kpts: int, tol: float = 1e-06):
    """Locate k-points in the irreducible Brillouin zone (IBZ) for periodic electronic-structure calculations and annotate the provided k-point mesh object with symmetry-reduced indexing and related data used throughout PySCF's PBC modules.
    
    Args:
        kpts (KPoints object): A mutable KPoints object that describes a k-point mesh in the Brillouin zone (BZ). In the PySCF PBC codebase this object is expected to provide at least the following attributes and methods that this function reads: cell (the simulation cell object), nkpts (int, number of k-points in the full BZ mesh), nop (int, number of point-group operations per lattice symmetry operation), ops (iterable of symmetry operation objects with method a2b(cell).rot returning rotation matrices), time_reversal (bool, whether time-reversal symmetry is considered), kpts_scaled (array of fractional/scaled k-point coordinates in the cell basis), verbose (logging verbosity level), and cell.get_abs_kpts(scaled_kpts) (method converting scaled to absolute k-points). This function modifies the kpts object in-place to add symmetry-reduced indexing and arrays used by downstream PBC routines; it does not return a new object. Practical significance: callers should pass the KPoints instance that represents the computed or desired k-mesh for band-structure, HF/DFT, or many-body calculations so that subsequent code can use the symmetry-reduced IBZ representation and weights produced here.
        tol (float): Numerical tolerance used to decide equivalence between k-points after applying symmetry rotations (including time reversal when enabled). The function compares fractional differences between transformed and reference k-points and treats them as identical when every component of the difference (after subtracting nearest integer multiples of lattice vectors) has absolute value < tol. Default 1e-06. Practical significance: choose tol small enough to avoid classifying distinct k-points as equal, and not so small that floating-point roundoff prevents recognition of symmetrically equivalent k-points. If tol is too small, the routine may mark some symmetry operations as not present for the k-mesh (producing -1 entries and a warning); if tol is too large, distinct k-points can be collapsed incorrectly into the same IBZ representative.
    
    Returns:
        None: The function has no return value. Instead, it modifies the provided KPoints object in-place to populate the following attributes (used by other PySCF PBC routines) and their practical roles:
            k2opk (ndarray of int): mapping for each BZ k-point giving the index of the image of that k-point under each symmetry operation (including time reversal if enabled). Used to identify which symmetry operation maps a k-point to another.
            bz2ibz (ndarray of int): for every BZ k-point index, the index of its representative in the IBZ. Used to fold full-BZ quantities into IBZ quantities.
            ibz2bz (ndarray of int): list of BZ indices that serve as unique IBZ representatives, in IBZ order. Used to expand IBZ results back to the full BZ.
            weights_ibz (ndarray of float): integration weights for each IBZ k-point computed as bincount(bz2ibz) * (1.0 / nkpts). Used to perform BZ integrals or averages from IBZ samples.
            kpts_scaled_ibz (ndarray): scaled (fractional) coordinates of IBZ representative k-points (subset of kpts.kpts_scaled). Used by symmetry-aware integrals and mapping routines.
            kpts_ibz (ndarray): absolute (Cartesian) coordinates of IBZ representative k-points obtained via cell.get_abs_kpts(kpts_scaled_ibz). Used for algorithms that require physical k vectors.
            nkpts_ibz (int): number of k-points in the IBZ (length of ibz2bz).
            k2opk (ndarray of int): (already listed) may contain -1 entries when certain rotations are not in the subgroup of symmetry operations that leave the k-mesh invariant; callers should be prepared for this when the k-mesh has lower symmetry than the lattice.
            time_reversal_symm_bz (ndarray of int): index of the time-reversal subgroup operation that maps each BZ k-point to its IBZ representative. Used to restore time-reversal labeling when reconstructing full-BZ data.
            stars_ops_bz (ndarray): operation indices for each BZ k-point describing which symmetry operations generate the star (orbit) of that k-point relative to IBZ representatives. Used to build symmetry "stars" for each representative.
            stars (list of ndarrays): for each IBZ index, an array of BZ indices that form its star (all BZ k-points mapped to that IBZ representative). Used to accumulate contributions over equivalent k-points.
            stars_ops (list of ndarrays): for each IBZ index, the array of operation indices corresponding to the members of the star. Used to reconstruct how each star member is generated from the representative.
            little_cogroup_ops (list of ndarrays): for each IBZ representative, the indices of symmetry operations that leave that representative invariant (the little cogroup); used in symmetry-adapted block-diagonalization and other reduction steps.
    
    Behavior and side effects:
        The function computes rotation matrices from the KPoints.ops entries (calling op.a2b(cell).rot) and, when time_reversal is True, augments them with the negated rotations to represent combined time-reversal operations. It uses an internal mapping routine (map_k_points_fast) to find where each BZ k-point is mapped under each rotation; entries of -1 in this mapping indicate a rotation not present in the subgroup of operations that keep the k-mesh invariant (this can happen when the k-mesh has lower symmetry than the lattice). When such mismatches are found, the function emits a logger warning if kpts.verbose >= logger.WARN and propagates -1 values appropriately. The routine then selects IBZ representatives by scanning k-points in reverse order, builds forward and inverse mapping arrays between BZ and IBZ indices, computes IBZ weights as counts divided by nkpts, converts scaled IBZ k-points to absolute coordinates via cell.get_abs_kpts, and determines per-k-point time-reversal and star-operation labels by comparing transformed coordinates within the specified tol. Finally, it assembles per-IBZ little cogroup operation lists.
    
    Failure modes and diagnostics:
        If the provided kpts object does not supply the expected attributes or methods (cell, nkpts, nop, ops, kpts_scaled, cell.get_abs_kpts, verbose), the function will raise AttributeError or TypeError. If floating-point rounding prevents matching even equivalent k-points, consider increasing tol; conversely, lowering tol avoids false equivalences at the risk of reporting reduced symmetry. When the k-mesh has lower symmetry than the lattice, the function inserts -1 markers in mapping arrays and issues a warning at logger.WARN verbosity or higher.
    
    Domain context:
        This routine is used in PySCF's periodic-boundary-condition (PBC) electronic-structure code to reduce computational cost and enforce symmetry when evaluating band structures, k-point-sampled integrals, and many-body sums by working in the irreducible portion of the Brillouin zone. The IBZ and associated weights and mappings it produces are consumed by HF/DFT, GW, and other k-point-resolved modules within the PySCF framework.
    """
    from pyscf.pbc.lib.kpts import make_kpts_ibz
    return make_kpts_ibz(kpts, tol)


################################################################################
# Source: pyscf.pbc.lib.kpts.map_kpts_tuples
# File: pyscf/pbc/lib/kpts.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_lib_kpts_map_kpts_tuples(
    kpts_scaled: numpy.ndarray,
    ops: numpy.ndarray,
    ntuple: int = 2,
    tol: float = 1e-06
):
    """Find symmetry-related k-point tuples in the Brillouin zone for periodic
    boundary condition (PBC) electronic-structure calculations.
    
    This function is used in the PySCF periodic boundary-condition k-point
    infrastructure (pyscf.pbc.lib.kpts) to identify how k-point tuples are
    mapped onto one another under a set of rotation operators. It is typically
    used when constructing symmetry-adapted data structures (for example, when
    assembling integrals or mapping k-point-dependent quantities across the
    first Brillouin zone) so that operations on k-points account for symmetry
    and reciprocal-lattice translations.
    
    Args:
        kpts_scaled (numpy.ndarray): Array of scaled k-point tuples with shape
            (nkpts, ntuple, 3). Each entry is a tuple of ntuple k-points expressed
            in fractional (scaled) coordinates with respect to the reciprocal
            lattice vectors. nkpts is the number of distinct tuples in the
            Brillouin-zone sampling. The second dimension equals the ntuple
            argument and groups k-points that are considered together (for
            example ntuple=2 for pairs). The third dimension has size 3 for the
            three Cartesian components of each scaled k-point. In practice this
            input comes from the PBC k-point generation routines in PySCF and
            must match the expected tuple layout used elsewhere in the library.
        ops (numpy.ndarray): Array of rotation operators with shape (nop, 3, 3)
            and integer entries. Each ops[s] is a 3x3 rotation operator that acts
            on scaled k-point coordinates (in the same scaled coordinate system
            used by kpts_scaled). These operators represent point-group symmetry
            rotations (without fractional translations); the function applies
            ops[s] to each k-point in a tuple to find the symmetry-related tuple.
            The number of operators nop is the first dimension of this array.
        ntuple (int): Dimension of tuples (the second dimension of kpts_scaled).
            Default is 2. This parameter indicates how many k-points are grouped
            in each tuple (for example 2 for pairs, 3 for triplets). It must match
            the second dimension of kpts_scaled, otherwise shape or indexing
            inconsistencies will occur.
        tol (float): Numerical tolerance used to decide when two k-points are
            equivalent modulo a reciprocal-lattice vector. K-points whose
            coordinates differ by less than tol (after reduction to the first
            Brillouin zone via round_to_fbz) are considered identical. Default is
            1e-06. This tolerance controls sensitivity to floating-point rounding
            and should be chosen consistent with how k-points were generated.
    
    Behavior and practical significance:
        The function builds a mapping table bz2bz_ks of shape (nkpts, nop) where
        each entry bz2bz_ks[k1, s] gives the index k2 such that applying the
        rotation ops[s] to the tuple at index k1 yields the tuple at index k2 up
        to an integer reciprocal-lattice vector K. Concretely,
        bz2bz_ks[k1, s] = k2 if ops[s] * kpts_scaled[k1] = kpts_scaled[k2] + K.
        This mapping is required in PBC computations to relate k-point-dependent
        quantities under symmetry operations and to fold results back into the
        first Brillouin zone consistently. The algorithm works by:
        1) applying each rotation operator to all tuples (using numpy.einsum),
        2) reducing both original and rotated tuples to the fundamental Brillouin
           zone with round_to_fbz using the provided tol,
        3) lexicographically sorting the combined set of original and rotated
           tuples, and
        4) identifying adjacent equal entries in the sorted array as matches.
        The function returns integer indices referencing the original k-point
        tuple ordering.
    
    Side effects, defaults, and failure modes:
        The function has no external side effects (it does not modify its inputs).
        Default values are ntuple=2 and tol=1e-06. The function assumes that
        kpts_scaled.shape == (nkpts, ntuple, 3) and ops.shape == (nop, 3, 3);
        mismatched shapes or incompatible dtypes may raise numpy broadcasting
        errors or IndexError from internal operations. If the expected pairing
        pattern is violated (for example, if no match is found for a rotated
        tuple or if the sorting/pairing logic yields unexpected indices), an
        AssertionError may be raised by internal checks asserting that the first
        partner index is in [0, nkpts-1] and the second partner index is in
        [nkpts, 2*nkpts-1]. If entries remain unmapped (no matching tuple within
        tol), they will remain -1 in the returned array, indicating that no
        symmetry-related tuple was found under the provided ops and tol.
    
    Returns:
        numpy.ndarray: bz2bz_ks with shape (nkpts, nop) and dtype int. Each entry
        bz2bz_ks[k1, s] is the index k2 (0 <= k2 < nkpts) satisfying
        ops[s] * kpts_scaled[k1] = kpts_scaled[k2] + K for some reciprocal
        lattice vector K. A value of -1 indicates that no matching tuple was
        found within the specified tolerance for that (k1, s) combination. This
        return value is intended to be used by other PBC routines in PySCF to
        permute or identify k-point tuples under symmetry operations.
    """
    from pyscf.pbc.lib.kpts import map_kpts_tuples
    return map_kpts_tuples(kpts_scaled, ops, ntuple, tol)


################################################################################
# Source: pyscf.pbc.lib.kpts.dm_at_ref_cell
# File: pyscf/pbc/lib/kpts.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_lib_kpts_dm_at_ref_cell(kpts: int, dm_ibz: numpy.ndarray):
    """pyscf.pbc.lib.kpts.dm_at_ref_cell computes the reference-cell (real-space cell at the origin) one-particle density matrix by transforming density matrices given for k-points in the irreducible Brillouin zone (IBZ) to the full Brillouin zone (BZ) and averaging over all k-points. This function is used in the PySCF periodic-boundary-condition (PBC) code path to obtain the real-space density matrix at the reference cell from k-resolved density matrices (for example, results of mean-field or correlated calculations performed with k-point sampling).
    
    Args:
        kpts (KPoints object): Object that describes the k-point sampling for the periodic system. In practice this object provides the number of k-points via the attribute kpts.nkpts and any additional metadata required by the transform_dm utility called internally. The kpts argument determines the normalization of the returned density matrix (dm0 is divided by kpts.nkpts) and therefore has direct significance for obtaining the physically normalized reference-cell density in periodic simulations.
        dm_ibz (numpy.ndarray): Density matrices defined on k-points in the irreducible Brillouin zone. Expected shape is ([2,] nkpts_ibz, nao, nao) where nkpts_ibz is the number of k-points in the IBZ and nao is the number of atomic orbitals; the optional leading axis of length 2 appears when spin blocks are present. These are the input k-resolved density matrices produced by PBC electronic structure procedures; the function first expands them to the full BZ (via transform_dm) and then averages to produce the reference-cell density.
    
    Returns:
        numpy.ndarray: dm0, the reference-cell density matrix with shape ([2,] nao, nao). This array is computed by (1) calling transform_dm(kpts, dm_ibz) to map IBZ densities to the full BZ, (2) summing the transformed density matrices over the k-point axis (-3 in the implementation) and (3) dividing by kpts.nkpts to obtain the average per k-point (the physically normalized real-space density matrix at the origin cell). The returned dtype may be complex if the input or intermediate transformed matrices are complex.
    
    Behavior, side effects, and failure modes:
        - The function relies on an external transform_dm routine to expand dm_ibz from the IBZ to the full BZ; errors raised by transform_dm (for example due to incompatible shapes or missing k-point metadata) propagate out of this function.
        - The returned dm0 is obtained as a per-k-point average: dm0 = sum(transform_dm(kpts, dm_ibz), axis=-3) / kpts.nkpts. Correct normalization therefore depends on kpts.nkpts being present and correctly set.
        - If the imaginary parts of dm0 are non-negligible, the function logs a warning using logger.warn with the message that reports the maximum absolute imaginary component; the implemented threshold for issuing this warning is 1e-10 (i.e., if abs(dm0.imag).max() > 1e-10). This is a non-fatal condition: no exception is raised, only a logged warning, and the complex-valued dm0 is returned.
        - The function does not modify the input dm_ibz in-place; it returns a new array dm0.
        - Common failure modes include AttributeError if the provided kpts object lacks the nkpts attribute, ValueError or IndexError from shape mismatches between dm_ibz and what transform_dm expects, and any exceptions propagated from transform_dm. Users should ensure dm_ibz conforms to the expected shape ([2,] nkpts_ibz, nao, nao) and that kpts correctly represents the k-point sampling used to produce dm_ibz.
    """
    from pyscf.pbc.lib.kpts import dm_at_ref_cell
    return dm_at_ref_cell(kpts, dm_ibz)


################################################################################
# Source: pyscf.pbc.lib.kpts.make_ktuples_ibz
# File: pyscf/pbc/lib/kpts.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_lib_kpts_make_ktuples_ibz(
    kpts: int,
    kpts_scaled: numpy.ndarray = None,
    ntuple: int = 2,
    tol: float = 1e-06
):
    """Construct k-point tuples in the irreducible Brillouin zone (IBZ) for
    periodic-boundary-condition electronic-structure calculations.
    
    This function is used in the PySCF PBC workflow to identify symmetry-unique
    ntuple combinations of k-points (for example pairs for two-point integrals)
    and to build mapping tables between the full Brillouin zone (BZ) of k-point
    tuples and the IBZ. The mappings and "stars" produced by this function are
    consumed by downstream routines that assemble symmetry-reduced sums over
    k-point tuples, compute weights for IBZ tuples, and apply point-group and
    time-reversal symmetry operations during k-point sampling.
    
    Args:
        kpts (KPoints object): KPoints object from pyscf.pbc that represents the
            sampled k-points, lattice cell, and symmetry operations. The function
            reads kpts.cell to construct rotation operators, kpts.ops for the
            list of symmetry operations, kpts.time_reversal to decide whether to
            include time-reversal symmetry, kpts.k2opk for direct mappings from
            k-points to their symmetry-transformed indices (when kpts_scaled is
            None), and kpts.verbose to control informational logging. Practically,
            pass the same KPoints instance used throughout the PBC calculation so
            that the IBZ construction is consistent with the cell and symmetry
            definitions used elsewhere in PySCF.
        kpts_scaled (numpy.ndarray): Optional array of scaled k-point coordinates
            used as the explicit set among which symmetry relations are sought.
            When provided, it must encode the candidate k-point tuples in the
            same reduced-coordinate basis as the cell and have shape
            (nkpts, ntuple, 3) where nkpts is the number of k-points and ntuple
            is the tuple dimension. If None (the default), the function uses
            kpts.k2opk from the supplied KPoints object and implicitly considers
            all k-points defined in kpts. Supplying kpts_scaled allows callers to
            restrict symmetry discovery to a specific subset or ordering of tuples.
        ntuple (int): Dimension of the k-point tuples to construct (for example
            ntuple=2 constructs ordered pairs of k-points). Default is 2. When
            kpts_scaled is None the total number of tuples considered is nkpts**ntuple
            where nkpts is the number of k-points in kpts. The ntuple value
            controls the combinatorial size of mappings and the resulting arrays.
        tol (float): Numerical tolerance for distinguishing k-points. K-points
            that differ by less than or equal to tol are treated according to the
            internal mapping routines; values outside this tolerance are considered
            distinct. Default is 1e-6 (KPT_DIFF_TOL). This tolerance affects the
            matching performed by map_kpts_tuples and therefore the contents of
            the mapping tables and stars.
    
    Returns:
        ibz2bz (numpy.ndarray): (nibz,) ndarray of int. Index list mapping each
            IBZ-representative tuple to its corresponding index in the full BZ
            enumeration of k-point tuples. nibz is the number of unique tuples
            retained in the IBZ. This array is used to expand IBZ results back to
            the full BZ.
        weight_ibz (numpy.ndarray): (nibz,) ndarray of int. Weights for each
            IBZ tuple (how many full-BZ tuples map to that IBZ representative),
            computed from the mapping counts and normalized by the ntuple
            combinatorial factor. These weights are used to form symmetry-reduced
            sums over the full BZ from quantities evaluated only on the IBZ.
        bz2ibz (numpy.ndarray): (nkpts**ntuple,) ndarray of int. Mapping table
            from the linear index of each full-BZ k-point tuple to the index of
            its corresponding IBZ representative (an index into ibz2bz). This
            array is used to reduce or fold quantities defined on the full BZ
            into the IBZ.
        stars (list of numpy.ndarray): list of (nibz,) ndarrays of int. For each
            IBZ representative, the array lists the indices (in the full BZ tuple
            enumeration) of the tuples that belong to the same symmetry "star"
            (i.e., are symmetry-equivalent under the considered operations). This
            structure mirrors the notion of orbital or k-point stars used in PBC
            symmetry reductions.
        stars_ops (list of numpy.ndarray): list of (nibz,) ndarrays of int. For
            each IBZ representative, the array gives the indices of the symmetry
            operations (from kpts.ops, and extended with time-reversal if present)
            that map the representative to each member of its star. These indices
            are useful when reconstructing how a particular full-BZ tuple is
            generated from the IBZ representative via a symmetry operation.
        stars_ops_bz (numpy.ndarray): (nkpts**ntuple,) ndarray of int. For every
            full-BZ tuple index this array stores the operation index that maps
            the IBZ representative to that tuple. This flat array is an alternative
            representation of stars_ops indexed on the full-BZ tuple enumeration.
    
    Behavior, side effects, and failure modes:
        - If kpts_scaled is provided, the function computes symmetry mappings by
          converting the symmetry operations in kpts.ops to rotation matrices in
          the cell basis and invoking map_kpts_tuples with the supplied scaled
          coordinates. If kpts_scaled is None, the function uses kpts.k2opk to
          build tuple mappings; in this branch the total number of tuples is
          nkpts**ntuple.
        - The function logs informational messages via kpts.logger when
          kpts.verbose >= logger.INFO, reporting the number of tuples considered
          and the number of unique tuples found in the IBZ.
        - The function uses sentinel value -1 in intermediate mapping arrays to
          denote tuples or operations that are not available; callers may observe
          -1 entries if certain symmetry operations do not map a tuple onto the
          discrete k-point grid.
        - The function performs no explicit input validation beyond relying on the
          called utilities (map_kpts_tuples, lib.cartesian_prod, lib.inv_base_repr_int).
          If kpts lacks the required attributes (cell, ops, k2opk, time_reversal,
          verbose) an AttributeError will be raised. If kpts_scaled has an
          incompatible shape the called mapping routines may raise ValueError or
          IndexError.
        - The returned arrays are newly allocated and owned by the caller; the
          function does not modify the input kpts object or kpts_scaled array.
        - The function is deterministic given the same kpts, kpts_scaled, ntuple,
          and tol; differences in ordering can arise from the ordering of symmetry
          operations in kpts.ops or the presence of time-reversal symmetry.
    """
    from pyscf.pbc.lib.kpts import make_ktuples_ibz
    return make_ktuples_ibz(kpts, kpts_scaled, ntuple, tol)


################################################################################
# Source: pyscf.pbc.lib.kpts.transform_1e_operator
# File: pyscf/pbc/lib/kpts.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_lib_kpts_transform_1e_operator(kpts: int, fock_ibz: numpy.ndarray):
    """pyscf.pbc.lib.kpts.transform_1e_operator
    Transform a 1-electron operator from the irreducible Brillouin zone (IBZ) representation to the full Brillouin zone (BZ) representation used in periodic electronic-structure calculations.
    
    Args:
        kpts (KPoints): KPoints object describing the k-point sampling, symmetry and related data required to expand IBZ quantities to the full BZ. In the PySCF periodic (pbc) context this object provides fields used by the transformation: kpts.nkpts (number of k-points in the full BZ), kpts.bz2ibz (mapping from full-BZ index to IBZ index), kpts.kpts_scaled_ibz (scaled coordinates of IBZ k-points), kpts.stars_ops_bz (index of the symmetry operation to apply for each BZ k-point), kpts.ops (symmetry operation objects with attributes such as is_eye), kpts.time_reversal_symm_bz (per-BZ-kpoint boolean for time-reversal conjugation), kpts.Dmats (precomputed representation matrices used by the symmetry transformer), and kpts.cell (unit cell needed by symm.transform_1e_operator). This function reads these attributes but does not modify the kpts object. If kpts is missing required attributes, AttributeError or IndexError will occur.
        fock_ibz (numpy.ndarray): Fock-like matrices provided only for k-points in the IBZ, with shape ([2,] nkpts_ibz, nao, nao). In practice this is either:
            - a complex ndarray of shape (nkpts_ibz, nao, nao) for a closed-shell / spin-restricted 1-electron operator, or
            - a length-2 sequence or ndarray whose first axis has size 2 and whose elements are arrays of shape (nkpts_ibz, nao, nao) for an unrestricted (UHF) operator, where the two blocks correspond to spin alpha and beta.
            The entries are the Fock (or other one-electron operator) matrices expressed in the atomic-orbital basis for each k-point in the IBZ. The function detects UHF input by checking whether fock_ibz[0][0] is a 2-D ndarray (matching the implementation in the source). If the array shapes or indexing do not match the expected layout, a ValueError or IndexError may be raised.
    
    Returns:
        fock_bz (numpy.ndarray): Fock-like matrices expanded to the full BZ with shape ([2,] nkpts, nao, nao). The return value is constructed as follows:
        - For spin-restricted / single-block input, an ndarray of shape (nkpts, nao, nao) is returned where nkpts == kpts.nkpts. Each element corresponds to the Fock matrix at a full-BZ k-point, obtained by selecting the corresponding IBZ matrix (via kpts.bz2ibz) and applying the appropriate symmetry operation (kpts.ops[kpts.stars_ops_bz[k]]) using symm.transform_1e_operator with the precomputed representation kpts.Dmats[iop]. If kpts.time_reversal_symm_bz[k] is True for a given k-point, the matrix is conjugated after the symmetry transform.
        - For UHF (two-spin-block) input, a ndarray of shape (2, nkpts, nao, nao) is returned where axis 0 corresponds to the two spin blocks (alpha, beta). Each spin block is expanded independently using the same mapping and symmetry operations as above.
        The function returns a new array and does not modify the input fock_ibz. Internally the code accumulates Python lists of transformed matrices and converts them to a numpy-compatible array via lib.asarray before reshaping; this may fail if the transformed blocks have inconsistent shapes.
    
    Behavior, side effects, and failure modes:
        - Purpose and domain: This routine is used in PySCF periodic (pbc) workflows to reconstruct operator matrices for all k-points in the full Brillouin zone from a compact representation stored only for symmetry-unique k-points (the IBZ). This expansion is necessary for tasks that require values at every sampled k-point (for example, building band energies, density matrices, or evaluating sums over the full BZ).
        - Symmetry transformation: For each full-BZ k-point the function finds the IBZ representative and applies the corresponding symmetry operation. If the symmetry operation is the identity (op.is_eye), the IBZ matrix is used directly; otherwise symm.transform_1e_operator(kpts.cell, ibz_kpt_scaled, fock_ibz, op, kpts.Dmats[iop]) is called to perform the rotation in the atomic-orbital basis. If time-reversal symmetry is flagged for that BZ k-point, the transformed matrix is conjugated.
        - UHF detection and handling: The function detects an unrestricted-spin input by checking the dimensionality of fock_ibz[0][0] in the same way as the implementation. When UHF input is detected, both spin blocks are transformed separately and returned with a leading spin axis of length 2.
        - Inputs are not modified; the result is a newly allocated numpy array. If kpts lacks expected attributes (nkpts, bz2ibz, ops, stars_ops_bz, time_reversal_symm_bz, Dmats, cell, etc.) the function will raise AttributeError or IndexError. If fock_ibz does not follow the expected shape conventions or contains inconsistent spin blocks, ValueError or IndexError may occur. The transform relies on symm.transform_1e_operator; errors from that routine (for example due to mismatched matrix dimensions or incompatible op/Dmats) will propagate.
        - No defaults: all required data must be provided via kpts and fock_ibz. The function assumes standard PySCF pbc data structures described above and in the PySCF documentation; it is not intended to accept arbitrary types or shapes beyond those used in PySCF's periodic HF/DFT code base.
    """
    from pyscf.pbc.lib.kpts import transform_1e_operator
    return transform_1e_operator(kpts, fock_ibz)


################################################################################
# Source: pyscf.pbc.lib.kpts_helper.check_kpt_antiperm_symmetry
# File: pyscf/pbc/lib/kpts_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_lib_kpts_helper_check_kpt_antiperm_symmetry(
    array: numpy.ndarray,
    idx1: int,
    idx2: int,
    tolerance: float = 1e-08
):
    """pyscf.pbc.lib.kpts_helper.check_kpt_antiperm_symmetry checks antipermutational symmetry of a k-point indexed many-particle array by swapping the k-point and corresponding orbital indices of two particles and testing whether the array is antisymmetric under that swap.
    
    Args:
        array (numpy.ndarray): Array to test for antipermutational symmetry. For an n-particle array the calling convention used throughout the pyscf.pbc.kpts_helper utilities is assumed: the first (2*n - 1) array axes are the k-point indices and the final 2*n axes are the orbital indices (for each particle there is one k-point index and one orbital index; because of momentum conservation one k-point index is implicit and not stored, hence 2*n-1 k-point axes). Typical arrays include amplitude tensors used in periodic correlated methods (for example T2 or T3 amplitudes with k-point and orbital axes). The function does not modify this array.
        idx1 (int): Zero-based particle index of the first particle to swap. This index selects which particle's k-point axis (one of the first 2*n-1 axes) and which particle's orbital axis (the axis at position (2*n - 1) + idx1) are swapped. Must be non-negative and strictly less than (2*n - 1). In the common T3 example (three particles), idx1 = 0 refers to the first particle's k-point and orbital axes (ki and i in t3[ki,kj,kk,ka,kb,i,j,a,b,c]).
        idx2 (int): Zero-based particle index of the second particle to swap. Same indexing convention as idx1: selects the k-point axis among the first 2*n-1 axes and the orbital axis at position (2*n - 1) + idx2. Must be non-negative and strictly less than (2*n - 1). For example, setting idx1 = 0 and idx2 = 1 swaps both ki<->kj and i<->j in a T3 tensor.
        tolerance (float): Numerical tolerance used to decide antisymmetry. The function computes the matrix norm of (array + array.transpose(permuted_axes)) using numpy.linalg.norm and returns True if this norm is strictly less than tolerance. Defaults to 1e-8. This tolerance accounts for finite numerical precision (for example due to FFT grids or floating-point roundoff) when validating symmetry.
    
    Returns:
        bool: True if the input array is antisymmetric under the combined swap of the two specified particles' k-point and orbital axes within the provided tolerance; False otherwise. A return value of True indicates the tested operator or amplitude obeys the expected antipermutational symmetry (important for physical operators represented in spin-orbital or spin-free form and for verification of numerical procedures). A return value of False indicates the symmetry test failed within the given tolerance and may point to numerical issues (for example an FFT grid that is too coarse) or an incorrect tensor construction.
    
    Behavior and failure modes:
        - The function infers the number of particles n from the array dimensionality using the convention described above. The caller must supply an array whose axes follow the k-point / orbital ordering convention; otherwise the test is not meaningful.
        - The function asserts that idx1 and idx2 are non-negative. If this condition fails an AssertionError is raised.
        - The function asserts that both idx1 and idx2 are strictly less than (2*n - 1). Attempting to swap the last implicit k-point index is not supported and triggers an AssertionError; this reflects the momentum-conservation convention where the final k-point axis is not explicitly indexed.
        - Only arrays for up to 3 particles are supported by this implementation. If the inferred particle count exceeds 3 the function raises NotImplementedError. This limit arises from the current implementation and can be extended in future versions of the module.
        - The test is purely diagnostic: it has no side effects and does not mutate the input array. It uses numpy.transpose with a constructed permutation of axes and numpy.linalg.norm to form the numeric test against tolerance.
    """
    from pyscf.pbc.lib.kpts_helper import check_kpt_antiperm_symmetry
    return check_kpt_antiperm_symmetry(array, idx1, idx2, tolerance)


################################################################################
# Source: pyscf.pbc.lib.linalg_helper.diagonalize_asymm
# File: pyscf/pbc/lib/linalg_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_lib_linalg_helper_diagonalize_asymm(H: numpy.ndarray):
    """Diagonalize a real, asymmetric matrix and return its eigenvalues and eigenvectors sorted by ascending eigenvalue real part. This helper is used in the PySCF periodic-boundary-condition (pbc) linear-algebra utilities to obtain eigenpairs of non-Hermitian operators that can arise in electronic-structure workflows; it wraps numpy.linalg.eig and provides a deterministic ordering of the output by the real part of the eigenvalues for downstream processing and comparisons.
    
    Args:
        H (numpy.ndarray): Input matrix to diagonalize. This is expected to be a square (2-D) numpy.ndarray representing a real, asymmetric matrix used in PySCF PBC linear-algebra tasks. The function calls numpy.linalg.eig(H); therefore H must be suitable for eigen-decomposition (square). The matrix H is not modified in-place; a copy of the eigenpairs is returned. If H has complex entries, numpy.linalg.eig will handle them and the function will still return eigenvalues and eigenvectors as numpy arrays (possibly complex).
    
    Returns:
        E (numpy.ndarray): One-dimensional array of eigenvalues returned by numpy.linalg.eig and then sorted in ascending order according to their real parts. Eigenvalues may be complex-valued when the input or the computed spectrum is non-real; this function does not discard or coerce imaginary parts.
        C (numpy.ndarray): Two-dimensional array whose columns are the eigenvectors corresponding to E. After sorting, C[:, i] is the eigenvector associated with E[i]. The eigenvectors are returned in the same dtype produced by numpy.linalg.eig.
    
    Notes on behavior and failure modes:
        - Sorting criterion: eigenpairs are ordered by E.real.argsort(), i.e., ascending real part of eigenvalues. If multiple eigenvalues share the same real part, their relative order is determined by numpy.argsort and is not otherwise guaranteed.
        - Numerical issues: eigenvalues and eigenvectors are computed by numpy.linalg.eig; results may be sensitive to floating-point round-off for nearly degenerate or ill-conditioned matrices.
        - Errors: any exceptions raised by numpy.linalg.eig (for example, failures in the underlying LAPACK routine) propagate to the caller. Users should handle numpy.linalg.LinAlgError or other numpy exceptions as appropriate.
        - Side effects: None on the input H; the function returns new arrays E and C.
    """
    from pyscf.pbc.lib.linalg_helper import diagonalize_asymm
    return diagonalize_asymm(H)


################################################################################
# Source: pyscf.pbc.lib.kpts_helper.round_to_fbz
# File: pyscf/pbc/lib/kpts_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_lib_kpts_helper_round_to_fbz(
    kpts: numpy.ndarray,
    wrap_around: bool = False,
    tol: float = 1e-06
):
    """Round scaled k-points to the first Brillouin zone used in PySCF periodic-boundary-condition (PBC) workflows.
    
    Args:
        kpts (ndarray): Scaled k-points with shape (..., 3). Each row of the trailing dimension is a 3-component fractional k-point expressed in units of the reciprocal lattice vectors (i.e., values are expected to be in the range of typical scaled coordinates). This function reshapes the input to (-1, 3) internally, so the last dimension of kpts must be 3; otherwise a ValueError or shape-related exception will occur. The input array is not modified in place; a new ndarray with the same shape is returned.
        wrap_around (bool): If True, map k-points into the interval [-0.5, 0.5) for each component; if False (default), map into [0.0, 1.0). This controls the final representation of fractional k-points in the first Brillouin zone: use wrap_around=True when the convention centers the zone at the origin (common in many solid-state calculations), and use False when the convention is 0..1 periodic coordinates.
        tol (float): Tolerance used to consider k-points identical and to determine the rounding precision. K-points that differ by less than tol are treated as the same and are "cleaned" using lib.cleanse to remove tiny numerical noise before rounding. The function computes an internal decimal precision from tol via -log10((tol+1e-16)/10.) and then rounds to that many decimal places. Default value is 1e-06. Passing non-finite or nonsensical tol values may lead to unexpected rounding behavior; if tol is non-numeric a TypeError will be raised.
    
    Returns:
        ndarray: New ndarray of the same shape as the input kpts, containing k-points mapped into the first Brillouin zone according to the wrap_around convention and rounded to a precision consistent with tol. Behavior details: components are reduced modulo 1.0, cleaned so points closer than tol are treated equal, rounded to the computed decimal precision, reduced modulo 1.0 again, and finally shifted by -1.0 for components >= 0.5 when wrap_around is True (producing values in [-0.5, 0.5)). No in-place modification of the input is performed. Failure modes: if the last dimension of kpts is not 3, reshaping will fail; if kpts contains NaN or infinite values, the result will contain corresponding NaN/infinite entries; if kpts is not a numeric ndarray a TypeError will be raised. This function is typically used in PySCF PBC k-point handling to ensure consistent folding and comparison of k-points when building k-point meshes, symmetry-reduced lists, or mapping k-dependent quantities into the canonical first Brillouin zone.
    """
    from pyscf.pbc.lib.kpts_helper import round_to_fbz
    return round_to_fbz(kpts, wrap_around, tol)


################################################################################
# Source: pyscf.pbc.lib.kpts_helper.intersection
# File: pyscf/pbc/lib/kpts_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_lib_kpts_helper_intersection(kpts1: numpy.ndarray, kpts2: numpy.ndarray):
    """Return the indices of rows in kpts1 that match any row in kpts2 within the module tolerance KPT_DIFF_TOL.
    
    This function is used in the PySCF periodic-boundary-condition (pbc) workflows to identify common k-points between two k-point meshes or sets. In practice, it helps determine which sampling points in reciprocal space (k-points) from kpts1 also appear in kpts2 within a small floating-point tolerance, a common need when aligning k-point meshes for band-structure calculations, integral evaluations, or symmetry-related operations in PySCF.
    
    Args:
        kpts1 (numpy.ndarray): A 2-D array of k-points. Each row is a k-point vector (for example, a 3-component reciprocal-space coordinate) and the array must have ndim == 2. The function treats each row as a coordinate in the same coordinate system used by kpts2.
        kpts2 (numpy.ndarray): A 2-D array of k-points with the same dimensionality (ndim == 2) as kpts1. Each row is a k-point vector to be compared against rows of kpts1.
    
    The function computes the elementwise absolute difference between every pair of rows from kpts1 and kpts2, then reduces that difference along the vector components by taking the maximum absolute component difference for each pair. A k-point row in kpts1 is considered to match a k-point row in kpts2 if this maximum component-wise absolute difference is strictly less than the module-level tolerance KPT_DIFF_TOL. If a row in kpts1 matches multiple rows in kpts2 it is returned only once. The returned indices are made unique (duplicates removed) and are returned in ascending order.
    
    Failure modes and side effects:
    - The function asserts that both inputs have ndim == 2; if this is not true an AssertionError is raised.
    - If the two arrays have a different number of components per k-point (different second-dimension sizes), NumPy will raise a ValueError during the subtraction operation.
    - The inputs should contain numeric types compatible with NumPy arithmetic; otherwise a TypeError or ValueError may be raised.
    - No in-place modification of the input arrays occurs.
    
    Returns:
        numpy.ndarray: A 1-D integer array of indices into kpts1. Each index identifies a row of kpts1 that has at least one matching row in kpts2 within KPT_DIFF_TOL. If no rows match, an empty 1-D numpy.ndarray is returned.
    """
    from pyscf.pbc.lib.kpts_helper import intersection
    return intersection(kpts1, kpts2)


################################################################################
# Source: pyscf.pbc.lib.kpts_helper.member
# File: pyscf/pbc/lib/kpts_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_lib_kpts_helper_member(kpt: numpy.ndarray, kpts: numpy.ndarray):
    """pyscf.pbc.lib.kpts_helper.member: Return the indices of k-points in a collection that coincide with a reference k-point within the module tolerance.
    
    Args:
        kpt (numpy.ndarray): 1D or ND array representing a single k-point in reciprocal space used in periodic boundary condition (PBC) electronic-structure calculations. In PySCF, a k-point typically encodes fractional coordinates in the Brillouin zone; this array is flattened with kpt.ravel() and its element count (kpt.size) is used to compare against candidates in kpts. The function treats kpt as the reference whose matches are sought, and it is expected to contain numeric values compatible with subtraction and absolute operations.
        kpts (numpy.ndarray): Array containing one or more k-points to be searched for matches to the reference kpt. The function requires kpts.ndim == kpt.ndim + 1 so that the leading axis/axes index distinct candidate k-points and the remaining dimensions match the shape of kpt; for example, when kpt is a 1D vector (common for fractional coordinates), kpts is typically a 2D array with shape (n_kpts, kpt.size). Internally kpts is reshaped to (-1, kpt.size) so the total number of elements in kpts must be divisible by kpt.size.
    
    Returns:
        numpy.ndarray: 1D integer array of indices into the flattened set of candidate k-points (i.e., the first axis of kpts.reshape(-1, kpt.size)) whose maximum absolute coordinate difference from kpt is strictly less than the module constant KPT_DIFF_TOL. The comparison uses the L-infinity norm (max absolute difference across coordinates) to determine equality within tolerance. If no matching k-points are found, an empty numpy.ndarray is returned. When one or more matches are found, duplicate indices are removed via numpy.unique before returning.
    
    Behavior, side effects, and failure modes:
        This function is used in PySCF's PBC k-point handling utilities to identify common k-points between a single reference k-point and a collection of k-points, for example when mapping integrals, exploiting translational symmetry, or assembling k-point meshes for periodic electronic-structure calculations. The function performs no in-place modification of inputs.
        The function asserts that kpts.ndim == kpt.ndim + 1; if this condition is not met an AssertionError is raised. If kpts cannot be reshaped into (-1, kpt.size) because the total number of elements in kpts is not divisible by kpt.size, a ValueError (from numpy.reshape) will be raised. Inputs must be numeric numpy.ndarray types that support subtraction, absolute value, and ravel operations; otherwise numpy will raise a TypeError or similar. Matching uses the module-level tolerance constant KPT_DIFF_TOL (a floating-point threshold defined elsewhere in the pyscf.pbc.lib.kpts_helper module); changing that constant alters the strictness of the equality test.
    """
    from pyscf.pbc.lib.kpts_helper import member
    return member(kpt, kpts)


################################################################################
# Source: pyscf.pbc.lib.kpts.get_rotation_mat_for_mos
# File: pyscf/pbc/lib/kpts.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_lib_kpts_get_rotation_mat_for_mos(
    kpts: int,
    mo_coeff: numpy.ndarray,
    ovlp: numpy.ndarray,
    k1: list,
    k2: list,
    ops_id: list = None
):
    """Rotation matrices for rotating molecular orbitals (MOs) defined at k-points k1 to those at k-points k2 using the space-group symmetry operations available in a PySCF periodic KPoints object.
    
    Args:
        kpts (KPoints): K-point object from pyscf.pbc.symm that bundles information about the periodic cell, the list of scaled k-points, the list of symmetry operations (ops), the corresponding D-matrices (Dmats) and the number of operations (nop). In the PySCF PBC domain this object identifies the Brillouin zone sampling and the symmetry operations used to transform atomic-orbital (AO) and MO quantities between k-points. The function reads kpts.cell, kpts.kpts_scaled, kpts.ops, kpts.Dmats and kpts.nop; it does not modify the kpts object.
        mo_coeff (array): MO coefficient arrays for all k-points. In practice this is the collection of MO coefficient matrices returned by periodic SCF codes in PySCF, indexed by k-point. Each entry mo_coeff[k] is used as the AO->MO coefficient matrix at k and is combined with the AO overlap and AO-space rotation matrices to construct MO-space rotation matrices that map MOs at one k-point to MOs at another.
        ovlp (array): Overlap matrix in atomic-orbital (AO) basis for each k-point. This provides the AO inner product <chi_i|chi_j> used to convert AO-space rotation operators (from symmetry operations) into MO-space operators via the sequence mo_coeff[k_orig].H * ovlp[k_orig] * R_AO.H * mo_coeff[k_target], where R_AO is the AO rotation matrix returned by the internal symmetry routine.
        k1 (array like): Indices (integers or array-like of integers) of the original k-points in the Brillouin zone whose MOs are the source (left) of the rotation. The length of k1 defines the number of k-point pairs to process; it must equal len(k2) and, if ops_id is provided, must equal len(ops_id).
        k2 (array like): Indices (integers or array-like of integers) of the target k-points in the Brillouin zone whose MOs are the destination (right) of the rotation. Each pair (k1[i], k2[i]) is processed independently to produce one array of rotation matrices. The function assumes that mo_coeff and ovlp are indexed by these integer k-point indices.
        ops_id (list, optional): Indices of space group operations to use for each k-point pair. If None (default), all symmetry operations in kpts (0..kpts.nop-1) are considered. If provided, ops_id must be an iterable with the same length as k1; each element ops_id[i] is converted to a 1-D array of integer operation indices to apply for the i-th k-point pair. The indices select entries from kpts.ops and kpts.Dmats. Providing ops_id restricts the set of rotations considered for each pair.
    
    Returns:
        out (list): A list with length equal to len(k1) (== len(k2)). Each element out[i] is a numpy.ndarray containing the rotation matrices for mapping MOs at k1[i] to MOs at k2[i] produced by the requested symmetry operations. The i-th array has one matrix per symmetry operation selected for that pair (the first dimension enumerates operations); each matrix is the MO-space representation computed as mo_coeff[k1[i]].conj().T @ ovlp[k1[i]] @ R_AO.conj().T @ mo_coeff[k2[i]] (where R_AO is the AO rotation matrix returned by the internal _get_rotation_mat call). In practice these matrices are complex-valued linear maps in MO space that can be used to transform MO coefficients or to identify symmetry-related MOs between k-points.
    
    Behavior, side effects, defaults, and failure modes:
        - The function iterates over pairs (k1[i], k2[i]) and over symmetry operation indices. If ops_id is None, it uses all operations in kpts (0..kpts.nop-1). If ops_id is provided it is interpreted per-pair and each element is reshaped to a 1-D array of integers.
        - The function calls pyscf.pbc.symm.symmetry._get_rotation_mat to obtain the AO-space rotation matrix for each operation; any exceptions raised by that routine (e.g., due to invalid cell/operation data) are propagated to the caller.
        - The function performs no in-place modification of the inputs kpts, mo_coeff, or ovlp; it constructs and returns new numpy arrays.
        - Preconditions enforced by the implementation: len(k1) must equal len(k2) (AssertionError raised otherwise). If ops_id is not None, its length must equal len(k1) (AssertionError raised otherwise). The provided operation indices in ops_id must be valid indices into kpts.ops and kpts.Dmats or an IndexError/other exception may be raised by numpy or the internal symmetry routines.
        - Numerical behavior depends on the shapes and dtypes of mo_coeff and ovlp supplied by the caller; the function combines conjugate transposes and matrix multiplications and therefore typically returns complex-valued rotation matrices when inputs are complex. Performance scales with the number of k-point pairs and the number of symmetry operations per pair; large numbers of operations or large MO dimensions increase CPU and memory usage.
        - This function is intended to be used within PySCF periodic boundary condition workflows to relate MO representations at symmetry-equivalent k-points (for example, when constructing symmetry-adapted quantities, comparing band characters, or rotating MO coefficients between k-points).
    """
    from pyscf.pbc.lib.kpts import get_rotation_mat_for_mos
    return get_rotation_mat_for_mos(kpts, mo_coeff, ovlp, k1, k2, ops_id)


################################################################################
# Source: pyscf.pbc.lib.kpts.transform_dm
# File: pyscf/pbc/lib/kpts.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_lib_kpts_transform_dm(kpts: int, dm_ibz: numpy.ndarray):
    """Transform density matrices from the irreducible Brillouin zone (IBZ) to the full Brillouin zone (BZ).
    
    This function is used in PySCF's periodic-boundary-condition (pbc) k-point utilities to expand density matrices computed only on symmetry-unique k-points (IBZ) into the full set of k-points in the BZ, applying the point-group symmetry operations and time-reversal as encoded by the provided KPoints object. The expanded density matrices are required for post-processing steps that assume explicit matrices for every k-point in the full BZ (for example, constructing k-point dependent observables, performing Fourier transforms across the full BZ, or feeding density matrices into integrals/electronic-structure routines that do not exploit IBZ symmetry).
    
    Args:
        kpts (KPoints): KPoints object that encodes the k-point sampling, mapping between full BZ and IBZ, symmetry operations, and transformation helpers. This object must provide attributes and methods accessed by this function: nkpts (total number of k-points in the full BZ), nkpts_ibz (number of k-points in the IBZ), bz2ibz (array mapping each BZ index to the corresponding IBZ index), kpts_scaled_ibz (scaled coordinates of IBZ k-points), stars_ops_bz (index of the symmetry operation mapping the IBZ k-point to each BZ k-point), ops (sequence of symmetry operation objects where each op has attribute is_eye used to detect the identity operation), Dmats (precomputed transformation matrices indexed by symmetry operation), time_reversal_symm_bz (boolean flags per BZ k-point indicating whether to apply complex conjugation), transform_mo_coeff (callable to transform molecular orbital coefficients from IBZ to BZ), and transform_mo_occ (callable to transform orbital occupations). The KPoints object is central to the practical significance of this function: it defines how a density matrix defined for one representative k-point in the IBZ is rotated/translated into the corresponding matrices at all k-points in the full BZ according to the crystal symmetry used in PySCF periodic calculations.
    
        dm_ibz (([2,] nkpts_ibz, nao, nao) ndarray): Density matrices defined for k-points in the IBZ. The array can represent either a spin-restricted (RHF) set with shape (nkpts_ibz, nao, nao) or a spin-unrestricted (UHF) set with a leading spin index giving shape (2, nkpts_ibz, nao, nao). Each element is a square matrix of size nao x nao (number of atomic orbitals) for a single IBZ k-point. Optionally, dm_ibz may have attributes mo_coeff and mo_occ; when present, these are transformed via kpts.transform_mo_coeff and kpts.transform_mo_occ and attached to the returned array (see Returns). The function detects the UHF form by checking whether dm_ibz is a 4-dimensional ndarray or whether dm_ibz[0][0] is a 2D ndarray; this detection determines whether both spin channels are transformed separately.
    
    Behavior and side effects:
        - For each full-BZ k-point index k (0 <= k < kpts.nkpts), the function identifies the corresponding IBZ index ibz_k_idx = kpts.bz2ibz[k], obtains the IBZ k-point coordinates kpts.kpts_scaled_ibz[ibz_k_idx], and determines the symmetry operation index iop = kpts.stars_ops_bz[k] that maps the IBZ k-point to that BZ k-point.
        - If the symmetry operation op = kpts.ops[iop] is the identity (op.is_eye is True), the IBZ density matrix is reused directly for that BZ k-point. Otherwise, the density matrix is transformed by calling symm.transform_dm(kpts.cell, ibz_kpt_scaled, dm_ibz[ibz_k_idx], op, kpts.Dmats[iop]). This applies the point-group operation and any associated unitary transformation stored in Dmats for that operation to obtain the density matrix at the target BZ k-point.
        - If the time_reversal_symm_bz flag for the BZ k-point is True, the transformed matrix is complex-conjugated to enforce time-reversal symmetry for that k-point.
        - For a UHF dm_ibz (spin-polarized), the function processes each spin block separately and returns an array with shape (2, nkpts, nao, nao). For RHF input it returns an array with shape (nkpts, nao, nao).
        - If the input dm_ibz object has attributes mo_coeff and mo_occ, these are transformed by calling kpts.transform_mo_coeff(dm_ibz.mo_coeff) and kpts.transform_mo_occ(dm_ibz.mo_occ) before the density-matrix expansion. The transformed mo_coeff and mo_occ are attached to the returned array via lib.tag_array so they can be retrieved as .mo_coeff and .mo_occ attributes on the returned object.
        - No in-place modification of the input dm_ibz is performed by this function; a new array (or tagged array) is returned.
    
    Failure modes:
        - Raises KeyError if the first dimension of dm_ibz does not match kpts.nkpts_ibz for RHF input, or if len(dm_ibz[0]) does not match kpts.nkpts_ibz for UHF input. The error message indicates the mismatch, e.g. 'Shape of the input density matrix does not match the number of IBZ k-points: {len(dm_ibz)} vs {kpts.nkpts_ibz}.' or the analogous message for the UHF case.
        - The function expects that the provided KPoints object exposes the attributes and methods documented above; AttributeError or other exceptions may occur if kpts is not a correctly constructed KPoints object from PySCF's pbc.kpts utilities.
        - The transformation symm.transform_dm may raise errors for invalid symmetry operations or incompatible matrix dimensions; such errors propagate out of this function.
    
    Returns:
        ndarray or tagged ndarray: Density matrices for k-points in the full BZ with shape ([2,] nkpts, nao, nao). For RHF input, the return value is an ndarray of shape (nkpts, nao, nao). For UHF input, the return is an ndarray with a leading spin index and shape (2, nkpts, nao, nao). If the input dm_ibz had attributes mo_coeff and mo_occ, the returned array is tagged with transformed mo_coeff and mo_occ as .mo_coeff and .mo_occ respectively (using lib.tag_array) so downstream code can access the corresponding molecular orbital coefficients and occupations expanded to the full BZ. The returned matrices are ready for use in subsequent PySCF pbc workflows that require explicit matrices at every BZ k-point (e.g., BZ-summed properties, k-dependent integrals, or visualization across the full Brillouin zone).
    """
    from pyscf.pbc.lib.kpts import transform_dm
    return transform_dm(kpts, dm_ibz)


################################################################################
# Source: pyscf.pbc.lib.kpts_helper.unique
# File: pyscf/pbc/lib/kpts_helper.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_lib_kpts_helper_unique(kpts: numpy.ndarray):
    """pyscf.pbc.lib.kpts_helper.unique finds and returns the unique k-points from a list of k-point vectors used in periodic-boundary-condition (PBC) electronic-structure calculations. It is used in PySCF PBC workflows to identify redundant sampling points in the Brillouin zone (for example, when reducing k-point grids by symmetry or eliminating duplicate k-points produced by mesh generation). The function identifies unique rows of the input array within a numerical tolerance controlled by the global KPT_DIFF_TOL: when modern numpy is available it rounds coordinates to a precision derived from KPT_DIFF_TOL and uses numpy.unique on rows; for older numpy it compares rows by absolute difference with KPT_DIFF_TOL.
    
    Args:
        kpts (numpy.ndarray): A numeric array with one k-point per row (a 2-D array of shape (nkpts, ndim) where each row is a k-point vector in reciprocal-space coordinates). The function will call np.asarray(kpts) internally, so inputs convertible to numpy.ndarray are accepted. The elements are interpreted as floating-point coordinates of k-points and are compared using the global tolerance KPT_DIFF_TOL to determine equality.
    
    Returns:
        tuple: A 3-tuple of numpy.ndarray objects:
            unique_kpts (numpy.ndarray): The unique k-point vectors determined from the input. When numpy.unique with axis=0 is available, these are the rows of the input corresponding to unique values after rounding to a precision computed as int(-np.log10(KPT_DIFF_TOL)); the returned array is ordered by the first occurrence of each unique k-point in the input (i.e., unique_kpts[i] equals kpts[uniq_index[i]]). When an older numpy without axis=0 support is used, the same result is produced by explicit tolerance-based pairwise comparisons.
            uniq_index (numpy.ndarray): Integer indices into the original input array kpts that give the positions of the returned unique_kpts. This array has length equal to the number of unique k-points and is sorted in ascending order of the original input positions (so kpts[uniq_index] == unique_kpts).
            uniq_inverse (numpy.ndarray): Integer mapping array of length nkpts (same length as the input kpts). For each input row j, uniq_inverse[j] is the index i such that unique_kpts[i] == kpts[j] within the numerical tolerance. This array can be used to reconstruct arrays aligned with the input kpts from arrays aligned with unique_kpts.
    
    Behavior and side effects:
        The function does not modify the input array kpts; it converts the input to a numpy.ndarray via np.asarray. The algorithm attempts to use numpy.unique with axis=0 (modern numpy), rounding input coordinates to a number of decimal digits determined from KPT_DIFF_TOL to group numerically equivalent k-points. If numpy.unique on 2-D arrays is unavailable (old numpy), the function falls back to an explicit O(nkpts^2) comparison using absolute differences and the same KPT_DIFF_TOL tolerance. The returned arrays are newly created numpy.ndarray objects derived from the input; no in-place modification of caller data occurs.
    
    Defaults and numerical tolerance:
        Equality of k-points is determined by the global constant KPT_DIFF_TOL. In the modern-numpy path, the code uses digits = int(-np.log10(KPT_DIFF_TOL)) to round coordinates before calling numpy.unique; in the fallback path the code uses absolute difference comparison abs(kpt - kpts).sum(axis=1) < KPT_DIFF_TOL. Therefore KPT_DIFF_TOL should be a small positive scalar; inappropriate values (zero, negative, or non-numeric) can lead to ValueError, TypeError, or incorrect grouping.
    
    Failure modes and errors:
        If kpts cannot be converted to a numeric numpy.ndarray, np.asarray will raise an appropriate exception (TypeError or ValueError). If the global KPT_DIFF_TOL is not a positive scalar, computing int(-np.log10(KPT_DIFF_TOL)) may raise a ValueError or produce an unexpected rounding precision. Very large nkpts values may make the fallback O(nkpts^2) comparison slow or memory intensive. The function relies on numpy behavior: any exceptions raised by numpy.unique or arithmetic operations will propagate to the caller.
    
    Practical significance in PySCF:
        This helper is intended for PBC electronic-structure modules in PySCF to eliminate duplicate k-points before performing per-k-point computations (e.g., building k-dependent Hamiltonians, integrating over the Brillouin zone), reducing computational cost and ensuring consistent ordering for downstream arrays that index by unique k-points.
    """
    from pyscf.pbc.lib.kpts_helper import unique
    return unique(kpts)


################################################################################
# Source: pyscf.pbc.lib.kpts.transform_mo_coeff_k
# File: pyscf/pbc/lib/kpts.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_lib_kpts_transform_mo_coeff_k(kpts: int, mo_coeff_ibz: numpy.ndarray, k: int):
    """Get MO coefficients for a single k-point in the full Brillouin zone (BZ).
    
    This function is used in the PySCF periodic-boundary-conditions (pbc) k-point handling code to produce molecular-orbital (MO) coefficient matrices for a specified k-point index in the full BZ by mapping from MO coefficients provided for k-points in the irreducible Brillouin zone (IBZ). It examines the k-point bookkeeping stored in the provided KPoints object (mapping from full BZ to IBZ, symmetry operations, and time-reversal flags), applies the appropriate spatial symmetry operation using pyscf.pbc.lib.symm.transform_mo_coeff when required, and applies complex conjugation if the k-point is related to its IBZ representative by time-reversal symmetry. The returned array is suitable for subsequent band-structure, density, or post-HF/post-DFT operations that expect MO coefficients defined on the full BZ.
    
    Args:
        kpts (KPoints): KPoints object that encodes k-point metadata and symmetry information used by the transformation. This object must provide at least the attributes bz2ibz, kpts_scaled_ibz, stars_ops_bz, ops, time_reversal_symm_bz, cell, and Dmats. bz2ibz is used to find the index of the IBZ representative for the requested full-BZ k-point. kpts_scaled_ibz supplies the scaled coordinates of IBZ k-points required by the symmetry transformer. stars_ops_bz and ops select the symmetry operation (op) to apply; Dmats provides the corresponding representation matrices for the operation. The practical significance is that kpts determines how MO coefficients defined only on the IBZ are mapped into the full BZ consistent with the crystal symmetry and time-reversal conventions used throughout PySCF pbc calculations.
    
        mo_coeff_ibz (numpy.ndarray): Array of MO coefficients defined on IBZ k-points with shape (nkpts_ibz, nao, nmo), where nkpts_ibz is the number of IBZ k-points, nao is the number of atomic orbitals, and nmo is the number of molecular orbitals (bands). Each slice mo_coeff_ibz[ibz_index] contains the MO coefficient matrix for an IBZ k-point. The function does not modify mo_coeff_ibz in-place, but when no spatial symmetry operation is needed for the target k-point (op.is_eye is True), the returned array may be a view referencing the corresponding slice of mo_coeff_ibz; modifying the returned array in that case can modify the original mo_coeff_ibz data.
    
        k (int): Integer index of the desired k-point in the full Brillouin zone. This index is used to look up the IBZ representative and the symmetry/time-reversal operations that map that representative to the full-BZ k-point. The index must be a valid index into kpts’ full-BZ indexing arrays (i.e., in range and consistent with kpts.bz2ibz and kpts.stars_ops_bz).
    
    Returns:
        numpy.ndarray: MO coefficient matrix for the specified k-point in the full Brillouin zone with shape (nao, nmo). If the symmetry operation for the full-BZ k-point is the identity, this may be the same array (a view) as the corresponding slice of mo_coeff_ibz; otherwise it is a new array returned by pyscf.pbc.lib.symm.transform_mo_coeff. If the k-point is flagged as related to its IBZ representative by time-reversal symmetry, the returned matrix is the complex conjugate of the (possibly transformed) IBZ coefficients.
    
    Raises/Failure modes:
        IndexError: If k is outside the valid range for the full-BZ k-point index arrays or if the derived IBZ index is invalid for mo_coeff_ibz.
        AttributeError: If kpts does not expose required attributes (bz2ibz, kpts_scaled_ibz, stars_ops_bz, ops, time_reversal_symm_bz, cell, Dmats).
        TypeError: If mo_coeff_ibz is not a numpy.ndarray or has incompatible dimensions (it must be indexable as mo_coeff_ibz[ibz_index] into a (nao, nmo) array).
        ValueError: If the shapes of the arrays (for example, mo_coeff_ibz[ibz_index]) do not match the expectations of the symmetry transformer called internally (pyscf.pbc.lib.symm.transform_mo_coeff).
    
    Behavior and side effects:
        The function performs deterministic, pure-data transformations based on kpts metadata and does not change kpts. It only reads kpts attributes and mo_coeff_ibz. When op.is_eye is True (the symmetry operation is the identity), the function assigns the IBZ slice directly to the return variable and may return a view into mo_coeff_ibz; callers that need an independent copy should explicitly copy() the result. When a nontrivial symmetry operation is required, the function calls pyscf.pbc.lib.symm.transform_mo_coeff(kpts.cell, ibz_k_scaled, mo_ibz, op, kpts.Dmats[iop]) to obtain a new array. If the k-point is related by time-reversal symmetry, the function applies complex conjugation to the (possibly transformed) coefficients before returning them. The function is intended to be used when assembling full-BZ MO coefficient sets from IBZ-only calculations so that subsequent electronic-structure routines see MO coefficients defined consistently across the entire Brillouin zone.
    """
    from pyscf.pbc.lib.kpts import transform_mo_coeff_k
    return transform_mo_coeff_k(kpts, mo_coeff_ibz, k)


################################################################################
# Source: pyscf.pbc.scf.khf.get_grad
# File: pyscf/pbc/scf/khf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_scf_khf_get_grad(mo_coeff_kpts: list, mo_occ_kpts: list, fock: list):
    """Compute and return the concatenated one-dimensional orbital gradient for K-point Hartree–Fock (khf) calculations in the PySCF periodic-boundary-condition (pbc) framework. This function is used in periodic electronic-structure workflows to obtain the orbital-gradient vector needed for orbital optimization or response procedures; it delegates the per-k-point gradient computation to the molecular (non K-point) gradient routine (mol_hf.get_grad) and then concatenates the per-k-point gradients into a single 1D array so downstream optimizers or property evaluators can operate on a unified gradient vector.
    
    Args:
        mo_coeff_kpts (list): A list with one entry per k-point containing the molecular-orbital coefficients for that k-point. Each entry is passed as-is to the underlying per-k-point gradient routine (mol_hf.get_grad). The list length defines the expected number of k-points; mo_coeff_kpts must therefore have the same number of elements as mo_occ_kpts and fock.
        mo_occ_kpts (list): A list with one entry per k-point containing the orbital occupation information for that k-point. Each entry is passed as-is to mol_hf.get_grad. The ordering and contents determine which orbitals are treated as occupied or virtual for each k-point when computing gradients.
        fock (list): A list with one entry per k-point containing the Fock matrix (or an object accepted by mol_hf.get_grad) for that k-point. Each fock[k] is used along with mo_coeff_kpts[k] and mo_occ_kpts[k] to compute the per-k-point gradient.
    
    Returns:
        numpy.ndarray: A one-dimensional NumPy array containing the orbital gradient values concatenated across k-points. The per-k-point gradients are computed in sequence for k = 0..nkpts-1 and then horizontally stacked (np.hstack) so that occupied and virtual index blocks from different k-points appear as sequential patches in the returned 1D vector. This layout matches the non-K-point (molecular) gradient convention but extended by concatenation over k-points, enabling existing optimizers that expect a 1D gradient to be reused for K-point calculations.
    
    Behavior, side effects, defaults, and failure modes:
        The function determines the number of k-points as nkpts = len(mo_occ_kpts) and iterates k from 0 to nkpts-1. For each k, it calls mol_hf.get_grad(mo_coeff_kpts[k], mo_occ_kpts[k], fock[k]) to obtain a per-k-point gradient and then concatenates these with numpy.hstack to form the final 1D array. There are no external side effects (no global state modification); the function returns the concatenated gradient. The caller is responsible for supplying mo_coeff_kpts, mo_occ_kpts, and fock as lists with matching lengths and with elements compatible with mol_hf.get_grad; otherwise, the function may raise IndexError (if list lengths differ) or propagate exceptions raised by mol_hf.get_grad (for example, due to incompatible array shapes or types). The ordering of entries in the returned array is critical for downstream routines: occupied and virtual orbital index blocks are grouped per k-point in the same sequence as the input lists.
    """
    from pyscf.pbc.scf.khf import get_grad
    return get_grad(mo_coeff_kpts, mo_occ_kpts, fock)


################################################################################
# Source: pyscf.pbc.lib.kpts.transform_mo_coeff
# File: pyscf/pbc/lib/kpts.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_lib_kpts_transform_mo_coeff(kpts: int, mo_coeff_ibz: numpy.ndarray):
    """pyscf.pbc.lib.kpts.transform_mo_coeff transforms molecular-orbital (MO) coefficient arrays defined for k-points in the irreducible Brillouin zone (IBZ) into MO coefficient arrays defined for the full Brillouin zone (BZ). This function is used in periodic-boundary-condition (PBC) electronic-structure workflows in PySCF to expand IBZ results (which exploit crystal symmetries to reduce computational effort) back to the full set of k-points needed for band-structure analysis, density reconstruction, and other post-processing that requires coefficients on every BZ k-point.
    
    Args:
        kpts (KPoints object): A KPoints object describing the k-point sampling, symmetry mappings, and related precomputed arrays for the periodic cell. In practical use within PySCF, this object provides the mapping from full BZ k-points to IBZ indices (kpts.bz2ibz), the scaled IBZ k-point coordinates (kpts.kpts_scaled_ibz), the star operation indices mapping IBZ to BZ (kpts.stars_ops_bz), the symmetry operations themselves (kpts.ops), precomputed density-matrix rotation matrices for those operations (kpts.Dmats), boolean flags for time-reversal symmetry per BZ k-point (kpts.time_reversal_symm_bz), and the counts kpts.nkpts and kpts.nkpts_ibz. The function uses these attributes to determine, for each full-BZ k-point, which IBZ k-point supplies the MO coefficients and which symmetry operation (including whether to apply a unitary transformation and/or complex conjugation) must be applied to recover the full-BZ coefficients. If the KPoints object does not expose the expected attributes or contains inconsistent counts, the function will raise an error (see Failure modes below).
    
        mo_coeff_ibz (numpy.ndarray): MO coefficient arrays for k-points in the IBZ. The documented shape is ([2,] nkpts_ibz, nao, nmo) where nkpts_ibz is the number of IBZ k-points, nao is the number of atomic orbitals, and nmo is the number of molecular orbitals. The optional leading dimension of size 2 indicates a spin-unrestricted (KUHF) representation: in that case mo_coeff_ibz[0] and mo_coeff_ibz[1] hold the alpha and beta spin-channel coefficient arrays respectively, each with shape (nkpts_ibz, nao, nmo). For spin-restricted inputs the array has shape (nkpts_ibz, nao, nmo). In the KUHF case the function detects the spin structure by checking that mo_coeff_ibz[0][0] is a 2D ndarray (ndim == 2) and processes alpha and beta channels separately. The entries are complex or real-valued coefficient matrices as produced by PySCF mean-field calculations on periodic systems.
    
    Behavior and practical significance:
        - For each full-BZ k-point index k in range(kpts.nkpts), the function finds the corresponding IBZ k-point via kpts.bz2ibz[k].
        - If the symmetry operation mapping that IBZ k-point to the BZ k-point is the identity (op.is_eye), the IBZ coefficients are reused directly.
        - Otherwise the function calls symm.transform_mo_coeff(kpts.cell, ibz_k_scaled, mo_ibz, op, kpts.Dmats[iop]) to apply the appropriate unitary transformation determined by the space-group symmetry operation op and the precomputed Dmats[iop]. This step rotates and phases the basis representation so that the coefficients are valid at the mapped BZ k-point.
        - If time_reversal_symm_bz[k] is True for the BZ k-point, the transformed MO coefficients are complex-conjugated to account for time-reversal symmetry.
        - For KUHF (spin-unrestricted) inputs, the function applies the above process independently to the alpha and beta spin-channel coefficient arrays and returns both spin channels expanded to the full BZ.
        - The function does not modify its inputs in-place; it constructs and returns new per-k-point coefficient arrays (though these may share memory depending on numpy internals).
    
    Failure modes and exceptions:
        - Raises KeyError if the provided mo_coeff_ibz does not match the expected number of IBZ k-points indicated by kpts.nkpts_ibz. For spin-restricted input this check is kpts.nkpts_ibz != len(mo_coeff_ibz). For the KUHF branch the check is kpts.nkpts_ibz != len(mo_coeff_ibz[0]). When this mismatch occurs the function raises KeyError with a message indicating the observed length versus kpts.nkpts_ibz.
        - Raises errors propagated from symm.transform_mo_coeff if the symmetry operation, cell, or coefficient array shapes are inconsistent with that routine's requirements.
        - If the kpts object is missing attributes referenced above (e.g., bz2ibz, ops, Dmats, stars_ops_bz, time_reversal_symm_bz, nkpts, nkpts_ibz), AttributeError or other exceptions may be raised.
    
    Returns:
        numpy.ndarray: MO coefficients for k-points in the full Brillouin zone with documented shape ([2,] nkpts, nao, nmo). The leading dimension of size 2 is present for spin-unrestricted (KUHF) usage and holds the alpha and beta spin-channel coefficient arrays respectively; otherwise the returned array has shape (nkpts, nao, nmo). Each returned per-k-point coefficient matrix is the IBZ coefficient transformed by the appropriate space-group operation and complex-conjugated if the target BZ k-point requires time-reversal. The returned coefficients are suitable for constructing band-structure data, k-point dependent densities, and any downstream routines in PySCF that expect MO coefficients defined on the full BZ.
    """
    from pyscf.pbc.lib.kpts import transform_mo_coeff
    return transform_mo_coeff(kpts, mo_coeff_ibz)


################################################################################
# Source: pyscf.pbc.scf.khf.make_rdm1
# File: pyscf/pbc/scf/khf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_scf_khf_make_rdm1(mo_coeff_kpts: list, mo_occ_kpts: list, **kwargs):
    """One-particle density matrices for all k-points in a periodic Hartree–Fock (k-point HF) calculation.
    
    This function constructs the atomic-orbital (AO) representation of the one-particle reduced density matrix (RDM-1) for each k-point by calling the molecular HF helper mol_hf.make_rdm1 for every k-point. In the context of PySCF's periodic electronic-structure calculations (pbc.scf.khf), these per-k-point density matrices are the fundamental objects used to evaluate electron density, expectation values of one-electron operators, and contributions to the Fock matrix across the Brillouin zone. The returned array is tagged with the input molecular-orbital coefficients and occupations so downstream routines can access that metadata without separate bookkeeping.
    
    Args:
        mo_coeff_kpts (list): A sequence (one element per k-point) of molecular-orbital coefficient arrays in the AO basis. Each element is the set of MO coefficients produced for that k-point by the mean-field solver; they determine the linear combination of atomic orbitals that define occupied and virtual orbitals. Practically, mo_coeff_kpts supplies the orbital shapes used to form the AO-space density at each k-point.
        mo_occ_kpts (list): A sequence (one element per k-point) of occupation arrays corresponding to mo_coeff_kpts. Each element indicates orbital occupancies (e.g., 0, 1, 2 or fractional occupations for metals/finite-temperature treatments) for the MOs at that k-point. mo_occ_kpts defines which orbitals contribute to the RDM-1 at each k-point and therefore controls the resulting electron count and density distribution.
        kwargs (dict): Additional keyword arguments collected by the caller. This implementation does not consume or forward these keywords; they are accepted for API compatibility but are ignored by this function. Callers should not expect any side effects from providing kwargs. If future versions use specific keywords, relying on passing kwargs here for behavior changes is unsupported in this version.
    
    Returns:
        ndarray: dm_kpts, an array of shape (nkpts, nao, nao) containing the one-particle density matrices in the AO basis for each k-point. nkpts equals len(mo_occ_kpts) (and is expected to equal len(mo_coeff_kpts)); nao denotes the number of atomic orbitals for the underlying periodic cell. Each slice dm_kpts[k] is the RDM-1 for k-point k computed by mol_hf.make_rdm1 from mo_coeff_kpts[k] and mo_occ_kpts[k]. The returned array is produced via lib.tag_array and is tagged with attributes 'mo_coeff' and 'mo_occ' that reference the provided mo_coeff_kpts and mo_occ_kpts respectively, enabling downstream code to access the originating orbital coefficients and occupations without separate storage.
    
    Behavior and failure modes:
        The function iterates over k from 0 to nkpts-1 and calls mol_hf.make_rdm1(mo_coeff_kpts[k], mo_occ_kpts[k]) for each k to build the list of per-k density matrices. If len(mo_coeff_kpts) != len(mo_occ_kpts), the function will raise an indexing error or produce inconsistent results; callers must provide matching sequences of the same length (nkpts). If individual elements of mo_coeff_kpts or mo_occ_kpts do not have the shapes expected by mol_hf.make_rdm1, that helper may raise TypeError or ValueError. The function does not modify the input mo_coeff_kpts or mo_occ_kpts objects; it constructs new density-matrix arrays and returns them. kwargs are ignored in this implementation and have no effect.
    """
    from pyscf.pbc.scf.khf import make_rdm1
    return make_rdm1(mo_coeff_kpts, mo_occ_kpts, **kwargs)


################################################################################
# Source: pyscf.pbc.scf.krohf.get_roothaan_fock
# File: pyscf/pbc/scf/krohf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_scf_krohf_get_roothaan_fock(focka_fockb: tuple, dma_dmb: tuple, s: list):
    """Compute the Roothaan effective Fock matrices for restricted open-shell Hartree–Fock (KROHF) in periodic boundary conditions (PBC) using per-k-point Fock and density matrices.
    
    This function implements the Roothaan prescription used in pyscf.pbc.scf.krohf to build an effective, Hermitian Fock operator from separate alpha (Fa) and beta (Fb) Fock matrices and the corresponding alpha (dma) and beta (dmb) one-particle density matrices for each k-point. The Roothaan effective Fock mixes Fa and Fb according to orbital occupation spaces: closed-shell orbitals use Fc = (Fa + Fb)/2, open-shell orbitals couple Fa and Fb through cross terms, and virtual orbitals use Fc again. Concretely, for each k-point the function forms three projectors on closed, open, and virtual subspaces using the input density matrices and the overlap matrix s[k]:
    pc = dmb[k] @ s[k]  (closed-space projector),
    po = (dma[k] - dmb[k]) @ s[k]  (open-space projector),
    pv = I - dma[k] @ s[k]  (virtual-space projector),
    where I is the nao-by-nao identity and nao is the number of atomic orbitals inferred from s[0]. The effective Fock for each k-point is assembled from projected contributions of Fc and cross terms with Fa and Fb, and then Hermitianized by adding its conjugate transpose. The function returns one effective Fock matrix per k-point and tags the returned array with the original focka and fockb inputs (via lib.tag_array) so downstream code in the KROHF driver can access the source spin components.
    
    Behavior and side effects:
    - The number of k-points is determined as nkpts = len(s). The function expects focka_fockb and dma_dmb to contain per-k-point entries with the same nkpts; mismatched lengths or nonconformant matrix shapes will cause NumPy errors (IndexError, ValueError, or TypeError) during matrix operations.
    - Inputs are not modified in-place by this function; the result is a new array produced by np.asarray and wrapped with lib.tag_array, which attaches attributes .focka and .fockb referencing the input spin Fock sequences.
    - The function assumes each overlap matrix s[k] and each density/Fock matrix is a square matrix with the same dimension nao (nao = s[0].shape[0]); if s[0] is not square or the matrices do not conform, NumPy will raise an exception during the dot products.
    - The output matrices are Hermitian within numerical precision because the function explicitly adds the conjugate transpose of each assembled matrix.
    - No implicit units or scaling are applied; matrices are used as provided by the calling KROHF code. The function is intended to be called from the periodic KROHF SCF driver in PySCF and follows the Roothaan effective-Fock conventions used there.
    
    Args:
        focka_fockb (tuple): A tuple (focka, fockb) where focka and fockb are sequences (indexed by k-point) of Fock matrices for the alpha and beta spins, respectively. Each element should be a square matrix-like object (for example, a numpy.ndarray) compatible with matrix multiplication with the corresponding overlap matrix s[k]. These inputs represent the spin-resolved Fock operators produced by the PBC KROHF procedure and are used to build the mixed Roothaan Fock.
        dma_dmb (tuple): A tuple (dma, dmb) where dma and dmb are sequences (indexed by k-point) of one-particle density matrices for the alpha and beta spins, respectively. Each density matrix must be conformable for multiplication with s[k] and with the corresponding Fock matrices; they are used to construct closed, open, and virtual-space projectors (pc, po, pv) for each k-point.
        s (list): A sequence of overlap matrices s[k] (one per k-point). The length of s determines the number of k-points (nkpts = len(s)) and each s[k] must be a square matrix with dimension equal to the number of atomic orbitals (nao). The overlap matrices are used to form the projectors and to ensure the effective Fock is constructed in the AO representation consistent with the input densities and Fock matrices.
    
    Returns:
        numpy.ndarray: An array of effective Roothaan Fock matrices with one entry per k-point (shape (nkpts, nao, nao) in typical usage). The returned array is produced by np.asarray and wrapped with lib.tag_array; the wrapper tags the array with attributes focka and fockb that reference the original input sequences focka and fockb. Each per-k-point matrix is Hermitianized (the function adds its conjugate transpose) and is suitable for use by the PBC KROHF SCF driver as the effective single-particle operator in subsequent diagonalization or response steps.
    """
    from pyscf.pbc.scf.krohf import get_roothaan_fock
    return get_roothaan_fock(focka_fockb, dma_dmb, s)


################################################################################
# Source: pyscf.pbc.symm.space_group.transform_trans
# File: pyscf/pbc/symm/space_group.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_symm_space_group_transform_trans(
    op: numpy.ndarray,
    a: numpy.ndarray,
    b: numpy.ndarray
):
    """pyscf.pbc.symm.space_group.transform_trans transforms a translation operator given in one lattice-basis representation into the equivalent translation operator expressed in another lattice-basis representation used in periodic boundary-condition symmetry operations in PySCF.
    
    Args:
        op (numpy.ndarray): Translation operator components in the source basis system :math:`\\mathbf{a}`. Must be a one-dimensional array of length 3 (shape (3,)). In the PySCF PBC/space-group context, op contains the fractional or basis-coordinate components of a translation vector expressed with respect to the row-major basis vectors supplied in `a`. This function treats `op` as a row vector and returns a new array with components in the target basis `b`.
        a (numpy.ndarray): Basis vectors of the source basis system :math:`\\mathbf{a}` (row-major). Must be a 3x3 array (shape (3,3)). Each row is a basis vector of the :math:`\\mathbf{a}` system expressed in a common Cartesian coordinate frame. In practice, `a` represents the lattice or unit-cell basis convention from which `op` is specified.
        b (numpy.ndarray): Basis vectors of the target basis system :math:`\\mathbf{b}` (row-major). Must be a 3x3 array (shape (3,3)). Each row is a basis vector of the :math:`\\mathbf{b}` system expressed in the same Cartesian frame as `a`. In PySCF workflows this allows converting translation operators between different unit-cell conventions or coordinate representations.
    
    Returns:
        numpy.ndarray: A one-dimensional array of shape (3,) containing the translation operator components expressed in the target basis `b`. The transformation performed is equivalent to computing the matrix P = (b.T)^{-1} @ a.T and returning op @ P.T (the implementation uses NumPy: P = np.dot(np.linalg.inv(b.T), a.T; return np.dot(op, P.T)). The returned array is a new object; the inputs are not modified.
    
    Behavior and practical notes:
        - The function assumes `a` and `b` provide row-major basis vectors expressed in the same Cartesian coordinate frame; consistent Cartesian representation is required for the transformation to be physically meaningful in PySCF PBC/space-group operations.
        - This routine is used in PySCF to convert translation operators (e.g., fractional translations, symmetry translations) when comparing or composing symmetry operations defined in different lattice-basis conventions.
        - There are no side effects; the function returns a new numpy.ndarray and does not modify `op`, `a`, or `b`.
    
    Failure modes and errors:
        - If `b.T` is singular (non-invertible), np.linalg.inv will raise a numpy.linalg.LinAlgError. This occurs when the rows of `b` (or columns of `b.T`) are linearly dependent and `b` does not define a valid 3D basis.
        - If the inputs do not have the required shapes (op not shape (3,), or a/b not shape (3,3)), NumPy will raise a ValueError during the matrix operations.
        - If inputs are not numpy.ndarray instances or contain incompatible dtypes, NumPy may raise TypeError or promote types according to NumPy casting rules.
    """
    from pyscf.pbc.symm.space_group import transform_trans
    return transform_trans(op, a, b)


################################################################################
# Source: pyscf.pbc.symm.symmetry.get_Dmat
# File: pyscf/pbc/symm/symmetry.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_symm_symmetry_get_Dmat(op: numpy.ndarray, l: int):
    """pyscf.pbc.symm.symmetry.get_Dmat computes the Wigner D-matrix for a given 3×3 rotation operator and an angular momentum quantum number l. This D-matrix is the matrix representation of the rotation in the angular-momentum-l irreducible representation and is used in PySCF periodic-boundary-condition (PBC) symmetry routines to construct symmetry-adapted representations of rotational operations in electronic structure calculations.
    
    Args:
        op ((3,3) ndarray): rotation operator in (x,y,z) system. This parameter must be a 3-by-3 NumPy ndarray representing a Cartesian rotation (or improper rotation) applied to Cartesian basis vectors. The function computes the determinant of op to detect improper rotations; if det(op) < 0 the code treats op as an improper rotation, multiplies op by -1 for Euler-angle extraction, and multiplies the resulting D-matrix by (-1)**l. If op does not have shape (3,3) or is not numeric, subsequent numerical operations (determinant, dot product, Euler-angle extraction) will raise NumPy or shape-related exceptions.
        l (int): angular momentum. Integer angular-momentum quantum number used to choose the degree of the Wigner D-matrix (the angular-momentum representation). This value is passed to the underlying Dmatrix routine that builds the representation for angular momentum l; it is expected to be an integer consistent with the domain of the Dmatrix implementation.
    
    Returns:
        ndarray: Wigner D-matrix corresponding to the rotation operator op in the angular-momentum-l representation. The return value is a NumPy ndarray produced by calling the internal Dmatrix routine with Euler angles obtained from op and the repository constant XYZ. For improper rotations (det(op) < 0 and numerically close to -1 within a tolerance of 1e-9), the function applies the phase factor (-1)**l to the D-matrix. The entries of the returned ndarray are rounded to 15 decimal places before being returned. Failure modes: if det(op) < 0 but not within the numeric tolerance of -1 the function raises an AssertionError; if op has incompatible shape or non-numeric entries, NumPy shape or type errors will be raised by the determinant/dot operations or by the Euler-angle extraction routine. The function has no external side effects (it does not modify global state), but it does internally replace op with -op when handling improper rotations.
    """
    from pyscf.pbc.symm.symmetry import get_Dmat
    return get_Dmat(op, l)


################################################################################
# Source: pyscf.pbc.scf.kuhf.make_rdm1
# File: pyscf/pbc/scf/kuhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_scf_kuhf_make_rdm1(mo_coeff_kpts: list, mo_occ_kpts: list, **kwargs):
    """Alpha and beta spin one-particle reduced density matrices (RDM1) for all k-points in a periodic unrestricted Kohn–Sham / Hartree–Fock calculation. This function is used in the pyscf.pbc.scf.kuhf module to construct the spin-resolved RDM1 in the atomic-orbital (AO) basis from molecular-orbital (MO) coefficients and MO occupation numbers for each k-point. The returned array is tagged with the input MO coefficients and occupations for downstream use in PySCF routines that expect these metadata (for example, computing electron density or expectation values over k-points).
    
    Args:
        mo_coeff_kpts (list): A length-2 list holding MO coefficient sequences for each spin. Each element mo_coeff_kpts[spin] is itself an indexable sequence of length nkpts, where mo_coeff_kpts[spin][k] is the MO-coefficient array for k-point k and spin (0 for alpha, 1 for beta). Each MO-coefficient array must have shape (nao, nmo), where nao is the number of atomic orbitals and nmo is the number of molecular orbitals. The arrays are used as-is and must support matrix multiplication and conjugate transpose (the implementation calls .T.conj() and np.dot).
        mo_occ_kpts (list): A length-2 list holding MO occupation sequences for each spin. Each element mo_occ_kpts[spin] is an indexable sequence of length nkpts, where mo_occ_kpts[spin][k] is a 1-D array or sequence of length nmo giving occupation numbers (floats) of the MOs at k-point k for that spin. Occupation entries are multiplied elementwise with the corresponding columns of mo_coeff_kpts to build the RDM; typical values are in the range [0,2] for electrons per orbital but the function does not enforce specific bounds.
        kwargs (dict): Additional keyword arguments. This function does not consume or propagate any kwargs; they are accepted for API compatibility but ignored. No side effects arise from kwargs. Supplying unexpected keys in kwargs does not change the outcome and will not be stored on the returned object.
    
    Behavior and practical details:
        The function computes, for each spin s ∈ {alpha, beta} and each k-point index k ∈ [0, nkpts-1], the AO-basis one-particle density matrix
            D_s(k) = C_s(k) · diag(occ_s(k)) · C_s(k)†,
        where C_s(k) = mo_coeff_kpts[s][k] (shape (nao, nmo)), occ_s(k) = mo_occ_kpts[s][k] (length nmo), diag(occ) denotes elementwise multiplication applied to columns of C, and † denotes conjugate transpose (.T.conj()). The implementation forms the list of per-k-point density matrices for alpha and beta spins, concatenates them, reshapes to an array of shape (2, nkpts, nao, nao), and returns a tagged array.
        The returned array elements are in the AO basis; diagonal elements summed over k and spin yield the electron density in AO indices appropriate for periodic calculations. This RDM1 is used throughout PySCF to compute expectation values, densities, and to interface with post-SCF methods that require spin- and k-resolved one-electron density matrices.
    
    Defaults and side effects:
        No in-place modification of the input lists is performed. The function returns a lib.tag_array (an ndarray-like object used in PySCF) whose data buffer holds the RDM1 and which has attributes mo_coeff and mo_occ tagging the returned object with the original mo_coeff_kpts and mo_occ_kpts inputs. kwargs are ignored and do not affect the return value or tags.
    
    Failure modes and validation:
        The function assumes mo_coeff_kpts and mo_occ_kpts are both length-2 sequences (alpha and beta). It determines nkpts from len(mo_occ_kpts[0]) and expects mo_occ_kpts[1] to have the same length; if these lengths differ, indexing or shape errors (IndexError or ValueError) will be raised by the code. Each mo_coeff_kpts[spin][k] must expose a .shape attribute of form (nao, nmo) and mo_occ_kpts[spin][k] must be broadcast-compatible to multiply the columns of the corresponding MO coefficient array (typically a 1-D sequence of length nmo). Mismatched nmo, nao, or incompatible shapes between corresponding entries will raise numpy broadcasting/linear-algebra errors (ValueError or IndexError). If mo_occ_kpts[0] is empty, nkpts cannot be inferred and subsequent operations will fail with IndexError.
    
    Returns:
        numpy.ndarray: A lib.tag_array (ndarray-like) with shape (2, nkpts, nao, nao). The first axis indexes spin (0 = alpha, 1 = beta), the second indexes k-points, and the last two axes are AO-basis matrix indices. The returned object is tagged with attributes mo_coeff (set to the input mo_coeff_kpts) and mo_occ (set to the input mo_occ_kpts). The array elements are complex-valued if the input MO coefficients are complex; otherwise they are real. The function does not return None; all results and metadata are delivered via the returned tagged array.
    """
    from pyscf.pbc.scf.kuhf import make_rdm1
    return make_rdm1(mo_coeff_kpts, mo_occ_kpts, **kwargs)


################################################################################
# Source: pyscf.pbc.symm.space_group.transform_rot
# File: pyscf/pbc/symm/space_group.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_symm_space_group_transform_rot(
    op: numpy.ndarray,
    a: numpy.ndarray,
    b: numpy.ndarray,
    allow_non_integer: bool = False
):
    """pyscf.pbc.symm.space_group.transform_rot transforms a 3x3 rotation operator expressed in one lattice basis (a) into the equivalent rotation operator expressed in another lattice basis (b). This function is used inside the PySCF periodic-boundary-condition (pbc) symmetry utilities to convert point-group rotation operators when changing crystallographic coordinate systems or lattice basis representations, ensuring consistency of space-group symmetry operations across different basis choices.
    
    Args:
        op (numpy.ndarray): A (3,3) array containing the rotation operator expressed in the source basis system a. In the PySCF PBC symmetry context, op represents a point-group rotation matrix (operator) that acts on Cartesian coordinates expressed relative to the basis vectors given by a. The function treats op as a linear operator to be similarity-transformed into the target basis b.
        a (numpy.ndarray): A (3,3) array of basis vectors for the source basis system a, provided in row-major order. Each row is one lattice/basis vector in the coordinate system used to interpret op. These basis vectors define the coordinate representation in which op is originally given; they must be non-degenerate (so that b.T inversion below is valid in the normal case).
        b (numpy.ndarray): A (3,3) array of basis vectors for the destination basis system b, provided in row-major order. Each row is one lattice/basis vector defining the target coordinate system to which op will be transformed. The algorithm computes the similarity transform P = inv(b.T) @ a.T to change the basis from a to b.
        allow_non_integer (bool): Whether to allow non-integer entries in the transformed rotation matrix R returned in the b basis. Default value is False. In typical crystallographic usage, point-group rotation matrices expressed in an integer lattice basis are integer-valued; when allow_non_integer is False the function enforces this and returns an integer array (dtype int) after checking that R is integer within the symmetry precision threshold (SYMPREC). If allow_non_integer is True the function returns the floating-point matrix without enforcing integer rounding.
    
    Returns:
        numpy.ndarray: A (3,3) array containing the rotation operator expressed in the b basis system. If allow_non_integer is False and the transformed matrix is consistent with integer-valued point-group symmetry within the module's symmetry precision (SYMPREC), the returned array is rounded and cast to integer dtype. If allow_non_integer is True, the function returns the floating-point transformed matrix (rounded to 15 decimal places to suppress numerical noise). Small numerical values with absolute magnitude below 1e-9 are zeroed before the integer check.
    
    Behavior, side effects, and failure modes:
        The function computes P = inv(b.T) @ a.T and then performs the similarity transform R = P @ op @ inv(P). Numerical noise is reduced by rounding R to 15 decimal places and setting elements with absolute value < 1e-9 to exactly zero. If allow_non_integer is False the function compares R to its nearest integer using the module-level tolerance SYMPREC. If the maximum absolute deviation from integer rounding exceeds SYMPREC, a RuntimeError is raised with the message "Point-group symmetries of the two coordinate systems are different." This error signals that op cannot be represented as an integer-valued point-group rotation in the target lattice basis b to within the configured symmetry precision, which typically indicates incompatible point-group symmetries between the two basis systems. If b.T is singular or near-singular, numpy.linalg.LinAlgError (or related numerical errors) may be raised during inversion; this indicates degenerate or invalid basis vectors in b and should be handled by the caller. No other global side effects occur.
    """
    from pyscf.pbc.symm.space_group import transform_rot
    return transform_rot(op, a, b, allow_non_integer)


################################################################################
# Source: pyscf.pbc.scf.krohf.make_rdm1
# File: pyscf/pbc/scf/krohf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_scf_krohf_make_rdm1(mo_coeff_kpts: list, mo_occ_kpts: list, **kwargs):
    """pyscf.pbc.scf.krohf.make_rdm1 builds the alpha and beta one-particle reduced density matrices (1-RDMs) for all k-points used in periodic (k-point) restricted open-shell Hartree-Fock calculations in the PySCF pbc.scf.krohf module. The function constructs spin-resolved 1-RDMs by selecting occupied molecular orbital (MO) columns from provided MO coefficient arrays according to the occupancy pattern and forming dma = C_a C_a^† and dmb = C_b C_b^† for each k-point. This is used in PySCF workflows to obtain per-k-point density matrices for energy evaluation, density-dependent property computations, and subsequent post-SCF analyses in periodic electronic structure calculations.
    
    Args:
        mo_coeff_kpts (list): List of per-k-point molecular orbital coefficient arrays. Each element is expected to be a 2-D array-like object with shape (nao, nmo) where nao is the number of atomic-orbital basis functions and nmo is the number of molecular orbitals for that k-point. The columns of each array are MO coefficients expressed in the AO basis for that k-point. The function uses complex conjugation (mo_coeff.conj().T) so complex-valued coefficient arrays (as arise with k-point sampling) are supported.
        mo_occ_kpts (list): List of per-k-point MO occupancy arrays. Each element is a 1-D array-like of length nmo giving occupation numbers for the corresponding entry of mo_coeff_kpts. Occupation values are interpreted exactly as used in the implementation: orbitals with occ > 0 are treated as occupied for the alpha-spin density, and orbitals with occ == 2 are treated as occupied for the beta-spin density. Typical values are 0, 1, or 2 for unoccupied, singly occupied, and doubly occupied orbitals respectively; the code logic relies on these comparisons and will select columns accordingly.
        kwargs (dict): Additional keyword arguments. The current implementation does not consume any keyword arguments; any entries passed in kwargs are ignored by the function. This parameter exists to accept and ignore extra keywords that may be forwarded by higher-level routines in PySCF.
    
    Behavior and practical details:
        The function iterates over k-points (enumerating mo_occ_kpts). For each k-point index k it selects the MO coefficient columns for alpha as mo_coeff_kpts[k][:, occ > 0] and for beta as mo_coeff_kpts[k][:, occ == 2], where occ is the corresponding element of mo_occ_kpts. It then forms the per-k-point density matrices by matrix-multiplying the selected MO coefficient matrices with their Hermitian transpose (np.dot(C, C.conj().T)). This construction yields the physical one-particle reduced density matrices in the atomic-orbital basis suitable for use in periodic Hartree-Fock energy and property calculations. The function preserves complex dtype if the input coefficients are complex (common for k-point calculations). No in-place modification of the provided mo_coeff_kpts or mo_occ_kpts inputs is performed.
    
    Defaults and side effects:
        There are no mutable side effects except for returning a tagged array object. The function returns a tagged array produced by lib.tag_array, which attaches the input mo_coeff and mo_occ as metadata attributes to the returned object. The function does not modify external state or perform I/O.
    
    Failure modes and input requirements:
        The function expects mo_coeff_kpts and mo_occ_kpts to be sequences of the same length (nkpts). Each mo_occ_kpts[k] must be indexable and have length equal to the number of columns in mo_coeff_kpts[k]; otherwise indexing or shape-mismatch errors (IndexError or ValueError from NumPy) will be raised when selecting columns or computing the dot product. If occupancy arrays contain values other than those intended (e.g., non-integer occupations), the selection logic (occ > 0 and occ == 2) will still be applied literally and may yield unexpected occupancy assignments. Users should ensure consistent shapes and sensible occupancy values before calling this function.
    
    Returns:
        ndarray: A tagged ndarray containing the spin-resolved one-particle density matrices for all k-points with shape (2, nkpts, nao, nao). The first index (0) corresponds to the alpha-spin 1-RDMs and the second index (1) corresponds to the beta-spin 1-RDMs. The returned object is produced by lib.tag_array and carries attributes mo_coeff (the original mo_coeff_kpts) and mo_occ (the original mo_occ_kpts) as metadata for downstream routines to access.
    """
    from pyscf.pbc.scf.krohf import make_rdm1
    return make_rdm1(mo_coeff_kpts, mo_occ_kpts, **kwargs)


################################################################################
# Source: pyscf.pbc.tools.k2gamma.translation_map
# File: pyscf/pbc/tools/k2gamma.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_tools_k2gamma_translation_map(nk: int):
    """pyscf.pbc.tools.k2gamma.translation_map generates a periodic translation index map used in PySCF periodic-boundary-condition (PBC) k-point utilities to map ordered pairs of k-point indices to a single k-point index according to modular subtraction. In the context of PySCF PBC k-point algorithms (see pyscf.pbc.tools.k2gamma), this mapping is used to find the relative k-point index associated with the difference between two k-points, which is necessary for enforcing momentum conservation and assembling k-point dependent integrals and tensors without explicit Python loops.
    
    Args:
        nk (int): Number of k-points (positive integer). This parameter specifies the dimension of the square translation map to produce. The function requires nk >= 1; providing a non-integer, zero, or negative value will cause NumPy operations to raise a TypeError or ValueError. In practical electronic-structure workflows within PySCF, nk corresponds to the number of sampled k-points in the Brillouin zone (for example, the product of a k-mesh along each reciprocal lattice direction).
    
    Returns:
        numpy.ndarray: A two-dimensional NumPy array of shape (nk, nk) and dtype int. The element at row i and column j equals (j - i) modulo nk, i.e., t_map[i, j] = (j - i) % nk, yielding integers in the range 0..nk-1. This array provides the translation mapping such that given two k-point indices i and j, t_map[i, j] gives the index of the k-point corresponding to their difference under periodic boundary conditions. The implementation constructs the array using NumPy stride tricks and an appended buffer to create the cyclic pattern efficiently; the function allocates a new integer array and returns it. There are no side effects (no global state is modified). Failure modes: passing invalid nk (non-integer, negative, or zero) will raise errors from NumPy; extremely large nk will consume O(nk^2) memory and may raise MemoryError.
    """
    from pyscf.pbc.tools.k2gamma import translation_map
    return translation_map(nk)


################################################################################
# Source: pyscf.pbc.tools.lattice.get_ase_diamond_cubic
# File: pyscf/pbc/tools/lattice.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_tools_lattice_get_ase_diamond_cubic(atom: str = "C"):
    """Get the ASE atoms for a cubic (8-atom) diamond unit cell.
    
    This function constructs and returns an ASE Atoms object representing the conventional cubic diamond unit cell containing 8 atoms. It is intended for use in periodic-boundary-condition (PBC) workflows within the PySCF pbc.tools utilities where a standard diamond cubic unit cell (carbon or silicon) is required as an input geometry for electronic-structure calculations. The function builds the cell by instantiating ase.lattice.cubic.Diamond with the chemical symbol and a lattice constant expressed in Bohr (the source code multiplies the tabulated lattice constant in Angstrom by A2B). The returned ASE Atoms instance can be passed directly to ASE-based tooling or converted as needed for PySCF PBC cell construction and integrals.
    
    Args:
        atom (str): Chemical element symbol selecting which diamond cubic structure to generate. Default is "C". Supported values are exactly "C" and "Si". If atom == "C", the function constructs Diamond(symbol='C', latticeconstant=3.5668*A2B), using a lattice constant of 3.5668 Å converted to Bohr by multiplication with A2B. If atom == "Si", the function constructs Diamond(symbol='Si', latticeconstant=5.431*A2B), using a lattice constant of 5.431 Å converted to Bohr. The parameter controls the species placed on the diamond lattice sites and thereby the atomic species and lattice parameter of the returned unit cell. Passing any other string value will not be accepted by this implementation and results in an error.
    
    Returns:
        ase.Atoms: An ASE Atoms object created by ase.lattice.cubic.Diamond corresponding to the requested diamond cubic unit cell (8-atom conventional cubic cell) with the symbol and lattice constant set as described above. This object contains atomic positions, cell vectors, and periodic boundary condition information suitable for downstream use in ASE or PySCF PBC routines.
    
    Raises and failure modes:
        NotImplementedError: Raised when atom is not "C" or "Si". The function raises NotImplementedError with a message indicating no formula was found for the given system and suggesting choosing a different system or adding it to the list.
        ImportError: If the ASE library (specifically ase.lattice.cubic.Diamond) is not available in the runtime environment, importing Diamond will raise ImportError; this function does not catch that exception.
        Other runtime errors: Errors raised by ASE when constructing the Diamond object (for example, invalid latticeconstant types) will propagate to the caller.
    
    Side effects and notes:
        The function performs an import from the ASE package (from ase.lattice.cubic import Diamond) at call time, which may incur module-import overhead. The lattice constants used are hard-coded in the source (3.5668 Å for carbon and 5.431 Å for silicon) and are converted to Bohr using the A2B factor present in the PySCF codebase; callers should be aware these fixed values reflect the typical conventional lattice parameters used by this utility.
    """
    from pyscf.pbc.tools.lattice import get_ase_diamond_cubic
    return get_ase_diamond_cubic(atom)


################################################################################
# Source: pyscf.pbc.tools.lattice.get_ase_graphene
# File: pyscf/pbc/tools/lattice.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_tools_lattice_get_ase_graphene(vacuum: float = 5.0):
    """Get the ASE atoms for the primitive (2-atom) graphene unit cell.
    
    This function constructs and returns an ASE Atoms object describing the
    primitive two-atom graphene unit cell (carbon atoms only) suitable for use
    with PySCF periodic-boundary-condition (pbc) workflows (for example,
    building a pyscf.pbc.Cell from an ASE Atoms object). The in-plane lattice
    constant 'a' is set to 2.46 (physical lattice constant for graphene) and
    the out-of-plane lattice constant 'c' is set from the vacuum parameter.
    Both lattice constants in the implementation are scaled by the module-level
    conversion factor A2B (the code multiplies values by A2B before passing to
    ASE), so the supplied vacuum value is interpreted as an Angstrom value and
    converted internally to Bohr for the ASE lattice constructor.
    
    Args:
        vacuum (float): Vacuum spacing along the cell z axis (out-of-plane)
            expressed in Angstrom. This value sets the ASE lattice constant 'c'
            via c = vacuum * A2B in the function implementation. The vacuum
            parameter controls the separation between periodic graphene layers
            when using a 2D periodic cell with a finite cell height; the
            default value is 5.0 (Angstrom). In practical PySCF PBC calculations,
            increasing this value reduces spurious interaction between periodic
            images in the direction perpendicular to the graphene plane. vacuum
            should be a positive floating-point number; providing zero or a
            negative value will produce a zero/negative cell height and will
            likely lead to invalid geometry or runtime errors from ASE or downstream
            PySCF routines.
    
    Returns:
        ase.Atoms: An ASE Atoms object representing the primitive (2-atom)
            graphene unit cell with carbon atoms. The returned object has its
            lattice constants set as {'a': 2.46 * A2B, 'c': vacuum * A2B} in the
            code, so coordinates and cell vectors are in Bohr after the A2B
            scaling. This object can be passed to PySCF PBC utilities that accept
            ASE Atoms (for example, creating a pyscf.pbc.Cell via from_ase).
            No filesystem or global state is modified by this function.
    
    Raises (behavioral notes / failure modes):
        ImportError: If the ASE package (ase.lattice.hexagonal.Graphene) is not
            available in the Python environment, the function will raise an
            ImportError when attempting to import or construct the ASE object.
        NameError: If the module-level conversion constant A2B is not defined or
            not imported into the module namespace, a NameError will be raised when
            attempting to compute lattice constants.
        ValueError / ASE errors: If vacuum is zero or negative, or otherwise
            produces an invalid cell, ASE or downstream PySCF functions may raise
            ValueError or other runtime errors. The caller should validate vacuum
            before calling if such values are possible.
    
    Notes:
        - The function uses ase.lattice.hexagonal.Graphene with atomic species
          'C' to create a primitive graphene cell. The in-plane lattice constant
          2.46 is the standard graphene lattice parameter used by the code.
        - Typical use in the PySCF PBC workflow is to generate an ASE cell for
          setting up plane-wave or Gaussian-based periodic calculations where a
          vacuum region in the z direction is required to simulate an isolated
          2D graphene layer.
    """
    from pyscf.pbc.tools.lattice import get_ase_graphene
    return get_ase_graphene(vacuum)


################################################################################
# Source: pyscf.pbc.tools.pbc.cutoff_to_gs
# File: pyscf/pbc/tools/pbc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_tools_pbc_cutoff_to_gs(a: numpy.ndarray, cutoff: float):
    """pyscf.pbc.tools.pbc.cutoff_to_gs — Deprecated helper that maps a plane-wave kinetic-energy cutoff to half-sized integer mesh counts for periodic-boundary-condition (PBC) plane-wave/FFT routines. This function is retained for backward compatibility and is replaced by cutoff_to_mesh, which returns the full mesh sizes; cutoff_to_gs returns the integer half of each mesh component produced by cutoff_to_mesh.
    
    Args:
        a (numpy.ndarray): Real-space lattice vectors or cell description used by PBC tools in PySCF. In the context of PySCF periodic calculations, this array provides the geometric definition of the periodic cell that determines reciprocal-lattice properties used to translate an energy cutoff into a discrete FFT/plane-wave mesh. The function forwards this array to cutoff_to_mesh, so any shape or dtype expectations are those required by cutoff_to_mesh.
        cutoff (float): Kinetic-energy cutoff value (in the units used by the surrounding PySCF PBC code, typically atomic units) that specifies the maximum |G+k|^2/2 (plane-wave kinetic energy) to be included in the plane-wave representation. This scalar controls how fine the reciprocal-space mesh must be to represent plane waves up to the given cutoff; cutoff_to_gs uses this value to compute the mesh via cutoff_to_mesh and then returns half of each mesh component.
    
    Returns:
        list: A list of integers. Each integer is computed as n//2 for the corresponding integer mesh component n returned by cutoff_to_mesh(a, cutoff). Practically, these integers represent half the number of grid points (per lattice direction) that cutoff_to_mesh would recommend for an FFT/plane-wave mesh given the provided lattice vectors a and energy cutoff. The result is intended for legacy code that expects these half-mesh counts.
    
    Behavior, defaults, and failure modes:
        This function performs no computations beyond delegating to cutoff_to_mesh(a, cutoff) and integer-dividing each returned mesh component by two. It has no side effects (it does not modify its inputs or global state). It is deprecated; callers are encouraged to use cutoff_to_mesh directly to obtain full mesh sizes. Any errors raised by cutoff_to_mesh (for example, due to incompatible or malformed lattice array a or invalid cutoff values) are propagated unchanged by cutoff_to_gs.
    """
    from pyscf.pbc.tools.pbc import cutoff_to_gs
    return cutoff_to_gs(a, cutoff)


################################################################################
# Source: pyscf.pbc.tools.pbc.gs_to_cutoff
# File: pyscf/pbc/tools/pbc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_tools_pbc_gs_to_cutoff(a: numpy.ndarray, gs: list):
    """pyscf.pbc.tools.pbc.gs_to_cutoff converts a grid-size specification given by gs into a mesh acceptable to mesh_to_cutoff and returns the corresponding plane-wave cutoff value for periodic boundary condition (PBC) calculations in PySCF. This function is deprecated and kept for backward compatibility; callers should use mesh_to_cutoff directly. In the context of PySCF, this function helps translate a coarse integer grid specification into the odd-valued mesh format expected by mesh_to_cutoff so the lattice vectors a (real-space cell) can be used to compute an equivalent plane-wave cutoff used by PBC electronic-structure routines.
    
    Args:
        a (numpy.ndarray): Real-space lattice vectors of the periodic cell used to define the simulation cell and reciprocal-space metric. In PySCF PBC routines, this array contains the lattice vectors that mesh_to_cutoff requires to convert a discrete reciprocal-space mesh into a numerical cutoff; gs_to_cutoff passes this array unchanged to mesh_to_cutoff.
        gs (list): Sequence of integers that specify a grid-size parameter per lattice direction. For each integer n in gs, gs_to_cutoff constructs an odd-valued mesh length 2*n+1 and passes the resulting list of mesh lengths to mesh_to_cutoff. The elements of gs are treated as integer grid-size parameters and are not validated beyond being used in the 2*n+1 transformation; correctness and shape requirements are enforced by mesh_to_cutoff.
    
    Returns:
        float: The numeric cutoff returned by mesh_to_cutoff when called with lattice vectors a and the mesh computed as [2*n+1 for n in gs]. This return value represents the plane-wave cutoff (a scalar numeric threshold) that PySCF PBC code can use to set reciprocal-space resolution. The function returns the mesh_to_cutoff result unchanged.
    
    Behavior and side effects:
        This function performs a simple, deterministic transformation of gs into an odd-valued mesh and delegates all computation to mesh_to_cutoff. There are no side effects such as modifying its inputs or global state. The function is deprecated; new code should call mesh_to_cutoff(a, mesh) directly where mesh is the list [2*n+1 for n in gs] if that transformation is desired.
    
    Failure modes:
        If a is not a numpy.ndarray of the shape or numeric type expected by mesh_to_cutoff, or if elements of gs are not integers (or otherwise incompatible with the 2*n+1 transformation), mesh_to_cutoff may raise a TypeError or ValueError. Any exceptions originate from mesh_to_cutoff or from Python due to invalid operations on the provided inputs. The deprecated wrapper does not catch or change those exceptions.
    """
    from pyscf.pbc.tools.pbc import gs_to_cutoff
    return gs_to_cutoff(a, gs)


################################################################################
# Source: pyscf.pbc.tools.k2gamma.double_translation_indices
# File: pyscf/pbc/tools/k2gamma.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_tools_k2gamma_double_translation_indices(kmesh: tuple):
    """Compute an index array that maps k-point pair subscripts (two-dimensional
    indices for a matrix indexed by k-point labels) to one-dimensional indices
    that exploit translation symmetry in periodic boundary condition (PBC)
    calculations. In the PySCF PBC context, many two-index quantities D[M,N]
    depend only on the relative translation between k-points (for example the
    symmetry D[M,N] = D[N-M] noted in the original implementation). This function
    builds the integer index array that allows reconstructing the full 2D matrix
    from a compact 1D array of symmetry-unique translation values.
    
    The function uses translation_map for each Cartesian reciprocal-lattice
    direction (kx, ky, kz) to obtain a representative index per k-point under
    translation symmetry, then combines those representatives with
    numpy.ravel_multi_index to produce a single flat index for each ordered pair
    (M, N). The resulting index array is suitable for indexing a 1D array D1 of
    symmetry-unique translation-dependent values to produce the full 2D matrix
    D2 via D2 = D1[double_translation_indices(kmesh)].
    
    Args:
        kmesh (tuple): A length-3 tuple of integers giving the k-point sampling
            grid size in each periodic direction (kx, ky, kz). Each element
            represents the number of k-points along that lattice direction and
            is used as the dims argument for numpy.ravel_multi_index. This argument
            is required and must contain three positive integers because the
            implementation accesses kmesh[0], kmesh[1], and kmesh[2] and builds
            per-dimension translation maps. In the PySCF PBC domain, kmesh
            describes the discrete sampling of the Brillouin zone used when
            exploiting translation symmetry to reduce storage and computation.
    
    Returns:
        numpy.ndarray: A 2D integer index array of shape (nk, nk) where nk is the
        product of the three integers in kmesh (nk = kx * ky * kz). Each element
        idx[p, q] is an integer in the range [0, nk-1] that maps the ordered pair
        of k-point labels (p, q) to a single flat index that selects the
        corresponding translation-unique value from a 1D array of length nk.
        In practical use within PySCF, if D1 is a 1D array of symmetry-unique
        translation-dependent values arranged so that axis position r corresponds
        to the representative multi-index produced by translation_map, then the
        full two-index matrix D2 for all ordered k-point pairs is obtained by
        indexing D1 with this returned array: D2 = D1[idx].
    
    Behavior and side effects:
        This function is pure (no side effects on global state) and deterministic:
        given the same kmesh it always returns the same index mapping. Internally
        it calls translation_map on each of the three mesh dimensions to obtain
        canonical representative indices per k-point under translation symmetry,
        then combines them with numpy.ravel_multi_index using kmesh as the dims
        argument.
    
    Failure modes and errors:
        If kmesh does not have length 3, the implementation will raise an
        IndexError when attempting to access kmesh[2]. If any entry of kmesh is
        not an integer or is less than or equal to zero, numpy.ravel_multi_index
        or the subsequent reshape may raise a TypeError or ValueError. Callers
        must therefore provide a length-3 tuple of positive integers as required
        by PBC k-point mesh conventions in PySCF.
    """
    from pyscf.pbc.tools.k2gamma import double_translation_indices
    return double_translation_indices(kmesh)


################################################################################
# Source: pyscf.pbc.tools.pbc.fftk
# File: pyscf/pbc/tools/pbc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_tools_pbc_fftk(f: numpy.ndarray, mesh: tuple, expmikr: numpy.ndarray):
    """pyscf.pbc.tools.pbc.fftk computes the 3D discrete Fourier transform (FFT) of a real-space function defined on a periodic lattice after multiplying by a k-dependent phase factor. This routine is used in PySCF periodic-boundary-condition (PBC) workflows to obtain reciprocal-space coefficients fk(k+G) for a given k-point: fk(k+G) = sum_r fk(r) e^{-i(k+G)r} = sum_r [f(r) e^{-i k r}] e^{-i G r}. In practice, fftk multiplies the input real-space array f by the provided precomputed phase array expmikr and then calls the underlying fft routine with the specified FFT grid mesh to return the reciprocal-space representation used in k-point and G-vector operations (for example, evaluating plane-wave components of periodic functions, integrals, or potentials in PBC electronic-structure calculations).
    
    Args:
        f (numpy.ndarray): Real-space function sampled on a uniform 3D grid representing the periodic part of the quantity of interest. In the PBC context, f is typically the periodic envelope defined on the real-space mesh points r. The function is not modified in place; fftk computes the product f * expmikr and passes the product to the FFT routine. If f and expmikr are not broadcast-compatible, a broadcasting or shape-mismatch error will be raised by NumPy.
        mesh (tuple): Tuple specifying the FFT grid dimensions used by the underlying FFT routine. This tuple determines the set of reciprocal-grid points G (and hence k+G) returned by the transform. The mesh must match the grid sampling implied by f (number of points along each Cartesian axis); if mesh is inconsistent with f, the result will be incorrect or the FFT routine may raise an error.
        expmikr (numpy.ndarray): Precomputed complex phase-factor array sampled on the same real-space grid as f. In PBC workflows this is the k-dependent phase factor (commonly e^{-i k·r} or the equivalent factor required by the calling code) that, when multiplied elementwise with f, yields the function whose FFT produces fk at k+G. expmikr must be broadcast-compatible with f; if its values or sampling do not correspond to the intended k-point, the returned reciprocal coefficients will correspond to a different k and produce incorrect physical results.
    
    Returns:
        numpy.ndarray: The complex-valued reciprocal-space array produced by performing a 3D FFT on the elementwise product f * expmikr using the provided mesh. The returned array contains Fourier coefficients arranged on the FFT grid corresponding to k+G points and is suitable for use in subsequent PBC reciprocal-space operations (for example, multiplying with Coulomb kernels or constructing k-point-dependent integrals). Errors and failure modes include shape/broadcast mismatches between f and expmikr, an incompatible mesh for the sampling of f, or invalid numeric types for the FFT; such conditions will raise exceptions from NumPy/the underlying FFT routine.
    """
    from pyscf.pbc.tools.pbc import fftk
    return fftk(f, mesh, expmikr)


################################################################################
# Source: pyscf.pbc.tools.lattice.get_ase_graphene_xxx
# File: pyscf/pbc/tools/lattice.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_tools_lattice_get_ase_graphene_xxx(vacuum: float = 5.0):
    """pyscf.pbc.tools.lattice.get_ase_graphene_xxx: Create and return an ASE Atoms object representing the primitive (2-atom) graphene unit cell configured for use in PySCF periodic-boundary-condition workflows.
    
    Args:
        vacuum (float): The out-of-plane cell spacing (c lattice parameter) supplied by the caller. This value is interpreted in Angstroms and then multiplied by the module-level A2B constant (Angstrom-to-Bohr) before constructing the ASE cell, so the returned ASE Atoms object uses Bohr units consistent with PySCF internal conventions. The default is 5.0 (Angstrom). In practical use within PySCF, this parameter controls the vacuum separation between periodic images in the direction normal to the graphene plane and should be set large enough to suppress spurious interlayer interactions for isolated-graphene calculations.
    
    Returns:
        ase.Atoms: An ASE Atoms instance that encodes a primitive (two carbon atom) graphene unit cell suitable as an input geometry for PySCF PBC calculations. Construction details: the in-plane lattice constant a is fixed to 2.46 (Angstrom) and multiplied by A2B (i.e., a = 2.46 * A2B), the out-of-plane lattice constant c is set to vacuum * A2B; the atoms are created via ase.lattice.bulk('C', 'hcp', a=..., c=...), and then the z-coordinate of the second atom is explicitly set to 0.0 (ase_atom.positions[1,2] = 0.0) so both carbon atoms lie in the same plane, yielding the correct 2-atom primitive graphene motif. The returned object contains the cell vectors and atomic positions in Bohr units and can be directly used where an ASE geometry object is required by PySCF PBC tools.
    
    Behavior, side effects, and failure modes:
        - The function imports and calls ASE routines (ase.lattice.bulk) to build the geometry; ASE must be installed and importable at runtime or an ImportError will occur.
        - The function relies on the module-level constant A2B to convert Angstrom input to Bohr. If A2B is not defined in the module namespace, a NameError will occur.
        - The line ase_atom.positions[1,2] = 0.0 mutates the returned ASE Atoms object so that the second atom's z coordinate is exactly zero; this is an intended, local modification and does not alter any global state.
        - Supplying a very small or non-positive vacuum value may produce an unphysically small c lattice parameter, causing overlapping periodic images or atoms; the function does not itself validate physical ranges for vacuum beyond what underlying libraries enforce.
        - Changes in the ASE API (for example deprecation or signature changes to ase.lattice.bulk) may break construction; callers should ensure compatibility between the installed ASE version and this utility.
    
    Practical significance:
        - This utility provides a concise, reproducible primitive graphene geometry (two-atom cell) with a standard in-plane lattice constant (2.46 Å) and user-controlled out-of-plane vacuum spacing. It is intended as a convenient starting geometry for electronic-structure calculations (DFT, HF, etc.) on graphene within PySCF's PBC modules, where cell vectors and atomic positions need to be provided as an ASE Atoms object in Bohr units.
    """
    from pyscf.pbc.tools.lattice import get_ase_graphene_xxx
    return get_ase_graphene_xxx(vacuum)


################################################################################
# Source: pyscf.pbc.tools.pbc.fft
# File: pyscf/pbc/tools/pbc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_tools_pbc_fft(f: numpy.ndarray, mesh: numpy.ndarray):
    """Perform the 3D FFT from real-space (R) grid to reciprocal-space (G) grid for periodic-boundary calculations in the pyscf.pbc.tools.pbc module.
    
    This function is used in the periodic (PBC) plane-wave / grid-based parts of PySCF to transform a real-space quantity sampled on a uniform 3D grid (for example a charge density or a component of a potential) into its representation on reciprocal lattice G-vectors. The output ordering of reciprocal-space indices follows the natural order used by numpy.fft and the Gv ordering produced by cartesian_prod. The FFT normalization factor is 1.0, consistent with the MH convention used elsewhere in PySCF and numpy.fft.
    
    Args:
        f (numpy.ndarray): The real-space function values to be transformed. Typical usage supplies a single flattened function as a one-dimensional array of length nx*ny*nz corresponding to the index order produced by cartesian_prod (i.e., flattened in the same nested ordering over the three grid axes). The function also accepts inputs that can be reshaped into shape (-1, nx, ny, nz) (for example a flattened concatenation of multiple functions or an array with a leading axis enumerating multiple grid functions). The concrete role of f is to provide the sampled values on the real-space grid that will be independently FFT'd along the 3 spatial dimensions to produce reciprocal-space coefficients.
        mesh (numpy.ndarray): A length-3 integer array specifying the number of grid points along each Cartesian direction (nx, ny, nz). mesh defines the 3D shape of the real-space grid used to interpret f and thereby determines the number of G-vectors (nx*ny*nz) in reciprocal space. The entries must be integers and mesh must be compatible with the total number of real-space samples in f (product(nx, ny, nz) must equal the per-function grid size). In practice mesh is used to reshape f into a 3D grid before applying the FFT wrapper.
    
    Returns:
        numpy.ndarray: The FFT result in reciprocal-space, returned in the same Gv/numpy.fft natural index order. For a single input function (common case), the return is a one-dimensional array of length nx*ny*nz containing the complex or real Fourier coefficients in G-space arranged in the same flattened ordering as cartesian_prod. If f encodes multiple functions (i.e., can be reshaped to shape (nfunc, nx, ny, nz) or into (-1, nx, ny, nz)), the return is a two-dimensional array of shape (nfunc, nx*ny*nz) where each row is the flattened FFT result for the corresponding input function. The normalization applied to the FFT is 1.0 (no additional scaling), consistent with numpy.fft.
    
    Behavior, side effects, defaults, and failure modes:
        - The function is pure (no external side effects) and returns a new numpy.ndarray; it does not modify its input array f in-place.
        - If f.size == 0 an array of the same shape and dtype as f filled with zeros is returned immediately.
        - Internally, f is reshaped with numpy.reshape(-1, *mesh) to form one or more 3D grids prior to calling the internal _fftn_wrapper that performs the forward 3D FFT. This means f must have a total size that is an integer multiple of the product(nx, ny, nz) so that the reshape is valid; otherwise numpy.reshape will raise a ValueError.
        - An assertion in the implementation enforces that either there is exactly one function to transform (leading dimension 1 after reshape) or that the first element of the original f has the same flattened size as a single reshaped grid slice; violation of this condition raises AssertionError.
        - mesh must be a length-3 integer array; non-integer or incorrectly sized mesh may lead to TypeError or ValueError from numpy operations.
        - The function preserves the index mapping (u, v, w) -> (j, k, l) described in the module: the mapping between real-space grid indices and reciprocal-space G-vector indices follows the cartesian_prod ordering and the natural ordering used by numpy.fft.
        - The FFT normalization factor is 1.0, as in MH and numpy.fft; users who require unitary or other normalization conventions must rescale the output externally.
        - Any errors originating from the underlying FFT implementation (_fftn_wrapper) will propagate (for example due to unsupported dtypes or memory errors).
    
    Practical significance in PySCF:
        - This routine is a building block in periodic electronic-structure computations (plane-wave and mixed Gaussian/plane-wave methods) provided by PySCF, converting spatially sampled quantities to G-space where convolutional operations, Poisson solvers, and integrals over reciprocal vectors are performed more efficiently.
    """
    from pyscf.pbc.tools.pbc import fft
    return fft(f, mesh)


################################################################################
# Source: pyscf.pbc.tools.pbc.cutoff_to_mesh
# File: pyscf/pbc/tools/pbc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_tools_pbc_cutoff_to_mesh(a: numpy.ndarray, cutoff: float):
    """Convert kinetic-energy (KE) cutoff to a minimal FFT mesh suitable for periodic
    (boundary) plane-wave / FFT operations in PySCF.
    
    This function is used in PySCF's periodic-boundary-condition (PBC) tools to
    choose the number of grid points along each lattice direction so that plane-wave
    reciprocal vectors with kinetic energy up to the given cutoff are representable
    on the uniform FFT grid. The conversion assumes the kinetic energy KE = |k|^2/2
    (atomic units) and the empirical relation between maximum wavevector and grid
    spacing (k_max ~ pi / grid_spacing). The routine computes the reciprocal
    lattice b = 2*pi * inv(a.T), determines the effective reciprocal-axis
    lengths via QR decompositions, calculates the required maximum reciprocal
    index Gmax = sqrt(2*cutoff)/|r| for each lattice direction, and returns an
    odd integer mesh mesh = ceil(Gmax)*2 + 1 to ensure symmetric sampling of
    positive and negative reciprocal vectors.
    
    Args:
        a ((3,3) ndarray): The real-space cell lattice vectors. Each row
            represents a lattice vector that defines the periodic cell used in PBC
            calculations. In practical PySCF workflows this array specifies the
            cell geometry for which the FFT grid is being chosen; it must be a
            numeric 3-by-3 array compatible with numpy linear-algebra operations.
        cutoff (float): KE energy cutoff in atomic units (a.u.). This scalar
            specifies the maximum one-electron kinetic energy (in the relation
            KE = |k|^2/2) that must be represented by the FFT mesh. The function
            expects a non-negative finite float; negative values will lead to
            invalid results (square-root of a negative number) or runtime warnings.
    
    Returns:
        mesh ((3,) array): A length-3 array of integers giving the number of FFT
            grid points along each lattice-vector direction. Each entry is computed
            as ceil(Gmax_direction) converted to int, multiplied by 2 and increased
            by 1 (mesh = ceil(Gmax).astype(int) * 2 + 1) so the returned mesh
            consists of odd integers. This mesh is the minimal (per this
            criterion) odd-sized grid that represents reciprocal vectors up to the
            kinetic-energy cutoff and is intended for use when setting FFT grids in
            PySCF PBC routines.
    
    Behavior and failure modes:
        - The routine computes the reciprocal lattice as b = 2*pi * inv(a.T). If
          the input array a is singular or nearly singular (non-invertible), numpy
          will raise a LinAlgError or produce unstable results.
        - The function uses QR decompositions to extract effective reciprocal-axis
          lengths; if a does not have shape (3,3) or is not numeric, numpy will
          raise shape/type-related exceptions.
        - The function expects cutoff >= 0. For negative cutoff values the
          calculation of sqrt(2*cutoff) is invalid and will produce NaNs or
          runtime warnings; callers should validate cutoff before calling.
        - There are no external side effects; the function only returns the
          computed mesh.
    """
    from pyscf.pbc.tools.pbc import cutoff_to_mesh
    return cutoff_to_mesh(a, cutoff)


################################################################################
# Source: pyscf.pbc.tools.lattice.get_ase_diamond_primitive
# File: pyscf/pbc/tools/lattice.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_tools_lattice_get_ase_diamond_primitive(atom: str = "C"):
    """pyscf.pbc.tools.lattice.get_ase_diamond_primitive: Construct and return an ASE Atoms object representing the primitive (2-atom) diamond unit cell for a specified elemental diamond crystal. This helper is used in the PySCF periodic-boundary-condition workflow to obtain a canonical primitive cell for diamond-structure materials which can then be used to build periodic lattices, run band-structure or plane-wave related tests, or convert between PySCF and ASE representations.
    
    Args:
        atom (str): Chemical symbol identifying which diamond-structure element to build. Accepted string values implemented by this function are 'C', 'Si', and 'Ge'. The parameter selects a predefined lattice constant appropriate for the chosen element and passes it to ase.build.bulk with structure 'diamond' to construct the primitive 2-atom cell. The default is 'C', which produces a carbon (diamond) primitive cell using a lattice constant of 3.5668*A2B. For 'Si' the lattice constant 5.431*A2B is used, and for 'Ge' 5.658*A2B is used. The lattice constant literals in the source are multiplied by the A2B conversion factor (Angstrom-to-Bohr) so that the created ASE Atoms object uses the unit convention expected by downstream PySCF routines that rely on Bohr units.
    
    Returns:
        ase.Atoms: An ASE Atoms instance representing the primitive (2-atom) diamond unit cell for the requested element. The returned object is created by ase.build.bulk with the 'diamond' crystal structure and the element-specific lattice constant shown above. This object is suitable for use in PySCF workflows that accept ASE Atoms input (for example, conversion to PySCF cell objects, geometry inspection, or further manipulation within ASE). No global state is modified by this function; it only constructs and returns the ASE Atoms object.
    
    Raises:
        NotImplementedError: If atom is not one of the implemented values ('C', 'Si', 'Ge'), the function raises NotImplementedError with a message indicating no formula is found for the requested system and suggesting choosing a different system or adding support for it. This behavior documents the failure mode for unsupported inputs.
    """
    from pyscf.pbc.tools.lattice import get_ase_diamond_primitive
    return get_ase_diamond_primitive(atom)


################################################################################
# Source: pyscf.pbc.tools.pbc.ifftk
# File: pyscf/pbc/tools/pbc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_tools_pbc_ifftk(g: numpy.ndarray, mesh: tuple, expikr: numpy.ndarray):
    """pyscf.pbc.tools.pbc.ifftk: Transform plane-wave Fourier coefficients f(k+G) into the real-space Bloch-like function fk(r) = (1/Ng) ∑_G f(k+G) e^{i(k+G)·r} by computing the inverse FFT over reciprocal vectors G and multiplying by the phase factor e^{i k·r}.
    
    Performs the 3D inverse fast Fourier transform (IFFT) of a set of plane-wave coefficients provided in g on an FFT grid specified by mesh, and then multiplies the IFFT result by the k-dependent phase factor expikr to produce the physical real-space function fk(r) that is periodic in the cell up to the e^{i k·r} Bloch phase. This routine is used in the PySCF periodic-boundary-condition (PBC) tools to reconstruct k-point dependent real-space quantities (for example, density components or orbital values) from their plane-wave (k+G) representations when performing electronic-structure calculations in crystals.
    
    Args:
        g (numpy.ndarray): Array of plane-wave Fourier coefficients f(k+G). In the context of PySCF PBC routines, g contains values indexed over reciprocal-lattice G vectors (arranged consistently with the FFT mesh). These coefficients are the input to the inverse FFT: the function calls the internal ifft(g, mesh) to compute the real-space periodic component ∑_G f(k+G)e^{iG·r}/Ng. The caller must ensure g is a numpy.ndarray compatible with the ifft implementation (dtype supporting complex values when appropriate).
        mesh (tuple): A tuple specifying the FFT grid dimensions used by the inverse FFT. In PySCF this mesh determines the number of grid points along each Cartesian direction used by ifft to realize the discrete inverse transform and the implicit normalization factor 1/Ng. The entries of mesh should correspond to the grid expected by the underlying ifft routine; passing an incompatible mesh (wrong length or non-integer entries) will lead to errors from the FFT routine.
        expikr (numpy.ndarray): Real-space array containing the complex phase factor e^{i k·r} evaluated on the same real-space grid returned by ifft(g, mesh). Multiplying the IFFT result elementwise by expikr yields fk(r) = [ifft over G of f(k+G) e^{iG·r}] * e^{i k·r}. expikr must be a numpy.ndarray whose shape is compatible for elementwise multiplication with the array returned by ifft(g, mesh) and whose dtype supports complex multiplication when the phase is complex.
    
    Returns:
        numpy.ndarray: The real-space Bloch-like function fk(r) computed as ifft(g, mesh) * expikr. The returned array is the same numpy.ndarray type as the inputs (dtype determined by inputs and FFT implementation) and represents the function that is periodic in the unit cell up to the global Bloch phase e^{i k·r}. No in-place modification of g or expikr is performed by this function; it returns a new array holding the product.
    
    Notes:
        - The function relies on the behavior and normalization of the underlying ifft implementation (called as ifft(g, mesh)). In the standard PySCF PBC implementation, that ifft includes the (1/Ng) normalization so that fk(r) follows the formula fk(r) = (1/Ng) ∑_G f(k+G) e^{i(k+G)·r}.
        - This routine has no side effects beyond computing and returning the result; it does not modify global state or the input arrays.
        - Common failure modes include shape mismatches between ifft(g, mesh) and expikr (which will typically raise a ValueError or broadcasting-related exception from NumPy), passing non-numpy types for g or expikr (TypeError), or providing an incompatible mesh to the IFFT routine (errors propagated from the FFT implementation). NaN or inf values in g or expikr will propagate into the result.
    """
    from pyscf.pbc.tools.pbc import ifftk
    return ifftk(g, mesh, expikr)


################################################################################
# Source: pyscf.pbc.tools.pbc.ifft
# File: pyscf/pbc/tools/pbc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_tools_pbc_ifft(g: numpy.ndarray, mesh: numpy.ndarray):
    """Perform the 3D inverse FFT from reciprocal-space (G) to real-space (R) for periodic-boundary-condition (PBC) calculations.
    
    This function is used in the pyscf.pbc.tools.pbc module to convert data defined on G-vectors (reciprocal lattice vectors) to values on a real-space grid. In practical electronic-structure workflows within PySCF for periodic systems (crystals), the output can represent quantities such as electron density or potentials sampled on a uniform real-space grid. The inverse FFT uses the same normalization convention as numpy.fft (a factor of 1./N), which differs from some other conventions (for example, MH which uses a factor of 1.), and therefore affects amplitude scaling and Parseval-related properties of transformed quantities.
    
    Args:
        g (numpy.ndarray): The input array containing one or more functions in G-space to be inverse-FFT'd. For a single G-space function the expected flattened shape is (nx*ny*nz,), where nx, ny, nz are the mesh sizes along the three reciprocal directions; this 1D layout must follow the index order used by span3 in the PBC tools so that the mapping between linear indices and (ix,iy,iz) grid indices is consistent. The implementation also accepts inputs that pack multiple G-space arrays along a leading dimension: in that case g.reshape(-1, *mesh) is used so the total number of elements of g must be an integer multiple of the product(nx*ny*nz). If g.size == 0 an array of zeros with the same shape and dtype is returned immediately. Practical significance: pass a flattened G-space array when transforming a single field, or pass a stacked array with a leading axis indexing multiple fields to transform several G-space datasets in one call.
        mesh (numpy.ndarray): Integer array of length 3 (nx, ny, nz) giving the number of G-vectors (grid points) along each reciprocal-space direction. The product nx*ny*nz defines the number of real-space grid points and must divide the total size of g. This parameter controls the shape used for the 3D inverse FFT and therefore how linear indices in g map to 3D grid indices in R-space.
    
    Behavior, side effects, defaults, and failure modes:
        - Normalization: the inverse FFT is scaled by 1./N (N = nx*ny*nz), consistent with numpy.fft.ifftn. This scaling ensures that transforms are consistent with numpy's forward FFT normalization and is important when comparing amplitudes or computing conserved quantities across domains.
        - Empty input: if g.size == 0 the function returns np.zeros_like(g) immediately; no FFT is performed.
        - Input reshaping: the code internally reshapes g to shape (-1, nx, ny, nz) using mesh; therefore the total number of elements in g must be divisible by nx*ny*nz. If this divisibility condition is not met, numpy.reshape will raise a ValueError.
        - Multiple fields: when g contains multiple G-space arrays packed along a leading dimension, each packed sub-array must have exactly nx*ny*nz elements. The function asserts that either there is a single packed array or that the first element of g (interpreted as an array) has the same size as each packed sub-array; if this internal consistency check fails an AssertionError can be raised.
        - Output ordering: the returned real-space values follow the natural (C-contiguous) ordering used by numpy.fft (the same index order as Gv in PySCF), enabling interoperability with other numpy FFT utilities and downstream PySCF routines that expect that ordering.
        - Errors: beyond the assertion and reshape-related ValueError described above, other exceptions may propagate from the underlying _ifftn_wrapper used to perform the 3D inverse FFT (for example, dtype or memory errors).
    
    Returns:
        numpy.ndarray: The inverse FFT result in real-space. For a single input function (g provided as a 1D array with size equal to nx*ny*nz) the return is a 1D array shaped (nx*ny*nz,) containing real-space samples in the numpy.fft natural order. If g contained multiple G-space arrays stacked along a leading dimension, the return has shape (m, nx*ny*nz) where m is the number of stacked arrays, i.e., the function returns multiple real-space fields packed along the first axis. The returned array uses the same dtype and device (CPU memory) as performed by the underlying numpy-based FFT wrapper.
    """
    from pyscf.pbc.tools.pbc import ifft
    return ifft(g, mesh)


################################################################################
# Source: pyscf.pbc.tools.pbc.mesh_to_cutoff
# File: pyscf/pbc/tools/pbc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_tools_pbc_mesh_to_cutoff(a: numpy.ndarray, mesh: tuple):
    """pyscf.pbc.tools.pbc.mesh_to_cutoff converts a real-space grid mesh (number of grid points along each periodic lattice vector) into an approximate kinetic-energy (KE) cutoff for each spatial direction used in plane-wave / reciprocal-space treatments within PySCF's periodic-boundary-condition (PBC) tools. The function is used in PBC workflows to map a discrete mesh specification (mesh) into the maximum reciprocal-space G-vector magnitude per direction and then to the corresponding KE cutoff via ke = |Gmax|^2 / 2, enabling consistent selection of plane-wave or G-vector truncation thresholds from a simple mesh description.
    
    Args:
        a (numpy.ndarray): Real-space lattice vectors used to define the periodic cell. This array is treated as a square matrix whose transpose is inverted to form the reciprocal-lattice matrix b = 2*pi * inv(a.T). In practice this corresponds to the 3x3 matrix of lattice vectors supplied to PySCF PBC routines; the matrix must be square and invertible (otherwise np.linalg.LinAlgError will be raised). The reciprocal lattice computed from a determines the physical scale of G-vectors used to derive the KE cutoff.
        mesh (tuple): Tuple of three integers giving the number of grid points along each lattice vector direction in the real-space mesh (one integer per periodic direction). The code converts this to an integer array and computes half-grid extents as (np.asarray(mesh) - 1) // 2 to obtain the maximal index magnitude in each direction. mesh must have length 3 and contain integer-like values; supplying a different length or non-integer-like values will produce an error or non-physical results.
    
    Returns:
        numpy.ndarray: A length-3 array of floating-point KE cutoff values, one per spatial direction. Each element is computed as Gmax**2 / 2 where Gmax is the product of the half-grid index (from mesh) and the corresponding maximum projected reciprocal-lattice vector magnitude (obtained via QR decompositions of permutations of the reciprocal-lattice matrix b = 2*pi*inv(a.T)). The returned array gives the kinetic-energy cutoff implied by the provided mesh along each Cartesian-like direction and can be used to set plane-wave/G-vector truncation thresholds in subsequent PBC calculations.
    
    Notes:
        - Behavior: The function computes three directional reciprocal-space scale factors (rx, ry, rz) by QR factorization of permuted forms of the reciprocal-lattice matrix to obtain the magnitude of basis vectors projected onto orthogonal axes, multiplies these by half the mesh extents, and converts to kinetic energy using ke = G^2/2. The algorithm is deterministic and has no side effects.
        - Failure modes: If a is singular (non-invertible), np.linalg.LinAlgError will be raised when computing the inverse. If mesh does not have length 3, indexing or broadcasting operations may raise IndexError or produce incorrect results. Supplying non-integer or negative mesh entries yields mathematically defined but likely non-physical results because the mesh is intended to represent counts of grid points (positive integers).
        - Units and interpretation: The function returns KE cutoff values in the units consistent with the input lattice vectors as used throughout PySCF (i.e., atomic units when lattice vectors are given in atomic units). The values represent per-direction cutoffs derived from the specified mesh; downstream code typically uses these cutoffs to select or compare plane-wave / G-vector sets.
    """
    from pyscf.pbc.tools.pbc import mesh_to_cutoff
    return mesh_to_cutoff(a, mesh)


################################################################################
# Source: pyscf.pbc.tools.pbc.round_to_cell0
# File: pyscf/pbc/tools/pbc.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_pbc_tools_pbc_round_to_cell0(r: numpy.ndarray, tol: float = 1e-06):
    """pyscf.pbc.tools.pbc.round_to_cell0 rounds scaled (fractional) coordinates to a reference unit cell used in periodic-boundary-condition (PBC) calculations. This function is part of the PySCF PBC tools and is used to map coordinate values expressed in unit-cell (scaled/fractional) coordinates into a canonical reference cell by delegating to pyscf.pbc.lib.kpts_helper.round_to_fbz with wrap_around=False and the specified tolerance.
    
    Args:
        r (numpy.ndarray): Array of scaled (fractional) coordinates to be rounded. In the PySCF PBC context, each element of this numpy.ndarray represents coordinate components expressed in units of the lattice vectors (scaled coordinates). The array may be any shape compatible with kpts_helper.round_to_fbz; typical usage is an array of shape (N, 3) for N coordinates, but the function accepts any numpy.ndarray shape that the underlying helper supports. This parameter is the primary input and determines which coordinate values are examined and adjusted according to the tolerance.
        tol (float): Rounding tolerance used to decide when a scaled coordinate is considered equal to a cell boundary or integer displacement. The default is 1e-6. Practically, values whose distance to the nearest integer multiple of the lattice basis is less than or equal to tol are treated as exact and are rounded accordingly. This parameter controls the sensitivity of the rounding operation and can be adjusted to avoid numerical noise causing incorrect cell assignments.
    
    Returns:
        numpy.ndarray: A numpy.ndarray containing the rounded scaled coordinates returned by pyscf.pbc.lib.kpts_helper.round_to_fbz called with wrap_around=False and the provided tol. The return value represents the input coordinates mapped to the reference unit cell according to the rounding rule controlled by tol. The exact shape and dtype follow what the underlying helper returns (commonly the same shape as the input r).
    
    Behavior and side effects:
        This function is a thin wrapper that delegates the rounding operation to pyscf.pbc.lib.kpts_helper.round_to_fbz with wrap_around explicitly set to False so that coordinates are rounded with respect to the reference unit cell without performing additional wrap-around behavior. It does not perform any I/O or global state mutation within PySCF; it returns the computed array. The function is typically used in workflows that need deterministic placement of points (k-points, atomic positions in scaled coordinates, etc.) into a canonical cell for periodic electronic structure calculations.
    
    Failure modes and errors:
        Errors raised by this function are propagated from the underlying kpts_helper.round_to_fbz implementation. If r is not a numpy.ndarray or has an unsupported shape or dtype, the underlying function may raise TypeError or ValueError (or other exceptions); these exceptions are not caught here. Users should ensure r is a valid numpy.ndarray of scaled coordinates and choose tol appropriate for their numerical precision to avoid unintended rounding.
    """
    from pyscf.pbc.tools.pbc import round_to_cell0
    return round_to_cell0(r, tol)


################################################################################
# Source: pyscf.scf.addons.canonical_orth_
# File: pyscf/scf/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_addons_canonical_orth_(S: numpy.ndarray, thr: float = 1e-07):
    """pyscf.scf.addons.canonical_orth_: Compute Löwdin's canonical (symmetric) orthogonalization matrix for an atomic-orbital overlap matrix.
    
    Args:
        S (numpy.ndarray): Real symmetric overlap matrix of the basis functions (commonly the atomic-orbital overlap matrix S_ij = <phi_i|phi_j>) used in quantum-chemistry mean-field calculations within PySCF. The function assumes S is a square numpy.ndarray representing the overlap between basis functions; the diagonal elements are used to form a diagonal normalization prefactor because some symmetry-adapted basis functions may not be individually normalized. This matrix is not modified by the function.
        thr (float): Eigenvalue threshold (default 1e-07). Eigenvalues of the normalized overlap matrix smaller than thr are treated as numerically zero and their corresponding eigenvectors are discarded to avoid instabilities from near-linear dependencies in the basis. Choosing a larger thr will reduce the number of retained orthonormalized basis vectors (reduces rank); choosing a smaller thr will retain more directions but can amplify numerical noise. The default value 1e-07 reflects a typical tolerance used in PySCF for rejecting near-zero overlap eigenvalues.
    
    Returns:
        numpy.ndarray: The orthogonalization/transformation matrix X (shape (n, m) with n equal to the dimension of S and m equal to the number of eigenvalues >= thr). X implements Löwdin's symmetric orthogonalization so that X.T @ S @ X = I_m (identity of size m), i.e. the columns of X are linear combinations of the original basis functions that are orthonormal with respect to the original overlap S. In typical PySCF usage, transform a Fock matrix F to the orthonormal basis by F' = X.T @ F @ X, diagonalize F' to obtain eigenvectors C' in the orthonormal basis, and recover molecular-orbital coefficients in the original AO basis by C = X @ C'. No in-place modification of the input S occurs.
    
    Notes and failure modes:
        - Algorithm: first normalize basis functions by the inverse square root of the diagonal of S (normlz = diag(S)^{-1/2}), form Snorm = normlz * S * normlz, compute the eigen-decomposition Snorm = V diag(s) V.T, discard eigenpairs with s < thr, form X = normlz * V_selected * diag(1/sqrt(s_selected)). This yields the returned X.
        - S must be (approximately) symmetric and positive semidefinite. If diag(S) contains zeros or negative entries, computing diag(S)^{-1/2} will produce infinities or NaNs; the routine does not perform explicit checks for these conditions and will propagate NumPy runtime warnings/errors. If S is not symmetric (due to numerical noise), results may be meaningless; symmetrize S before calling if necessary.
        - The routine is designed for use in PySCF SCF-related workflows to produce a stable orthonormal basis for diagonalization and other linear-algebra steps; discarding eigenvalues below thr effectively removes (near-)linearly-dependent basis directions and changes the effective basis rank.
    """
    from pyscf.scf.addons import canonical_orth_
    return canonical_orth_(S, thr)


################################################################################
# Source: pyscf.scf.addons.partial_cholesky_orth_
# File: pyscf/scf/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_addons_partial_cholesky_orth_(
    S: numpy.ndarray,
    canthr: float = 1e-07,
    cholthr: float = 1e-09
):
    """Partial Cholesky orthogonalization for curing basis-set overcompleteness in atomic-orbital (AO) representations used in PySCF SCF workflows. This routine implements the procedure described by S. Lehtola to identify a numerically robust subset of AO basis functions via a pivoted Cholesky decomposition of a normalized overlap matrix and to orthogonalize that retained sub-basis using canonical orthogonalization. The resulting transformation is intended for use in self-consistent field (SCF) and related electronic-structure calculations where near-linear dependencies (overcompleteness) of the AO basis degrade numerical stability.
    
    Args:
        S (numpy.ndarray): Square AO overlap matrix S_{μν} in the atomic-orbital basis. In practice this is the molecular overlap matrix produced by PySCF basis integrals. The routine expects S to be a finite, real-valued square matrix with positive diagonal elements (S_{μμ} > 0) so that normalization by the diagonal is defined. S represents the metric in which linear dependencies arise; its role is central because the algorithm normalizes S, sorts basis functions by Gershgorin-circle magnitude to improve pivot selection, and performs a pivoted Cholesky on the normalized matrix to identify a well-conditioned subspace.
        canthr (float): Threshold used by the canonical orthogonalization step applied to the selected sub-basis (defaults to 1e-07). In domain terms, this tolerance determines which small generalized eigenvalues of the sub-block overlap are treated as numerical zero during canonical orthogonalization; it controls how aggressively near-linear dependencies inside the retained sub-basis are removed. Smaller values make the orthogonalization more permissive (retain more components), larger values remove more components. The canonical orthogonalization is applied to the un-normalized sub-block S[idx, idx] after pivot selection.
        cholthr (float): Tolerance passed to the pivoted Cholesky decomposition on the normalized overlap matrix (defaults to 1e-09). This parameter controls the stopping criterion of the pivoted Cholesky: the decomposition truncates when remaining pivots fall below cholthr in magnitude. In quantum-chemistry practice, cholthr sets how strictly the algorithm prunes basis functions that contribute negligibly to the span of the overlap matrix; tighter tolerances (smaller cholthr) retain more pivots and thus a larger sub-basis, while larger tolerances produce a smaller retained set to cure overcompleteness.
    
    Returns:
        X (numpy.ndarray): A rectangular transformation matrix with shape (N, r) where N = S.shape[0] and r is the number of retained orthonormalized basis functions determined by the pivoted Cholesky and canonical orthogonalization. The columns of X are expressed in the original AO basis and form an orthonormal set with respect to the original overlap metric within numerical tolerances, i.e., X.T @ S @ X ≈ I_r. Practically, X can be used to transform AO quantities (density, Fock, etc.) into the reduced orthonormal subspace to stabilize SCF and post-SCF procedures. If the pivoted Cholesky finds no pivots above the cholthr, r may be zero and X will have shape (N, 0).
    
    Behavior, side effects, defaults, and failure modes:
        The function first rescales S by the inverse square root of its diagonal to obtain a normalized overlap Snorm; this requires finite, positive diagonal entries in S. It then sorts basis functions using a Gershgorin-circle-based heuristic to initialize the pivot order for a pivoted Cholesky decomposition on Snorm. The pivoted Cholesky (with tolerance cholthr) selects pivot indices and an effective rank r; those pivots index a sub-block Ssub = S[idx, idx] of the original overlap that is then orthogonalized by canonical_orth_ with threshold canthr to produce Xsub. The full output X places Xsub into the rows corresponding to the retained indices and zeros elsewhere. The original input matrix S is not modified by this routine (copies of sub-blocks are made), so there are no in-place side effects on S.
        Common failure modes include passing a non-square matrix S, S with zero or negative diagonal elements (leading to division by zero or invalid normalization), or S containing NaN/Inf entries; in such cases the normalization step or subsequent linear-algebra routines will raise standard numpy errors (e.g., divide-by-zero, invalid value, or LinAlgError). Choosing extremely small cholthr or canthr values may retain ill-conditioned directions and defeat the purpose of overcompleteness removal; conversely, overly large tolerances may remove physically important basis functions. This routine assumes the presence of the helper routines pivoted_cholesky and canonical_orth_ in the same PySCF addon context; errors in those routines will propagate up unchanged.
    
    References:
        S. Lehtola, "Curing basis set overcompleteness with pivoted Cholesky decompositions", J. Chem. Phys. 151, 241102 (2019).
        S. Lehtola, "Accurate reproduction of strongly repulsive interatomic potentials", Phys. Rev. A 101, 032504 (2020).
    """
    from pyscf.scf.addons import partial_cholesky_orth_
    return partial_cholesky_orth_(S, canthr, cholthr)


################################################################################
# Source: pyscf.qmmm.pbc.mm_mole.create_mm_cell
# File: pyscf/qmmm/pbc/mm_mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_qmmm_pbc_mm_mole_create_mm_cell(
    atoms_or_coords: numpy.ndarray,
    a: numpy.ndarray,
    charges: numpy.ndarray = None,
    radii: numpy.ndarray = None,
    rcut_ewald: float = None,
    rcut_hcore: float = None,
    unit: str = "Angstrom"
):
    """Create an MM Cell object for periodic QM/MM simulations (pyscf.qmmm.pbc.mm_mole.create_mm_cell).
    This factory function builds and returns a pyscf Cell configured to represent classical
    molecular-mechanics (MM) particles placed in a periodic lattice. It converts input
    coordinates and optional per-particle properties (charges, Gaussian radii) into the
    internal representations required by PySCF periodic modules, applies unit conversion
    to atomic units when needed, and forwards MM-related options (Ewald and hcore cutoffs)
    to the returned Cell. In the PySCF domain, this Cell is used to supply external
    classical charge distributions and cutoff parameters for periodic electrostatics and
    QM/MM coupling (e.g., Ewald summation and one-electron integrals in periodic boundary
    conditions).
    
    Args:
        atoms_or_coords (numpy.ndarray): Cartesian coordinates of the MM particles.
            Must be a 2-D NumPy array with shape (N, 3) where each row is (x, y, z).
            These coordinates are interpreted in the length unit given by the `unit`
            argument. Internally, coordinate-only entries are converted to atom records
            compatible with gto.format_atom by pairing each coordinate tuple with the
            atomic number 0 (a ghost atom marker). Supplying coordinates that do not
            conform to the expected 2-D shape or dtype may cause numpy operations or
            gto.format_atom to raise an error.
        a (numpy.ndarray): Lattice primitive vectors of the periodic cell as a (3, 3)
            NumPy array. Each row represents one lattice vector in the same length unit
            specified by `unit`. Reciprocal lattice vectors are computed internally as
            b1, b2, b3 = 2*pi*inv(a).T when required by downstream routines. The array
            must be convertible to floating point and have shape (3,3); otherwise an
            error may be raised when constructing the Cell.
        charges (numpy.ndarray): 1-D NumPy array of length N containing the classical
            point charges for the MM particles, or None to omit explicit charges. When
            provided, these charges are passed through to the returned Cell via the
            'charges' keyword and are used by PySCF MM/periodic routines to evaluate
            Coulomb interactions with the quantum region. If the length does not match
            the number of coordinate rows in `atoms_or_coords`, later validation in
            Cell construction or QM/MM code may raise an exception.
        radii (numpy.ndarray): 1-D NumPy array of length N giving the Gaussian charge
            distribution radii for each MM particle, or None. Values are interpreted in
            the same length unit as `unit`. Internally, radii are converted to atomic
            units (dividing by param.BOHR) unless `unit` denotes atomic units, and then
            converted to Gaussian exponents via zeta = 1 / radii**2. The resulting zeta
            array is passed to the Cell as 'zeta' to represent finite-width Gaussian
            charge distributions; if radii is None, zeta is set to None and no Gaussian
            smearing is provided. A length mismatch with `atoms_or_coords` may cause an
            error later in Cell construction.
        rcut_ewald (float): Optional cutoff distance for the Ewald summation (in the
            length unit specified by `unit`). If not None, this scalar is converted to
            atomic units (dividing by param.BOHR when `unit` is not atomic units) and
            forwarded to the Cell via the 'rcut_ewald' keyword. If None, the Cell is
            constructed without explicitly setting an Ewald cutoff (Cell defaults apply).
        rcut_hcore (float): Optional cutoff distance for one-electron (hcore) integrals
            or truncation used by periodic MM/hcore coupling (in the length unit specified
            by `unit`). If not None, this scalar is converted to atomic units (dividing
            by param.BOHR when `unit` is not atomic units) and forwarded to the Cell via
            the 'rcut_hcore' keyword. If None, no explicit hcore cutoff is set here and
            Cell defaults apply.
        unit (str): String specifying the length unit of the input coordinates, lattice
            vectors, radii, and cutoff distances. Default is "Angstrom". If `unit` does
            not represent atomic units according to the internal is_au(unit) check, all
            length quantities (a, radii, rcut_ewald, rcut_hcore) are converted to atomic
            units by dividing by param.BOHR before constructing the Cell. Use of an
            unrecognized unit string may cause incorrect conversion or downstream errors.
    
    Returns:
        Cell: A pyscf.pbc.gto.Cell instance configured to represent the MM particles and
        the periodic lattice. The returned Cell contains atom records produced from
        `atoms_or_coords` (coordinate entries patched as ghost atoms with atomic number 0),
        the lattice primitive vectors `a` (converted to atomic units if applicable), and
        MM-specific keyword entries forwarded as provided: 'charges' (the input `charges`
        array or None), 'zeta' (computed from `radii` as 1/radii**2 or None), and
        optional 'rcut_ewald' and 'rcut_hcore' cutoff values (converted to atomic units
        when `unit` is not atomic units). Construction may raise errors propagated from
        gto.format_atom, numpy conversions, or Cell initialization if inputs have
        incompatible shapes, types, or values.
    """
    from pyscf.qmmm.pbc.mm_mole import create_mm_cell
    return create_mm_cell(
        atoms_or_coords,
        a,
        charges,
        radii,
        rcut_ewald,
        rcut_hcore,
        unit
    )


################################################################################
# Source: pyscf.qmmm.mm_mole.create_mm_mol
# File: pyscf/qmmm/mm_mole.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_qmmm_mm_mole_create_mm_mol(
    atoms_or_coords: numpy.ndarray,
    charges: numpy.ndarray = None,
    radii: numpy.ndarray = None,
    unit: str = "Angstrom"
):
    """Create an MM (molecular mechanics) Mole object from coordinates and optional
    charges/radii for use in QM/MM simulations in PySCF. This function is used by
    the qmmm module to build a lightweight representation of the classical (MM)
    region: it accepts either raw Cartesian coordinates or a preformatted atom
    specification, normalizes the atom entries via gto.format_atom, converts
    Gaussian radii into the internal zeta parameter (1 / radius^2) in atomic
    units when provided, and returns a pyscf.gto.mole.Mole object that carries
    the MM atoms, their partial charges, and Gaussian width parameters for
    electrostatic embedding or other QM/MM interactions.
    
    Args:
        atoms_or_coords (numpy.ndarray or array-like): Cartesian coordinates of MM
            atoms or a preformatted atom list. When supplied as a numpy.ndarray of
            shape (N, 3) or as a sequence of coordinate tuples [(x1, y1, z1),
            (x2, y2, z2), ...], each coordinate tuple is converted to a "ghost"
            atom entry by prefixing a zero atomic symbol (0) so the resulting atom
            list becomes [(0, (x1, y1, z1)), ...]. If atoms_or_coords is already
            a formatted atom list (for example, [(symbol_or_number, (x, y, z)),
            ...]), the function leaves the entries as-is and passes them to
            gto.format_atom. The function then calls gto.format_atom(atoms,
            unit=unit) to normalize the coordinate and atom-formatting; any
            format-related errors are raised by gto.format_atom. This parameter is
            the principal geometric input used to define the MM region in QM/MM
            calculations performed with PySCF.
        charges (numpy.ndarray, optional): 1D array of partial charges for the MM
            atoms. These charges are passed directly to the returned Mole via the
            charges keyword so they become the classical point charges associated
            with each MM site. If None (the default), no explicit charges are set
            on the Mole object. If the length of charges does not match the number
            of atoms, an exception may be raised by the Mole constructor or by
            downstream code that assumes per-atom charges.
        radii (numpy.ndarray, optional): 1D array of Gaussian charge-distribution
            radii for MM atoms. When provided, the function converts radii to a
            1D numpy.ndarray of dtype float and flattens it. If unit is not the
            special atomic-unit string recognized as "au" by is_au(unit), radii are
            converted from the given unit into Bohr (atomic units) by dividing by
            param.BOHR. The internal Gaussian width parameter zeta is then
            computed as 1.0 / radii**2 and passed to the returned Mole as the
            zeta keyword. If radii is None (default), zeta is left as None and no
            Gaussian smearing is applied. Mismatched radii length relative to the
            number of atoms may raise errors from the Mole constructor or other
            downstream checks.
        unit (str): Unit string for the input coordinates and radii. Default is
            "Angstrom". The unit string is forwarded to gto.format_atom for
            coordinate interpretation. For radii conversion, the function treats
            non-atomic-unit values by dividing by param.BOHR to obtain Bohr units
            before computing zeta. If an unrecognized unit string is provided,
            gto.format_atom or is_au(unit) may produce behavior consistent with
            their own validation rules.
    
    Returns:
        pyscf.gto.mole.Mole: A Mole instance that represents the MM subsystem for
        QM/MM calculations. Practical significance: the returned Mole contains the
        normalized atom list (with ghost atoms if raw coordinates were supplied),
        the charges array (if provided) as per-atom classical charges, and the
        zeta array (if radii were provided) giving Gaussian widths for smearing the
        MM charges. There are no in-place modifications of the input arrays; the
        function constructs and returns a new Mole object. Errors are raised by
        underlying helpers (gto.format_atom, Mole constructor) when inputs are
        malformed (invalid atom format, mismatched array lengths, invalid units,
        etc.).
    """
    from pyscf.qmmm.mm_mole import create_mm_mol
    return create_mm_mol(atoms_or_coords, charges, radii, unit)


################################################################################
# Source: pyscf.scf.dhf.get_grad
# File: pyscf/scf/dhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_dhf_get_grad(
    mo_coeff: numpy.ndarray,
    mo_occ: numpy.ndarray,
    fock_ao: numpy.ndarray
):
    """DHF gradients: compute the virtual-occupied block of the Dirac–Hartree–Fock (DHF) Fock operator in the molecular orbital basis and return it flattened.
    
    Args:
        mo_coeff (numpy.ndarray): Molecular orbital coefficient matrix in the atomic-orbital (AO) basis. In the PySCF DHF context this is the AO→MO coefficient array whose columns are molecular orbitals; the code treats it as a 2-D array with shape (n_ao, n_mo) so that mo_coeff[:, i] gives the AO expansion of the i-th MO. The matrix may be real or complex depending on the calculation; its role is to transform the Fock operator from the AO basis into the MO basis to form virtual–occupied coupling elements used in gradient and response computations.
        mo_occ (numpy.ndarray): One-dimensional occupancy array for the molecular orbitals. Each entry corresponds to the occupation of the matching column in mo_coeff. The implementation determines occupied orbitals by the test (mo_occ > 0); therefore any entry strictly greater than 0 is treated as occupied and entries equal to 0 as virtual. Typical usage in the DHF workflow is to provide integer occupations (0, 1, 2) or floating occupations; the array length must equal n_mo (the number of columns of mo_coeff).
        fock_ao (numpy.ndarray): Fock matrix expressed in the atomic-orbital basis. In the DHF context this is the AO Fock operator (Hermitian in standard cases) used to build MO-space coupling. The function expects fock_ao to be a square 2-D array with shape (n_ao, n_ao) compatible with the number of rows of mo_coeff.
    
    Returns:
        numpy.ndarray: A one-dimensional NumPy array containing the virtual–occupied gradient (coupling) matrix flattened with row-major (C-style) ordering. Internally the function computes G = C_vir^H · F_AO · C_occ where C_vir are the columns of mo_coeff selected as virtual (mo_occ == 0), C_occ are the occupied columns (mo_occ > 0), and ^H denotes the conjugate transpose. The resulting G has shape (n_vir, n_occ) and is returned as a 1-D array of length n_vir * n_occ. The dtype of the returned array follows NumPy rules from the input arrays (complex if inputs are complex, otherwise real).
    
    Behavior and side effects:
        The function does not modify its inputs. Occupation selection is performed with the boolean mask occidx = (mo_occ > 0) and virtual orbitals by the complement; partial occupations (values between 0 and the maximum occupation) are treated as occupied if they are strictly positive. If the array dimensions are incompatible (for example, mo_coeff has a different number of rows than the dimensions of fock_ao, or the length of mo_occ does not match the number of columns of mo_coeff), NumPy will raise an error (typically ValueError) when attempting the matrix multiplications. This routine is intended for use in DHF gradient/response code paths within PySCF where one needs the MO-space virtual–occupied Fock couplings flattened for subsequent assembly of analytic gradients or response vectors.
    """
    from pyscf.scf.dhf import get_grad
    return get_grad(mo_coeff, mo_occ, fock_ao)


################################################################################
# Source: pyscf.scf.ghf.guess_orbspin
# File: pyscf/scf/ghf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_ghf_guess_orbspin(mo_coeff: numpy.ndarray):
    """pyscf.scf.ghf.guess_orbspin: Guess orbital spin assignments for generalized Hartree‑Fock (GHF) orbital coefficients.
    
    Guesses whether each molecular orbital is spin-up (alpha, encoded 0), spin-down (beta, encoded 1), or undetermined (encoded -1) by inspecting the orbital coefficient blocks for alpha and beta atomic orbitals (AOs). This function is used in the PySCF GHF code path to provide an initial, per-orbital spin classification when orbitals are represented in a spin-blocked AO basis. The result informs downstream logic that needs to know which orbitals are effectively pure-alpha, pure-beta, or mixed/ambiguous (for example, when building occupation patterns or performing spin-resolved analyses).
    
    Args:
        mo_coeff (numpy.ndarray): Orbital coefficient matrix with shape (nao, nmo). Each column is one molecular orbital expressed in a spin-blocked AO basis. The function interprets the first nao//2 rows as coefficients on the alpha-AO block and the remaining rows as the beta-AO block. The array is typically of a floating dtype (as produced by PySCF orbital routines). For correct behavior, the caller must provide coefficients arranged in this spin-blocked ordering; otherwise the classification will be meaningless. The function hard-codes a numerical threshold of 1e-14 to decide when coefficients are effectively zero; coefficients whose absolute value is strictly less than this threshold are treated as zero for the purpose of classification. If nao is not an even decomposition of alpha/beta AO counts or if the matrix contains NaN/Inf entries, the classification may be incorrect or yield many undetermined (-1) entries.
    
    Behavior and side effects:
        The function computes nao, nmo = mo_coeff.shape and then splits the rows into mo_a = mo_coeff[:nao//2] (alpha block) and mo_b = mo_coeff[nao//2:] (beta block). For each orbital (column), it tests whether all entries in the alpha block are below the absolute threshold (abs(...) < 1e-14); if so, that orbital is classified as a beta orbital. It similarly tests whether all entries in the beta block are below the threshold; if so, that orbital is classified as an alpha orbital. The classification encoding is: 0 for alpha, 1 for beta, and -1 for unknown/mixed when neither block is (nearly) all zero. The implementation initializes the output to -1, assigns 0 where the beta block is near-zero, then assigns 1 where the alpha block is near-zero; consequently, if both blocks are simultaneously near-zero for an orbital (both tests true), the final value will be 1 (beta) because that assignment occurs last. There are no other side effects: the function does not modify its input array and does not touch global state.
    
    Failure modes and limitations:
        If the input does not follow the expected spin-blocked row ordering, the result will be incorrect. The fixed numerical threshold (1e-14) may be inappropriate for very small- or very large-magnitude coefficient representations; callers requiring a different sensitivity should post-process the output or scale inputs prior to calling. Presence of NaN or Inf in mo_coeff can lead to unexpected boolean results and yield many undetermined classifications. If precise tie-breaking behavior for the rare case where both blocks are nearly zero matters, note that the function currently prefers beta (1) in that situation due to assignment order.
    
    Returns:
        numpy.ndarray: Integer array of length nmo with dtype int. Each element corresponds to one molecular orbital and is 0 for an orbital judged to be alpha-only, 1 for beta-only, or -1 when the orbital cannot be classified as pure alpha or beta (mixed/ambiguous). This array is intended for use in GHF initialization and spin-resolved orbital handling within PySCF.
    """
    from pyscf.scf.ghf import guess_orbspin
    return guess_orbspin(mo_coeff)


################################################################################
# Source: pyscf.scf.addons.get_ghf_orbspin
# File: pyscf/scf/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_addons_get_ghf_orbspin(
    mo_energy: numpy.ndarray,
    mo_occ: numpy.ndarray,
    is_rhf: bool = None
):
    """Get the spin label for each generalized Hartree–Fock (GHF) spin-orbital produced
    when converting closed-shell RHF or spin-unrestricted UHF molecular orbitals
    into a GHF spin-orbital ordering. This helper is used in PySCF workflows that
    expand spatial molecular orbitals into spin-orbitals (two spin states per
    spatial orbital) and need a deterministic mapping from the original RHF/UHF
    occupation and energy information to a per-GHF-orbital spin label.
    
    Behavior summary: For RHF input the function interprets a single spatial
    orbital energy array and a single occupancy array and constructs an ordering
    that places occupied GHF spin-orbitals before virtual ones, breaking
    degeneracies and open-shell ordering according to the RHF convention used in
    PySCF (doubly occupied spatial orbitals produce alpha then beta spin-orbitals,
    open-shell singly occupied orbitals produce a final alpha spin-orbital in the
    occupied block, etc.). For UHF input the function treats separate alpha and
    beta energy/occupation arrays, sorts occupied and virtual orbitals by their
    energies (using rounding to 6 decimal places and a stable sort to avoid
    spurious reordering from numerical noise), and returns a combined sequence of
    alpha/beta labels that matches the energy-based ordering. The returned array
    is intended to accompany a 2*nmo-length GHF coefficient matrix that arises
    from expanding nmo spatial orbitals into spin-orbitals.
    
    Args:
        mo_energy (numpy.ndarray): Molecular orbital energies. For RHF input this
            is a one-dimensional numpy array of length nmo containing spatial
            orbital energies. For UHF input this is a sequence/array-like where
            mo_energy[0] and mo_energy[1] are the alpha and beta orbital-energy
            arrays respectively (each of length nmo). The function uses the
            dimensionality of mo_energy[0] to guess RHF vs UHF when is_rhf is None:
            for RHF mo_energy[0] is a scalar (ndim == 0) and the function treats
            the input as RHF; for UHF mo_energy[0] is an array and the function
            treats the input as UHF. These energies determine ordering for
            degeneracy resolution and splitting between occupied and virtual sets.
        mo_occ (numpy.ndarray): Molecular orbital occupation numbers. For RHF
            input this is a one-dimensional numpy array of length nmo with values
            0, 1, or 2 (mo_occ == 2 indicates doubly occupied spatial orbitals;
            mo_occ > 0 is treated as occupied). For UHF input this is a
            two-element sequence/array-like where mo_occ[0] and mo_occ[1] are the
            alpha and beta occupation arrays respectively (each length nmo). The
            function counts mo_occ > 0 to determine occupied orbitals and uses
            mo_occ == 2 for distinguishing doubly-occupied vs singly-occupied
            orbitals in the RHF case. Correct interpretation relies on the
            PySCF occupation conventions for RHF/UHF wavefunctions.
        is_rhf (bool, optional): Flag to force interpretation of the inputs as
            RHF (True) or UHF (False). Default None causes automatic detection:
            if mo_energy[0].ndim == 0 the function assumes RHF, otherwise UHF.
            Providing an explicit boolean overrides the automatic guess. Passing
            an incorrect flag inconsistent with the shapes/contents of mo_energy
            and mo_occ will produce incorrect labels or runtime errors.
    
    Returns:
        numpy.ndarray: One-dimensional array of integer spin labels with length
        equal to 2 * nmo (where nmo is the number of spatial orbitals). Each
        element is either 0 (alpha spin) or 1 (beta spin). The i-th element gives
        the spin label of the i-th GHF spin-orbital according to the conversion
        ordering described above (occupied spin-orbitals first, then virtual
        spin-orbitals; degeneracy and open-shell conventions applied per RHF/UHF
        rules). This array is intended for use in PySCF routines that assemble or
        interpret a GHF coefficient matrix produced from RHF or UHF orbitals.
    
    Notes and side effects:
        This function has no side effects and does not modify its inputs. It uses
        numpy operations, a stable argsort, and rounding to 6 decimal places when
        comparing orbital energies for UHF to reduce ordering changes due to
        numerical noise. The function assumes PySCF-style occupation arrays and
        orbital-energy arrays; if the provided arrays have inconsistent shapes,
        nonstandard occupancy conventions, or are not numpy-compatible, the
        function may raise standard numpy exceptions (IndexError, ValueError,
        TypeError) or produce incorrect spin-label sequences. Users should ensure
        that mo_energy and mo_occ correspond to the same basis/set of spatial
        orbitals and follow the RHF/UHF conventions used throughout PySCF.
    """
    from pyscf.scf.addons import get_ghf_orbspin
    return get_ghf_orbspin(mo_energy, mo_occ, is_rhf)


################################################################################
# Source: pyscf.scf.ghf.det_ovlp
# File: pyscf/scf/ghf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_ghf_det_ovlp(
    mo1: numpy.ndarray,
    mo2: numpy.ndarray,
    occ1: numpy.ndarray,
    occ2: numpy.ndarray,
    ovlp: numpy.ndarray
):
    """pyscf.scf.ghf.det_ovlp: Compute the overlap between two different Slater determinants represented by molecular orbital (MO) coefficient arrays and produce a matrix used to build an asymmetric density matrix in generalized Hartree–Fock (GHF) calculations. This function is used in PySCF to evaluate the scalar overlap (product of singular values) of the occupied-MO subspace of one determinant with that of another, and to return the U Lambda^{-1} V^H factor needed when forming asymmetric transition or coupling density matrices.
    
    Args:
        mo1 (numpy.ndarray): MO coefficient matrix for determinant A. Each column corresponds to a molecular orbital in the basis used to compute the one-electron overlap. In practice, mo1 is provided by a GHF or other SCF calculation within PySCF and is used here to select the occupied orbital columns via occ1 for the occupied-subspace overlap.
        mo2 (numpy.ndarray): MO coefficient matrix for determinant B. Same role and format as mo1 but for the second determinant. mo2 is combined with mo1 and the atomic-orbital overlap matrix ovlp to form the occupied-orbital overlap matrix whose singular values quantify the determinant overlap.
        occ1 (numpy.ndarray): Occupation array for determinant A. This numeric array is interpreted elementwise with the condition occ1>0 indicating occupied molecular orbitals in mo1. The function uses the sum of occ1 to determine the number of electrons/occupied orbitals and to select the corresponding columns from mo1. If the total number of occupied orbitals differs from that of occ2, the function raises a RuntimeError because electronic coupling between determinants with different electron numbers is not defined.
        occ2 (numpy.ndarray): Occupation array for determinant B. Interpreted the same way as occ1 to select occupied columns of mo2. Its sum must equal the sum of occ1 (same electron count) for a valid overlap; otherwise the function raises RuntimeError('Electron numbers are not equal. Electronic coupling does not exist.').
        ovlp (numpy.ndarray): Atomic-orbital overlap matrix (AO overlap). This matrix provides the metric in the atomic orbital basis used to compute the overlap between occupied molecular orbitals of the two determinants via mo1.T.conj() @ ovlp @ mo2 when restricted to occupied columns. ovlp typically comes from the basis set integrals in PySCF SCF modules.
    
    Behavior and practical details:
        The function first checks that the total number of occupied orbitals (sum of occ1 and occ2) is equal; if not, it raises RuntimeError to indicate electronic coupling is undefined for different electron numbers. It then forms the occupied-orbital overlap matrix S_occ = mo1[:, occ1>0].T.conj() @ ovlp @ mo2[:, occ2>0]. A singular value decomposition S_occ = U @ Lambda @ V^H is performed. The scalar return value is the product of the singular values in Lambda, which serves as the determinant-like overlap between the occupied subspaces of the two determinants and is used in coupling/transition amplitude evaluations. The matrix return value x is computed as U @ Lambda^{-1} @ V^H (implemented as dot(u / s, vt) in the source) and is intended for constructing asymmetric density matrices or transition density operators between the two determinants in GHF-based workflows within PySCF.
        Note that if S_occ has zero or numerically tiny singular values, division by those singular values occurs when computing Lambda^{-1}; this may produce very large or infinite entries in x or lead to numerical instability. The function does not catch or regularize such singularities; callers should ensure occupied subspaces are compatible or apply their own regularization if needed.
    
    Returns:
        tuple: A two-item tuple (overlap_prod, x) where
            overlap_prod (float): The product of the singular values of the occupied-orbital overlap matrix S_occ. This scalar quantifies the overall overlap (determinant-like) between the two determinants' occupied subspaces and is used in computing electronic coupling or transition amplitudes.
            x (numpy.ndarray): The matrix U @ Lambda^{-1} @ V^H derived from the SVD of S_occ. This matrix is used to construct asymmetric density matrices (e.g., transition densities) between the two determinants in GHF contexts.
    
    Raises:
        RuntimeError: If numpy.sum(occ1) != numpy.sum(occ2). The error message matches the implementation: 'Electron numbers are not equal. Electronic coupling does not exist.' No other exceptions are explicitly handled; numerical issues such as division by zero when singular values are zero will propagate as floating-point warnings or produce inf/NaN entries in x.
    
    Side effects:
        None. The function performs linear algebra and returns computed values without modifying its input arrays.
    """
    from pyscf.scf.ghf import det_ovlp
    return det_ovlp(mo1, mo2, occ1, occ2, ovlp)


################################################################################
# Source: pyscf.scf.hf.Kgwh
# File: pyscf/scf/hf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_hf_Kgwh(Ei: float, Ej: float, updated_rule: bool = False):
    """pyscf.scf.hf.Kgwh computes the generalized Wolfsberg–Helmholtz (GWH) parameter used to scale off-diagonal Hamiltonian or resonance integrals in semiempirical and extended-Hückel-like approximations within the PySCF chemistry framework.
    
    This function returns a scalar floating-point parameter k_GWH derived from two input orbital-energy-like scalars Ei and Ej. The returned parameter is typically used when constructing approximate one-electron coupling (resonance) matrix elements between basis functions or atomic orbitals in semiempirical modules and HF/SCF-oriented helper code inside PySCF. By default the function returns a fixed baseline GWH value (k = 1.75) consistent with common practice; when updated_rule is set to True, it applies the modified scheme from J. Am. Chem. Soc. 100, 3686 (1978); doi:10.1021/ja00480a005, which makes the GWH parameter depend on the relative difference of Ei and Ej through a polynomial in Delta = (Ei - Ej)/(Ei + Ej).
    
    Args:
        Ei (float): First energy-like scalar input. In practice this represents a diagonal Hamiltonian value or an orbital/atomic-orbital energy used to parameterize the GWH scaling between two sites or basis functions. Must be a finite floating-point number. The function treats this value as an energy-like scalar and performs arithmetic combining it with Ej; no unit conversion is performed by this routine.
        Ej (float): Second energy-like scalar input analogous to Ei. Represents the other diagonal Hamiltonian value or orbital/atomic-orbital energy involved in the pairwise GWH estimate. Must be a finite floating-point number. The combination Ei + Ej is used as a denominator in the updated rule, so care must be taken to avoid Ei + Ej == 0.
        updated_rule (bool): Flag selecting the computation rule. If False (default), the function returns the constant baseline GWH parameter k = 1.75 (the "original rule"). If True, the function computes Delta = (Ei - Ej)/(Ei + Ej) and returns k + Delta**2 + Delta**4 * (1 - k), following the updated scheme described in J. Am. Chem. Soc. 100, 3686 (1978); doi:10.1021/ja00480a005. Use updated_rule=True when a dependence on the relative difference of Ei and Ej is desired for more nuanced semiempirical scaling.
    
    Returns:
        float: The computed generalized Wolfsberg–Helmholtz parameter (k_GWH). This scalar is intended to be multiplied into off-diagonal Hamiltonian/resonance integrals when assembling approximate one-electron coupling elements in semiempirical routines or helper functions within PySCF. The returned value is dimensionless and derived directly from the provided Ei and Ej according to the selected rule.
    
    Behavior, side effects, and failure modes:
        - Pure function with no side effects; does not modify inputs or global state.
        - Default behavior (updated_rule=False) returns the constant 1.75; this is the simplest approximation and is inexpensive to evaluate.
        - When updated_rule=True the computation performs a division by (Ei + Ej). If Ei + Ej == 0, a ZeroDivisionError will be raised by Python. Callers must ensure Ei + Ej is nonzero or handle the exception.
        - The routine does not validate units; inputs should be provided consistently (same energy units) because only their ratio and sum are used.
        - Inputs that are NaN or infinite will propagate resulting NaN/inf outputs; callers should sanitize inputs if necessary.
        - No additional logging, I/O, or stateful behavior occurs.
    """
    from pyscf.scf.hf import Kgwh
    return Kgwh(Ei, Ej, updated_rule)


################################################################################
# Source: pyscf.scf.diis.get_err_vec_orth
# File: pyscf/scf/diis.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_diis_get_err_vec_orth(
    s: numpy.ndarray,
    d: numpy.ndarray,
    f: numpy.ndarray,
    Corth: numpy.ndarray
):
    """Compute the SCF DIIS error vector in an orthonormal molecular-orbital basis.
    
    Args:
        s (numpy.ndarray): Overlap matrix S or a stack of overlap matrices. In PySCF SCF routines S represents the atomic-orbital overlap integrals used to form the Fock/diagonalization problem; here s is used with density and Fock operators to form the commutator-like quantity (S D F - F D S). Expected as a 2-D array for a single problem or a 3-D array where the first axis indexes a batch of problems (for example multiple k-points or replicated contexts) that must match f and, when applicable, s.ndim==3.
        d (numpy.ndarray): Density matrix D or a stack of density matrices with the same batching convention as s and f. D provides the electronic occupancy information used in the error expression S D F - F D S. For UHF cases d may be an array-like container with separate spin blocks (the code handles the spin blocks when f has an extra leading axis of length 2).
        f (numpy.ndarray): Fock matrix F or a stack of Fock matrices. For the common restricted/HF case f is a 2-D array; when s is 3-D and f.ndim==3 the function computes error vectors for each element along the leading axis and concatenates them; for unrestricted (UHF) the implementation recognizes the pattern f.ndim == s.ndim + 1 with f.shape[0] == 2 and concatenates the alpha and beta error vectors. f participates in the matrix product that yields the quantity C^H (S D F - F D S) C.
        Corth (numpy.ndarray): Orthonormal orbital coefficient matrix C in the basis where the orbital overlap is identity, or a stack of such matrices matching the batching convention of s and f. Corth is used to transform the operator S D F - F D S into the orthonormal molecular-orbital representation via Corth.conj().T @ (...) @ Corth. If the Corth object has an attribute named orbsym, that symmetry array is used to build a symmetry mask (orbsym[:, None] != orbsym) to zero matrix elements that are symmetry-forbidden; this reduces numerical noise in DIIS builds (see issue referenced in source).
    
    Behavior and details:
        The function evaluates the operator difference in the orthonormal MO basis given by
        Corth.conj().T @ (s @ d @ f - f @ d @ s) @ Corth,
        which corresponds to the error vector employed by Pulay DIIS in SCF iterations. For the 2-D case (f.ndim == 2) a single error matrix is computed and returned flattened by row-major ravel(). For the 3-D batched case (f.ndim == 3 and s.ndim == 3) the routine computes the error matrix for each batch index i using Corth[i], s[i], d[i], f[i], applies the optional symmetry mask to set symmetry-forbidden elements to zero, flattens each error matrix, and horizontally stacks the flattened vectors into a single 1-D array. For the common unrestricted/HF pattern (f.ndim == s.ndim + 1 and f.shape[0] == 2) the function computes and concatenates the alpha and beta spin error vectors by recursive calls.
        The function respects complex arithmetic: conjugate-transpose (Corth.conj().T) is used consistently, and the returned error vector is constructed as (sdf.conj().T - sdf).ravel() so that anti-Hermitian parts appear correctly in complex-valued calculations.
        If Corth contains an attribute orbsym, it is expected to be indexable as orbsym[:] and used only to form the boolean mask sym_forbid = orbsym[:, None] != orbsym; elements of the transformed error matrix that correspond to True in that mask are set to zero prior to flattening to reduce numerical error in DIIS.
    
    Side effects:
        The function does not modify its input arrays in-place; it reads s, d, f, and Corth and returns a new numpy.ndarray. The only non-local behavior is reading the optional attribute Corth.orbsym if present; no other global state is accessed or mutated.
    
    Failure modes:
        If the shapes/dimensions of s, d, f, and Corth do not match one of the handled patterns (2-D Fock for RHF-like cases; matched 3-D batching where f.ndim==3 and s.ndim==3; or the UHF pattern where f.ndim == s.ndim + 1 and f.shape[0] == 2), the function raises RuntimeError('Unknown SCF DIIS type'). Mismatched leading axes between s, d, f, and Corth in the batched case will produce index or broadcasting errors or trigger the RuntimeError. The function assumes inputs are numpy.ndarray and uses their ndim attributes; providing other array-like types may lead to attribute errors.
    
    Returns:
        numpy.ndarray: A one-dimensional numpy array containing the flattened error vector(s). For a single 2-D problem this is the flattened matrix (Corth.conj().T (SDF - FDS) Corth). For batched or UHF inputs the return is the horizontal concatenation of each batch or spin-block error vector, in the same order as the leading axis of the inputs. The array may be complex-valued when inputs are complex.
    """
    from pyscf.scf.diis import get_err_vec_orth
    return get_err_vec_orth(s, d, f, Corth)


################################################################################
# Source: pyscf.scf.hf.eig
# File: pyscf/scf/hf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_hf_eig(h: numpy.ndarray, s: numpy.ndarray):
    """pyscf.scf.hf.eig solves the generalized Hermitian eigenvalue problem HC = S C E used in Hartree–Fock / Roothaan-style electronic-structure calculations, where H is the one-electron (core or Fock) matrix in an atomic-orbital (AO) basis, S is the AO overlap matrix, C contains eigenvectors (molecular-orbital coefficients) as columns, and E is the diagonal matrix of eigenvalues. This function delegates the linear-algebra work to scipy.linalg.eigh and then enforces a deterministic sign convention on the returned eigenvectors to improve reproducibility in downstream PySCF workflows.
    
    Args:
        h (numpy.ndarray): Real or complex square matrix representing the Hamiltonian or Fock operator in the AO basis. In PySCF usage this is typically the core-Hamiltonian or Fock matrix assembled from one- and two-electron integrals. h must be Hermitian (real symmetric for real-valued calculations) and have the same shape as s. The function does not modify h.
        s (numpy.ndarray): Real or complex square overlap matrix in the same AO basis as h. In typical quantum-chemistry use, s is the AO overlap matrix and is expected to be Hermitian and (for a well-posed generalized eigenproblem) positive-definite. s must have the same shape as h. The function does not modify s.
    
    Returns:
        e (numpy.ndarray): One-dimensional array of eigenvalues (length n for an n-by-n input), returned in ascending order as produced by scipy.linalg.eigh. In the electronic-structure context these correspond to orbital energies for the provided H and S.
        c (numpy.ndarray): Two-dimensional array of eigenvectors with shape (n, n). Each column c[:, j] is the eigenvector (molecular-orbital coefficients in the AO basis) associated with eigenvalue e[j]. The eigenvectors are normalized according to the generalized eigenproblem convention returned by scipy.linalg.eigh (i.e., they satisfy C^H S C = I within numerical precision). After computation, the routine enforces a deterministic phase/sign convention: for each column the element with largest absolute real part is chosen and, if its real part is negative, the entire column is multiplied by -1. This post-processing is intended to make the sign of eigenvectors reproducible across runs; it uses only the real part to decide the flip, so for strongly complex eigenvectors the phase is only partially fixed.
    
    Behavior, side effects, and failure modes:
        This function calls scipy.linalg.eigh(h, s) to solve the Hermitian generalized eigenproblem h c = s c e. scipy.linalg.eigh requires h and s to be Hermitian (s typically positive-definite); if these conditions are violated the underlying LAPACK routine may raise scipy.linalg.LinAlgError or produce NaNs/invalid results. The function itself does not validate matrix Hermiticity beyond what scipy enforces, nor does it regularize or perturb s; callers should ensure s is well-conditioned for the generalized problem (in PySCF this is normally the case for properly constructed AO overlap matrices). No global state is modified; only the returned eigenvector array c is post-processed in-place to enforce the sign convention. The routine preserves the numerical ordering of eigenvalues provided by scipy.linalg.eigh (ascending) and returns arrays suitable for immediate use in constructing density matrices or orbital-based quantities in SCF and post-SCF modules.
    """
    from pyscf.scf.hf import eig
    return eig(h, s)


################################################################################
# Source: pyscf.scf.hf.dot_eri_dm
# File: pyscf/scf/hf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_hf_dot_eri_dm(
    eri: numpy.ndarray,
    dm: numpy.ndarray,
    hermi: int = 0,
    with_j: bool = True,
    with_k: bool = True
):
    """Compute Coulomb (J) and exchange (K) matrices from two-electron integrals and density matrix(es) for use in Hartree–Fock and related SCF procedures.
    
    This function is used in the PySCF SCF machinery to build the two-electron contribution to the Fock matrix: the Coulomb matrix J and the exchange matrix K. It accepts either a full 4-index eri array (reshaped to (N,N,N,N)) or an 8-fold compressed ERI representation handled by the internal _vhf.incore routine. The density matrix input may be a single density matrix or a stack/list of density matrices; the function returns J and K with matching layout and dtype to the input and computed integrals.
    
    Args:
        eri (ndarray): 8-fold or 4-fold electron repulsion integrals (ERIs) or a complex integral array containing N**4 elements, where N is the number of orbitals. If eri.dtype is complex128 or eri.size == nao**4, the array is interpreted as a full (N,N,N,N) tensor and is reshaped accordingly; otherwise the implementation dispatches to pyscf.scf._vhf.incore to process compact ERI formats. The eri determines which computational path is used (direct einsum over the full tensor, or _vhf.incore for packed formats) and therefore influences memory and CPU tradeoffs.
        dm (ndarray or list of ndarrays): A single density matrix with shape (..., N, N) or a list/stack of density matrices. The last two dimensions must be square with size N (number of orbitals). The function converts dm to a NumPy array and treats the leading dimension as the index over multiple density matrices; a single (N,N) matrix will produce single (N,N) J and K outputs, while an (M,N,N) array produces M J and M K matrices. If dm is complex128, the function separates real and imaginary parts and combines results (real part processed with the hermi flag, imaginary part processed with hermi=0) so that complex density matrices are supported.
        hermi (int): Whether to enforce hermiticity/symmetry in the computed J and K when the internal _vhf.incore path is used. This flag controls how symmetric/antisymmetric contributions are treated when integrals are supplied in packed (non-full-tensor) form.
            0 : no hermitian or symmetric enforcement (default). The function will not assume hermiticity and will compute J/K as-is.
            1 : hermitian. Instructs the underlying routine to return hermitian (conjugate symmetric) J/K consistent with real-symmetric density matrices where applicable.
            2 : anti-hermitian. Instructs the underlying routine to treat results as anti-hermitian when that is required by the integral/density conventions.
        with_j (bool): If True (default), compute and return the Coulomb (J) matrix/matrices. If False, skip computing J and return None for the J position. Skipping can save computation if only K is required.
        with_k (bool): If True (default), compute and return the exchange (K) matrix/matrices. If False, skip computing K and return None for the K position. Skipping can save computation if only J is required.
    
    Returns:
        tuple: A pair (vj, vk) where vj is the Coulomb matrix or array of Coulomb matrices and vk is the exchange matrix or array of exchange matrices corresponding to the input density matrix/matrices:
            vj (ndarray or None): If dm was a single (N,N) array, vj is (N,N). If dm was (M,N,N), vj is (M,N,N). If with_j is False, vj is None. The dtype follows the computation path: when eri is complex or eri.size == N**4 the result preserves complex dtype; when _vhf.incore is used for real integrals, the dtype matches dm.real (and imaginary contributions are added for complex dm).
            vk (ndarray or None): Same layout and conventions as vj but for exchange matrices. If with_k is False, vk is None.
    
    Behavior, side effects, defaults, and failure modes:
        - Data layout and reshaping: The function calls numpy.asarray(dm) and infers nao = dm.shape[-1]. For full-tensor ERIs (eri.dtype == complex128 or eri.size == nao**4) eri is reshaped as (nao,nao,nao,nao) and NumPy einsum is used: J ~ einsum('ijkl,xji->xkl') and K ~ einsum('ijkl,xjk->xil'). For compact/8-fold ERI representations (typical packed format used in PySCF), the function delegates to pyscf.scf._vhf.incore(eri, dm.real, hermi, with_j, with_k).
        - Complex densities: If dm.dtype is complex128 while eri follows the packed/real path, the function computes J/K for the real part with the provided hermi and for the imaginary part with hermi=0, then combines them as v = v_real + 1j * v_imag. This preserves correct complex linearity for complex density matrices.
        - Performance and memory: Using the full (N,N,N,N) path (einsum) requires holding an N**4 array in memory; using packed ERI formats with _vhf.incore may be more memory-efficient but relies on the implementation of _vhf.incore and the hermi flag to exploit permutational symmetry. Choosing with_j/with_k can reduce work if only one of J or K is needed.
        - Error conditions: The function will raise standard NumPy exceptions if shapes are incompatible (for example, if eri cannot be reshaped to (N,N,N,N) when expected, or if the last two dimensions of dm are not square or do not match the orbital count implied by eri). Passing invalid types that cannot be converted to ndarray will also raise. Mismatched sizes between eri and dm lead to ValueError or IndexError from NumPy operations.
        - Side effects: This function has no external side effects (it does not modify global state). It may call pyscf.scf._vhf.incore which performs in-core ERI processing; that call is internal and its behavior affects runtime but does not mutate inputs.
    
    Practical significance in PySCF:
        - dot_eri_dm is a core utility used by PySCF SCF implementations to obtain the two-electron contributions to the Fock matrix from stored integrals and density matrices. Accurate and efficient J/K construction is critical for Hartree–Fock energy and gradient evaluations and for hybrid density functional calculations that include exact exchange.
    """
    from pyscf.scf.hf import dot_eri_dm
    return dot_eri_dm(eri, dm, hermi, with_j, with_k)


################################################################################
# Source: pyscf.scf.hf.unpack_uniq_var
# File: pyscf/scf/hf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_hf_unpack_uniq_var(dx: numpy.ndarray, mo_occ: numpy.ndarray):
    """unpack_uniq_var fills the full orbital-gradients (orbital-rotation) matrix from a compact vector of unique variables used in self-consistent field (SCF) orbital optimization routines in the PySCF quantum chemistry framework.
    
    Args:
        dx (numpy.ndarray): One-dimensional array containing the unique independent orbital-rotation variables (orbital-gradient components) as produced by routines that extract only the independent entries of the orbital-rotation matrix. In the SCF/HF context used across pyscf.scf.hf, dx holds the compact set of complex or real entries that parameterize the anti-Hermitian orbital-rotation generator. The dtype of the returned matrix is preserved from dx.dtype. The length of dx must match the number of entries selected by uniq_var_indices(mo_occ); otherwise numpy will raise a broadcasting/assignment error (typically ValueError).
        mo_occ (numpy.ndarray): One-dimensional occupancy array of molecular orbitals with length nmo (nmo = len(mo_occ)). Each element encodes the occupation of the corresponding molecular orbital (commonly integers 0, 1, or 2 in restricted calculations). mo_occ is used to determine which matrix elements are independent via uniq_var_indices(mo_occ), so its length and contents determine the structure and size of the unpacked orbital-rotation matrix.
    
    Returns:
        numpy.ndarray: A new two-dimensional numpy.ndarray shaped (nmo, nmo) containing the full orbital-rotation (orbital-gradient) matrix reconstructed from dx. The matrix equals X - X.conj().T where X is an intermediate matrix with dx placed into the positions indicated by uniq_var_indices(mo_occ). The returned matrix is anti-Hermitian (skew-Hermitian), has dtype dx.dtype, and is suitable for use as an orbital-rotation generator or full gradient in SCF procedures. No in-place modification of dx or mo_occ occurs. If mo_occ is empty or dx does not match the expected number of unique variables, numpy will raise an error during assignment.
    """
    from pyscf.scf.hf import unpack_uniq_var
    return unpack_uniq_var(dx, mo_occ)


################################################################################
# Source: pyscf.scf.hf.pack_uniq_var
# File: pyscf/scf/hf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_hf_pack_uniq_var(x: numpy.ndarray, mo_occ: numpy.ndarray):
    """pyscf.scf.hf.pack_uniq_var extracts the independent (unique) variables from a full orbital-gradient or orbital-rotation array used in Hartree–Fock / self-consistent-field (SCF) orbital optimization.
    
    This function is used in PySCF's SCF/HF modules to reduce the number of parameters passed to optimizers or response routines by selecting only the non-redundant elements of an orbital-gradient or orbital-rotation representation. The selection of which elements are considered "unique" is determined from the molecular orbital occupation pattern (mo_occ) via the helper function uniq_var_indices(mo_occ). In practical computational-chemistry workflows, this reduction removes redundant rotations (for example, rotations that are symmetry- or occupation-related) so that downstream algorithms operate on the minimal set of independent orbital-rotation variables, improving efficiency and stability.
    
    Args:
        x (numpy.ndarray): Array containing the full orbital-gradients or orbital-rotation variables. This array must be indexed in the same ordering convention expected by PySCF’s orbital-rotation machinery (i.e., the same ordering used by uniq_var_indices). The array can be any numpy.ndarray type that supports integer or boolean indexing; the function will return the subset x[idx] where idx is computed from mo_occ. Practical significance: x typically arises from gradient or rotation computations in HF/SCF procedures and may contain redundant entries corresponding to dependent orbital rotations.
        mo_occ (numpy.ndarray): One-dimensional numpy array of molecular orbital occupation numbers that defines which orbital pairs produce independent rotation variables. The occupation pattern (e.g., occupied vs virtual orbitals) is used by uniq_var_indices to compute index positions of unique variables. In practice, mo_occ is the array of occupation numbers from an SCF calculation (same length as the number of molecular orbitals) and determines which elements of x are retained as independent parameters.
    
    Returns:
        numpy.ndarray: A numpy array containing only the selected unique variables from x, in the same relative order as produced by indexing x with the indices returned by uniq_var_indices(mo_occ). The returned array is suitable for use by optimizers and response routines that require only independent orbital-rotation parameters.
    
    Behavior and side effects:
    - The function internally calls uniq_var_indices(mo_occ) to compute the indices of independent variables and then returns x[idx]. There are no other side effects; x and mo_occ are not modified.
    - The function preserves the ordering of variables as determined by uniq_var_indices. It does not reshape or otherwise transform the selected values beyond basic numpy indexing semantics.
    
    Failure modes and errors:
    - If mo_occ does not have the expected 1D structure or contains invalid values required by uniq_var_indices, uniq_var_indices may raise an error (e.g., ValueError or TypeError) which will propagate to the caller.
    - If the indices computed by uniq_var_indices are out of bounds for x, numpy indexing will raise an IndexError.
    - If x does not support the required indexing (for example, not a numpy.ndarray), a TypeError or IndexError may be raised by numpy indexing operations.
    
    No defaults are applied by this function; both x and mo_occ must be provided.
    """
    from pyscf.scf.hf import pack_uniq_var
    return pack_uniq_var(x, mo_occ)


################################################################################
# Source: pyscf.scf.hf.uniq_var_indices
# File: pyscf/scf/hf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_hf_uniq_var_indices(mo_occ: numpy.ndarray):
    """uniq_var_indices returns a boolean mask selecting the unique orbital-rotation variables
    (occupied→virtual rotations) used when forming orbital-gradients in the SCF code.
    This function is used in PySCF's self-consistent field (SCF) procedures to identify
    which matrix elements of the orbital-rotation (gradient) matrix correspond to
    independent rotation parameters for alpha and beta spin manifolds. In practical
    electronic-structure work within PySCF, the mask produced by this function is used
    to assemble and compress gradient and Hessian blocks by keeping only the unique
    occupied→virtual rotational degrees of freedom.
    
    Args:
        mo_occ (numpy.ndarray): One-dimensional array of molecular orbital occupation
            numbers for all molecular orbitals (length nmo). Each entry encodes the
            occupation of the corresponding molecular orbital: an entry > 0 is treated
            as occupied for the alpha-spin manifold, and an entry equal to 2 is treated
            as occupied for the beta-spin manifold. Typical values in PySCF SCF contexts
            are 0, 1, or 2, but any numeric values are handled according to the
            comparisons performed here (mo_occ > 0 and mo_occ == 2). The array must
            therefore be indexable as a 1-D numpy.ndarray; if it is not one-dimensional
            or not numpy-backed, the function may raise an IndexError or otherwise yield
            shape/broadcasting errors.
    
    Returns:
        numpy.ndarray: A boolean mask with shape (nmo, nmo) where nmo is len(mo_occ).
        An entry mask[i, j] is True if and only if the matrix element corresponding to
        a rotation from orbital j (occupied) to orbital i (virtual) is one of the
        unique variables to retain when building orbital-gradients. Concretely, mask
        is True when (i is virtual for alpha AND j is occupied for alpha) OR
        (i is virtual for beta AND j is occupied for beta), using the occupancy tests
        described above. The returned mask has no side effects; it does not modify
        mo_occ. If mo_occ has unexpected shape or dtype, the function may raise a
        broadcasting/indexing error rather than a controlled ValueError.
    """
    from pyscf.scf.hf import uniq_var_indices
    return uniq_var_indices(mo_occ)


################################################################################
# Source: pyscf.scf.hf.get_grad
# File: pyscf/scf/hf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_hf_get_grad(
    mo_coeff: numpy.ndarray,
    mo_occ: numpy.ndarray,
    fock_ao: numpy.ndarray
):
    """Compute the restricted Hartree–Fock (RHF) orbital gradient vector in the molecular
    orbital (MO) basis for use in PySCF electronic structure routines.
    
    This function is part of the PySCF (Python-based Simulations of Chemistry Framework)
    toolset and is used to form the occupied–virtual block of the Fock matrix in the MO
    representation for closed-shell RHF calculations. The output is commonly used by SCF
    response, orbital-rotation, and post-Hartree–Fock procedures that require the coupling
    between occupied and virtual spatial orbitals.
    
    Args:
        mo_coeff (2D ndarray): Obital coefficients. Array of molecular orbital
            coefficients expressed in the atomic orbital (AO) basis with shape
            (n_ao, n_mo). Each column is an MO coefficient vector. The function uses
            these coefficients to form the occupied and virtual MO subblocks via
            projection of the AO Fock matrix into the MO basis.
        mo_occ (1D ndarray): Orbital occupancy. One-dimensional array of length n_mo
            giving the occupancy of each MO. Entries with value > 0 are treated as
            occupied (internally occidx = mo_occ > 0) and entries with value <= 0 are
            treated as virtual. This routine follows the source-code rule that any
            positive occupancy marks an occupied orbital; fractional occupancies > 0
            will be classified as occupied accordingly.
        fock_ao (2D ndarray): Fock matrix in AO representation. Square AO-basis Fock
            matrix with shape (n_ao, n_ao). This matrix is multiplied by the MO
            coefficients to obtain the occupied–virtual MO block.
    
    Behavior and details:
        The function partitions molecular orbitals into occupied and virtual sets using
        mo_occ > 0, constructs the occupied and virtual MO coefficient submatrices
        C_occ and C_vir from mo_coeff, and computes the matrix product
        G_matrix = C_vir^H · F_ao · C_occ. For closed-shell RHF the result is scaled by
        a factor of 2 (accounting for spin degeneracy of spatial orbitals), so the
        implemented expression is G_matrix * 2. The routine applies a Hermitian transpose
        (conj().T) to the virtual MO coefficient block so complex-valued MO coefficients
        are handled correctly. The computed G_matrix has shape (n_vir, n_occ) and is
        then flattened in row-major (C) order to produce the returned 1D vector: the
        first n_occ elements correspond to couplings between the first virtual orbital
        and all occupied orbitals, the next n_occ elements correspond to the second
        virtual orbital, and so on.
    
    Side effects:
        This function has no external side effects; it performs only array operations
        and returns the computed gradient vector.
    
    Failure modes and input validation:
        The function does not perform explicit shape validation beyond relying on NumPy
        operations. If the input arrays have incompatible shapes (for example
        mo_coeff.shape[0] != fock_ao.shape[0], or mo_coeff.shape[1] != mo_occ.shape[0]),
        NumPy will raise an exception (e.g., ValueError or a broadcasting error) during
        the dot-product operations. If all orbitals are classified as occupied or all
        as virtual, the function will return an empty 1D array with length zero.
        Users should ensure mo_coeff, mo_occ, and fock_ao are consistent and conform to
        the AO/MO conventions used in PySCF.
    
    Returns:
        1D ndarray: Flattened gradient vector in the MO representation with length
        n_occ * n_vir, containing the entries of 2 * (C_vir^H · F_ao · C_occ) flattened
        in C order (shape flattened from (n_vir, n_occ)). This vector encodes the
        occupied–virtual orbital couplings for RHF and is intended for use by SCF
        response, orbital rotation updates, and other PySCF routines that operate on
        MO-gradient vectors.
    """
    from pyscf.scf.hf import get_grad
    return get_grad(mo_coeff, mo_occ, fock_ao)


################################################################################
# Source: pyscf.scf.hf.level_shift
# File: pyscf/scf/hf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_hf_level_shift(
    s: numpy.ndarray,
    d: numpy.ndarray,
    f: numpy.ndarray,
    factor: float
):
    """pyscf.scf.hf.level_shift applies an energy level shift to virtual molecular orbitals in Hartree–Fock self-consistent-field (SCF) procedures to improve convergence by increasing the Fock matrix diagonal elements associated with virtual space.
    
    This routine constructs an operator that projects onto the virtual-space block in the atomic-orbital (AO) representation and adds a uniform energy offset Delta (the level shift) to that virtual-space block of the Fock matrix. In PySCF workflows this is used when performing SCF iterations to discourage occupation of virtual orbitals and to stabilize convergence in difficult cases (e.g., near-degeneracies or variational collapse). The implementation follows the algebraic form F_new = F + (S - S D S) * Delta, where S is the AO overlap matrix, D is the AO density matrix (occupied-space projector), and F is the current AO Fock matrix.
    
    Args:
        s (numpy.ndarray): AO overlap matrix S. A 2D numpy.ndarray containing overlap integrals between atomic-orbital basis functions in the same basis used to form d and f. This matrix is used to form the projector onto the virtual subspace via the expression S - S @ D @ S. The array must be a numeric 2D array compatible with matrix multiplication with d and f; mismatched shapes will raise standard NumPy errors.
        d (numpy.ndarray): AO density matrix D. A 2D numpy.ndarray representing the current SCF density (occupied-space projector) in the same AO basis as s and f. d is used to remove the occupied-space contribution from the identity in the S-weighted projector S - S D S. The array must be numeric and conformable with s and f for matrix multiplication.
        f (numpy.ndarray): AO Fock matrix F. A 2D numpy.ndarray representing the current Fock operator in the AO basis. The function returns a modified copy of this matrix with the level shift added to the virtual-space block; f itself is not modified in place by this function (the operation returns a new array).
        factor (float): Level shift magnitude Delta. A floating-point scalar with the same energy units as the entries of f. This value is multiplied by the AO virtual-space projector (S - S D S) and added to f to produce the shifted Fock matrix. Choosing a nonzero factor increases virtual orbital energies; very large values can overly bias the solution and impede obtaining a physically meaningful SCF result.
    
    Returns:
        numpy.ndarray: New Fock matrix after applying the level shift. A 2D numpy.ndarray equal to f + (s - s @ d @ s) * factor. The returned array is a separate object (the input f is not overwritten). Errors and failure modes include exceptions from NumPy operations if the inputs have incompatible shapes or contain non-finite values (NaN or Inf), and numerical deterioration of the SCF solution or loss of physical fidelity if factor is chosen inappropriately large.
    """
    from pyscf.scf.hf import level_shift
    return level_shift(s, d, f, factor)


################################################################################
# Source: pyscf.scf.hf.make_rdm1
# File: pyscf/scf/hf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_hf_make_rdm1(mo_coeff: numpy.ndarray, mo_occ: numpy.ndarray, **kwargs):
    """Construct the one-particle reduced density matrix (RDM1) in the atomic-orbital (AO)
    representation from molecular orbital coefficients and orbital occupancies. This
    function is used in PySCF SCF/Hartree–Fock workflows to obtain the AO-basis
    electron density matrix gamma = sum_i n_i |phi_i><phi_i|, which is consumed by
    energy and property evaluators elsewhere in the package.
    
    Args:
        mo_coeff (2D ndarray): Orbital coefficients in the AO basis. Each column of
            this matrix is a molecular orbital expressed in AO basis functions. The
            expected shape is (n_ao, n_mo) where n_ao is the number of atomic
            orbitals (basis functions) and n_mo is the number of molecular orbitals.
            These coefficients are used as the basis transformation to build the AO
            density matrix from MO occupancies; complex-valued coefficients are
            supported and handled via conjugation in the construction.
        mo_occ (1D ndarray): Orbital occupancies. A one-dimensional array of length
            n_mo (must match mo_coeff.shape[1]) giving the occupancy (typically
            integer or float) assigned to each molecular orbital. Orbitals with
            mo_occ > 0 are treated as occupied and contribute to the RDM1 with
            weight equal to their occupancy. Fractional occupancies are supported
            by weighting the contribution of each orbital by its occupancy value.
        kwargs (dict): Additional keyword arguments accepted for API compatibility.
            This implementation does not consume or forward these kwargs; they are
            ignored. No side effects result from providing kwargs to this function.
            Users should not rely on kwargs to alter behavior of make_rdm1.
    
    Behavior and side effects:
        The function selects columns of mo_coeff for which the corresponding
        entries in mo_occ are positive (mo_occ > 0), forms mocc = mo_coeff[:, mo_occ>0],
        and computes the AO density matrix as dm = (mocc * mo_occ[mo_occ>0]).dot(mocc.conj().T).
        Concretely, this realizes the weighted projector sum gamma = sum_i n_i |phi_i><phi_i|
        in the AO basis. If no orbital has mo_occ > 0, the result is the (n_ao, n_ao)
        zero matrix. The returned array is wrapped/tagged using lib.tag_array with
        mo_coeff and mo_occ attached as metadata (this metadata is used elsewhere in
        PySCF to trace origin of the density matrix). The function does not modify
        its input arrays.
    
    Failure modes and constraints:
        mo_coeff must be a 2D ndarray and mo_occ must be a 1D ndarray whose length
        equals mo_coeff.shape[1]. If these dimensionality/shape assumptions are not
        met, NumPy indexing or broadcasting will raise an exception (e.g., IndexError
        or ValueError) from the underlying array operations. Values in mo_occ that
        are negative are treated as unoccupied (they do not contribute to the RDM1).
    
    Returns:
        2D ndarray: One-particle density matrix in the AO representation with shape
        (n_ao, n_ao). The matrix equals the weighted sum over occupied molecular
        orbitals gamma = sum_i n_i |phi_i><phi_i|, constructed from mo_coeff and
        mo_occ. The returned array is tagged (via lib.tag_array) with the original
        mo_coeff and mo_occ as metadata for downstream use in PySCF.
    """
    from pyscf.scf.hf import make_rdm1
    return make_rdm1(mo_coeff, mo_occ, **kwargs)


################################################################################
# Source: pyscf.scf.ghf.spin_square
# File: pyscf/scf/ghf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_ghf_spin_square(mo: list, s: numpy.ndarray = 1):
    """pyscf.scf.ghf.spin_square computes the expectation value of the total spin-squared operator S^2 and the corresponding spin multiplicity (2S+1) for a Generalized Hartree–Fock (GHF) / unrestricted HF (UHF) wavefunction described by occupied molecular orbitals. This function is used in PySCF to quantify the spin and spin-contamination of an electronic mean-field wavefunction constructed from occupied alpha and beta orbitals and an atomic-orbital (AO) overlap matrix, for example after an scf.UHF calculation.
    
    The implementation evaluates S^2 = 1/2 (S+ S- + S- S+) + Sz^2 by forming occupied-space overlap matrices for alpha and beta spin channels (saa, sbb) and the cross overlap (sab), then computing same-electron and two-electron contributions for S+S-, S-S+, and Sz^2. The returned values are suitable for diagnosing spin contamination and reporting the spin expectation and multiplicity in post-SCF analysis within the PySCF quantum-chemistry framework.
    
    Args:
        mo (list): Occupied alpha and occupied beta orbitals provided as a length-2 Python list whose first element is a numpy.ndarray of occupied alpha orbital coefficients and whose second element is a numpy.ndarray of occupied beta orbital coefficients. Each array should have shape (nao, nocc_alpha) and (nao, nocc_beta) respectively, where nao is the number of atomic orbitals (AO) in the basis and nocc_alpha/nocc_beta are the counts of occupied spin-orbitals in each spin channel. In the practical PySCF workflow this argument is typically obtained from an SCF object as (mf.mo_coeff[0][:,mf.mo_occ[0]>0], mf.mo_coeff[1][:,mf.mo_occ[1]>0]). The function uses these matrices to build occupied-space overlap matrices (saa, sbb, sab) and to compute traces and two-particle contraction terms that define S^2. If the shapes do not match the AO dimension assumptions (for example, mismatched nao between alpha and beta arrays), the function will raise an error (see Failure modes).
    
        s (numpy.ndarray): AO overlap information. By default this parameter is provided as the scalar 1 (the function signature default) which is treated numerically as the identity overlap in the AO basis (equivalent to orthonormal AO basis where overlap matrix is the identity); in typical usage callers pass the AO overlap matrix returned by mol.intor('int1e_ovlp_sph'). When s is a numpy.ndarray it must encode the AO overlap. Two ndarray layouts are accepted by the implementation but are both represented here as the same ndarray type: either a square overlap matrix of shape (nao, nao) or a two-spin-block matrix of shape (2*nao, 2*nao) whose alpha and beta AO overlap diagonal blocks are identical. When s is a numpy.ndarray the function asserts that s.size equals nao**2 or that the top-left and bottom-right blocks are numerically equal; the code then uses the top-left nao-by-nao block as the AO overlap matrix. The AO overlap matrix is used to form occupied-space overlap matrices via contractions mo_alpha^H * s * mo_alpha, mo_beta^H * s * mo_beta and mo_alpha^H * s * mo_beta, which are the basic building blocks for the S^2 expectation. Providing an incorrect-shaped or inconsistent overlap array will raise an AssertionError (see Failure modes).
    
    Behavior, side effects, defaults, and failure modes:
        This function is pure with respect to external state: it performs numerical linear-algebra operations on the provided arrays and returns two floating-point results without mutating the inputs. Default behavior: if s is left as the default scalar 1, the function treats the AO basis as orthonormal and computes overlaps using mo^T @ mo. When s is a numpy.ndarray the function extracts and uses the upper-left nao-by-nao block as the AO overlap; if the provided ndarray is a 2*nao-by-2*nao matrix the function checks that the alpha and beta diagonal blocks are identical and then uses the alpha block. Failure modes: the function will raise an AssertionError if s is a numpy.ndarray but its size does not equal nao**2 and the diagonal blocks are not numerically identical; it will raise standard numpy errors (e.g., AttributeError, ValueError) if mo is not a length-2 list of ndarrays with compatible shapes (for example, missing attributes like shape or mismatched AO dimensions), or if the dot products cannot be computed because of dimension mismatches. Numerically, the final S^2 value is returned as the real part of the computed complex expression; tiny numerical imag parts are discarded by taking .real. The multiplicity is computed from the effective S returned by S = sqrt(S^2 + 1/4) - 1/2 and then 2S+1 is returned; for pathological negative S^2 results due to numerical noise the square-root expression may produce NaN/-Inf and propagate; such issues indicate ill-conditioned input matrices.
    
    Returns:
        list of two floats: A two-element list where the first element is the expectation value of the total-spin operator S^2 for the GHF/UHF wavefunction defined by the provided occupied orbitals and AO overlap, and the second element is the corresponding spin multiplicity 2S+1 computed from the returned S value. The first float is the physically meaningful S^2 expectation used to assess spin contamination (for example a pure doublet has S^2 approx 0.75), and the second float provides the usual multiplicity reported in quantum-chemistry output. No other side effects occur; inputs are not modified.
    """
    from pyscf.scf.ghf import spin_square
    return spin_square(mo, s)


################################################################################
# Source: pyscf.scf.hf_symm.map_degeneracy
# File: pyscf/scf/hf_symm.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_hf_symm_map_degeneracy(mo_energy: numpy.ndarray, orbsym: numpy.ndarray):
    """Find degeneracy correspondence for cylindrical symmetry.
    
    This function is used in PySCF's symmetry-aware SCF procedures to identify and
    map pairs of molecular orbitals that are degenerate because of cylindrical
    (symmetry axis) point-group behavior (for example, the ex/ey pair for linear
    molecules). It compares orbital energies and symmetry labels to produce an
    index mapping that pairs each orbital with its degenerate partner when such a
    pair exists; orbitals not participating in the targeted degeneracies map to
    themselves. The resulting mapping is commonly used by downstream routines that
    need a consistent correspondence between components of degenerate orbital
    subspaces (for example, when performing symmetry-adapted rotations or when
    enforcing degeneracy constraints during orbital manipulations).
    
    Args:
        mo_energy (numpy.ndarray): 1-D array of orbital energies (floating-point)
            where mo_energy[i] is the energy of the i-th molecular orbital. The
            array must align elementwise with orbsym: both arrays have the same
            length and indices refer to the same orbitals. Energies are compared
            after rounding to 7 decimal places (mo_energy.round(7)) and with a
            numerical matching tolerance of 1e-6; this is intended to account for
            floating-point noise while enforcing that truly degenerate orbitals
            have (within tolerance) identical energies.
        orbsym (numpy.ndarray): 1-D integer array of orbital symmetry labels where
            orbsym[i] encodes the irreducible representation or symmetry character
            of the i-th molecular orbital using the encoding expected by the
            PySCF cylindrical-symmetry handlers. The function inspects
            orbsym % 10 and selects labels in the set {0, 2, 5, 7} as candidates
            for forming degenerate pairs; for a given chosen label ir_ex it
            attempts to pair it with ir_ey defined as ir_ex + 1 if ir_ex is even
            or ir_ex - 1 if ir_ex is odd. The array length determines the number of
            orbitals (norb = orbsym.size) and must match mo_energy.size.
    
    Behavior and algorithmic details:
        The function constructs an integer index array degen_mapping initially set
        to the identity permutation (degen_mapping[i] = i). It then iterates over
        the unique symmetry labels ir_ex present among orbsym entries selected by
        orbsym % 10 in (0, 2, 5, 7). For each ir_ex the corresponding partner
        label ir_ey is computed as described above. Orbitals with labels in the
        small exclusion set (0, 1, 5, 4) are explicitly skipped and left mapped to
        themselves. For each candidate pair of labels, the routine:
          - Collects indices ex_idx where orbsym == ir_ex and ey_idx where
            orbsym == ir_ey.
          - Verifies that ex_idx.size == ey_idx.size; if not, this is treated as a
            symmetry inconsistency and an exception is raised (see Failure modes).
          - Compares the energies mo_energy[ex_idx] and mo_energy[ey_idx] after
            rounding to 7 decimal places and identifies a one-to-one correspondence
            using an absolute tolerance of 1e-6. If a complete one-to-one
            correspondence cannot be established, an exception is raised.
          - Fills degen_mapping so that each index in ex_idx maps to its matched
            partner in ey_idx and vice versa (the mapping is mutual, i.e.
            degen_mapping[degen_mapping[i]] == i for paired indices).
    
    Side effects:
        None. The function is pure with respect to input arrays (it does not modify
        mo_energy or orbsym) and returns a new numpy.ndarray describing the
        mapping.
    
    Failure modes and exceptions:
        The function raises PointGroupSymmetryError (defined elsewhere in the
        PySCF codebase) in two situations that indicate inconsistent symmetry or
        numerical degeneracy expectations:
          - When the number of orbitals labeled by ir_ex does not equal the number
            labeled by the corresponding ir_ey (ex_idx.size != ey_idx.size).
          - When the rounded energies of candidate paired orbitals cannot be
            matched in a one-to-one manner within the tolerance 1e-6 (mapping.size
            != ex_idx.size).
        These failures indicate that the provided orbsym labels and mo_energy
        values are not consistent with the assumed cylindrical degeneracy pattern
        and should be investigated by the caller (e.g., by checking symmetry
        assignments, numerical precision, or by re-evaluating orbitals under a
        different symmetry treatment).
    
    Returns:
        numpy.ndarray: Integer array degen_mapping with the same length as orbsym
        and mo_energy. For each orbital index i, degen_mapping[i] is the index of
        the orbital paired with i due to cylindrical degeneracy. For orbitals not
        part of any detected degenerate pair the mapping equals the identity
        (degen_mapping[i] == i). The array is suitable for use as an index map in
        subsequent PySCF symmetry-aware orbital manipulations and reordering.
    """
    from pyscf.scf.hf_symm import map_degeneracy
    return map_degeneracy(mo_energy, orbsym)


################################################################################
# Source: pyscf.scf.diis.get_err_vec_orig
# File: pyscf/scf/diis.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_diis_get_err_vec_orig(s: numpy.ndarray, d: numpy.ndarray, f: numpy.ndarray):
    """pyscf.scf.diis.get_err_vec_orig computes the DIIS (Direct Inversion in the Iterative Subspace) error vector used to accelerate Self-Consistent Field (SCF) convergence in PySCF by forming matrix products involving the AO overlap matrix S, the density matrix D, and the Fock matrix F. The original one-line docstring in the source reads "error vector = SDF - FDS", but the implemented routine forms S*D*F, then returns (SDF)† - SDF (i.e., FDS - SDF) flattened into a one-dimensional numpy.ndarray. This function is used inside SCF DIIS infrastructure to produce the residuals whose linear combinations are optimized to reduce the SCF error and reach self-consistency.
    
    Args:
        s (numpy.ndarray): The AO overlap matrix or a stack of overlap matrices. For common closed-shell cases this is a 2D array of shape (n, n) giving the overlap S in the atomic-orbital basis. For batched or multi-block situations (for example multiple k-points or multiple independent problems), s may be a 3D array where the first axis indexes the batch and each s[i] is an (n, n) overlap matrix. The overlap matrix S quantifies the non-orthogonality of the atomic-orbital basis and is required to form the S D F product used in DIIS residuals. The function does not modify s.
    
        d (numpy.ndarray): The density matrix or a stack of density matrices. In the usual closed-shell SCF this is a 2D array of shape (n, n) representing D. In unrestricted (UHF) calculations d is commonly provided as a 3D array with the spin index first (shape (2, n, n)) so that d[0] and d[1] are the alpha and beta density matrices. When s is provided as a 3D stack, d is expected to have a matching first axis so that each density matrix pairs with the corresponding overlap matrix. The density matrix D encodes the occupied orbital population and is used together with S and F to compute the DIIS residuals. The function does not modify d.
    
        f (numpy.ndarray): The Fock matrix or a stack of Fock matrices. For standard closed-shell calculations this is a 2D array of shape (n, n). For batched/multi-block situations f may be 3D with the same leading axis semantics as s (i.e., f[i] corresponds to s[i] and d[i]). For unrestricted HF (UHF) calculations f can have an extra leading axis for spin (shape (2, n, n)), in which case the function treats the first axis as the spin index and returns the concatenated error vectors for the two spin channels. The Fock matrix F represents the effective one-electron operator in the SCF procedure and is combined with S and D to form the residual. The function does not modify f.
    
    Behavior:
        For a 2D Fock matrix (f.ndim == 2) the function computes the matrix product S*D*F (implemented as reduce(lib.dot, (s, d, f)) in the source), then forms the anti-Hermitian residual (SDF)† - SDF, and returns that residual flattened with numpy.ravel(). This is the primary error vector used in DIIS when s, d, and f are single matrices.
    
        If f is 3D and s is also 3D (both batched with the same leading dimension), the function loops over the leading index i, computes S[i]*D[i]*F[i] for each i, forms (SDF)† - SDF for each block, ravel()s each block, and horizontally stacks the resulting 1D arrays into a single 1D numpy.ndarray. This supports cases where multiple independent overlap/density/Fock blocks are supplied (for example multiple k-points or multiple independent systems).
    
        If f.ndim == s.ndim + 1 and f.shape[0] == 2, the function recognizes an unrestricted-HF (UHF) spin-separated representation where the leading axis of f (and of d) is the spin index. It recursively calls itself for each spin block and returns the horizontal concatenation of the two spin error vectors in the order (spin-0 errors, spin-1 errors). This is the branch used for UHF DIIS residual assembly.
    
    Side effects and defaults:
        The function does not modify its inputs s, d, or f; it allocates and returns a new numpy.ndarray for the error vector. There are no optional parameters or defaults. The routine relies on numpy and on the dot-product implementation referenced in the source (via reduce(lib.dot, ...)) to compute matrix products.
    
    Failure modes:
        If the shapes of s, d, and f do not match any of the handled patterns (2D case, matching 3D batched case, or the UHF spin-separated case where f.ndim == s.ndim + 1 and f.shape[0] == 2), the function raises RuntimeError('Unknown SCF DIIS type'). Callers must ensure that the arrays have consistent dimensions appropriate to closed-shell, batched, or UHF use cases.
    
    Returns:
        numpy.ndarray: A one-dimensional numpy array containing the flattened DIIS error vector(s). For a single 2D input block of shape (n, n) the returned array has length n*n and contains (SDF)† - SDF flattened in row-major order. For batched 3D inputs the return value is the horizontal concatenation of each block's flattened residuals. For UHF inputs with two spin blocks the return value is the concatenation of the spin-0 residual vector followed by the spin-1 residual vector. The dtype is typically complex when the input matrices are complex-valued.
    """
    from pyscf.scf.diis import get_err_vec_orig
    return get_err_vec_orig(s, d, f)


################################################################################
# Source: pyscf.scf.hf_symm.so2ao_mo_coeff
# File: pyscf/scf/hf_symm.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_hf_symm_so2ao_mo_coeff(so: list, irrep_mo_coeff: list):
    """Transfer the basis of molecular orbital (MO) coefficient matrices from a
    symmetry-adapted block-diagonal representation (one block per irreducible
    representation) into the full atomic-orbital (AO) basis by applying the
    per-irrep transformation matrices and horizontally concatenating the results.
    
    This function is used in the PySCF symmetry-aware self-consistent-field (SCF)
    workflow (pyscf.scf.hf_symm) to reconstruct the complete AO-basis MO
    coefficient matrix from MO coefficients that are stored separately for each
    irreducible representation (irrep). The reconstructed AO-basis coefficient
    matrix is required for downstream steps such as density matrix construction,
    Fock matrix evaluation, integral transforms, and orbital-based analyses.
    
    Args:
        so (list): A Python list whose element at index ir (so[ir]) is the
            transformation matrix that maps MO coefficients for irreducible
            representation ir into the full AO basis. Each element is expected to
            be a 2-D array-like object (typically a numpy.ndarray) representing a
            linear transformation with compatible dimensions for left-multiplication
            of the corresponding element of irrep_mo_coeff. The length of this
            list defines the number of irreducible representations processed and
            must match the length of irrep_mo_coeff. The order of elements must
            correspond to the same irrep ordering used to build irrep_mo_coeff.
        irrep_mo_coeff (list): A Python list whose element at index ir
            (irrep_mo_coeff[ir]) is the MO coefficient matrix for irreducible
            representation ir in the symmetry-adapted basis. Each element is
            expected to be a 2-D array-like object (typically a numpy.ndarray)
            with a number of rows compatible with the number of columns of the
            corresponding so[ir] so that numpy.dot(so[ir], irrep_mo_coeff[ir])
            performs a valid matrix multiplication. The list length and element
            ordering must match those of so.
    
    Behavior and side effects:
        The function applies numpy.dot to each pair (so[ir], irrep_mo_coeff[ir])
        for ir in range(len(so)), producing a sequence of 2-D arrays. These arrays
        are then concatenated horizontally using numpy.hstack to form a single
        2-D numpy.ndarray in the AO basis. The function does not modify the input
        lists or their elements; it returns a newly allocated numpy.ndarray that
        contains the concatenated AO-basis MO coefficients. There are no other
        side effects (no global state is changed).
    
    Defaults:
        There are no optional parameters or defaults. Both inputs must be provided
        and follow the expectations above.
    
    Failure modes:
        If len(irrep_mo_coeff) < len(so) an IndexError will be raised when the
        function attempts to access a missing element of irrep_mo_coeff. If the
        individual matrix shapes are incompatible for matrix multiplication,
        numpy.dot will raise a ValueError or TypeError. If the intermediate results
        produced for different irreps have mismatched numbers of rows, numpy.hstack
        will raise a ValueError. Passing non-array-like objects for list elements
        may raise TypeError when numpy.dot is invoked. The caller should validate
        that the per-irrep matrices have compatible shapes and that both lists use
        the same irrep ordering before calling this function.
    
    Returns:
        numpy.ndarray: A 2-D numpy array representing the full AO-basis molecular
        orbital coefficient matrix obtained by applying each per-irrep
        transformation so[ir] to the corresponding irrep_mo_coeff[ir] and
        horizontally concatenating the results in ir-index order. The number of
        columns in the returned array equals the total number of molecular orbital
        columns across all irreps; the number of rows equals the AO basis size
        implied by the transformation matrices so[ir].
    """
    from pyscf.scf.hf_symm import so2ao_mo_coeff
    return so2ao_mo_coeff(so, irrep_mo_coeff)


################################################################################
# Source: pyscf.scf.hf.make_rdm2
# File: pyscf/scf/hf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_hf_make_rdm2(mo_coeff: numpy.ndarray, mo_occ: numpy.ndarray, **kwargs):
    """pyscf.scf.hf.make_rdm2: Construct the two-particle (2-body) reduced density matrix (2-RDM) in the atomic-orbital (AO) representation for a Hartree–Fock (HF) determinant. This function is used in the PySCF electronic structure framework to produce a 2-RDM consistent with the one-particle density matrix (1-RDM) returned by make_rdm1, so it can be used to evaluate HF energies, electron-electron expectation values, and to provide a reference 2-RDM for post-HF methods.
    
    The returned 2-RDM uses the index ordering
    dm2[p, q, r, s] = < q^+ s^+ r p >,
    and the HF energy can be formed using
    E = einsum('pq,qp', hcore, 1pdm) + einsum('pqrs,pqrs', eri, 2pdm) / 2,
    where h1[p,q] = <p|h|q> and eri[p,q,r,s] = (pq|rs). The implementation constructs the 2-RDM from the 1-RDM (dm1) as
    dm2 = dm1 ⊗ dm1 - (swap dm1 ⊗ dm1)/2,
    which yields a 4D ndarray consistent with a single-determinant HF wavefunction.
    
    Args:
        mo_coeff (2D ndarray): Orbital coefficient matrix in the AO basis. Each column corresponds to one molecular orbital (MO). In PySCF usage, mo_coeff transforms AO-based quantities into the MO basis and its column count determines the number of orbitals used to form the 1-RDM and therefore the dimensions of the resulting 2-RDM. The array must be a numeric 2D numpy.ndarray suitable for linear-algebra operations.
        mo_occ (1D ndarray): Occupancy of each molecular orbital. This 1D numpy.ndarray provides the occupation numbers (e.g., 0, 1, 2 for restricted HF) corresponding to the columns of mo_coeff. The length of mo_occ must match the number of columns in mo_coeff; mismatched lengths will cause an error when constructing the 1-RDM.
        kwargs (dict): Additional keyword arguments forwarded verbatim to make_rdm1. These keywords affect how the 1-RDM is constructed (for example, options handled by make_rdm1 within PySCF) and therefore can change the computed 2-RDM. This function does not inspect or modify kwargs; they are passed to make_rdm1 for processing.
    
    Behavior and side effects:
        - The function first calls make_rdm1(mo_coeff, mo_occ, **kwargs) to obtain the one-particle density matrix (dm1) in AO representation. The behavior and accepted keywords of make_rdm1 therefore directly affect make_rdm2.
        - The 2-RDM is computed using numpy.einsum with the algebraic form dm2 = einsum('ij,kl->ijkl', dm1, dm1) - einsum('ij,kl->iklj', dm1, dm1)/2, i.e., the direct product of dm1 with itself minus the exchange-symmetrized term scaled by 1/2. The computation allocates a 4D numpy.ndarray to hold the result.
        - No in-place modification of the inputs is performed; mo_coeff and mo_occ are not altered by this function. The only side effect is memory allocation for intermediate and final arrays and the call to make_rdm1.
        - The function is intended for use with HF single-determinant density matrices and produces a 2-RDM consistent with such determinants; it is commonly used to evaluate HF electron-electron energies and to compare/convert to 2-RDMs from correlated (post-HF) methods.
    
    Failure modes and errors:
        - TypeError will be raised (directly or indirectly) if mo_coeff or mo_occ are not numeric numpy.ndarray objects or cannot be used by make_rdm1.
        - ValueError (or errors from make_rdm1) will occur if the length of mo_occ does not match the number of orbitals (columns) in mo_coeff, or if the shapes of arrays produced by make_rdm1 are incompatible with the einsum contractions.
        - MemoryError can occur for large systems because the 2-RDM is a 4D array whose size scales as O(n^4) with the number of basis functions/orbitals (the function will allocate intermediate arrays of comparable size).
        - Any exceptions raised by make_rdm1 (e.g., due to invalid kwargs) propagate to the caller.
    
    Returns:
        4D ndarray: The two-particle reduced density matrix in AO representation with index ordering dm2[p,q,r,s] = <q^+ s^+ r p>. The returned object is a numpy.ndarray (4-dimensional) constructed from the 1-RDM as described above; typically its shape is (n_ao, n_ao, n_ao, n_ao) where n_ao (the AO basis size) is determined by mo_coeff. This 2-RDM can be used directly to compute two-electron expectation values (for example, via einsum with electron repulsion integrals) or passed to downstream routines that expect a HF-consistent 2-RDM.
    """
    from pyscf.scf.hf import make_rdm2
    return make_rdm2(mo_coeff, mo_occ, **kwargs)


################################################################################
# Source: pyscf.scf.rohf.get_roothaan_fock
# File: pyscf/scf/rohf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_rohf_get_roothaan_fock(focka_fockb: tuple, dma_dmb: tuple, s: numpy.ndarray):
    """Roothaan effective Fock matrix for restricted open-shell Hartree–Fock (ROHF) calculations.
    This function constructs the Roothaan effective Fock operator described in the ROHF formalism (see Ross thesis reference in original implementation). It combines the alpha and beta Fock matrices and the alpha and beta density matrices to build projectors onto the closed (core), open-shell, and virtual subspaces in the atomic-orbital (AO) basis using the AO overlap matrix s. The resulting matrix is symmetrized to enforce Hermiticity and returned with metadata tags referencing the original alpha and beta Fock matrices. In practical PySCF ROHF workflows this effective Fock is used to represent the one-electron operator that reproduces ROHF block structure for subsequent diagonalization or orbital rotations.
    
    Args:
        focka_fockb (tuple): A length-2 tuple containing the alpha and beta Fock matrices (focka, fockb). Each element is a square numpy.ndarray in the AO basis whose dimensions equal the number of atomic orbitals (nao). These matrices are the standard spin-dependent Fock operators computed earlier in an ROHF iteration. The function computes Fc = (focka + fockb) * 0.5 (the spin-averaged Fock) and uses focka and fockb directly when assembling cross terms between subspace projectors.
        dma_dmb (tuple): A length-2 tuple containing the alpha and beta density matrices (dma, dmb). Each element is a square numpy.ndarray in the AO basis with the same shape as the Fock matrices. These density matrices define the occupied subspaces: dmb is used to form the core (closed) projector, dma-dmb the open-shell projector, and dma the occupied space used to obtain the virtual projector as I - dma * s. The function does not modify the input density matrices.
        s (numpy.ndarray): The AO overlap matrix (square numpy.ndarray) of shape (nao, nao), where nao is the number of atomic orbitals. s is used to build orthogonal projectors for the closed, open, and virtual subspaces via products with the input density matrices. The function reads s.shape[0] to determine nao and expects s to be conformable with the supplied Fock and density matrices.
    
    Returns:
        numpy.ndarray: The Roothaan effective Fock matrix in the AO basis. The returned array has shape (nao, nao) matching s and the input Fock/density matrices. The matrix is assembled according to the ROHF block pattern (closed/open/virtual) with Fc = (focka + fockb) / 2 and explicit cross terms between subspace projectors; it is explicitly symmetrized by adding its conjugate transpose to enforce Hermiticity. As a side effect, the returned array is tagged (via lib.tag_array) with the original focka and fockb under metadata keys 'focka' and 'fockb' so downstream PySCF routines can access the source Fock matrices. The function does not modify its inputs.
    
    Behavior and failure modes:
        The function constructs three projectors: pc = dmb * s (core/closed), po = (dma - dmb) * s (open-shell), and pv = I - dma * s (virtual), then forms quadratic and cross terms by matrix multiplication with Fc, focka, and fockb following the ROHF Roothaan prescription. The implementation expects all matrix inputs to be two-dimensional, square, and mutually conformable for matrix multiplication; mismatched shapes or incompatible dtypes will raise Python/numpy exceptions (for example, ValueError or TypeError) originating from numpy.dot or related operations. The function assumes standard dense numpy arrays and does not accept non-array inputs unless they implement the same ndarray interface for dot products. No in-place modification of inputs occurs. There are no default arguments; all three parameters are required.
    """
    from pyscf.scf.rohf import get_roothaan_fock
    return get_roothaan_fock(focka_fockb, dma_dmb, s)


################################################################################
# Source: pyscf.scf.rohf.get_grad
# File: pyscf/scf/rohf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_rohf_get_grad(
    mo_coeff: numpy.ndarray,
    mo_occ: numpy.ndarray,
    fock: numpy.ndarray
):
    """pyscf.scf.rohf.get_grad computes the ROHF orbital-rotation gradient vector for the unique off-diagonal MO blocks used in restricted open-shell Hartree–Fock (ROHF) response and orbital optimization procedures. The gradient returned corresponds to the combined off-diagonal blocks [co + cv + ov] (core-occupied, core-virtual, occupied-virtual) of the Fock operator expressed in the molecular orbital (MO) basis and is intended for use in orbital rotation/update routines that require only the independent rotation parameters for alpha and beta spin spaces.
    
    This function is used in the PySCF ROHF module to extract the independent gradient components that drive orbital rotations during SCF optimization or analytic gradient assembly. It projects the provided Fock operator into the MO basis using the supplied MO coefficients, selects the matrix elements that correspond to rotations between occupied and virtual orbitals for alpha and beta spins according to the occupation vector, and returns these elements as a flattened 1D array of the independent variables.
    
    Args:
        mo_coeff (numpy.ndarray): MO coefficient matrix that maps atomic orbital (AO) basis to molecular orbitals (MO). Expected shape is (nao, nmo) where nao is the number of AOs (matching the row/column dimension of fock when fock is in AO basis) and nmo is the number of MOs. mo_coeff is used to transform the Fock matrices from the AO basis into the MO basis by the operation mo_coeff.conj().T @ fock @ mo_coeff; the conjugate transpose accounts for complex-valued coefficients. Practical significance: correct shape and complex/real dtype are required so that the MO-basis Fock matrices are computed without broadcasting or linear-algebra errors.
    
        mo_occ (numpy.ndarray): 1D array of MO occupation numbers (typically values 0, 1, or 2 in ROHF). The array length must equal the number of MOs (nmo). mo_occ defines which orbitals are occupied for alpha spin (occidxa = mo_occ > 0) and which are doubly occupied for beta spin (occidxb = mo_occ == 2). These boolean masks determine the unique independent rotation blocks (virtual vs occupied) whose Fock matrix elements form the gradient. Practical significance: mo_occ partitions the MO space into core/occupied/virtual subspaces used to select the off-diagonal gradient blocks; incorrect occupancy values or mismatched length will produce incorrect masks or raise shape errors.
    
        fock (numpy.ndarray): Representation of the Fock operator provided to be projected into the MO basis. Typical and recommended forms (supported by the implementation) are:
            - a single 2D numpy.ndarray: interpreted as a (nao, nao) AO-basis Fock matrix and used for both alpha and beta spins;
            - a sequence (tuple or list) of two 2D numpy.ndarrays (focka, fockb): separate AO-basis Fock matrices for alpha and beta spins;
            - a 3D numpy.ndarray with ndim == 3 where two matrices are stacked along the first axis (e.g., shape (2, nao, nao)) to represent alpha and beta Fock matrices;
            - an object with attributes focka and fockb providing the alpha and beta Fock matrices.
        The function transforms the provided Fock(s) to the MO basis via mo_coeff.conj().T.dot(fockX).dot(mo_coeff) and then selects the off-diagonal blocks. Practical significance: the AO-basis dimension (nao) must match the number of rows of mo_coeff; when providing separate alpha/beta Fock matrices they must have matching shapes. If fock is a single 2D array, it is used for both spins. Failure modes: mismatched array shapes between mo_coeff and fock or improperly structured fock (neither a 2D array, a 3D stacked array, a sequence of two arrays, nor an object with focka/fockb) will cause NumPy linear-algebra operations to raise exceptions (e.g., ValueError) or attribute errors.
    
    Returns:
        numpy.ndarray: A 1D array containing the independent ROHF orbital-rotation gradient elements selected from the MO-basis Fock matrices. The returned vector contains elements corresponding to the boolean mask uniq_var_a | uniq_var_b where uniq_var_a selects virtual (alpha) × occupied (alpha) entries and uniq_var_b selects virtual (beta) × occupied (beta) entries; these correspond to the off-diagonal blocks [co + cv + ov] in the MO-index partitioning [cc co cv; oc oo ov; vc vo vv]. The dtype of the returned array matches the dtype of the computed MO-basis Fock matrices (real or complex). No in-place modification of inputs is performed; the function has no side effects beyond creating and returning this gradient array. Exceptions raised by NumPy (for example due to shape mismatches) indicate incorrect input shapes or incompatible fock formats.
    """
    from pyscf.scf.rohf import get_grad
    return get_grad(mo_coeff, mo_occ, fock)


################################################################################
# Source: pyscf.scf.rohf.make_rdm1
# File: pyscf/scf/rohf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_rohf_make_rdm1(mo_coeff: numpy.ndarray, mo_occ: numpy.ndarray, **kwargs):
    """One-particle (spin-separated) density matrix builder for restricted open-shell Hartree–Fock (ROHF) orbitals.
    This function constructs the alpha and beta one-particle density matrices in the atomic-orbital (AO) basis from molecular orbital coefficients and orbital occupancies. It is used in PySCF ROHF workflows (for energy evaluation, Fock matrix build, and property calculations) to represent the electronic density split into alpha and beta spin components consistent with ROHF conventions: singly occupied orbitals contribute only to the alpha density, while doubly occupied orbitals contribute to both alpha and beta densities.
    
    Args:
        mo_coeff (numpy.ndarray): Molecular orbital coefficient matrix. This array maps atomic-orbital (AO) basis functions to molecular orbitals (MOs). In practice its shape is (n_ao, n_mo), where n_ao is the number of AOs (rows) and n_mo the number of MOs (columns). Elements may be real or complex; the implementation uses mo_coeff.conj().T so complex-valued coefficients are supported. The columns are scaled by occupation factors to produce the AO-basis density matrices.
        mo_occ (numpy.ndarray): Orbital occupancy specification. Two formats are accepted:
            1) A 1-D numpy.ndarray of length n_mo with integer occupancies (commonly 0, 1, or 2). In this case the function interprets mo_occa = (mo_occ > 0).astype(numpy.double) so any nonzero occupancy contributes to the alpha density, and mo_occb = (mo_occ == 2).astype(numpy.double) so only doubly occupied orbitals contribute to the beta density. This implements the ROHF rule that singly occupied orbitals are alpha-only.
            2) A pair-like object (mo_occa, mo_occb) provided as mo_occ such that the function unpacks it into separate alpha and beta occupation arrays. Each of mo_occa and mo_occb must be array-like with length n_mo and contain the per-MO occupation numbers to be applied directly (they are used multiplicatively against mo_coeff columns).
        kwargs (dict): Additional keyword arguments accepted for API compatibility. The current implementation does not consume or forward these arguments; they are ignored. Including kwargs allows callers in the PySCF driver code to pass extra options without changing this function signature.
    
    Behavior, defaults, and failure modes:
        - If mo_occ is a 1-D numpy.ndarray, the function creates internal occupancy arrays mo_occa and mo_occb as described above and casts them to numpy.double for numerical consistency.
        - If mo_occ is not a 1-D numpy.ndarray, the function attempts to unpack mo_occ into (mo_occa, mo_occb). If that unpacking fails (for example, mo_occ is neither a 1-D array nor an iterable of length 2), Python will raise a TypeError or ValueError during unpacking.
        - The density matrices are computed as dm_a = dot(mo_coeff * mo_occa, mo_coeff.conj().T) and dm_b = dot(mo_coeff * mo_occb, mo_coeff.conj().T). This multiplies each MO coefficient column by the corresponding occupation factor and contracts back to the AO basis, yielding AO×AO matrices. If the length of the occupation arrays does not match the number of columns in mo_coeff, a broadcasting or shape-related error (ValueError) will be raised by NumPy.
        - The computation preserves complex arithmetic: if mo_coeff is complex, the conjugate transpose is used and dm_a/dm_b will generally be complex-valued arrays.
        - No external side effects modify mo_coeff or the provided occupancy arrays; the function returns new density matrices.
        - kwargs are ignored, so passing unknown keyword options will not change behavior but also will not raise an error.
    
    Returns:
        tuple (numpy.ndarray, numpy.ndarray): A pair (dm_a, dm_b) of one-particle density matrices in the AO basis for the alpha and beta spins, respectively. Each returned numpy.ndarray has shape (n_ao, n_ao), where n_ao is the number of atomic orbitals (the number of rows of mo_coeff). The returned value is produced via lib.tag_array((dm_a, dm_b), mo_coeff=mo_coeff, mo_occ=mo_occ) so the tuple-like result is tagged with metadata keys 'mo_coeff' and 'mo_occ' reflecting the inputs; this metadata may be used by downstream PySCF routines to retain provenance of the density matrices.
    """
    from pyscf.scf.rohf import make_rdm1
    return make_rdm1(mo_coeff, mo_occ, **kwargs)


################################################################################
# Source: pyscf.scf.uhf.make_rdm1
# File: pyscf/scf/uhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_uhf_make_rdm1(mo_coeff: tuple, mo_occ: tuple, **kwargs):
    """Compute the spin-separated one-particle reduced density matrices (RDM1) in the atomic-orbital (AO) representation for an unrestricted Hartree–Fock (UHF) wavefunction. This function is part of the PySCF (Python-based Simulations of Chemistry Framework) scf.uhf module and is used to convert molecular-orbital (MO) coefficients and their occupancies into AO-basis density matrices for alpha and beta spins. The returned density matrices are suitable for downstream property evaluations and post-SCF routines in PySCF.
    
    Args:
        mo_coeff (tuple of 2D ndarrays): Orbital coefficient matrices for alpha and beta spins. Each element of the tuple corresponds to one spin (index 0 = alpha, index 1 = beta). Each 2D ndarray has columns that represent molecular orbitals (MOs); the rows correspond to atomic-orbital (AO) basis functions. In practice these matrices are produced by UHF solvers in PySCF and are used here as the linear transformation between AO and MO representations.
        mo_occ (tuple of 1D ndarrays): Occupation numbers for alpha and beta spins. Each element of the tuple corresponds to the occupancies of the MOs in the matching mo_coeff entry (index 0 = alpha, index 1 = beta). Occupancies weight the contribution of each MO to the one-particle density and are typically integers (0,1,2) for closed-shell or fractional for open-shell/temperature-smearing calculations; this function treats them numerically as provided.
        kwargs (dict): Additional keyword arguments captured by the function signature. In this implementation kwargs are accepted for API compatibility but are not used to alter the computation. Any keys in kwargs will be ignored by make_rdm1; they do not change the return value or produce side effects.
    
    Behavior:
        The density matrix for each spin is built by summing outer products of MO coefficient columns weighted by their occupancies, implemented as dm = mo_coeff * mo_occ @ mo_coeff.conj().T using numpy.dot and complex conjugation of MO coefficients. Concretely, for each spin s, dm_s = mo_s * diag(mo_occ_s) * mo_s^H, where mo_s is the mo_coeff for spin s and mo_s^H is its conjugate transpose. The function uses numpy.dot for the matrix multiplication and returns the two spin-block density matrices in AO representation. The returned density matrices are Hermitian within numerical precision. The function attaches the input mo_coeff and mo_occ as metadata tags to the returned object using lib.tag_array, which helps downstream PySCF routines retain provenance information.
    
    Side effects and defaults:
        There are no side effects that modify inputs. The function does not modify mo_coeff or mo_occ. The only additional effect is that the returned object is created via lib.tag_array and includes the tags mo_coeff and mo_occ set to the input values. kwargs are ignored by this implementation; no default keyword behavior is applied.
    
    Failure modes:
        A ValueError or numpy exception may be raised if the inputs have incompatible shapes (for example, if the number of occupancy entries does not match the number of MO columns in the corresponding mo_coeff array, or the tuples do not have length 2). A TypeError or numpy.linalg error may arise if inputs are not numeric ndarrays. If MO coefficient arrays contain NaNs or Infs, the resulting density matrices will contain NaNs/Infs and may break downstream code.
    
    Returns:
        A tag_array-like sequence (tuple-like) containing two 2D ndarrays for alpha and beta spins: the first element is the alpha-spin AO-basis one-particle density matrix and the second element is the beta-spin AO-basis one-particle density matrix. Each matrix is constructed as described above and is tagged with the input mo_coeff and mo_occ via lib.tag_array for use by other PySCF routines.
    """
    from pyscf.scf.uhf import make_rdm1
    return make_rdm1(mo_coeff, mo_occ, **kwargs)


################################################################################
# Source: pyscf.scf.uhf.make_rdm2
# File: pyscf/scf/uhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_uhf_make_rdm2(mo_coeff: tuple, mo_occ: tuple):
    """pyscf.scf.uhf.make_rdm2 computes the two-particle reduced density matrix (RDM2) in the atomic orbital (AO) representation for an unrestricted Hartree–Fock (UHF) determinant specified by molecular orbital coefficients and occupations. In the PySCF electronic-structure workflow this function is used to obtain the pair density needed to evaluate two-electron expectation values (for example, the Coulomb and exchange contributions to the electronic energy) and other two-body properties. The function constructs the RDM2 from the one-particle density matrices (RDM1) of the alpha and beta spin channels using outer products and the proper same-spin antisymmetrization required for a single-determinant UHF wavefunction.
    
    Args:
        mo_coeff (tuple of 2D ndarrays): Orbital coefficients for alpha and beta spins. The tuple must contain two 2D numpy.ndarrays (first alpha, then beta). Each array has AO rows and MO columns, and each column represents one molecular orbital expansion in the AO basis. In practice mo_coeff is taken from a UHF object in PySCF and must be consistent with mo_occ: the number of columns in mo_coeff[s] must match the length of mo_occ[s] for s in (0,1). The function uses these coefficients only to form the one-particle density matrices via make_rdm1 and does not modify mo_coeff in place.
        mo_occ (tuple of 1D ndarrays): Occupancies for alpha and beta spins. The tuple must contain two 1D numpy.ndarrays (first alpha, then beta) with occupancy numbers for each molecular orbital (typically 0.0, 1.0, or 2.0 in UHF context, but fractional occupations are accepted numerically). mo_occ determines the one-particle density matrices constructed by make_rdm1; values must align with the corresponding mo_coeff arrays (lengths equal to the number of columns in mo_coeff). The function treats mo_occ as read-only and has no default; passing inconsistent shapes will propagate errors from make_rdm1 or numpy.einsum.
    
    Behavior and algorithmic details:
        The function first calls make_rdm1(mo_coeff, mo_occ) to obtain the alpha and beta one-particle density matrices in the AO basis, denoted dm1a and dm1b. It then constructs three spinblocks of the two-particle density matrix in AO representation:
        - dm2aa: the same-spin (alpha,alpha) block computed as the outer product dm1a ⊗ dm1a minus the exchange term that enforces fermionic antisymmetry (i.e., dm2aa_{ijkl} = dm1a_{ij} dm1a_{kl} - dm1a_{il} dm1a_{kj}). This is appropriate for a single Slater determinant UHF alpha block.
        - dm2bb: the same-spin (beta,beta) block computed similarly from dm1b.
        - dm2ab: the opposite-spin (alpha,beta) block computed as the simple outer product dm1a ⊗ dm1b (no exchange subtraction for opposite spins).
        The implementation uses numpy.einsum to form the 4-index tensors; AO indices follow the order (i, j, k, l) consistent with typical chemist indexing for two-electron integrals and contractions.
    
    Side effects, defaults, and failure modes:
        The function has no side effects on its inputs (it does not modify mo_coeff or mo_occ) and returns new numpy arrays. There are no implicit defaults: both mo_coeff and mo_occ must be provided as two-element tuples. If the shapes of mo_coeff and mo_occ are inconsistent (for example, differing numbers of MOs or mismatched AO dimension), make_rdm1 or numpy.einsum will raise a ValueError or an IndexError propagated to the caller. Passing non-numeric objects, arrays of incompatible dtype, or nested structures that are not two 2D/1D ndarrays will similarly produce exceptions from numpy operations. The function assumes the input represents a single-determinant UHF state and therefore the resulting RDM2 corresponds to the independent-particle form; it does not attempt to enforce N-representability conditions beyond the determinant construction nor does it include correlation beyond the UHF mean-field description.
    
    Returns:
        A tuple of three 4D ndarrays for alpha,alpha and alpha,beta and beta,beta spins: (dm2aa, dm2ab, dm2bb). Each returned element is a numpy.ndarray with four AO indices (i, j, k, l) and shape (nao, nao, nao, nao) where nao is the number of atomic orbitals implied by the rows of mo_coeff[0] and mo_coeff[1] (they must be consistent). dm2aa and dm2bb include the same-spin antisymmetry via the exchange subtraction; dm2ab is the direct product of the alpha and beta one-particle density matrices. These returned RDM2 tensors are suitable for contraction with two-electron integrals in the AO basis to compute two-electron energy contributions and related two-body properties in the PySCF UHF workflow.
    """
    from pyscf.scf.uhf import make_rdm2
    return make_rdm2(mo_coeff, mo_occ)


################################################################################
# Source: pyscf.scf.uhf.make_asym_dm
# File: pyscf/scf/uhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_uhf_make_asym_dm(
    mo1: numpy.ndarray,
    mo2: numpy.ndarray,
    occ1: numpy.ndarray,
    occ2: numpy.ndarray,
    x: numpy.ndarray
):
    """One-particle asymmetric density matrix for unrestricted Hartree–Fock (UHF) spinorbitals.
    
    This function constructs an asymmetric transition one-particle density matrix between two UHF wavefunctions (often produced by independent SCF runs) by projecting occupied molecular orbitals from the first determinant onto the occupied orbitals of the second determinant using the matrices x returned by det_ovlp. In practical PySCF workflows this is used to form the alpha and beta spin blocks of a transition (asymmetric) density matrix when comparing or coupling two different UHF solutions (for example, geometries or basis variants). The implementation selects occupied columns from the provided MO coefficient arrays and computes dm_alpha = mo1_alpha * x_alpha * mo2_alpha^H and dm_beta = mo1_beta * x_beta * mo2_beta^H using matrix multiplication (numpy.dot).
    
    Args:
        mo1 (2D ndarrays): Molecular orbital coefficients for the first determinant. In UHF usage these coefficients are provided with spin components accessible as mo1[0] (alpha) and mo1[1] (beta); each indexed element is a 2D ndarray whose columns are molecular orbitals in the AO basis. The function will slice columns corresponding to occupied orbitals according to occ1.
        mo2 (2D ndarrays): Molecular orbital coefficients for the second determinant. In UHF usage these coefficients are provided with spin components accessible as mo2[0] (alpha) and mo2[1] (beta); each indexed element is a 2D ndarray whose columns are molecular orbitals in the AO basis. The function will slice columns corresponding to occupied orbitals according to occ2.
        occ1 (2D ndarrays): Occupation numbers for the first determinant, given per spin. Occ1[0] and occ1[1] are used as boolean masks (occ1[spin] > 0) to select occupied orbitals from mo1[spin]. Typical values come from the mo_occ arrays returned by PySCF UHF objects (mf.mo_occ). Each element must broadcast sensibly to index the second axis (columns) of the corresponding mo1 spin block.
        occ2 (2D ndarrays): Occupation numbers for the second determinant, given per spin. Occ2[0] and occ2[1] are used as boolean masks (occ2[spin] > 0) to select occupied orbitals from mo2[spin]. Typical values come from the mo_occ arrays returned by PySCF UHF objects (mf.mo_occ). Each element must broadcast sensibly to index the second axis (columns) of the corresponding mo2 spin block.
        x (2D ndarrays): The spin-blocked overlap-inversion matrices typically returned by det_ovlp, denoted mathematically as U Lambda^{-1} V^H. x[0] and x[1] are the matrices applied to the occupied MO subspaces of the alpha and beta spins respectively. Each x[spin] must have dimensions compatible with the number of occupied orbitals selected from mo1[spin] and mo2[spin].
    
    Returns:
        A list of 2D ndarrays for alpha and beta spin: The function returns an array-like container with two 2D ndarrays (first element is the alpha-spin one-particle asymmetric density matrix, second element is the beta-spin matrix). Each returned 2D ndarray is the matrix product mo1_spin[:, occ_mask1] @ x_spin @ mo2_spin[:, occ_mask2].conj().T and represents the transition density in the atomic-orbital basis for the corresponding spin.
    
    Behavior and side effects:
        - The function does not modify its input arrays; it constructs and returns new numpy arrays.
        - Occupied orbitals are selected by the condition occ[spin] > 0 on the second index (columns) of mo1[spin] and mo2[spin].
        - The multiplication order is chosen to produce the AO-basis transition density matrix from MO coefficients and the overlap-inversion factor x produced by det_ovlp.
        - Inputs are assumed to follow the UHF convention used throughout PySCF: spin components accessible as index 0 (alpha) and 1 (beta).
        - No explicit type checks are performed beyond what numpy.dot enforces.
    
    Failure modes:
        - A ValueError or numpy broadcasting/matrix-dimension error will be raised if the shapes of mo1, mo2, occ1, occ2, and x are incompatible for the slicing and matrix multiplications performed (for example, if occ masks do not index the MO coefficient columns correctly or if x[spin] has mismatched dimensions).
        - Supplying inputs that do not follow the expected spin-block layout (alpha at index 0, beta at index 1) will produce incorrect results or runtime errors.
        - If all entries in occ1[spin] or occ2[spin] are non-positive for a given spin, the corresponding occupied subspace is empty and the matrix multiplications will fail or produce empty arrays.
    
    See also:
        det_ovlp: routine that computes determinants of overlap and returns the x matrices (U Lambda^{-1} V^H) used here. Typical usage in PySCF: compute det, x = det_ovlp(mf1.mo_coeff, mf1.mo_occ, mf2.mo_coeff, mf2.mo_occ, s) and then call make_asym_dm(mf1.mo_coeff, mf2.mo_coeff, mf1.mo_occ, mf2.mo_occ, x) to obtain the asymmetric density.
    """
    from pyscf.scf.uhf import make_asym_dm
    return make_asym_dm(mo1, mo2, occ1, occ2, x)


################################################################################
# Source: pyscf.scf.uhf.det_ovlp
# File: pyscf/scf/uhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_uhf_det_ovlp(
    mo1: tuple,
    mo2: tuple,
    occ1: tuple,
    occ2: tuple,
    ovlp: numpy.ndarray
):
    """pyscf.scf.uhf.det_ovlp: Calculate the overlap between two unrestricted-Hartree-Fock (UHF) Slater determinants built from two different sets of molecular orbitals. In the PySCF domain this routine is used to evaluate the scalar overlap S_{12} = <Psi_A | Psi_B> between determinant |Psi_A> defined by (mo1, occ1) and determinant |Psi_B> defined by (mo2, occ2). The overlap is computed as the product of the singular values of the alpha- and beta-spin molecular-orbital overlap matrices obtained from projecting occupied orbitals into the atomic-orbital (AO) basis with the provided AO overlap matrix ovlp; the routine also returns the matrices U Lambda^{-1} V^H (one per spin) that are useful in forming asymmetric transition density matrices between the two determinants.
    
    Args:
        mo1 (tuple): A length-2 tuple containing the molecular orbital coefficient matrices for determinant A. The first element is the alpha-spin MO coefficient array and the second element is the beta-spin MO coefficient array. Each element is a 2D numpy.ndarray with AO basis rows and MO coefficient columns (conventionally shape (n_ao, n_mo)). These coefficients are used to build occupied orbital subblocks by selecting columns where occ1[...] > 0 and to form the MO-overlap matrices o_a and o_b via c1^H * ovlp * c2.
        mo2 (tuple): A length-2 tuple containing the molecular orbital coefficient matrices for determinant B. The first element is the alpha-spin MO coefficient array and the second element is the beta-spin MO coefficient array. Each element is a 2D numpy.ndarray with the same AO-basis row dimension as mo1 elements. mo2 is used together with mo1 and ovlp to construct the overlap submatrices for alpha and beta spins and to perform the singular value decompositions that determine the determinant overlap.
        occ1 (tuple): A length-2 tuple giving the occupation pattern for determinant A for alpha and beta spins. Each element is an array-like object (numeric occupations or boolean mask) indexed over the MO columns in the corresponding element of mo1. The code selects occupied columns by the test occ1[spin] > 0; therefore any convention that yields positive values for occupied orbitals and non-positive for virtuals is accepted. occ1 determines which columns of mo1 are treated as occupied when building the overlap matrices.
        occ2 (tuple): A length-2 tuple giving the occupation pattern for determinant B for alpha and beta spins, analogous to occ1 and indexed to the MO columns of mo2. The routine selects occupied columns from mo2 using occ2[spin] > 0. The number of occupied alpha (and separately beta) orbitals implied by occ1 and occ2 must match; otherwise an exception is raised because overlap between determinants with different electron numbers is undefined for this coupling.
        ovlp (numpy.ndarray): The atomic-orbital (AO) overlap matrix (2D numpy.ndarray) with shape (n_ao, n_ao). This matrix defines the non-orthonormal AO basis inner product used to transform MO coefficients into MO-overlap submatrices o_a and o_b via c1^H * ovlp * c2. ovlp must be Hermitian and consistent with the AO basis used to generate mo1 and mo2.
    
    Returns:
        tuple: A two-element tuple (S_prod, (x_a, x_b)) where:
            S_prod (float): The scalar overlap between the two determinants, given by the product of all singular values from the alpha-spin and beta-spin MO overlap submatrices. Numerically, S_prod = prod(s_a) * prod(s_b) where s_a and s_b are the singular-value vectors returned by SVD of the alpha and beta overlap matrices, respectively. In chemical terms this scalar is the determinant-level overlap <Psi_A|Psi_B> used in electronic coupling, non-orthogonal CI, or transition-density constructions.
            (x_a, x_b) (tuple of numpy.ndarray): A pair of 2D numpy.ndarrays (one for alpha spin x_a and one for beta spin x_b) equal to U * Lambda^{-1} * V^H for the corresponding MO overlap SVDs (U, Lambda, V^H from the SVD of each spin block). Each x_spin has shape (n_occ_spin, n_occ_spin) where n_occ_spin is the number of occupied orbitals for that spin (after occ>0 selection). These matrices are returned because they are used to form asymmetric transition or coupling density matrices between the two determinants (they appear when solving for one-sided inverse in nonorthogonal basis transformations).
    
    Behavior, side effects, and failure modes:
        - The routine selects occupied MO columns by testing occ[spin] > 0. If occ arrays are not aligned with the corresponding mo arrays (different lengths), behavior is undefined; ensure occ entries index MO columns in mo tuples.
        - If the number of occupied alpha orbitals in mo1 and mo2 differ, or the number of occupied beta orbitals differ, the function raises RuntimeError('Electron numbers are not equal. Electronic coupling does not exist.') because overlap between determinants with differing electron counts (per spin) is not computed by this routine.
        - The implementation performs a numeric singular value decomposition (numpy.linalg.svd) on the alpha and beta MO-overlap matrices. numpy.linalg.svd may raise numpy.linalg.LinAlgError on pathological inputs; such exceptions propagate to the caller.
        - Singular values equal to zero (or extremely small values near machine precision) lead to infinite or very large entries in Lambda^{-1} and therefore in x_a/x_b. The code computes reciprocal(s) directly and does not internally regularize small singular values; callers should guard or regularize singular values if needed for numeric stability (for example by applying a threshold to set tiny singular values to zero and handling the pseudo-inverse externally).
        - The function does not modify its inputs (mo1, mo2, occ1, occ2, ovlp) in-place; it allocates intermediate arrays for the SVD and the returned matrices.
    
    Practical significance in PySCF workflows:
        - This function is typically used in post-SCF routines that operate on non-orthogonal determinants (for example, evaluation of overlaps in non-orthogonal CI, computing electronic couplings, or constructing transition density matrices between UHF states). The returned scalar S_prod quantifies the overlap magnitude between the two determinants; the x_a and x_b matrices are the building blocks for constructing asymmetric transition densities and transformed one- and two-electron integrals in the MO basis for couplings.
    """
    from pyscf.scf.uhf import det_ovlp
    return det_ovlp(mo1, mo2, occ1, occ2, ovlp)


################################################################################
# Source: pyscf.solvent.cosmors.get_sas_volume
# File: pyscf/solvent/cosmors.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_solvent_cosmors_get_sas_volume(surface: dict, step: float = 0.2):
    """pyscf.solvent.cosmors.get_sas_volume computes the solvent-accessible surface (SAS) volume enclosed by a molecule and returns that volume in atomic units (a.u.). This function is used in PySCF's implicit solvation and solvent modeling workflows (e.g., mc.with_solvent.surface) to quantify the volume of space accessible to a solvent probe around a molecular structure; the computed SAS volume is commonly used in solvation energy models, surface-area/volume-based descriptors, and other continuum-solvent corrections.
    
    Args:
        surface (dict): Dictionary containing precomputed SAS parameters produced by mc.with_solvent.surface. The function reads the following keys from this dict: 'atom_coords' (array-like of atomic coordinates in Bohr), 'R_vdw' (sequence of van der Waals radii in Bohr, indexed by atom), and 'gslice_by_atom' (an iterable used to select the relevant radii per atom). The values provide the geometric description of the molecule and SAS probe radii required to define the SAS geometry. The practical significance is that these inputs locate the molecular atoms and assign radii that determine the SAS boundary used for numerical integration. If any required key is missing or contains incompatible shapes, a KeyError or an array-shape-related exception will be raised.
        step (float): Grid spacing for the planar 2D numerical integration mesh in Bohr (atomic units). The function constructs a 2D grid spanning the molecule's SAS bounding box with spacing approximately equal to step along the two smallest spatial dimensions and integrates line intersection lengths to estimate the 3D SAS volume. Smaller step values increase numerical accuracy of the Riemann-sum integration at the cost of higher computational time and more grid points; larger values reduce cost but reduce accuracy. The default is 0.2 (Bohr). step must be a positive float; passing non-positive values may result in a ValueError or invalid linspace construction.
    
    Returns:
        float: SAS-defined volume of the molecule in atomic volume units (Bohr^3). This scalar is computed by:
        1) extracting atom coordinates and per-atom radii from the surface dict,
        2) computing coordinate-wise minima and maxima of coords ± radii to form a tight bounding box,
        3) reordering axes to minimize the 2D integration mesh size,
        4) building a 2D grid (xs, ys) with spacing determined by step, computing the area element dx*dy, and
        5) summing dx*dy multiplied by the SAS line intersection length at each grid point (using an internal _get_line_sas_intersection_length routine) to produce the total enclosed volume.
        The returned value is not converted to other units (e.g., Å^3); callers must convert units externally if required.
    
    Behavior, side effects, and failure modes:
        - Pure calculation with no side effects on external state; it does not modify the input surface dict.
        - Numerical integration accuracy depends on step: default step=0.2 balances accuracy and performance for typical molecular systems; reduce step for more precise volume estimates.
        - The function assumes coordinates and radii are expressed in Bohr and that surface['R_vdw'] can be indexed according to entries in surface['gslice_by_atom']. Mismatched indexing or shapes may raise IndexError, KeyError, or array-shape-related exceptions.
        - A non-positive step will lead to invalid mesh construction (e.g., zero-length linspace) and may raise a ValueError or produce an incorrect result; callers should validate step > 0.
        - Computational cost scales with the 2D grid size (number of xs times number of ys) and the complexity of per-line intersection calculations; large molecules or very small step values can be computationally expensive in time.
        - The algorithm integrates a discretized projection of the SAS and therefore yields an approximation of the true continuous SAS volume; errors decrease as step -> 0.
        - This routine relies on internal helper functions for per-line intersection length calculation; if those helpers are missing or modified, behavior may change.
    """
    from pyscf.solvent.cosmors import get_sas_volume
    return get_sas_volume(surface, step)


################################################################################
# Source: pyscf.solvent.grad.pcm.grad_switch_h
# File: pyscf/solvent/grad/pcm.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_solvent_grad_pcm_grad_switch_h(x: numpy.ndarray):
    """pyscf.solvent.grad.pcm.grad_switch_h computes the first derivative of the scalar switching function h(x) used in PySCF's polarizable continuum model (PCM) gradient routines. The implementation evaluates the polynomial derivative dy = 30.0*x**2 - 60.0*x**3 + 30.0*x**4 elementwise and enforces dy = 0.0 outside the switching interval [0, 1]. In the PCM context this derivative modulates how cavity/continuum coupling changes with a scalar switching coordinate x and is used during analytic solvent gradient assembly.
    
    Args:
        x (numpy.ndarray): Real-valued numpy array of switching-coordinate samples for which the derivative is required. In the PCM gradient code this array represents one or more scalar measures (e.g., normalized distances or shape parameters) that determine the extent of the switching between continuum and explicit regions. The function expects a numpy.ndarray input; the operation is performed elementwise on every entry of x. Values of x less than 0 or greater than 1 are treated as outside the switching region and their derivative is set to 0.0. If x contains NaN or infinite values, numpy's arithmetic rules apply and the corresponding output entries will reflect those special values.
    
    Returns:
        numpy.ndarray: An array of the same shape as x containing the computed first derivative dy = 30.0*x**2 - 60.0*x**3 + 30.0*x**4 inside the interval 0 <= x <= 1 and 0.0 for x < 0 or x > 1. The returned array carries floating-point values (numpy will upcast integer inputs to a floating dtype). There are no side effects: the function does not modify global state or the input array in-place (it returns a new array), and it will not perform any I/O. Invalid input types (non-numpy.ndarray) are outside the documented contract and may raise a TypeError or produce undefined behavior.
    """
    from pyscf.solvent.grad.pcm import grad_switch_h
    return grad_switch_h(x)


################################################################################
# Source: pyscf.scf.uhf.spin_square
# File: pyscf/scf/uhf.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_scf_uhf_spin_square(mo: list, s: numpy.ndarray = 1):
    """pyscf.scf.uhf.spin_square computes the expectation value of the total spin-squared operator <S^2> and the corresponding spin multiplicity (2S+1) for an unrestricted Hartree–Fock (UHF) determinant. This function is used in the PySCF UHF code path to quantify spin contamination and to report the effective spin state of a UHF wavefunction given the occupied alpha and beta molecular orbitals and the atomic-orbital (AO) overlap matrix.
    
    The routine evaluates the operator S^2 = 1/2 (S_+ S_- + S_- S_+) + S_z^2 for a single-determinant UHF wavefunction by (1) forming the occupied-alpha vs occupied-beta MO overlap matrix in the MO basis, (2) computing cross-spin contributions from S_+S_- and S_-S_+, and (3) adding the S_z^2 contribution that depends on the difference in alpha and beta occupation numbers. The implementation follows the derivation used in PySCF UHF code and in the example usage shown in the project README and source examples.
    
    Args:
        mo (list): a list of 2 ndarrays. The first element is the occupied alpha molecular orbital coefficient array (shape (nbasis, nocc_alpha)), and the second element is the occupied beta molecular orbital coefficient array (shape (nbasis, nocc_beta)). These arrays are the standard occupied MO slices returned by PySCF UHF objects (for example, mo = (mf.mo_coeff[0][:, mf.mo_occ[0]>0], mf.mo_coeff[1][:, mf.mo_occ[1]>0])). The function requires that each element is a 2-D ndarray with a number of rows equal to the AO basis size (nbasis) and a number of columns equal to the respective number of occupied orbitals.
        s (numpy.ndarray): AO overlap. The atomic-orbital overlap matrix in the AO basis with shape (nbasis, nbasis). The overlap is used to transform between AO and MO representations when forming the occupied-alpha vs occupied-beta overlap. For convenience the function accepts the scalar value 1 (the function signature defaults to 1), which is interpreted as the identity/orthonormal-AO limit (i.e., no AO overlap) because numpy.dot with a scalar acts as multiplication; supplying 1 reproduces the orthonormal-AO behavior used in minimal or pre-orthonormalized contexts. For general use supply the full AO overlap matrix produced by mol.intor('int1e_ovlp') or mol.intor('int1e_ovlp_sph') in PySCF.
    
    Behavior and important details:
        - The routine computes the occupied-alpha vs occupied-beta MO overlap matrix M = mo_a.conj().T @ s @ mo_b and then
          ssxy = 0.5*(nocc_alpha + nocc_beta) - sum(|M|^2) which accumulates the S_+S_- and S_-S_+ contributions that mix alpha and beta occupied orbitals.
          ssz = 0.25*(nocc_beta - nocc_alpha)**2 is the S_z^2 contribution from occupation difference.
          The final expectation value is ss = real(ssxy + ssz).
          The spin quantum number used to report multiplicity is S = sqrt(ss + 0.25) - 0.5, and the multiplicity returned is 2*S + 1.
        - The function forces the returned S^2 to the real part (ss.real) to avoid negligible complex round-off; the multiplicity is computed from that real value.
        - The function does not modify its inputs; it returns computed scalar values only.
        - Typical usage in PySCF is to pass occupied MO coefficient arrays extracted from an scf.UHF object and the AO overlap matrix from the molecule object (mol.intor('int1e_ovlp_sph') or equivalent).
        - The implementation assumes molecular-orbital arrays and overlap are in consistent basis and phase conventions. If inputs use inconsistent bases (mismatched nbasis, incompatible ordering) the numeric result is meaningless.
    
    Failure modes and error conditions:
        - If mo is not a list of two 2-D ndarrays, or if the two ndarrays have a number of rows inconsistent with the provided overlap matrix s (i.e., nbasis mismatch), numpy will raise shape-mismatch errors during the matrix multiplications.
        - If s is neither a scalar nor an ndarray with shape (nbasis, nbasis), the code will raise an exception from numpy.dot or produce an incorrect result.
        - Very large numerical spin contamination or pathological linear dependencies in the AO basis may produce large values under the square root; domain errors (negative argument to sqrt from large negative numerical noise) are avoided by using the algebraic expression implemented here, but users should ensure inputs are physically meaningful and well-conditioned.
        - The function does not perform explicit type checking beyond what numpy operations enforce; invalid dtypes or non-numeric arrays will raise numpy TypeError/ValueError.
    
    Returns:
        A list of two floats. The first is the expectation value of S^2 for the provided UHF determinant (⟨S^2⟩). The second is the corresponding spin multiplicity 2S+1 computed from that expectation value. These two returned scalar values quantify spin contamination (deviation of ⟨S^2⟩ from S(S+1)) and report the effective multiplicity of the determinant in the PySCF UHF workflow.
    """
    from pyscf.scf.uhf import spin_square
    return spin_square(mo, s)


################################################################################
# Source: pyscf.solvent.hessian.pcm.gradgrad_switch_h
# File: pyscf/solvent/hessian/pcm.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_solvent_hessian_pcm_gradgrad_switch_h(x: numpy.ndarray):
    """Second derivative of the PCM switching function h(x) used in solvent Hessian calculations.
    
    This function evaluates the elementwise second derivative h''(x) of the smoothing/switching function h(x) that appears in pyscf.solvent.hessian.pcm. In the domain 0 <= x <= 1 the second derivative is computed from the cubic polynomial
    h''(x) = 60.0*x - 180.0*x**2 + 120.0*x**3,
    and values outside the closed interval [0, 1] are clamped to 0.0 (i.e., h''(x) = 0 for x < 0 or x > 1). The switching function h(x) is used in the polarizable continuum model (PCM) machinery to smoothly transition between regions (for example, between solvent-exposed and buried surface regions) when assembling analytic gradients and Hessians of solvation-related quantities; this routine supplies the curvature contribution (second derivative) of that switch, evaluated elementwise for array inputs. The operation is fully vectorized and has no side effects on input arrays.
    
    Args:
        x (numpy.ndarray): Input array of scalar switching parameters x for which the second derivative is required. Each element represents a dimensionless switching coordinate (for example a scaled distance or blending parameter used by the PCM cavity/switch function). The function treats the array elementwise and returns an array of the same shape. The implementation uses floating-point arithmetic (literal constants are floats), so integer-valued arrays will be promoted to floating dtype in the result. The API expects a numpy.ndarray; passing non-ndarray objects may raise an exception or rely on numpy's conversion/broadcasting semantics.
    
    Returns:
        numpy.ndarray: Array of the same shape as the input x containing the elementwise second derivative values h''(x). For input elements in [0, 1], values follow the cubic polynomial 60.0*x - 180.0*x**2 + 120.0*x**3. For input elements outside that interval the corresponding output elements are exactly 0.0. The returned array dtype will be a floating-point dtype determined by numpy's arithmetic (commonly numpy.float64).
    """
    from pyscf.solvent.hessian.pcm import gradgrad_switch_h
    return gradgrad_switch_h(x)


################################################################################
# Source: pyscf.solvent.pcm.switch_h
# File: pyscf/solvent/pcm.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_solvent_pcm_switch_h(x: numpy.ndarray):
    """switching polynomial used in the polarizable continuum model (PCM) code path of PySCF.
    This function implements the smooth switching function (Eq. 3.19) used to transition
    between regions (for example, across a cavity surface discretization) in continuum
    solvation treatments. The implementation follows the corrected polynomial form
    y = x**3 * (10.0 - 15.0*x + 6.0*x**2) and applies hard bounds outside the unit
    interval. Reference: J. Chem. Phys. 133, 244111 (2010) — note that the original
    paper contains a typographical error in the printed formula; this function encodes
    the corrected form used in PySCF's PCM routines.
    
    Args:
        x (numpy.ndarray): Input array of dimensionless switching coordinates.
            Each element of x represents a normalized coordinate along which the
            switching is evaluated (typically a scaled distance or overlap-like
            measure used in PCM cavity/surface constructions). The array must be a
            numpy.ndarray (any shape is accepted) and the operation is applied
            elementwise. The function is vectorized: the output has the same shape
            as x. Numerical dtype is determined by numpy broadcasting and operations;
            integer inputs will be upcast to a floating type during computation.
            Values outside the closed interval [0, 1] are clamped as described below.
            If x contains NaN or infinite values, the corresponding outputs follow
            numpy arithmetic rules (NaN/infs will generally propagate).
    
    Returns:
        numpy.ndarray: Array y with the same shape as x containing the switched values.
            For 0 <= x <= 1, y is the smooth cubic-quintic polynomial y = x**3*(10 - 15*x + 6*x**2)
            that monotonically increases from 0 to 1 and has continuous first and second
            derivatives (used to avoid discontinuities in PCM surface properties).
            For x < 0, y is set to 0.0. For x > 1, y is set to 1.0.
            The function does not modify the input array x (no in-place side effects).
            If the input is not a numpy.ndarray, behavior is undefined and a TypeError
            or other numpy exception may be raised by the underlying operations.
    """
    from pyscf.solvent.pcm import switch_h
    return switch_h(x)


################################################################################
# Source: pyscf.solvent.grad.pcm.get_dD_dS
# File: pyscf/solvent/grad/pcm.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_solvent_grad_pcm_get_dD_dS(
    surface: dict,
    dF: numpy.ndarray,
    with_S: bool = True,
    with_D: bool = False
):
    """pyscf.solvent.grad.pcm.get_dD_dS computes derivatives of the PCM Coulomb interaction matrices with respect to surface grid coordinates used in polarizable continuum model (PCM) gradient evaluations. It returns the per-grid-coordinate derivatives of the non-symmetric D matrix and the symmetric S matrix, plus grid-local diagonal contributions assembled from a provided dF array. This routine is intended for use inside PySCF's PCM gradient code to assemble forces and energy derivatives arising from the solvent reaction field acting on a molecular solute.
    
    Args:
        surface (dict): Dictionary describing the cavity surface and per-grid parameters required by the derivative expressions. The function expects the following keys in this dict and the corresponding practical meanings:
            grid_coords (numpy.ndarray): Array of surface grid point coordinates with shape (n_grid, 3). Each row is the Cartesian position of a tessera on the molecular cavity. These coordinates define the pairwise vectors and distances used to form dS and dD.
            charge_exp (numpy.ndarray): One-dimensional array of Gaussian exponents (size n_grid) used for the effective surface charge smearing. These exponents enter the short-range modulated Coulomb kernels and determine the regularization of self- and near-self interactions.
            norm_vec (numpy.ndarray): Array of unit normal vectors at each grid point with shape (n_grid, 3). Normals are used to form the D matrix (which couples normals to Coulomb kernels) and enter the directional derivative contributions.
            switch_fun (numpy.ndarray): One-dimensional array (size n_grid) of switching-function values for each grid point that weight diagonal/self contributions. These appear in the diagonal scaling used to compute dSii. The function will raise broadcasting/multiplication errors if shapes are incompatible.
        dF (numpy.ndarray): Array containing per-grid diagonal perturbation factors that couple to the analytic derivative prefactor computed from charge_exp and switch_fun. The routine multiplies a computed per-grid scalar prefactor (derived from charge_exp and switch_fun) with this dF array to form dSii; therefore dF must be shape-compatible for elementwise multiplication with an expanded-per-grid prefactor. In practice dF carries the derivative of the local switching/area factors for each grid point produced earlier in the PCM gradient pipeline and its shape is preserved in the returned dSii.
        with_S (bool): Flag nominally intended to request computation of the S matrix derivative. Default True. Note: in the current implementation the S off-diagonal derivatives (dS) are always computed regardless of this flag; with_S is accepted for API compatibility but is effectively ignored. This is a documented behavioral caveat and may be changed in future revisions.
        with_D (bool): Flag controlling whether the derivative of the non-symmetric D matrix (dD) is computed. Default False. When with_D is False the function returns dD as None and still computes dS and dSii. When with_D is True the function computes dD using the surface normals and the same regularized Coulomb kernel used for S.
    
    Behavior and side effects:
        - The function computes pairwise vectors ri - rj and their norms rij from surface['grid_coords'] and uses elementwise operations with surface['charge_exp'] to form regularized interaction arguments xi_r_ij.
        - Off-diagonal derivatives for S are computed as a vector (3 Cartesian components) for every ordered pair of grid points (i,j) and returned as dS with shape (n_grid, n_grid, 3). S is symmetric in indices (i,j) but the returned dS contains the full pairwise derivative tensor; diagonal entries are explicitly set to zero to avoid singular self-interactions.
        - If with_D is True, dD is computed as a full (n_grid, n_grid, 3) array containing the derivative of the D matrix (which couples surface normals to the Coulomb kernel). D is not symmetric; the code uses surface['norm_vec'] and projects normals against pairwise vectors. Diagonal contributions for dD are set to zero to avoid singularities.
        - The diagonal contribution dSii is formed by computing a per-grid scalar prefactor from surface['charge_exp'] and surface['switch_fun'] (dSii_dF = -exponents * sqrt(2/pi) / switch_fun**2) and multiplying that prefactor, after insertion of singleton axes, with the provided dF array. The returned dSii has the same shape as dF and encodes the self/diagonal derivative contributions for S required by downstream PCM gradient assembly.
        - To avoid division by zero on grid self-interactions the implementation temporarily replaces diagonal rij values and explicitly fills diagonal derivative entries with zero. Callers must therefore supply valid non-NaN, finite input arrays; invalid inputs can lead to runtime warnings or exceptions from NumPy/Scipy routines.
        - The implementation uses numpy and scipy.special.erf; SciPy must be available at runtime.
    
    Failure modes and preconditions:
        - Missing keys in the surface dict or mismatched array shapes will raise standard NumPy broadcasting or KeyError exceptions. The caller must ensure the surface dict contains 'grid_coords', 'charge_exp', 'norm_vec', and 'switch_fun' with consistent lengths (n_grid) and correct shapes: grid_coords (n_grid,3), charge_exp (n_grid,), norm_vec (n_grid,3), switch_fun (n_grid,).
        - If with_D is True but norm_vec contains zero or non-unit normals, the resulting dD will reflect those values; the routine does not re-normalize normals.
        - The function assumes finite values for all inputs; extremely small switch_fun values can cause very large prefactors in dSii and may produce numerical instability.
        - SciPy/NumPy exceptions (e.g., from erf, exp, division by zero) are propagated to the caller.
    
    Returns:
        tuple: A triple (dD, dS, dSii) where:
            dD (numpy.ndarray or None): If with_D is True, a numpy.ndarray of shape (n_grid, n_grid, 3) containing the derivative of the non-symmetric D matrix with respect to each Cartesian coordinate of the source grid point (i.e., partial derivatives partial_i D_ij). If with_D is False, dD is None. Diagonal entries are zeroed to avoid singular self-contributions.
            dS (numpy.ndarray): Numpy array of shape (n_grid, n_grid, 3) containing the derivative of the symmetric S matrix with respect to the source grid coordinates. Each entry corresponds to the vector derivative of the pairwise S_ij kernel; diagonal entries are set to zero by construction to regularize self-interactions.
            dSii (numpy.ndarray): Array with the same shape as the provided dF input, containing the diagonal/self contributions for S assembled from the per-grid prefactor (derived from charge_exp and switch_fun) multiplied elementwise by dF. This term is intended to be combined with the off-diagonal dS contributions during PCM gradient assembly.
    """
    from pyscf.solvent.grad.pcm import get_dD_dS
    return get_dD_dS(surface, dF, with_S, with_D)


################################################################################
# Source: pyscf.solvent.pcm.get_D_S
# File: pyscf/solvent/pcm.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_solvent_pcm_get_D_S(surface: dict, with_S: bool = True, with_D: bool = False):
    """pyscf.solvent.pcm.get_D_S generates the PCM surface interaction matrices D and S used in the polarizable continuum model (PCM) formulation described in J. Chem. Phys. 133, 244111 (2010). It builds the pairwise Coulomb-like matrix S between surface tesserae represented by smeared Gaussian charge distributions and, optionally, the dipolar coupling matrix D that depends on surface normals. The function reads the required surface discretization data from the provided surface dictionary and returns (D, S) where S is always produced and D is produced only when requested.
    
    Args:
        surface (dict): Dictionary describing the discretized solvent cavity (surface tesserae). The function expects these keys to be present and to contain array-like values that can be interpreted as numpy arrays with the shapes described below. Each key is read but not modified; the function has no other side effects on the provided dictionary.
            - 'charge_exp': 1-D array-like, length N. Exponential width parameters (xi) for the Gaussian charge distribution assigned to each surface element (tessera). These control the spatial smearing of the apparent surface charge and enter the inter-tessera kernels via xi_i * xi_j / sqrt(xi_i^2 + xi_j^2).
            - 'grid_coords': 2-D array-like with shape (N, 3). Cartesian coordinates of the N surface tesserae in the same coordinate units used by the rest of the PCM setup. Pairwise Euclidean distances are computed with scipy.spatial.distance.cdist.
            - 'switch_fun': 1-D array-like, length N. Per-tessera scalar used to scale the diagonal entries of S. The code sets S_ii = charge_exp_i * sqrt(2/pi) / switch_fun_i after computing off-diagonal elements.
            - 'norm_vec': 2-D array-like with shape (N, 3). Outward normal vectors at each tessera. Required only when with_D is True because D depends on the projection of inter-tessera vectors onto these normals.
            - 'R_vdw': 1-D array-like, length N. Per-tessera van der Waals radii. Required only when with_D is True because the diagonal of D is set using R_vdw (see Return details).
        with_S (bool): Flag intended to request construction of the S matrix. Default True. Note: in the current implementation S is always computed and returned regardless of this flag; the parameter remains in the signature for API compatibility but is not used to skip computation.
        with_D (bool): Flag to request construction of the D matrix. Default False. If True, the function computes the dipolar-coupling matrix D that depends on grid_coords and norm_vec; if False, the function returns D as None.
    
    Returns:
        tuple: A pair (D, S) where each element is as described below.
        D (numpy.ndarray or None): The dipolar-coupling matrix of shape (N, N) when with_D is True, otherwise None. Off-diagonal entries are computed from the analytical expression implemented in the source:
            D_ij = S_ij * (n_ij / r_ij^2) - 2 * xi_r_ij / sqrt(pi) * exp(-xi_r_ij^2) * (n_ij / r_ij^3),
        where r_ij is the Euclidean distance between tessera i and j, xi_r_ij = (xi_i * xi_j / sqrt(xi_i^2 + xi_j^2)) * r_ij, and n_ij is the projection of the vector r_i - r_j onto the normal vectors (computed via broadcasting). The diagonal entries are set to
            D_ii = -charge_exp_i * sqrt(2/pi) / (2 * R_vdw_i).
        S (numpy.ndarray): The Coulomb-like interaction matrix of shape (N, N). Off-diagonal entries are computed as
            S_ij = erf(xi_r_ij) / r_ij
        with rij replaced by 1 temporarily on the diagonal to avoid division-by-zero during the off-diagonal computation, and then the diagonal entries are set to
            S_ii = charge_exp_i * sqrt(2/pi) / switch_fun_i.
        The returned arrays follow the same numeric conventions as the inputs (no unit conversion is performed here).
    
    Behavior, defaults, and failure modes:
        - S is always computed and returned by this function. The with_S parameter is accepted but currently ignored.
        - D is computed only when with_D is True; otherwise D is returned as None.
        - The function uses scipy.spatial.distance.cdist to compute pairwise distances and scipy.special.erf for the error-function kernel; scipy and numpy must be available in the runtime environment.
        - To avoid a division-by-zero when computing off-diagonal S entries, the code temporarily fills the diagonal of the pairwise distance matrix with 1 and then explicitly assigns the diagonal of S using switch_fun. This ensures stable numerical behavior for identical coordinates on the diagonal.
        - If required keys are missing from surface, a KeyError will be raised. If array shapes are incompatible (for example lengths or 3-component coordinates/normals do not match), numpy broadcasting or arithmetic will raise a ValueError or produce invalid results; ensure charge_exp, switch_fun, and R_vdw are length-N arrays and grid_coords and norm_vec are shape (N, 3).
        - If any R_vdw entries are zero when with_D is True, the diagonal assignment for D will produce a division-by-zero (inf or runtime warning). Non-finite or NaN input values will propagate into the outputs.
        - No in-place modification of the surface dictionary is performed; all intermediate arrays are local to the function.
    
    Practical significance:
        - These matrices are used within the PCM implementation in PySCF to describe electrostatic interactions among discretized surface elements and to assemble linear systems for apparent surface charges and their response. S represents the Coulomb kernel between smeared surface charges; D encodes how those interactions change along the local surface normal directions and is required for treatments that include normal-derivative coupling or certain linear-response/PBC extensions. The returned matrices are intended to be consumed by higher-level PCM routines in pyscf.solvent.pcm and follow the conventions used in the cited J. Chem. Phys. publication.
    """
    from pyscf.solvent.pcm import get_D_S
    return get_D_S(surface, with_S, with_D)


################################################################################
# Source: pyscf.symm.addons.eigh
# File: pyscf/symm/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_symm_addons_eigh(h: numpy.ndarray, orbsym: list):
    """Solve the standard Hermitian (or real symmetric) eigenvalue problem by exploiting known symmetry labels of the basis to block-diagonalize the matrix before diagonalization.
    
    This function is a PySCF convenience wrapper used in the context of molecular electronic structure calculations (see the PySCF README). It delegates to pyscf.lib.linalg_helper.eigh_by_blocks to partition the input matrix into symmetry blocks defined by the orbital symmetry labels and then solves the eigenvalue problem block-wise. In practice this speeds up and clarifies diagonalization of operators represented in a basis (for example, one-electron integrals or Fock matrices transformed into a symmetry-adapted orbital basis) by returning eigenvalues and eigenvectors consistent with the supplied symmetry labeling.
    
    Args:
        h (numpy.ndarray): Square matrix to diagonalize. In PySCF workflows this is typically an operator represented in an orbital or atomic basis (for example, c.T * intor('int1e_*') * c in the example from the original docstring). The array must be two-dimensional and shape (n, n). The matrix is treated as Hermitian (or real symmetric); behavior for non-Hermitian input is delegated to the underlying eigh_by_blocks implementation.
        orbsym (list): Sequence of symmetry labels for each basis function (length n). Each entry identifies the symmetry (irreducible representation) of the corresponding row/column in h; these labels are used to group rows/columns into blocks. In PySCF this list is produced by routines such as symm.label_orb_symm and must correspond elementwise to the ordering of basis/orbitals used to build h.
    
    Returns:
        tuple: A pair (eigvals, eigvecs) where eigvals is a one-dimensional numpy.ndarray of eigenvalues and eigvecs is a two-dimensional numpy.ndarray whose columns are the corresponding eigenvectors. Eigenvectors are returned in the same basis/order as h and are grouped consistently with the provided orbsym labels. The first element contains the eigenvalues for all blocks concatenated in an order determined by the block decomposition performed by the underlying routine.
    
    Behavior and side effects:
        This function performs no in-place modification of the inputs; it constructs and diagonalizes block submatrices internally via pyscf.lib.linalg_helper.eigh_by_blocks. It relies on the correctness and consistency of orbsym with the ordering of h: if orbsym does not match the dimension or ordering of h, the block decomposition will be incorrect.
    
    Failure modes:
        If h is not a two-dimensional square numpy.ndarray with shape (n, n) or if len(orbsym) != n, the underlying block-diagonalization/diagonalization routine will raise an exception (for example ValueError or an error propagated from pyscf.lib.eigh_by_blocks). Numerical issues (e.g., non-Hermitian input, degenerate blocks) are handled as per the behavior of the underlying eigh_by_blocks implementation; errors or warnings from that routine may be raised or emitted.
    
    Notes:
        Use this function in PySCF workflows when you have symmetry-adapted orbital labels and wish to exploit point-group symmetry to reduce the cost of diagonalization and to obtain eigenvectors that preserve the specified symmetry assignments. The function simply forwards the inputs to pyscf.lib.eigh_by_blocks with labels=orbsym.
    """
    from pyscf.symm.addons import eigh
    return eigh(h, orbsym)


################################################################################
# Source: pyscf.solvent.hessian.smd_experiment.atomic_surface_tension
# File: pyscf/solvent/hessian/smd_experiment.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_solvent_hessian_smd_experiment_atomic_surface_tension(
    symbols: list,
    coords: numpy.ndarray,
    n: float,
    alpha: float,
    beta: float,
    water: bool = True
):
    """Calculates per-atom contributions to the SMD "surface tension" Hessian used in the SMD implicit-solvent model experimental routine. This routine assembles atomic tension tensors from pairwise switching-function second derivatives and solvent-specific tension parameters so that downstream code in the pyscf.solvent.hessian.smd_experiment module can combine these atomic contributions into the solvent-related part of a molecular Hessian. The implementation follows the structure in the source: it iterates over the provided atomic symbol list, uses module-level tables (for example sigma_water, sigma_n, sigma_alpha, sigma_beta and r_zz) and switching-function helpers (swtich_function, hess_swtich_function, smd_grad.grad_switch_function) to compute per-atom tensor contributions. Coordinates are expected in Angstrom as used throughout the SMD implementation in this module.
    
    Args:
        symbols (list): List of atomic symbols (strings) for the molecule in the same order as the coordinates. Each entry determines which per-atom/per-bond tension terms are computed (for example 'H', 'C', 'N', 'O' trigger different formulas). The function requires that len(symbols) == coords.shape[0]; unsupported symbols (not in the handled set) are mapped to zero-tension arrays.
        coords (numpy.ndarray): Atomic Cartesian coordinates with shape (natm, 3), where natm is the number of atoms (must equal len(symbols)). Coordinates are interpreted in Angstrom. The function uses pairwise differences and distances built from this array; coords with incorrect shape will cause an error (for example IndexError or ValueError) when array operations assume a (natm,3) layout.
        n (float): Solvent refractive-index-related descriptor used by the SMD parametrization. When water is False, this scalar multiplies entries from the module-level sigma_n dictionary to form part of bond/atom tension contributions. It has no effect if water is True.
        alpha (float): Solvent acidity descriptor used by the SMD parametrization. When water is False, this scalar multiplies entries from the module-level sigma_alpha dictionary to form part of bond/atom tension contributions. It has no effect if water is True.
        beta (float): Solvent basicity descriptor used by the SMD parametrization. When water is False, this scalar multiplies entries from the module-level sigma_beta dictionary to form part of bond/atom tension contributions. It has no effect if water is True.
        water (bool): If True (default), the function uses pre-tabulated water-specific per-atom/per-bond tensions (module-level sigma_water) and ignores the numeric n, alpha, beta descriptors. If False, tensions are formed by linear combination of sigma_n, sigma_alpha, sigma_beta entries with the supplied n, alpha, beta scalars. This flag controls the practical significance of the solvent descriptors and selects the parametrization branch used to compute tensions.
    
    Behavior, side effects, defaults, and failure modes:
      This function constructs an internal list "tensions" by iterating over each atom index i and computing a per-atom contribution tensor according to the atom type. For supported atom types the routine builds contributions from pairwise switching-function Hessians and gradients (via hess_swtich_function, smd_grad.grad_switch_function, and swtich_function) and multiplies them by bond- or atom-specific scalar tensions obtained either from sigma_water (when water is True) or from the linear combination sigma_n * n + sigma_alpha * alpha + sigma_beta * beta (when water is False). The function fills the pairwise distance matrix rij and replaces diagonal distances with 1 to avoid division-by-zero in distance-based operations (this mirrors the guard in the source code). Unsupported elements (atomic symbols not in the handled set) are assigned zero-valued arrays and do not contribute to the resulting tensions. The routine depends on several module-level variables and functions (for example sigma_*, r_zz, hess_swtich_function, swtich_function, smd_grad); if any of these are missing or not initialized, a NameError or similar exception will be raised. The implementation in the source contains specialized branches per element (H, C, N, O, and heavier halogens/Si/S/Cl/Br) and some branches intentionally return zero tensors for particular atom types per the current experimental parametrization. The default behavior (water=True) selects the water-specific parametrization. Because the code builds per-atom arrays of different internal shapes for different atom types, numpy will produce an array-of-objects when those shapes differ; callers should therefore be prepared to handle either a regular numeric ndarray (when all per-atom arrays broadcast to a common shape) or an object-dtype ndarray where each element is a numpy.ndarray holding that atom's tension contribution. The source contains a top-level "TODO: debug later" comment and certain array-shape inconsistencies in the implementation; callers should treat this function as experimental and verify shapes and numerical results before using them in production workflows.
    
    Returns:
        numpy.ndarray: One-dimensional numpy array (length natm) constructed from the internal list of per-atom tensors. Each element of this returned array is itself a numpy.ndarray that encodes the atomic contribution to the SMD surface-tension-related Hessian/tension for the corresponding atom in symbols. The exact inner-array shape depends on the atom type and the interactions present: for unsupported atoms the element is a zero array, while for supported atoms the per-atom array contains tensors assembled from switching-function Hessians and gradients (examples in the source include arrays initialized as zeros of shape (natm, 3) or (natm, natm, 3, 3)). The outer numpy.ndarray may therefore have dtype=object when per-atom arrays do not share a common shape. No value is written to disk; the return value is provided for in-memory use by downstream Hessian assembly and solvent-response computations.
    """
    from pyscf.solvent.hessian.smd_experiment import atomic_surface_tension
    return atomic_surface_tension(symbols, coords, n, alpha, beta, water)


################################################################################
# Source: pyscf.solvent.grad.pcm.get_dF_dA
# File: pyscf/solvent/grad/pcm.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_solvent_grad_pcm_get_dF_dA(surface: dict):
    """pyscf.solvent.grad.pcm.get_dF_dA: Compute the Cartesian derivatives of the per-grid switching function F and the per-grid surface area A with respect to atomic coordinates for use in polarizable continuum model (PCM) solvent gradient assembly. This routine implements the discrete-surface expression given in J. Chem. Phys. 133, 244111 (2010), Appendix C, and is intended for use inside PySCF's PCM gradient codepath to propagate how changes in atomic positions change the switched surface contributions used in solvent reaction-field and forces.
    
    Args:
        surface (dict): A dictionary describing the discretized molecular cavity surface and auxiliary data required to evaluate switching-function derivatives. Required keys (read-only) and their practical meanings are:
            atom_coords (numpy.ndarray): An array of shape (natom, 3) with Cartesian coordinates of nuclei/atoms in the same units as grid_coords. These coordinates are the variables with respect to which derivatives are computed; natom is the number of atoms.
            grid_coords (numpy.ndarray): An array of shape (ngrids, 3) with Cartesian coordinates of surface tesserae (surface grid points). ngrids is the total number of surface grid points across all atoms.
            switch_fun (numpy.ndarray): A one-dimensional array of length ngrids containing the switching-function values F at each grid point. In PCM, F is the smooth "switch" that blends cavity segments; its derivatives scaled by F contribute to solvent forces.
            area (numpy.ndarray): A one-dimensional array of length ngrids with the surface area weight A for each grid point (tessera area). The derivative of A with respect to atomic coordinates contributes to the solvent gradient via area-weighted integrals.
            R_in_J (array-like): An array broadcastable to the per-grid-per-atom riJ shape (for example length natom) that provides the reference inner radii R_in for the switching function for each atom-J pair. These values are used to form the reduced distance diJ = (riJ - R_in_J)/R_sw_J and are part of the switching-function definition from the referenced JCP appendix.
            R_sw_J (array-like): An array broadcastable to the per-grid-per-atom riJ shape (for example length natom) that provides the switching width parameters R_sw used in diJ. R_sw_J scales the spatial extent of the switching region and therefore controls how rapidly F and A change with geometry.
            gslice_by_atom (sequence of pairs of ints): For each atom index ia, surface['gslice_by_atom'][ia] is a 2-tuple (p0, p1) giving the half-open slice of grid indices [p0:p1] that are associated with atom ia (the contiguous block of grid points processed for that atom). This mapping is used to restrict local loops and enforce locality in the gradient evaluation.
            The function expects the provided arrays to be numeric numpy arrays or array-like objects that are compatible with numpy operations. All arrays are treated read-only by this function; the function does not modify the input dict or its arrays.
    
    Behavior, defaults, and numerical safeguards:
        - The function loops over atoms and for each atom processes only the grid points assigned to that atom via gslice_by_atom. For each grid point block it computes riJ = |r_i - R_J| (distance from grid point to every atom), forms the reduced distances diJ = (riJ - R_in_J) / R_sw_J, and evaluates a switching function h(diJ) and its gradient via module-level helpers switch_h and grad_switch_h (these helpers must be available in the same pcm gradient module and implement the switching functional form from the cited reference).
        - Self-contributions (grid point to its owning atom) are excluded by setting diJ[:, ia] = 1.0 followed by zeroing ri_rJ[:, ia, :] so that no spurious self-derivative arises.
        - Very small reduced distances are thresholded: entries with diJ < 1e-8 are set to zero and their coordinate-difference vectors ri_rJ are zeroed. This protects against numerical singularities when grid points coincide with atomic centers or when diJ is effectively zero.
        - The code computes dfiJ = grad_switch_h(diJ) / (fiJ * riJ * R_sw_J) and multiplies by the coordinate differences to obtain vector derivatives. If input arrays violate the assumptions (for example fiJ exactly zero for some diJ values or riJ exactly zero where not masked), floating-point exceptions or infinities may occur; the existing thresholding mitigates common cases but the caller must ensure physically sensible surface and radius inputs.
        - No global state is modified. The function constructs and returns new numpy arrays; it does not mutate the provided surface dict or its arrays.
    
    Failure modes and error conditions:
        - Missing required keys in the surface dict will raise a KeyError.
        - Incompatible array shapes or arrays that cannot be broadcasted to the expected per-grid-by-atom shape will raise numpy broadcasting or indexing errors (ValueError or IndexError).
        - If switch_h or grad_switch_h are not defined or do not accept the same array shapes expected here, a NameError or TypeError will be raised.
        - Numerical instabilities may arise for pathological inputs (e.g., zero switching widths R_sw_J, zero radii R_in_J combined with colocated points) despite the built-in small-value threshold; users should validate surface generation code that produced the surface dict.
    
    Returns:
        tuple(numpy.ndarray, numpy.ndarray): A pair (dF, dA) of numpy arrays, each with shape (ngrids, natom, 3). dF[i, a, :] is the Cartesian derivative of the switching function contribution F at grid index i with respect to the Cartesian coordinates of atom a; dA[i, a, :] is the Cartesian derivative of the surface area weight A at grid index i with respect to the Cartesian coordinates of atom a. These arrays are intended to be assembled into the full PCM solvent gradient (forces/energy derivatives) by higher-level routines in pyscf.solvent.grad.pcm and follow the conventions used in the referenced J. Chem. Phys. appendix.
    """
    from pyscf.solvent.grad.pcm import get_dF_dA
    return get_dF_dA(surface)


################################################################################
# Source: pyscf.symm.Dmatrix.get_euler_angles
# File: pyscf/symm/Dmatrix.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_symm_Dmatrix_get_euler_angles(c1: numpy.ndarray, c2: numpy.ndarray):
    """Find the three Euler angles (alpha, beta, gamma) in the z-y-z convention that rotate coordinates from frame c1 to frame c2.
    
    This function is used in PySCF's symmetry and rotation utilities (pyscf.symm.Dmatrix) to determine the intrinsic z-y-z Euler rotation that maps one coordinate frame or 3D point to another. In the context of quantum-chemistry workflows (see README), these Euler angles are commonly used to align molecular coordinate frames, rotate symmetry-adapted matrices, or construct rotation operators that transform basis functions and density matrices between frames. The implementation supports two input styles for backward compatibility: (a) 2D arrays that represent a right-handed orthonormal frame given by three axis vectors, and (b) 1D coordinate vectors representing single points in real space. Angles are returned in radians and follow numerical safeguards for near-parallel or antiparallel vectors.
    
    Args:
        c1 (numpy.ndarray): The source coordinate description to be rotated. Must be provided either as a 2D array or a 1D array:
            - If a 2D array, it is interpreted as a frame where c1[0], c1[1], c1[2] are the x, y, z axis vectors (typically length-3, unit or orthonormal vectors). The function computes the z-y-z Euler angles that rotate this frame into the frame described by c2. This mode is intended for rotating coordinate frames or basis axes (practical significance: aligning molecular frames or rotating symmetry-adapted axes).
            - If a 1D array, it is interpreted as a 3D point/vector in real space (length-3). In this backward-compatible mode the function computes angles that rotate the point c1 to c2 via intrinsic z-y-z rotations (practical significance: aligning individual coordinates).
            Numerical behavior: dot products and norms are compared to ±1 using a tolerance of 1e-12 to avoid NaNs from arccos; cross products are normalized with the usual Euclidean norm. No in-place modification of c1 occurs.
    
        c2 (numpy.ndarray): The target coordinate description after rotation. Must have the same form (2D frame or 1D point) as c1:
            - If a 2D array, it is interpreted as the destination frame with c2[0], c2[1], c2[2] as its x, y, z axis vectors. The function finds the intrinsic z-y-z Euler angles (alpha, beta, gamma) such that applying the z-y-z rotation to frame c1 yields frame c2 (practical significance: to produce rotation matrices that transform tensors or orbital coefficients between frames).
            - If a 1D array, it is interpreted as the destination 3D point to which c1 should be rotated. In this mode the function asserts that the Euclidean norms of c1 and c2 match to within 1e-12 (failure mode: an AssertionError is raised if norms differ beyond the tolerance).
            Numerical behavior: dot products close to ±1 are handled explicitly (using arccos(±1)) to maintain numerical stability; sign decisions for alpha and gamma are made by evaluating cross product orientations relative to the z axes of the frames.
    
    Returns:
        tuple(float, float, float): (alpha, beta, gamma) Euler rotation angles in radians following the z-y-z (intrinsic) convention. Practical details:
            - alpha and gamma are determined from arccos with sign corrections and therefore may lie in approximately [-pi, pi].
            - beta is computed from arccos of the z-axis dot product and lies in [0, pi].
            - Special cases where the corresponding dot product is numerically equal to ±1 are handled explicitly to avoid floating-point domain errors from arccos.
            - No side effects: the function does not modify its inputs and only returns the three angles. Failure modes include an AssertionError when c1 and c2 are 1D vectors with unequal norms (beyond 1e-12).
    """
    from pyscf.symm.Dmatrix import get_euler_angles
    return get_euler_angles(c1, c2)


################################################################################
# Source: pyscf.symm.addons.irrep_id2name
# File: pyscf/symm/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_symm_addons_irrep_id2name(gpname: str, irrep_id: int):
    """Convert an internal irreducible representation (irrep) identifier to the human-readable irrep symbol used by PySCF symmetry routines.
    
    This function is part of the pyscf.symm.addons utilities and is used throughout PySCF to translate numeric/internal irrep identifiers (the values recorded in IRREP_ID_TABLE in pyscf/symm/param.py) into standard irrep symbol strings (for example 'A1', 'B2u', etc.) for reporting, labeling orbitals, and interfacing with symmetry-aware routines. The function normalizes the provided point group name via std_symb and dispatches to specialized handlers for SO3 and linear-molecule groups (Dooh/Coov). For other point groups it maps the (possibly high-symmetry) integer id into the CHARACTER_TABLE entry for the normalized group, using the last digit of irrep_id when the id encodes high-symmetry information.
    
    Args:
        gpname (str): The point group symbol for the molecule or system, e.g. 'C1', 'C2v', 'D2h', 'SO3', 'Dooh', or 'Coov'. This string is normalized by std_symb before lookup. Its role is to select the appropriate character table or specialized conversion routine in the PySCF symmetry database (pyscf/symm/param.py and pyscf.symm.basis).
        irrep_id (int): The internal integer identifier for the irreducible representation as produced/defined by PySCF (see IRREP_ID_TABLE in pyscf/symm/param.py). For high-symmetry groups such as Dooh/Coov this integer may encode extra information; in the general mapping to non-linear groups the code uses irrep_id % 10 to obtain the index into the D2h-style character table. The value must be an integer compatible with the tables used by PySCF.
    
    Returns:
        str: The standardized irrep symbol corresponding to the provided gpname and irrep_id. For gpname == 'SO3' the symbol is produced by basis.so3_irrep_id2symb. For gpname in ('Dooh', 'Coov') the symbol is produced by basis.linearmole_irrep_id2symb(gpname, irrep_id). For other groups the symbol is taken as the first element of param.CHARACTER_TABLE[gpname][irrep_id % 10]. The returned string is intended for display, labeling orbitals, and consuming by other PySCF routines that expect standard irrep symbol names.
    
    Behavior and failure modes:
        The function has no side effects and does not modify input arguments. It relies on std_symb, the basis conversion helpers, and param.CHARACTER_TABLE maintained in pyscf/symm. If gpname does not correspond to a recognized point group after normalization, a KeyError will be raised when accessing param.CHARACTER_TABLE. If irrep_id is out of range for the selected group's table, an IndexError may be raised. A TypeError may occur if gpname is not a string or irrep_id is not an integer. Callers should ensure inputs conform to the conventions in pyscf/symm/param.py (IRREP_ID_TABLE and CHARACTER_TABLE) to avoid these errors.
    """
    from pyscf.symm.addons import irrep_id2name
    return irrep_id2name(gpname, irrep_id)


################################################################################
# Source: pyscf.solvent.smd.smd_radii
# File: pyscf/solvent/smd.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_solvent_smd_smd_radii(alpha: float):
    """pyscf.solvent.smd.smd_radii returns an element-indexed array of atomic van-der-Waals radii used by the SMD (Solvation Model based on Density) implementation in PySCF. The function builds a radii table from the package's radii.VDW baseline values (which in PySCF encode SMD/Bondi/default fallbacks) and applies SMD-specific overrides for selected elements. The oxygen radius is adjusted according to the SMD parametrization (eq. (16) in the SMD literature) using the scalar solvent parameter alpha. These radii are intended for use when constructing molecular solvation cavities and related continuum-solvation quantities inside the PySCF solvent/SMD code paths.
    
    Args:
      alpha (float): Solvent-dependent SMD parameter that controls the oxygen atomic radius via equation (16) of the SMD model. In this implementation, if alpha >= 0.43 the oxygen radius is set to 1.52 (Bohr units after the function's unit conversion); if alpha < 0.43 the oxygen radius is increased linearly as r = 1.52 + 1.8*(0.43 - alpha). alpha is treated as a plain Python float; non-finite values (NaN/inf) will raise exceptions during comparison/arithmetic. The parameter represents the same solvent-responsive quantity used by PySCF's SMD routines to modify cavity radii and must be provided by the caller when computing SMD solvation properties.
    
    Returns:
      numpy.ndarray: One-dimensional numeric array indexed by atomic number Z (element index) where the entry at index Z is the SMD atomic radius for that element expressed in atomic units (Bohr). The returned array has the same array-like type and indexing convention as radii.VDW from the PySCF radii module. The function applies the following explicit SMD overrides to the baseline radii (after the internal unit handling): hydrogen (Z=1) = 1.20, carbon (Z=6) = 1.85, nitrogen (Z=7) = 1.89, oxygen (Z=8) = value computed from alpha (see Args), fluorine (Z=9) = 1.73, silicon (Z=14) = 2.47, phosphorus (Z=15) = 2.12, sulfur (Z=16) = 2.49, chlorine (Z=17) = 2.38, bromine (Z=35) = 2.60 (SMD18 override), iodine (Z=53) = 2.74. Elements not explicitly overridden retain their values as provided by radii.VDW (which in PySCF encodes SMD radii when available, otherwise Bondi values, and historically a fallback value of 2.0 where radii were not defined). The routine returns a new array and does not modify the original radii.VDW object held in the radii module.
    
    Behavior and side effects:
      This function is pure with respect to external state: it operates on a copy of radii.VDW and returns a new array, leaving radii.VDW unchanged. It relies on the radii module (radii.VDW and radii.BOHR) being present and correctly populated; a missing or malformed radii module will raise an ImportError/NameError or similar at runtime when this function is called. The function performs a simple conditional adjustment for oxygen based on alpha (threshold 0.43) and explicit constant overrides for several elements (listed above). Units: the returned numbers are in Bohr (atomic units) consistent with the SMD implementation in PySCF. Failure modes: supplying non-finite alpha (NaN, inf) will cause runtime errors during comparison/arithmetic; extreme alpha values outside the range intended by the SMD parametrization will yield extrapolated oxygen radii according to the linear rule implemented here.
    """
    from pyscf.solvent.smd import smd_radii
    return smd_radii(alpha)


################################################################################
# Source: pyscf.solvent.smd_experiment.atomic_surface_tension
# File: pyscf/solvent/smd_experiment.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_solvent_smd_experiment_atomic_surface_tension(
    symbols: list,
    coords: numpy.ndarray,
    n: float,
    alpha: float,
    beta: float,
    water: bool = True
):
    """pyscf.solvent.smd_experiment.atomic_surface_tension computes per-atom surface-tension contributions used by the SMD (Solvation Model based on Density) experiment code path in PySCF. It evaluates atom-centered contributions for a molecular solute given atomic types, Cartesian coordinates, and three scalar solvent descriptors, combining per-atom and pairwise bond descriptors from module-level lookup tables to produce a numpy.ndarray of tensions aligned with the input atom ordering.
    
    This function is used within the implicit-solvent SMD implementation to estimate how each atom of a solute contributes to the solute–solvent surface tension term. It assembles contributions from (1) atom-type-specific base tensions and (2) pairwise bond/neighbor-dependent terms that are activated by interatomic distances and precomputed radius/switch parameters. The computation relies on module-level dictionaries and helper utilities defined elsewhere in the same module: sigma_water, sigma_n, sigma_alpha, sigma_beta, r_zz, and swtich_function. It also uses scipy.spatial.distance.cdist to form the NxN matrix of interatomic distances.
    
    Args:
        symbols (list): Ordered list of atomic symbols (strings) for the molecule, e.g. ['C', 'H', 'H', ...]. Each entry identifies the element of the corresponding atom and determines which lookup values and bond/neighbor rules are applied. Only atoms with symbols in ['H', 'C', 'N', 'O', 'F', 'Si', 'S', 'Cl', 'Br'] are processed with nonzero contributions; other symbols yield a tension of 0 in the output.
        coords (numpy.ndarray): Two-dimensional array of atomic Cartesian coordinates with shape (N, 3), where N == len(symbols). Coordinates are expected in Angstrom units (original source referred to "Anstrong"); pairwise distances are computed with scipy.spatial.distance.cdist. A mismatched length between symbols and coords or a coords array not shaped (N, 3) will raise an error (for example, IndexError or a shape-related exception from cdist) and represents a failure mode.
        n (float): Scalar solvent descriptor (named n in the source). This descriptor is combined with module-level bond/atom sensitivity coefficients stored in sigma_n to form part of the non-water solvent contribution. When the optional water flag is True, this parameter is not used because per-atom/bond sigma_water values are selected instead.
        alpha (float): Scalar solvent descriptor (named alpha in the source). This descriptor is multiplied by coefficients in the module-level sigma_alpha dictionary to contribute to atom/bond tensions for non-water solvents. As with n, if water is True the sigma_water values override usage of this descriptor.
        beta (float): Scalar solvent descriptor (named beta in the source). This descriptor is multiplied by coefficients in the module-level sigma_beta dictionary and combined into atom/bond tensions for non-water solvents. It is ignored when water is True.
        water (bool): Optional boolean flag (default True) that selects whether to use water-specific per-atom and per-bond tensions from the module-level sigma_water dictionary. If water is True, the function returns tensions determined solely by sigma_water lookups (falling back to 0.0 for missing keys) and ignores n, alpha, and beta. If water is False, tensions are assembled as linear combinations of sigma_n, sigma_alpha, and sigma_beta entries and the provided scalar descriptors. This flag does not change the required shapes of symbols or coords.
    
    Returns:
        numpy.ndarray: One-dimensional numpy.ndarray of length N with the per-atom surface-tension contributions in the same order as the input symbols. The numeric values are computed from the module-level sigma_* dictionaries, the r_zz radius/switch parameters, and activation by a switch function (swtich_function). Units and absolute scale are determined by the values stored in the module-level sigma_* dictionaries and r_zz; the function itself does not perform unit conversions. If the inputs are invalid (mismatched lengths, wrong coords shape, missing module-level lookup objects, or required third-party dependency scipy missing), the function will raise the corresponding Python exception (e.g., IndexError, ValueError, NameError, or ImportError) rather than returning a value.
    
    Additional behavior and failure modes:
        - The function computes an NxN pairwise distance matrix using scipy.spatial.distance.cdist, so memory and CPU scale as O(N^2); very large N may cause high memory use or slow performance.
        - The implementation checks element types and applies element-specific formulas: hydrogen and carbon include neighbor-dependent bond activations; nitrogen uses a non-integer exponent (1.3) for one of its neighbor terms; carbon uses a squared neighbor-count term for one contribution. These formulaic choices are taken verbatim from the source code and affect how neighbor geometry modulates per-atom tension.
        - The function depends on the presence and expected structure of module-level objects: sigma_water, sigma_n, sigma_alpha, sigma_beta (dictionaries keyed by atom symbol or tuple of atom symbols), r_zz (dictionary providing switch radius and width tuples), and the callable swtich_function. If any of these are absent or have unexpected contents, NameError or KeyError or TypeError may be raised.
        - Atoms with symbols not explicitly handled by the code (not in the list above) are assigned a tension of 0. The function does not modify its inputs (symbols, coords) and has no other side effects beyond reading module-level lookup tables and computing the returned array.
    """
    from pyscf.solvent.smd_experiment import atomic_surface_tension
    return atomic_surface_tension(symbols, coords, n, alpha, beta, water)


################################################################################
# Source: pyscf.symm.Dmatrix.dmatrix
# File: pyscf/symm/Dmatrix.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_symm_Dmatrix_dmatrix(l: int, beta: float, reorder_p: bool = False):
    """Wigner small-d matrix (z-y-z convention).
    
    Computes the Wigner small-d matrix d^l(beta) for angular-momentum rank l and rotation
    angle beta using the z-y-z Euler-convention commonly used in quantum chemistry and
    angular-momentum algebra. In PySCF this function is used to construct rotation
    operators and symmetry-transformation matrices for spherical tensors, spherical
    harmonics, and spin-orbital block rotations that appear in symmetry-adapted
    electronic-structure calculations. For small l (0, 1, 2) the implementation uses
    closed-form expressions; for larger l it evaluates the standard factorial-based
    sum (vectorized with NumPy) that implements the conventional definition of the
    Wigner small-d matrix elements d^l_{m1,m2}(beta) = <l,m1| e^{-i beta J_y} |l,m2>.
    
    Args:
        l (int): The angular-momentum rank (non-negative integer) of the Wigner
            small-d matrix. Physically, l corresponds to the total angular-momentum
            quantum number (for example, l=0 for s, l=1 for p, l=2 for d functions).
            The returned matrix has shape (2*l+1, 2*l+1), with rows/columns indexed
            by magnetic quantum numbers m = -l,...,+l in increasing order. Passing
            a negative or non-integer l will cause internal NumPy array construction
            to fail (ValueError or related exception); callers should ensure l is a
            non-negative int.
        beta (float): The rotation angle (in the same units used by numpy trigonometric
            functions, i.e. radians) for the rotation about the y axis in the
            z-y-z Euler convention. The function computes cos(beta/2) and sin(beta/2)
            internally and uses these values in closed-form (l<=2) or factorial-sum
            (l>2) formulas. Extremely large |beta| are allowed (periodicity applies),
            but numerical cancellation can occur for large l or angles producing
            very small matrix elements.
        reorder_p (bool): Optional flag (default False). For l == 1 only, if True the
            function reorders rows and columns by the permutation [2, 0, 1] before
            returning. This reordering changes the magnetic-quantum-number indexing
            convention and is provided to match alternative conventions used in some
            parts of quantum-chemistry code (it permutes the basis ordering for p
            orbitals). For l != 1 this flag has no effect (the code does not apply
            any reordering).
    
    Returns:
        numpy.ndarray: A real-valued NumPy array of shape (2*l+1, 2*l+1) containing
        the Wigner small-d matrix elements d^l_{m1,m2}(beta) using the z-y-z
        convention. The matrix elements are returned in row-major order with the
        first row/column corresponding to m = -l and the last to m = +l, unless
        reorder_p=True for l==1 in which case the matrix has been permuted by
        [2,0,1] in both rows and columns. No in-place modification of caller data
        occurs; the function allocates and returns a new NumPy array.
    
    Notes and failure modes:
        - For l == 0 the function returns a 1x1 identity matrix.
        - For l == 1 and l == 2 optimized closed-form real-valued expressions are
          used (faster and more accurate than the general factorial sum).
        - For l > 2 a factorial-based summation formula is evaluated. Because
          factorials grow rapidly, very large l can cause floating-point overflow,
          underflow, or loss of precision; numerical accuracy degrades with l.
        - The function assumes beta is given in radians consistent with NumPy's
          trigonometric functions; no unit conversion is performed.
        - The implementation relies on NumPy and returns NumPy floating types; users
          who require increased precision should convert the result or adapt the
          routine to use higher-precision arithmetic.
        - The function does not explicitly validate types beyond relying on Python
          and NumPy behavior; passing incompatible types will raise the corresponding
          exceptions from NumPy (TypeError, ValueError, or related errors).
    """
    from pyscf.symm.Dmatrix import dmatrix
    return dmatrix(l, beta, reorder_p)


################################################################################
# Source: pyscf.symm.addons.find_symmetric_mo
# File: pyscf/symm/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_symm_addons_find_symmetric_mo(
    moso: numpy.ndarray,
    ovlpso: numpy.ndarray,
    thr: float = 1e-08
):
    """Find the molecular orbitals (MOs) that are symmetry-adapted to a given irreducible representation (irrep) in PySCF.
    
    This function is used in PySCF to identify which columns of a molecular orbital coefficient matrix transform purely within a symmetry-adapted atomic-orbital (AO) subspace (an irrep block). In practice, callers construct moso as the overlap between symmetry-adapted AOs and MOs (for example by reduce(numpy.dot, (csym.T.conj(), s, mo)), where csym comes from mol.symm_orb and s is the AO overlap matrix) and ovlpso as the overlap matrix of the symmetry-adapted AOs (for example by reduce(numpy.dot, (csym.T.conj(), s, csym))). The routine projects each MO into the symmetry-adapted AO block by solving ovlpso * x = moso[:, j] (via a Cholesky-based solver) and then computes the self-overlap diag = <moso[:, j] | x>. MOs with diag numerically equal to 1 (within the tolerance thr) are considered to transform like that irrep and are selected.
    
    Args:
        moso (numpy.ndarray): 2D float array with shape (n_ao_sym, n_mo). This is the overlap matrix of symmetry-adapted AO and MO: rows index symmetry-adapted AO basis functions for the targeted irrep block, and columns index molecular orbitals. In PySCF workflows this array is typically obtained from csym (mol.symm_orb), the AO overlap matrix s, and the full MO coefficients mo as reduce(numpy.dot, (csym.T.conj(), s, mo)). The function uses moso to test how well each MO is represented entirely within the given AO symmetry block.
        ovlpso (numpy.ndarray): 2D float array with shape (n_ao_sym, n_ao_sym). This is the overlap matrix between symmetry-adapted AOs for the same irrep block (for example reduce(numpy.dot, (csym.T.conj(), s, csym))). ovlpso is used as the metric for projecting MOs into the AO subspace via a Cholesky-based linear solve. Note: if ovlpso is numerically singular, the implementation will add a tiny diagonal shift (1e-12) to ovlpso in-place to allow the solver to proceed; this mutates the provided ovlpso array.
        thr (float): Threshold to consider an MO symmetry-adapted. Default is 1e-8. After projecting each MO into the symmetry-adapted AO subspace and computing the self-overlap value diag_j = <moso[:, j] | (ovlpso^{-1} moso[:, j])>, the MO is marked as symmetry-adapted if abs(1 - diag_j) < thr. Use a smaller thr for stricter classification and a larger thr to tolerate more numerical deviation.
    
    Returns:
        numpy.ndarray: 1D bool array of length n_mo. Each element is True if the corresponding column of moso (the corresponding MO) is classified as symmetry-adapted to the provided AO irrep block (i.e., its projected self-overlap diag is within thr of 1), and False otherwise. The array can be used as a boolean index to select symmetry-adapted MOs from the original MO coefficient matrix.
    
    Behavior, side effects, and failure modes:
        The function solves linear systems ovlpso * x = moso[:, j] using a Cholesky-based solver (pyscf.lib.cho_solve) and computes diag values via numpy.einsum. If the initial Cholesky solve raises numpy.linalg.LinAlgError due to near-singularity of ovlpso, the function adds 1e-12 to the diagonal elements of ovlpso in-place and retries the solve; this modifies the caller-provided ovlpso array. If the solver still fails after the diagonal perturbation, the LinAlgError will propagate to the caller. Shape mismatches between moso and ovlpso (incompatible n_ao_sym or unexpected array dimensionality) will raise standard NumPy broadcasting or linear-algebra exceptions. The function does not return additional diagnostic information; callers who need the numeric diag values should compute them separately using the same inputs.
    """
    from pyscf.symm.addons import find_symmetric_mo
    return find_symmetric_mo(moso, ovlpso, thr)


################################################################################
# Source: pyscf.symm.Dmatrix.Dmatrix
# File: pyscf/symm/Dmatrix.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_symm_Dmatrix_Dmatrix(
    l: int,
    alpha: float,
    beta: float,
    gamma: float,
    reorder_p: bool = False
):
    """pyscf.symm.Dmatrix.Dmatrix returns the Wigner rotation D-matrix for angular momentum l and a rotation specified by Euler angles in the z-y-z convention. The matrix implements D_{m m'} = <l m | R(alpha, beta, gamma) | l m'> and is commonly used in PySCF for rotating spherical-harmonic angular-momentum basis functions (for example when transforming molecular orbital or integral representations under symmetry operations).
    
    Args:
        l (int): The angular momentum quantum number l >= 0. This determines the size of the returned square matrix, which has shape (2*l+1, 2*l+1) and indices corresponding to magnetic quantum numbers m = -l, -l+1, ..., l. The function expects a non-negative integer; providing a negative value or a non-integer will lead to incorrect behavior or runtime errors.
        alpha (float): The first Euler angle (rotation about z) in radians. In the z-y-z convention used here, this angle contributes a phase factor e^{-i * alpha * m} multiplying the left side (row index m) of the small-d matrix.
        beta (float): The second Euler angle (rotation about y) in radians. This angle is passed to the internal small-d matrix generator dmatrix(l, beta) to produce the real-valued Wigner small-d matrix d_{m m'}(beta) used between the two z-rotations.
        gamma (float): The third Euler angle (rotation about z) in radians. In the z-y-z convention, this angle contributes a phase factor e^{-i * gamma * m'} multiplying the right side (column index m') of the small-d matrix.
        reorder_p (bool): Whether to reorder p functions (l == 1) into Cartesian (x, y, z) ordering. Default is False. Practical significance: different parts of PySCF and external integral conventions expect p-function ordering either in the spherical-harmonic sequence m = -1,0,1 or in Cartesian x,y,z order. When reorder_p is True and l == 1, the returned matrix is permuted by the index mapping [2,0,1] applied to both rows and columns, so that the output matches the (x,y,z) ordering. For l != 1 this parameter is ignored (no reordering is applied). Note: internally the small-d and real-basis conversion routines are called with their own reorder flags set to False; the only explicit permutation performed by this function is the final [2,0,1] permutation when l == 1 and reorder_p is True.
    
    Returns:
        numpy.ndarray: A square matrix of shape (2*l+1, 2*l+1) whose element at row index corresponding to m and column index corresponding to m' equals D_{m m'} = <l m | R(alpha,beta,gamma) | l m'> computed in the real spherical-harmonic basis with m indices ordered from -l to l. For l == 0 this function returns a 1x1 identity matrix. For l > 0 the matrix is assembled as D_{m m'} = exp(-i*alpha*m) * d_{m m'}(beta) * exp(-i*gamma*m'), where d_{m m'}(beta) is the Wigner small-d matrix generated by dmatrix(l, beta), and then converted to the real basis via the internal _dmat_to_real routine. The entries are in general complex due to the phase factors from the z-rotations; special cases and particular Euler angles can yield purely real matrices.
    
    Behavior and failure modes:
        - The function assumes l is a non-negative integer. Passing negative or non-integer l values will produce incorrect results or runtime exceptions (the code uses numpy.arange(-l, l+1) and indexing that depend on integer l).
        - alpha, beta, gamma are expected to be real-valued angles in radians. Non-finite values (NaN or infinities) will propagate and produce invalid matrix entries.
        - reorder_p only affects the output when l == 1; for other l values it has no effect.
        - Numerical round-off errors can accumulate for large l due to the use of standard floating-point arithmetic in computing exponentials and small-d matrix elements.
        - There are no external side effects; the function returns the rotation matrix and does not modify global state.
    """
    from pyscf.symm.Dmatrix import Dmatrix
    return Dmatrix(l, alpha, beta, gamma, reorder_p)


################################################################################
# Source: pyscf.symm.addons.irrep_name2id
# File: pyscf/symm/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_symm_addons_irrep_name2id(gpname: str, symb: str):
    """Convert an irreducible-representation (irrep) symbol used in molecular point-group symmetry to the internal integer irrep ID used throughout PySCF's symmetry machinery.
    
    This function is part of PySCF's symmetry utilities for quantum-chemistry calculations (see project README). It accepts human-readable point-group and irrep symbols, canonicalizes them with std_symb, and maps them to the internal integer identifier that PySCF uses to index symmetry blocks, orbitals, basis-function blocks, and other symmetry-dependent data structures. The mapping behavior depends on the canonicalized point group: SO3 irreps are handled by basis.so3_irrep_symb2id, linear-molecule groups Dooh/Coov are handled by basis.linearmole_irrep_symb2id, and all other groups are looked up in param.IRREP_ID_TABLE.
    
    Args:
        gpname (str): The point-group symbol for the molecular symmetry (for example 'C2v', 'D3h', 'SO3', 'Dooh', or 'Coov'). This string is normalized by std_symb before lookup to produce a canonical point-group name; the canonical name determines which internal table or helper is used to convert the irrep symbol to an integer ID. Providing the correct point-group label is required because different groups use different mapping tables or helper functions.
        symb (str): The irrep symbol within the given point group (for example 'A1', 'E', 'T2g', or other group-specific labels). This string is also normalized by std_symb before lookup. The symbol must be a valid irrep name for the (canonicalized) gpname; the returned integer corresponds to the internal ID for that particular irrep in PySCF.
    
    Behavior and side effects:
        Both gpname and symb are passed through std_symb to standardize formatting and aliases before any mapping is attempted. If the canonical gpname is 'SO3', the function delegates to basis.so3_irrep_symb2id(symb). If the canonical gpname is 'Dooh' or 'Coov', the function delegates to basis.linearmole_irrep_symb2id(gpname, symb). For all other canonical point groups, the function performs a dictionary lookup in param.IRREP_ID_TABLE[gpname][symb] to obtain the integer ID. The function has no side effects beyond calling these helpers and performing lookups; it does not modify global state or input objects.
    
    Failure modes and notes:
        If gpname or symb cannot be canonicalized to a recognized point group or irrep name, the std_symb call or the subsequent mapping/lookup may raise an exception (for example a KeyError from param.IRREP_ID_TABLE or whatever exception the delegated helper functions raise). Callers should ensure they pass valid, canonicalizable point-group and irrep strings. The function assumes string inputs and the semantics of std_symb and the basis/param helpers; it does not perform automatic correction of fundamentally invalid labels.
    
    Returns:
        int: The internal irrep ID corresponding to the provided (canonicalized) irrep symbol within the specified point group. This integer is the index used by PySCF to identify symmetry irreps in internal tables (param.IRREP_ID_TABLE) and to index symmetry-adapted objects such as orbital blocks, integrals, and representation matrices.
    """
    from pyscf.symm.addons import irrep_name2id
    return irrep_name2id(gpname, symb)


################################################################################
# Source: pyscf.symm.addons.std_symb
# File: pyscf/symm/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_symm_addons_std_symb(gpname: str):
    """pyscf.symm.addons.std_symb converts a point-group name string into the canonical capitalization format used by PySCF's symmetry handling routines.
    
    This function is used in the symmetry subsystem of the PySCF electronic structure framework to normalize user-provided or computed point-group identifiers so that downstream code (for example, symmetry-adapted basis generation, integral symmetry classification, and point-group specific algorithms) can rely on a consistent symbol format. The routine preserves a special-case symbol ('SO3') exactly as given by the caller; for all other non-empty strings it returns a new string with the first character capitalized and all remaining characters converted to lower-case, which matches common point-group notation such as D2h.
    
    Args:
        gpname (str): The input point-group name provided by the caller. This is the raw symbol identifying a molecular or rotational symmetry group (for example 'd2h', 'D2H', 'SO3'). The function treats this value as textual input and returns a standardized string for use by PySCF symmetry modules. The function expects a non-empty Python string; passing a non-string object may raise a TypeError when the code attempts string indexing or case conversion, and passing an empty string will raise an IndexError due to indexing gpname[0]. The comparison for the special-case 'SO3' is case-sensitive: only the exact string 'SO3' is returned unchanged.
    
    Returns:
        str: A canonicalized point-group symbol suitable for use within PySCF. For most inputs, this is gpname[0].upper() + gpname[1:].lower(), which converts examples like 'd2h' or 'D2H' to 'D2h'. If gpname is exactly 'SO3', the original string 'SO3' is returned unchanged. No other side effects occur; the function does not modify global state or its input object (it returns a new string).
    """
    from pyscf.symm.addons import std_symb
    return std_symb(gpname)


################################################################################
# Source: pyscf.symm.geom.alias_axes
# File: pyscf/symm/geom.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_symm_geom_alias_axes(axes: numpy.ndarray, ref: numpy.ndarray):
    """pyscf.symm.geom.alias_axes renames/reorders a set of Cartesian axes so they are as close as possible to a reference axis frame and enforces a right-handed coordinate system.
    
    Args:
        axes (numpy.ndarray): Array containing the candidate Cartesian axes to be renamed and reordered. In the PySCF symmetry and geometry context this is expected to contain three Cartesian axis vectors (axis vectors are used to define coordinate frames for molecules and symmetry operations). The function indexes the first axis dimension (axes[[...]]), so in typical usage axes is a 3x3 array with each row (or the first-axis entries) representing a Cartesian axis vector. The array is not modified in-place; a reordered copy is produced and returned.
        ref (numpy.ndarray): Reference Cartesian axes used to choose the ordering. In PySCF this represents the desired coordinate frame (for example a canonical molecular frame or a symmetry reference). The function uses ref to determine which permutation of axes best matches the reference via an internal helper closest_axes.
    
    Returns:
        numpy.ndarray: A new numpy.ndarray containing the reordered axes chosen to be as close as possible to ref. The returned array has the same array-like layout as the input and, in typical PySCF usage, will be a 3x3 array with axis vectors ordered to match ref. To preserve a right-handed coordinate system the implementation checks the determinant of the reordered axes and, if the determinant is negative, swaps the first two axes (x and y) so the returned frame is right-handed (determinant >= 0 when possible). The input arrays are not modified; the returned array is a reordering/copy.
    
    Behavior, side effects, and failure modes:
        The function computes an index triplet (x_id, y_id, z_id) by calling the module's closest_axes helper to pick which of the provided axes best corresponds to the reference axes. It then forms a new_axes array by reordering axes with that index triplet. If numpy.linalg.det(new_axes) < 0 the implementation swaps the x and y selections (equivalently axes[[y_id, x_id, z_id]]) to attempt to restore a right-handed coordinate system. There are no other side effects (no global state is changed). If axes and ref do not have compatible shapes (for example not indexable to select three axis entries, or not square so that numpy.linalg.det can be evaluated) NumPy will raise the usual errors (IndexError, ValueError, or TypeError) propagated to the caller. The function does not validate orthonormality of axes; it only reorders and enforces handedness by a sign check on the determinant. The exact tie-breaking and metric used to decide "closest" are implemented by closest_axes; callers who require a different metric should reorder axes prior to calling or call closest_axes directly.
    """
    from pyscf.symm.geom import alias_axes
    return alias_axes(axes, ref)


################################################################################
# Source: pyscf.symm.geom.rotation_mat
# File: pyscf/symm/geom.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_symm_geom_rotation_mat(vec: numpy.ndarray, theta: float):
    """pyscf.symm.geom.rotation_mat returns a 3x3 rotation matrix for rotating 3D Cartesian vectors by an angle theta about an axis specified by vec. The function is used throughout PySCF geometry and symmetry utilities to perform rigid-body rotations of atomic coordinates, molecular frames, and to construct rotation operators needed for point-group symmetry operations and coordinate transformations in electronic structure calculations.
    
    Args:
        vec (numpy.ndarray): A length-3 1D array-like Cartesian vector that specifies the rotation axis in 3-dimensional space. The components are interpreted as (x, y, z) in the same Cartesian coordinate system used for molecular coordinates in PySCF. The axis vector is normalized internally by a call to _normalize(vec) before building the rotation matrix, so the caller may pass a non-unit vector; if vec has zero length or cannot be normalized, the underlying normalization routine will fail (raising an exception) and no rotation matrix will be returned. The input must be compatible with numpy.reshape(-1, 1) / reshape(1, -1) to produce a 3-element vector; providing an array with a size other than 3 will trigger a numpy error from the reshape or subsequent operations.
        theta (float): Rotation angle in radians. The function uses numpy.cos and numpy.sin, so theta is interpreted in radians. Positive theta follows the right-hand rule about the axis given by vec: when vec points toward the observer, a positive theta produces a counterclockwise rotation of vectors in the plane perpendicular to vec.
    
    Returns:
        numpy.ndarray: A 3x3 floating-point orthogonal rotation matrix R (dtype typically numpy.float64) such that new(x,y,z) = R * old(x,y,z) when old and new are 3-component column vectors. The matrix is constructed using Rodrigues' rotation formula: R = c*I + s*U_x + (1-c)*(u u^T), where c = cos(theta), s = sin(theta), U_x is the 3x3 skew-symmetric cross-product matrix of the normalized axis, and u u^T is the outer product of the normalized axis with itself. The returned matrix has determinant ≈ +1 (proper rotation) and no side effects on global state.
    
    Behavior, defaults, and failure modes:
        The axis vector is normalized internally; callers do not need to supply a unit vector. If vec has zero magnitude, or is not shape-compatible with a length-3 vector, the internal normalization or reshaping will raise an exception (for example ValueError or a numpy-related error). The function does not perform input type coercion beyond what numpy operations require; non-numeric inputs or arrays with incorrect sizes will result in exceptions propagated from numpy or the _normalize helper. The function has no side effects (it does not modify its inputs or global state) and returns a new numpy.ndarray representing the rotation operator for use in transforming coordinates, basis-function centers, or other 3D vectors in PySCF calculations.
    """
    from pyscf.symm.geom import rotation_mat
    return rotation_mat(vec, theta)


################################################################################
# Source: pyscf.symm.geom.is_identical_geometry
# File: pyscf/symm/geom.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_symm_geom_is_identical_geometry(
    coords1: numpy.ndarray,
    coords2: numpy.ndarray,
    weights: numpy.ndarray
):
    """pyscf.symm.geom.is_identical_geometry: Fast check whether two molecular geometries are identical using Casimir tensors.
    
    Performs a computationally efficient comparison between two sets of atomic coordinates by computing Casimir tensor invariants (orders 1 through 3) for each geometry with the supplied per-atom weights and verifying that the maximum absolute difference for each tensor order is within the module's global tolerance. This function is intended for use inside the PySCF electronic structure framework to quickly determine whether two molecular geometries can be treated as the same geometry (for example, to avoid redundant symmetry analyses, integral rebuilds, or expensive reinitializations) before invoking more expensive routines.
    
    Args:
        coords1 (numpy.ndarray): Array of atomic coordinates for the first geometry. This should be a numeric NumPy array whose leading dimension indexes atoms and whose remaining dimensions store Cartesian coordinates (commonly shaped (N, 3) for N atoms). The function requires coords1.shape == coords2.shape; if the shapes differ the function returns False immediately. The coordinates are used as input to compute Casimir tensor invariants that summarize the spatial arrangement of the atoms.
        coords2 (numpy.ndarray): Array of atomic coordinates for the second geometry to compare against coords1. Must be a numeric NumPy array with the same shape as coords1. The geometry represented by coords2 is converted to Casimir tensor invariants using the same weights and compared order-by-order (orders 1 through 3) to the invariants from coords1.
        weights (numpy.ndarray): Per-atom numeric weights supplied as a NumPy array. These weights are used when forming the Casimir tensors (for example, they may encode atomic masses, nuclear charges, or element-dependent coefficients) and must be aligned with the atom indexing of coords1 and coords2 (i.e., the atom dimension of weights must correspond to the atom dimension of the coordinate arrays). The same weights are applied to both geometries during invariant computation.
    
    Behavior and side effects:
        The function computes Casimir tensor invariants for orders 1, 2, and 3 for both geometries and compares them. For each order, it computes the elementwise absolute difference between the two tensors and checks the maximum of that difference against the module-level TOLERANCE constant. If any order exhibits a maximum absolute difference greater than TOLERANCE, the function concludes the geometries are different and returns False. If all three orders are within TOLERANCE, it returns True. There are no side effects: the input arrays are not modified. If coords1.shape != coords2.shape the function returns False immediately without computing tensors. If coords or weights contain NaN or infinite values, the result is undefined and may lead to False or propagation of NaNs during comparisons; callers should ensure numeric finite inputs.
    
    Failure modes and limitations:
        The check is a fast heuristic based on Casimir tensor invariants up to order 3 and relies on the global TOLERANCE threshold; geometries that differ by amounts smaller than TOLERANCE will be treated as identical. The method is intended to detect equivalence up to global rotations/translations as encoded by the Casimir tensors, but it is not a substitute for exhaustive permutation-aware graph isomorphism checks for chemically equivalent atoms of identical element types unless weights are chosen appropriately. Mismatched input shapes cause immediate False. Inputs that are not numeric numpy.ndarray objects will raise typical NumPy errors when used in tensor computations.
    
    Returns:
        bool: True if coords1 and coords2 are judged identical under the Casimir-tensor comparison (orders 1–3) using the provided weights and the module TOLERANCE; False otherwise.
    """
    from pyscf.symm.geom import is_identical_geometry
    return is_identical_geometry(coords1, coords2, weights)


################################################################################
# Source: pyscf.solvent.pcm.get_F_A
# File: pyscf/solvent/pcm.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_solvent_pcm_get_F_A(surface: dict):
    """pyscf.solvent.pcm.get_F_A: Generate the F (switch function) and A matrices used by the polarizable continuum model (PCM) implementation in PySCF, following the formulation and notation in J. Chem. Phys. 133, 244111 (2010).
    
    This function extracts surface discretization data from the provided surface dictionary and computes the A matrix entrywise as A = weights * R_vdw**2 * switch_fun. In the PCM algorithm, the switch function modulates contributions of tesserae (surface elements) and acts as the F prefactor in linear equations for apparent surface charges; A combines the surface quadrature weights, the square of the van der Waals radius at each tessera, and that switch prefactor to produce the prefactor used in matrix assembly. The function performs only elementwise arithmetic and does not modify the input dictionary or any global state.
    
    Args:
        surface (dict): Surface descriptor dictionary produced by PCM surface-generation routines in PySCF. Must contain the keys 'R_vdw', 'switch_fun', and 'weights'. Each value is expected to be a numeric sequence or array-like object (the same length or broadcastable shapes) representing per-tessera quantities:
            - 'R_vdw': per-tessera van der Waals radii used in PCM surface discretization; these radii are squared and scale A.
            - 'switch_fun': per-tessera switch function values that act as the F prefactor in PCM equations (returned as the first output).
            - 'weights': per-tessera quadrature weights for surface integrals; these weight the contribution of each tessera to A.
        The order and exact names of the keys are significant: missing keys will cause a KeyError. The arithmetic requires that the three values support elementwise multiplication; mismatched shapes that cannot be broadcast for elementwise operations will raise an error (for example, ValueError from the underlying numeric library).
    
    Returns:
        tuple: A 2-tuple (switch_fun, A) where:
            switch_fun: The same object/value taken from surface['switch_fun']. In PCM terminology this is the F prefactor (switch function) applied per tessera; it is returned so callers can use the prefactor directly in subsequent matrix assembly without re-extracting it from the input dictionary.
            A: The computed A matrix entries (elementwise values) given by weights * R_vdw**2 * switch_fun. A provides the per-tessera prefactors used when assembling PCM linear operators and right-hand sides; callers typically use these values when building the discrete linear system for apparent surface charges.
        No in-place modification of the input surface dictionary is performed.
    
    Raises:
        KeyError: If surface does not contain one or more required keys: 'R_vdw', 'switch_fun', or 'weights'.
        TypeError: If the values for these keys do not support the required numeric operations (e.g., cannot be multiplied).
        ValueError: If the shapes of the values are incompatible for elementwise multiplication and cannot be broadcast together by the underlying numeric library.
    """
    from pyscf.solvent.pcm import get_F_A
    return get_F_A(surface)


################################################################################
# Source: pyscf.symm.addons.route
# File: pyscf/symm/addons.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_symm_addons_route(target: int, nelec: int, orbsym: list):
    """pyscf.symm.addons.route selects a combination of orbital indices that produce a Slater determinant with a desired overall point-group symmetry label. In the PySCF electronic-structure context, orbital symmetry labels (orbsym) are integer-encoded irreducible representations and are combined with a bitwise exclusive OR (XOR) to obtain the determinant symmetry; this function searches for nelec orbitals whose XOR equals the target symmetry and returns the corresponding 0-based indices.
    
    Args:
        target (int): Desired overall symmetry label for the determinant. This integer is the target irreducible-representation code used in PySCF symmetry bookkeeping; the function looks for a set of orbital symmetry labels that combine (via bitwise XOR) to this target value. Practical significance: use the same integer encoding of point-group irreps as used elsewhere in PySCF to request a determinant of that symmetry.
        nelec (int): Number of electrons (equivalently, number of orbitals to occupy) to select for the determinant. This must be a positive integer (nelec >= 1) because the implementation treats the nelec == 1 case specially; calling with nelec > len(orbsym) cannot succeed and will return an empty list. Passing nelec <= 0 leads to undefined behavior (possible uncontrolled recursion) and is not supported.
        orbsym (list): Sequence of integer symmetry labels for available molecular orbitals, in the same order as the orbital indices used elsewhere in PySCF. Each element is an integer irreducible-representation code; the function combines chosen entries with bitwise XOR to test whether they produce the target. The implementation also accepts a numpy.ndarray for orbsym (it will be converted to a Python list internally), but the canonical expected type in the API signature is a list. Practical significance: orbsym describes the symmetry of each orbital used to construct many-electron determinants that respect point-group symmetry.
    
    Returns:
        list: A Python list of 0-based integer orbital indices that, when the corresponding orbsym entries are combined with bitwise XOR, yield the target symmetry. The returned list has length equal to nelec and preserves increasing order of indices (the search picks combinations without repetition and returns the first matching combination found). If no valid combination exists, returns an empty list ([]). Side effects: none on caller objects (the function may convert a numpy.ndarray orbsym to a local list but does not mutate the input). Performance and failure modes: the routine uses a recursive combinatorial search and can be exponential in nelec; it stops at the first solution found and does not enumerate all solutions. Use this function in PySCF workflows when you need to pick orbitals that form a determinant of a specified point-group symmetry; validate that target and orbsym use the same integer encoding and that nelec is within [1, len(orbsym)].
    """
    from pyscf.symm.addons import route
    return route(target, nelec, orbsym)


################################################################################
# Source: pyscf.symm.basis.linearmole_symm_descent
# File: pyscf/symm/basis.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_symm_basis_linearmole_symm_descent(gpname: str, irrep_id: int):
    """pyscf.symm.basis.linearmole_symm_descent maps an irreducible representation identifier from a linear-molecule point group encoding used elsewhere in PySCF down to the equivalent D2h or C2v irreducible representation identifier. This reduction is used in PySCF's symmetry handling for linear molecules so that routines which only implement D2h/C2v symmetry (for example, symmetry-aware integral evaluation, orbital labeling, and symmetry-adapted post-Hartree–Fock methods) can operate on representations originating from the higher-order linear groups.
    
    Args:
        gpname (str): The name of the point group encoding for a linear molecule as used in PySCF. This function accepts exactly the two canonical linear-group identifiers 'Dooh' and 'Coov' (the PySCF-internal names corresponding to the D∞h and C∞v families of linear-molecule symmetry). The gpname determines whether the function will attempt the symmetry descent; any other gpname is considered invalid for this routine and triggers an error.
        irrep_id (int): An integer identifier for an irreducible representation in the original linear-group encoding. In PySCF this integer encodes the specific irrep label assigned by upstream symmetry-processing code; the practical role of irrep_id is to be reduced to the corresponding D2h or C2v irrep id so that D2h/C2v-only routines can consume it. The function computes the reduction by taking irrep_id % 10 (the least-significant decimal digit), so irrep_id is expected to be an integer that encodes the irrep in the same scheme used elsewhere in PySCF.
    
    Returns:
        int: The reduced irreducible-representation identifier suitable for D2h or C2v usage. The returned integer is the result of irrep_id % 10 and therefore represents the mapping from the linear-group encoding to the target D2h/C2v encoding used in downstream PySCF symmetry code (for example, for selecting symmetry-adapted basis functions or assigning orbital labels).
    
    Raises:
        PointGroupSymmetryError: If gpname is not one of the two accepted linear-group identifiers ('Dooh', 'Coov'), the function raises PointGroupSymmetryError with a message indicating that the provided gpname is not appropriate for linear molecules. This communicates to callers that the symmetry descent is not defined for the supplied point group name.
        TypeError: If irrep_id is not an integer (for example, a string or None), the modulo operation (irrep_id % 10) may raise a TypeError; callers should pass an integer irrep_id consistent with PySCF's internal irrep encoding.
    
    Notes:
        There are no other side effects; the function does not modify global state or input objects. The purpose of this utility is purely to provide a deterministic numeric mapping used during symmetry-aware parts of PySCF calculations for linear molecules.
    """
    from pyscf.symm.basis import linearmole_symm_descent
    return linearmole_symm_descent(gpname, irrep_id)


################################################################################
# Source: pyscf.symm.sph.sph_real2pure
# File: pyscf/symm/sph.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_symm_sph_sph_real2pure(l: int, reorder_p: bool = True):
    """sph_real2pure(l, reorder_p=True)
    Transformation matrix from real spherical harmonic functions to pure (complex) spherical harmonic
    functions. In the PySCF symmetry utilities this function is used to convert coefficients, integrals,
    or orbital representations expressed in a real-valued spherical-harmonic basis (commonly used to
    represent Cartesian-like atomic-orbital components such as p_x, p_y, p_z) into the pure (complex)
    spherical-harmonic basis labeled by magnetic quantum number m = -l,...,l. This conversion is required
    in quantum chemistry workflows (for example, symmetry-adapted integral transformations and angular
    momentum coupling) when code expects the standard complex spherical-harmonic convention. The
    implementation returns the Hermitian-conjugate (conjugate transpose) of sph_pure2real(l, reorder_p),
    which for the conventions used in PySCF is the matrix inverse of the pure-to-real transform.
    
    Args:
        l (int): Angular momentum quantum number l for the spherical harmonics. This integer selects the
            subspace dimension 2*l+1 of the transform (the number of m components from -l to +l). In
            practical use within PySCF, l = 0,1,2,... corresponds to s, p, d, ... shells. Passing a
            non-integer or negative value will result in an error from the underlying routines; callers
            should provide a non-negative integer consistent with the orbital shell they are converting.
        reorder_p (bool): Whether the real p functions are ordered as (x, y, z) in the input real
            spherical-harmonic basis. When True (the default), the function assumes the real p basis
            vectors correspond to Cartesian ordering (p_x, p_y, p_z) and constructs the transform
            accordingly. When False, an alternative ordering convention for the three real p functions is
            assumed. This flag only affects the l=1 (p) block of the transform and therefore influences
            conversions involving p orbitals; higher-l blocks are constructed consistently with PySCF's
            internal conventions. Default True.
    
    Returns:
        numpy.ndarray: A square complex-valued transformation matrix of shape (2*l+1, 2*l+1). When this
        matrix is left-multiplied by a column vector of coefficients expressed in the real spherical-
        harmonic basis (with the same ordering convention implied by reorder_p), the result is the column
        vector of coefficients in the pure (complex) spherical-harmonic basis with m running from -l to +l.
        The function produces the conjugate-transpose of sph_pure2real(l, reorder_p); numerically this is
        the inverse transform for the conventions used in PySCF.
    
    Behavior and failure modes:
        The function has no external side effects (it does not modify global state). It delegates to
        sph_pure2real(l, reorder_p) and returns its conjugate transpose. If sph_pure2real raises an
        exception (for example due to an invalid l or internal numerical error), that exception is
        propagated to the caller. Consumers should ensure l is an appropriate non-negative integer and
        supply reorder_p consistent with how their real-basis coefficients are ordered.
    """
    from pyscf.symm.sph import sph_real2pure
    return sph_real2pure(l, reorder_p)


################################################################################
# Source: pyscf.symm.sph.multipoles
# File: pyscf/symm/sph.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_symm_sph_multipoles(r: numpy.ndarray, lmax: int, reorder_dipole: bool = True):
    """Compute all real multipole components up to a given angular momentum using PySCF conventions.
    
    This function is part of the PySCF quantum-chemistry framework (pyscf.symm.sph) and is used to evaluate multipole basis functions (r^l times spherical harmonic components) on a set of 3D grid points. It builds Cartesian monomials x^lx y^ly z^lz for each degree l and uses the internal libcint/cart2sph transformation (via pyscf.gto.cart2sph) to convert them to PySCF's spherical multipole components. The output is suitable for use in symmetry analysis, multipole moment evaluation, and other molecular property calculations within PySCF that expect spherical multipole components organized per angular momentum l.
    
    Args:
        r (numpy.ndarray): Array of 3D coordinates where multipoles are evaluated. Must have shape (ngrid, 3) where ngrid is the number of points; rows correspond to points and columns to Cartesian coordinates (x, y, z). The coordinates are interpreted in the same Cartesian unit system used throughout PySCF and are used to form Cartesian monomials that are transformed to spherical multipoles. If r has incorrect dimensionality or second dimension not equal to 3, the function will raise an indexing or shape-related error from numpy operations.
        lmax (int): Maximum angular momentum l (inclusive) for which multipoles are computed. The function computes multipole components for all integer l = 0, 1, ..., lmax. lmax must be a non-negative integer; providing a negative value will result in incorrect behavior or an error during loops/array construction.
        reorder_dipole (bool): Default True. Controls a legacy permutation applied to the l=1 (dipole) components to reconcile libcint Cartesian ordering and a spherical m-index ordering. Libcint/pyscf.gto.cart2sph produces first-order components in Cartesian p-function ordering (px, py, pz). If reorder_dipole is True (the default), the function preserves the libcint/cartesian ordering for l=1 (px, py, pz). If reorder_dipole is False and lmax >= 1, the function applies the permutation [1, 2, 0] to the l=1 row ordering (i.e., it reorders the returned 3 components to a different ordering used by some spherical-m conventions, corresponding to a mapping from (px, py, pz) to the ordering used for m = -1, 0, +1 in certain PySCF contexts). Use this flag to select which dipole ordering is returned to match downstream code expectations.
    
    Behavior and practical significance:
        - For each angular momentum l in 0..lmax, the function constructs all Cartesian monomials of total degree l evaluated at each input point and passes them to pyscf.gto.cart2sph to obtain spherical multipole components. The returned components are proportional to r^l times the (real) spherical harmonic components used in PySCF, and are thus directly usable as multipole basis function values in molecular integrals, multipole moment computations, and symmetry-adapted analyses.
        - The function is optimized for low angular momenta by leveraging the libcint/cart2sph transformation; for very large lmax the cost grows combinatorially with l and may become expensive in memory and CPU time.
        - The second axis ordering of each returned array follows PySCF/libcint conventions: the index along the second axis corresponds to the input points in the same order as r (i.e., axis 1 corresponds to r[i]).
    
    Failure modes and edge cases:
        - If r is not a two-dimensional numpy.ndarray of shape (ngrid, 3), numpy indexing or broadcasting operations will raise an error (IndexError or ValueError).
        - If lmax is negative or not an integer, the loops and array shapes will behave incorrectly and may raise TypeError or ValueError.
        - The dipole reordering behavior is controlled by reorder_dipole; selecting the wrong value may produce an ordering mismatch with downstream code that expects a specific m-index ordering. Verify the expected dipole component ordering when integrating with other PySCF modules.
    
    Returns:
        ylms (list of numpy.ndarray): A list of length lmax+1. The element ylms[l] is a numpy.ndarray with shape (2*l+1, ngrid), where ngrid == r.shape[0]. Each row of ylms[l] contains one spherical multipole component (proportional to r^l times the real spherical harmonic component) evaluated at all input points, ordered according to PySCF's internal cart2sph convention. For l=0, ylms[0] has shape (1, ngrid) (the monopole). For l=1, the three rows correspond to the first-order components; their ordering is the libcint/cartesian px,py,pz order when reorder_dipole is True (default), and is permuted by [1,2,0] when reorder_dipole is False to match an alternate spherical m = -1,0,1 ordering used in some contexts.
    """
    from pyscf.symm.sph import multipoles
    return multipoles(r, lmax, reorder_dipole)


################################################################################
# Source: pyscf.symm.sph.sph_pure2real
# File: pyscf/symm/sph.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_symm_sph_sph_pure2real(l: int, reorder_p: bool = True):
    """pyscf.symm.sph.sph_pure2real: Construct the transformation matrix U that converts complex pure spherical harmonic functions Y_m (m = -l,...,l) into real spherical harmonic functions O_m used by PySCF for real-valued atomic/molecular basis functions and symmetry operations. This function is used in the PySCF symmetry and spherical-harmonic utilities to produce the unitary mapping between the complex spherical-harmonic basis (commonly produced by angular momentum theory) and the real-valued combinations (commonly used for real-valued basis functions such as Cartesian p/d/... orbitals). The matrix U implements the convention
        O_m = sum_{m'} Y_{m'} * U(m', m)
    with the array indexing convention described below, and it is returned as a 2D numpy array with complex dtype.
    
    Args:
        l (int): Angular momentum quantum number l >= 0 that determines the number of spherical harmonic components. The function constructs an (2*l + 1) x (2*l + 1) transformation matrix. The index i in the returned matrix corresponds to magnetic quantum number m = i - l (i runs 0..2*l), so row/column index i maps to m = i - l. In PySCF this l is used to generate the spherical harmonics for shells (e.g., l=0 for s, l=1 for p, l=2 for d), and the returned matrix is used to transform integrals, coefficients, and symmetry-adapted functions between the complex spherical-harmonic basis and the real basis. The argument must be an integer; passing a non-integer or a negative integer will raise an error from the underlying numpy operations (TypeError/ValueError).
        reorder_p (bool): Whether to apply the special p-function reordering convention used in many PySCF routines. Default True. When True and l == 1, the real p functions are arranged in the (x, y, z) Cartesian order in the returned mapping (so that the real basis columns correspond to x, y, z ordered real p functions). When False or for l != 1, the general spherical-to-real conversion follows the m-index parity conventions implemented in the code (alternating sign rules depending on whether m is odd or even). This flag has no side effects beyond changing the entries of the returned matrix; it only affects the ordering convention for the p shell (l == 1).
    
    Returns:
        numpy.ndarray: A 2D complex-valued numpy.ndarray U of shape (2*l + 1, 2*l + 1) that implements the mapping from complex spherical harmonics Y_m' (rows indexed by m' = -l..l using index = m'+l) to real spherical harmonics O_m (columns indexed by m = -l..l using index = m+l) according to O_m = sum_{m'} Y_{m'} * U[m', m]. The array dtype is complex because the mapping uses complex phase factors (multiples of i and sqrt(1/2)). The function has no side effects; it allocates and returns a new numpy array. If l is not a non-negative integer (e.g., negative or non-integer), the function will raise an error when attempting to create the array or index it (propagating numpy/TypeError or ValueError). The mapping convention and the p-shell reordering are the ones used throughout PySCF for converting spherical harmonic-based quantities (such as angular parts of integrals or angular momentum-adapted coefficients) into the real orbital basis used in many molecular electronic structure routines.
    """
    from pyscf.symm.sph import sph_pure2real
    return sph_pure2real(l, reorder_p)


################################################################################
# Source: pyscf.symm.geom.symm_identical_atoms
# File: pyscf/symm/geom.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_symm_geom_symm_identical_atoms(gpname: str, atoms: list):
    """Symmetry identical atoms
    
    Compute groups of symmetry-equivalent atom indices for a molecule in a specified point group. This function is used in the PySCF symmetry utilities to identify which atomic sites are mapped onto each other by the point group operations (for example to reduce integrals, label orbitals, and exploit symmetry in electronic structure calculations). The implementation applies the symmetry operation matrices provided by symm_ops and the operator ordering in OPERATOR_TABLE to the input Cartesian coordinates, compares sorted coordinate arrays using argsort_coords, and groups atom indices that are permuted into each other by all symmetry operations for the given point group.
    
    Args:
        gpname (str): The point group name. This is the group identifier used by PySCF symmetry routines (for example 'C2v', 'D2h', 'Dooh', 'Coov', etc.). The function has special-case behavior for linear groups: if gpname == 'Dooh' a single-axis reflection/rotation test based on the 'sz' operator is used; if gpname == 'Coov' the function treats every atom as non-equivalent and returns each atom in its own group. For other group names the function looks up symmetry operation matrices from symm_ops and the operation ordering from OPERATOR_TABLE.
        atoms (list): A list of atoms where each atom is represented as a two-element sequence or tuple (label, coord). The first element label (typically a string like 'H', 'C', or any atom identifier used by PySCF) is used by other commented routines (e.g. gto.charge) and the second element coord is a sequence-like iterable of Cartesian coordinates (converted to a float numpy array in the function). Coordinates are expected to be given in the coordinate frame consistent with the point group determination (typically the same origin and orientation used to assemble the symmetry operators). The function reads the coordinates as numpy.array([a[1] for a in atoms], dtype=float).
    
    Returns:
        list: A list of lists of integers. Each inner list contains zero-based indices into the input atoms list that are equivalent under all symmetry operations of gpname. Each group is sorted in ascending order and contains unique indices; groups partition the set of all atom indices (each atom index appears in exactly one group). For gpname == 'Coov' the function returns [[0], [1], ..., [N-1]] where N is len(atoms). For gpname == 'Dooh' and other point groups the groups reflect the permutation structure produced by applying the group's symmetry operation matrices and sorting permutations produced by argsort_coords.
    
    Behavior and side effects:
        The function constructs a numpy array of coordinates from atoms and applies symmetry operation matrices returned by symm_ops(gpname). For non-linear groups it applies every operator listed in OPERATOR_TABLE[gpname]; for Dooh it uses the 'sz' operator; for Coov it returns singleton groups. For each applied operator the function computes the new coordinates, obtains a sorting permutation via argsort_coords, and compares the permuted coordinates with the reference sorted coordinates using numpy.allclose with the module constant TOLERANCE. No modification is made to the input atoms list; the function returns a new list of index groups.
    
    Failure modes and diagnostics:
        If the coordinates transformed by any symmetry operator cannot be matched to the reference sorted coordinates within the tolerance (TOLERANCE) a PointGroupSymmetryError is raised with a message indicating that symmetry identical atoms were not found and suggesting adjustment of the tolerance symm.geom.TOLERANCE. This commonly occurs if the provided coordinates are not in the expected reference frame (for example if the molecular origin/centering used to build the symmetry operators differs from the coordinates) or if floating-point differences exceed the tolerance. The source contains a commented-out check for the charge-weighted center that is not enforced; therefore users should ensure coordinates are expressed in the same coordinate system used to determine gpname and symm_ops. The function relies on the external utilities symm_ops, OPERATOR_TABLE, argsort_coords, numpy, and the constant TOLERANCE; incorrect or inconsistent definitions in these utilities may also produce errors or incorrect groupings.
    
    Practical significance:
        The returned groups are intended for downstream symmetry-aware routines in PySCF (for example to construct irreducible representations, reduce integral loops, or map per-atom properties under symmetry). Indices are zero-based and refer directly to the ordering of atoms supplied in the atoms argument.
    """
    from pyscf.symm.geom import symm_identical_atoms
    return symm_identical_atoms(gpname, atoms)


################################################################################
# Source: pyscf.symm.cg.cg_spin
# File: pyscf/symm/cg.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_symm_cg_cg_spin(l: int, jdouble: int, mjdouble: int, spin: float):
    """pyscf.symm.cg.cg_spin: Compute the Clebsch–Gordan coefficient <l,m,1/2,spin|j,mj> for coupling an orbital angular momentum l with a spin-1/2 particle.
    
    This function is used in PySCF (Python-based Simulations of Chemistry Framework) wherever one needs the analytic closed-form Clebsch–Gordan coefficient for coupling an orbital angular momentum l and a spin-1/2 degree of freedom to form a total angular momentum j = l ± 1/2. In electronic-structure and symmetry routines (for example, constructing spin-adapted basis functions, spinor spherical harmonics, or transforming between product bases and total-j bases), callers supply integer "doubled" quantum numbers jdouble and mjdouble to avoid fractional representations, and a floating-point spin projection. The routine returns the real-valued coefficient according to the two allowed total-j branches (j = l + 1/2 or j = l - 1/2) and the sign convention implemented in the original PySCF code.
    
    Args:
        l (int): Orbital angular momentum quantum number l (non-negative integer). In the coupling <l,m,1/2,spin|j,mj>, l identifies the orbital part of the product state. Practically, l selects the subspace of spherical-harmonic indices used in symmetry and basis transformations.
        jdouble (int): Twice the total angular momentum j (i.e., jdouble = 2*j). The function uses jdouble to select the branch j = l + 1/2 (when jdouble == 2*l + 1) or j = l - 1/2 (when jdouble == 2*l - 1). Using the doubled integer representation keeps all quantum numbers integral in calling code and matches the convention used elsewhere in PySCF symmetry utilities.
        mjdouble (int): Twice the magnetic quantum number mj (i.e., mjdouble = 2*mj). mjdouble corresponds to the total magnetic projection of the coupled state and must be supplied in the doubled-integer convention consistent with jdouble. The value is used directly in the analytic square-root formulas and should be chosen so that it is physically consistent with jdouble (e.g., typical valid range is |mjdouble| <= jdouble).
        spin (float): Spin projection of the spin-1/2 particle (physically ±0.5). The implementation uses the sign of this value (spin > 0 treated as "spin up", spin <= 0 treated as "spin down") to select the appropriate coefficient and sign in the analytic expression. Note that the code examines only the sign of spin; nonstandard magnitudes will be interpreted by sign only, so callers should pass the physical values +0.5 or -0.5 to obtain meaningful Clebsch–Gordan coefficients.
    
    Returns:
        float: The Clebsch–Gordan coefficient value c = <l,m,1/2,spin|j,mj> computed as a real floating-point number according to the internal analytic formulas:
        - If jdouble == 2*l + 1 (j = l + 1/2): c = +sqrt(0.5*(2*l+1 + mjdouble)/(2*l+1)) for spin > 0, otherwise c = +sqrt(0.5*(2*l+1 - mjdouble)/(2*l+1)) for spin <= 0.
        - If jdouble == 2*l - 1 (j = l - 1/2): c = -sqrt(0.5*(2*l+1 - mjdouble)/(2*l+1)) for spin > 0, otherwise c = +sqrt(0.5*(2*l+1 + mjdouble)/(2*l+1)) for spin <= 0.
        - For any other jdouble value (i.e., total j not equal to l±1/2), the function returns 0.0 because the simple analytic coupling implemented here does not apply.
        The return value has no side effects on program state.
    
    Behavior, defaults, and failure modes:
        - The function implements only the two analytic branches for coupling l with a spin-1/2 particle (j = l ± 1/2). It does not compute general Clebsch–Gordan coefficients for other combinations of angular momenta.
        - Inputs must follow the doubled-integer convention for jdouble and mjdouble; failing to do so will lead to incorrect numerical results.
        - The function does not raise Python exceptions for out-of-range or inconsistent quantum numbers. Instead, invalid combinations can lead to non-physical numeric results: if an argument to numpy.sqrt becomes negative (for example, because mjdouble is inconsistent with l/jdouble), numpy.sqrt will return NaN and may emit a runtime warning. Callers should validate quantum-number ranges before calling if strict error handling is required.
        - There are no side effects: the function does not modify global state or external objects.
        - The function relies on numpy.sqrt internally and returns a plain Python float (numpy scalar converted to float by return).
        - For physically meaningful coefficients, supply l as a non-negative integer, jdouble equal to 2*l+1 or 2*l-1, mjdouble consistent with the chosen jdouble, and spin set to +0.5 or -0.5.
    """
    from pyscf.symm.cg import cg_spin
    return cg_spin(l, jdouble, mjdouble, spin)


################################################################################
# Source: pyscf.symm.sph.real_sph_vec
# File: pyscf/symm/sph.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_symm_sph_real_sph_vec(r: numpy.ndarray, lmax: int, reorder_p: bool = False):
    """Computes real (Cartesian) spherical harmonics evaluated on a set of 3D vectors for all angular momenta up to the specified maximum lmax.
    
    This function is used in PySCF to generate the angular basis functions (real spherical harmonics) that appear in multipole expansions and atomic-orbital-like angular components used across molecular integrals, multipole moment evaluation, and symmetry-adapted basis constructions. The implementation normalizes input Cartesian vectors to unit length (so the angular coordinates are taken on the unit sphere), converts the usual complex spherical harmonics to the real-valued linear combinations, and delegates to the internal multipoles helper to produce the final array layout. The returned data structure matches the convention used elsewhere in PySCF for angular-channel sampling (one entry per l from 0..lmax).
    
    Args:
        r (numpy.ndarray): Real-valued Cartesian coordinate array of the points where the spherical harmonics are evaluated. Expected shape is (npoints, 3), with columns corresponding to x, y, z. The function normalizes each row to unit length internally; the input array is not modified in-place. Supplying zero vectors (rows with norm == 0) will lead to division by zero and produce invalid values or raise an error.
        lmax (int): Non-negative integer giving the maximum angular momentum l to include. All angular channels from l = 0 up to and including l = lmax are computed. The returned list therefore has length lmax + 1. Passing a negative value will be treated as invalid and will raise an error.
        reorder_p (bool = False): Boolean flag forwarded to the internal multipoles routine that controls the ordering of the l = 1 (p) components in the returned arrays. When False (default), the spherical-harmonic ordering of magnetic quantum number m (from -l to +l) is preserved. When True, the p-channel components are reordered to match PySCF's internal Cartesian p-orbital ordering convention (practical when these harmonic values are consumed by routines expecting Cartesian p = {px, py, pz} ordering). This flag does not change the numerical values, only the ordering of indices for l = 1.
    
    Returns:
        list[numpy.ndarray]: A list of length lmax + 1. The element at index l is a numpy.ndarray of shape (2*l + 1, npoints) containing the real spherical harmonics Y_{l,m} sampled at the normalized input vectors. Within the array for angular momentum l, the row index corresponds to magnetic quantum number m arranged from m = -l .. +l by the index mapping m_index = l + m (except that when reorder_p is True, the l = 1 block may be permuted to match PySCF's Cartesian p ordering). The values are real floats.
    
    Behavior, side effects, and failure modes:
        - Input normalization: each input vector r[i] is normalized to unit length before evaluating angular functions; the original r array is not modified.
        - Numerical clamping and robustness: internal algorithms clamp intermediate cosine values to the valid [-1, 1] range when converting Cartesian coordinates to spherical angles; nevertheless, extremely ill-conditioned input (very small norms, NaNs, or Infs) may propagate and produce invalid outputs.
        - Shape and type checks: the function expects r to be a 2D numpy.ndarray with second dimension size 3. If r.ndim != 2 or r.shape[1] != 3, the function will raise a ValueError or an IndexError depending on the underlying numpy indexing. If lmax is not an integer or is negative, a ValueError is raised.
        - Zero-length vectors: rows of r with zero Euclidean norm will cause division by zero when normalizing and will either raise an error or produce Inf/NaN entries in the result.
        - Dependencies: the implementation relies on numpy and the internal multipoles implementation (which in turn may use scipy.special.sph_harm in alternative code paths). Missing dependencies or incompatible versions can cause ImportError or runtime failures.
    
    Examples of practical significance:
        - Use this function to generate angular dependence of multipole basis functions sampled on a grid of directions for electrostatic or dispersion multipole integrals.
        - Use the reorder_p flag when the consumer of the harmonics expects Cartesian p-orbital ordering (px, py, pz) rather than spherical-m harmonic ordering.
    """
    from pyscf.symm.sph import real_sph_vec
    return real_sph_vec(r, lmax, reorder_p)


################################################################################
# Source: pyscf.symm.sph.cart2spinor
# File: pyscf/symm/sph.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_symm_sph_cart2spinor(l: int):
    """pyscf.symm.sph.cart2spinor: Compute the transformation that maps Cartesian Gaussian basis functions of a given angular momentum to the spinor (spherical spin) basis used in PySCF.
    
    Args:
        l (int): The angular momentum quantum number for which to build the Cartesian-to-spinor transformation. In the context of PySCF and quantum chemistry, l specifies the degree of the spherical (and corresponding Cartesian) harmonic functions (e.g., l=0 for s, l=1 for p, l=2 for d). This integer parameter determines the size and structure of the returned transformation data and is used when converting basis-function representations and integrals from a Cartesian Gaussian basis to a spinor (spherical spin) basis in relativistic or spin-dependent electronic-structure calculations. The function expects an integer value; negative or non-integer inputs are invalid and will cause the underlying implementation to raise an exception.
    
    Returns:
        object: The exact return value produced by pyscf.gto.cart2spinor_l(l). Practically, this is the transformation data (typically a matrix or array-like data structure defined by the gto module) that maps Cartesian basis functions of angular momentum l to the corresponding spinor (spherical spin) basis. This returned transformation is intended for use in converting basis coefficients, integrals, and operator representations within PySCF workflows that require spinor-adapted basis functions (for example, when assembling one- and two-electron integrals for relativistic or spin–orbit-coupled methods). The function does not modify global state; it simply returns the data produced by gto.cart2spinor_l. Errors and exceptions raised by the underlying gto.cart2spinor_l implementation (for example, due to invalid l values or internal allocation failures) are propagated to the caller.
    """
    from pyscf.symm.sph import cart2spinor
    return cart2spinor(l)


################################################################################
# Source: pyscf.tdscf._lr_eig.VW_Gram_Schmidt_fill_holder
# File: pyscf/tdscf/_lr_eig.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_tdscf__lr_eig_VW_Gram_Schmidt_fill_holder(
    V_holder: numpy.ndarray,
    W_holder: numpy.ndarray,
    X_new: numpy.ndarray,
    Y_new: numpy.ndarray,
    lindep: float = 1e-12
):
    """VW_Gram_Schmidt_fill_holder performs a two-stage orthogonalization used in PySCF's linear-response eigenvalue (lr_eig) solvers: it first projects out components of the candidate vectors (X_new, Y_new) against an existing basis stored in V_holder and W_holder (a QR-like step), then performs a symmetric orthogonalization that produces a small set of mutually orthonormalized partner vectors for the X and Y blocks appropriate for time-dependent self-consistent-field (TD-SCF) linear-response problems. This function is used in PySCF to expand the iterative Krylov/subspace basis for solving the LR eigenproblem (e.g., TDHF/TDDFT) while controlling linear dependence and numerical stability.
    
    Args:
        V_holder (numpy.ndarray): Array holding the existing X-like basis vectors (columns). In the domain of TD-SCF linear-response solvers in PySCF, V_holder represents previously accepted X-block basis vectors. This array is used only for projection (to remove components already present in the basis) and is not modified by this function.
        W_holder (numpy.ndarray): Array holding the existing Y-like basis vectors (columns). In TD-SCF context, W_holder represents the previously accepted Y-block basis vectors. Like V_holder, it is used for projection and is not modified by this function.
        X_new (numpy.ndarray): Candidate new X-block vectors to be orthogonalized. Shape convention in the code treats the first dimension as the vector length (number of components) and the second as the number of candidate vectors. The function modifies X_new in place by projecting out components along V_holder and W_holder before computing the final symmetric orthogonalized output. The dtype of X_new is preserved when constructing returned arrays or when returning an empty result.
        Y_new (numpy.ndarray): Candidate new Y-block vectors to be orthogonalized. As with X_new, the first dimension is the vector length and the second is the number of candidate vectors. Y_new is also modified in place by projection against V_holder and W_holder. The dtype of Y_new is preserved in returned arrays or empty results.
        lindep (float): Linear-dependence threshold used to screen eigenvalues during symmetric orthogonalization. It defaults to 1e-12. Eigenvalues of the X/X+Y/Y overlap matrix smaller than or equal to this threshold are considered linearly dependent and are discarded. The sqrt of this threshold (lindep**0.5) is used in additional checks for near-singular or near-unit couplings during symmetric diagonalizations.
    
    Returns:
        tuple:
            numpy.ndarray: x_orth_T with dtype matching X_new.dtype. This is the transpose of the orthonormalized X-block vectors and has shape (k, n) where n equals X_new.shape[0] (the vector length) and k is the number of accepted orthonormalized vectors. If no vectors survive the linear-dependence screening, an empty array of shape (0, n) is returned (same dtype as X_new). These returned rows are intended to be appended as new rows (or converted back to column form) to the solver basis (e.g., to V_holder).
            numpy.ndarray: y_orth_T with dtype matching Y_new.dtype. This is the transpose of the orthonormalized Y-block vectors with the same shape convention and semantics as x_orth_T. If no vectors survive, an empty array of shape (0, n) is returned (same dtype as Y_new). The pair (x_orth_T, y_orth_T) represent the symmetrically orthogonalized partner vectors for the X and Y blocks, suitable for use in LR eigenvalue iterations.
    
    Behavior, side effects, and failure modes:
        - Projection (in-place modification): The function first computes projections of X_new and Y_new onto the spaces spanned by V_holder and W_holder and subtracts those components from X_new and Y_new. Therefore X_new and Y_new are modified in place to remove components already present in the existing basis. V_holder and W_holder are not modified.
        - Symmetric orthogonalization: After projection, the routine forms small dense overlap matrices (s11 and s21) from the residual X_new and Y_new and performs eigendecompositions to identify independent directions and to build a symmetric orthogonalization that respects the block coupling between X and Y. This step extracts a set of coefficients used to form mutually orthonormal partner vectors for the X and Y blocks.
        - Linear-dependence screening: Eigenvalues of the s11 matrix below lindep are treated as linear dependent and removed. If all eigenvalues are removed (no independent directions remain), the function returns two empty arrays (shapes (0, n) as described above) and does not add new basis vectors.
        - Additional numerical checks: The routine inspects the eigenvalues w of a transformed coupling matrix (csc) and uses a mask based on 1 - abs(w) > sqrt(lindep) to avoid nearly singular or perfectly coupled directions. If no suitable directions are found, the function returns empty arrays. If certain conditions indicate potential numerical instability (e.g., smallest retained eigenvalue near sqrt(lindep) or |w| very close to 1 within 1e-3), the function reruns parts of the orthogonalization (extra eigen-decompositions and rescaling) to reduce numerical errors before producing the final orthonormalized outputs.
        - Returned orientation: The returned arrays are transposed (k, n) to match the calling convention used by the lr_eig driver that expects rows corresponding to new basis vectors. Users should convert back to column orientation if necessary for appending to V_holder or W_holder.
        - Dtype preservation: Returned arrays preserve dtypes of X_new and Y_new. When no vectors are accepted, zero-sized arrays with the matching dtype are returned.
        - Exceptions: Linear algebra operations use numpy.linalg.eigh and may raise numpy.linalg.LinAlgError or other numpy exceptions if the underlying LAPACK routines fail. Such exceptions propagate to the caller.
        - Numerical limitations: Because the algorithm relies on dense eigendecompositions of small overlap matrices, it is sensitive to round-off when eigenvalues are close to the lindep threshold or when coupling eigenvalues w are very close to ±1. In such cases the function either reruns orthogonalization steps to mitigate errors or conservatively discards problematic directions and returns fewer (possibly zero) output vectors.
    
    Practical significance in PySCF:
        - This routine is a low-level utility in pyscf.tdscf._lr_eig used to grow and maintain a stable, orthonormal Krylov/subspace basis for iterative solution of the linear-response eigenproblem (e.g., TDHF/TDDFT). Correct use of this function helps ensure that the iterative eigensolver remains stable, avoids redundant/linearly dependent search directions, and respects the coupled X/Y block structure characteristic of LR-TD methods.
    """
    from pyscf.tdscf._lr_eig import VW_Gram_Schmidt_fill_holder
    return VW_Gram_Schmidt_fill_holder(V_holder, W_holder, X_new, Y_new, lindep)


################################################################################
# Source: pyscf.tdscf._lr_eig.TDDFT_subspace_eigen_solver
# File: pyscf/tdscf/_lr_eig.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_tdscf__lr_eig_TDDFT_subspace_eigen_solver(
    a: numpy.ndarray,
    b: numpy.ndarray,
    sigma: numpy.ndarray,
    pi: numpy.ndarray,
    nroots: int
):
    """TDDFT_subspace_eigen_solver solves the linear-response time-dependent density functional theory (TDDFT) subspace eigenproblem for excitation energies and excitation/de-excitation amplitude vectors using a structured transformation and standard dense linear algebra routines. This routine implements the block-eigenproblem algebra shown in the source comments:
      [ a  b ] x - [ σ   π] x  Ω = 0
      [ b  a ] y   [-π  -σ] y    = 0
    and returns excitation energies Ω and corresponding x (excitation) and y (de-excitation) amplitude matrices computed by scaling with the diagonal of sigma, LU and Cholesky factorizations, and a Hermitian diagonalization of an auxiliary matrix M. In the PySCF TDDFT code path this function is used inside the linear-response solver to transform the generalized Casida-like eigenproblem into a standard Hermitian eigenproblem and to reconstruct physical amplitudes from the subspace eigenvectors.
    
    Args:
        a (numpy.ndarray): Real (or complex) square matrix A of the TDDFT linear-response block. In PySCF this corresponds to the A block (resonant part) of the particle-hole response kernel expressed in the chosen subspace. The matrix must be square and have the same shape as b, sigma, and pi. It is used to form (a+b) and (a-b) combinations required by the algorithm. The function does not modify this input in place.
        b (numpy.ndarray): Real (or complex) square matrix B of the TDDFT linear-response block. In PySCF this corresponds to the B block (coupling part) of the particle-hole response kernel in the subspace. The matrix must be square and conformable with a, sigma, and pi. It is used in forming (a+b) and (a-b) in the internal matrix algebra; b is not modified in place.
        sigma (numpy.ndarray): Square matrix that defines the diagonal-based scaling (metric) used to transform the generalized eigenproblem into a standard form. The code uses the absolute values of sigma's diagonal to form d = abs(diag(sigma)) and the scaling d^(-1/2). In PySCF TDDFT this matrix represents the block entering the generalized metric [σ  π; -π -σ]. sigma must have the same shape as a and b. If sigma has zeros on the diagonal the scaling will involve division by zero and will raise an error.
        pi (numpy.ndarray): Square matrix that, together with sigma, defines the off-diagonal metric coupling in the generalized eigenproblem (the π block in [σ  π; -π -σ]). pi must have the same shape as sigma, a, and b. The algorithm uses sigma - pi and sigma + pi combinations; properties of these combinations (for example positive-definiteness required by Cholesky) affect numerical success.
        nroots (int): Number of requested excitation roots to return. The function attempts to return up to nroots positive excitation energies Ω (square roots of positive eigenvalues of an auxiliary Hermitian matrix). If fewer than nroots positive eigenvalues are found the function returns only the available positive roots (see failure modes below). nroots controls column truncation of the returned amplitude matrices.
    
    Returns:
        omega (numpy.ndarray): One-dimensional array of excitation energies Ω (non-negative floats) obtained as the positive square roots of selected eigenvalues of the auxiliary Hermitian matrix. The returned length is min(nroots, number_of_positive_eigenvalues); if negative or zero eigenvalues are present they are discarded and only positive eigenvalues contribute to omega. The energies are returned in ascending order corresponding to the eigenvalue ordering from numpy.linalg.eigh on the auxiliary matrix.
        x (numpy.ndarray): Two-dimensional array of excitation amplitude vectors (x) with shape (N, k) where N = a.shape[0] is the subspace dimension and k = len(omega) is the number of returned roots. These columns are constructed to satisfy the normalization relationship implied in the algorithm (derived from Z^T Z = 1/Ω in the code) and are computed from scaled LU/Cholesky transforms of the subspace eigenvectors. x is suitable for further TDDFT response amplitude reconstruction in PySCF.
        y (numpy.ndarray): Two-dimensional array of de-excitation amplitude vectors (y) with shape (N, k), computed consistently with x using the algebra in the implementation (x+y and x-y reconstructions). y is the complementary de-excitation amplitude matrix used in the TDDFT linear-response solution.
    
    Behavior, numerical procedure, side effects, and failure modes:
        The function performs the following main numerical steps: compute d = abs(diag(sigma)), form d^(-1/2); build scaled matrices d^(-1/2)(sigma-pi)d^(-1/2) and d^(-1/2)(a-b)d^(-1/2); compute an LU factorization with permutation of d^(-1/2)(sigma-pi)d^(-1/2); form GGT = U_inv^T * d^(-1/2)(a-b)d^(-1/2) * U_inv and compute its Cholesky factor G (lower triangular); build the Hermitian matrix M = G^T L_inv d^(-1/2)(a+b)d^(-1/2) L_inv^T G; diagonalize M with numpy.linalg.eigh to obtain eigenvalues omega2 and eigenvectors Z; select positive eigenvalues and corresponding eigenvectors up to nroots; compute omega = sqrt(omega2) and reconstruct x, y via the given scaling formulas. The function returns omega, x, y and does not modify input arrays in place.
        The algorithm assumes consistent square shapes for a, b, sigma, and pi (all size N x N). If shapes mismatch, NumPy broadcasting or matrix-multiplication routines will raise an exception. The routine uses dense linear algebra routines from SciPy and NumPy: scipy.linalg.lu, scipy.linalg.cholesky, np.linalg.inv, and np.linalg.eigh; exceptions from these lower-level routines (for example numpy.linalg.LinAlgError) will propagate. In particular, Cholesky will fail if GGT is not positive definite; LU and explicit inverses require invertible triangular factors; explicit use of np.linalg.inv may be sensitive to near-singular matrices and can produce large numerical errors for ill-conditioned inputs.
        If any eigenvalues of the auxiliary matrix M are non-positive (<= 0), the implementation discards them and returns only the positive roots (up to nroots). This means that if the input subspace or metric produces non-physical or numerically non-positive eigenvalues, fewer than nroots roots will be returned rather than raising a custom error. Users should check the length of omega to confirm they received the expected number of roots.
        There are no external side effects (no file I/O, no global state mutation). The routine relies on floating-point algebra; numerical stability depends on the conditioning of sigma, a, b, and pi and on the validity of the algebraic assumptions (e.g., that the scaled matrices used for Cholesky and diagonalization are Hermitian and, where required, positive definite).
    """
    from pyscf.tdscf._lr_eig import TDDFT_subspace_eigen_solver
    return TDDFT_subspace_eigen_solver(a, b, sigma, pi, nroots)


################################################################################
# Source: pyscf.tools.chkfile_util.dump_mo
# File: pyscf/tools/chkfile_util.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_tools_chkfile_util_dump_mo(filename: str, key: str = "scf"):
    """pyscf.tools.chkfile_util.dump_mo dumps molecular orbital coefficients stored in a PySCF checkpoint file.
    
    This function reads SCF or MCSCF orbital information from a PySCF checkpoint file (chkfile) and delegates formatting/output of the orbital coefficient matrix to pyscf.tools.dump_mat.dump_mo. It is intended for users and developers of the PySCF (Python-based Simulations of Chemistry Framework) library who need to inspect or export molecular orbital coefficients produced by self-consistent field (SCF) or multiconfigurational SCF (MCSCF) calculations. The function locates the orbital coefficient array in the checkpoint data, associates it with the molecular object loaded from the same file, and invokes the dump routine that produces a human-readable matrix representation of the orbitals for post-processing, debugging, or archival inspection.
    
    Args:
        filename (str): Path to a PySCF checkpoint file (chkfile) that was produced by an SCF or MCSCF calculation. This file is read using the chkfile utilities (chkfile.load_scf, chkfile.load_mol, or chkfile.load). The filename must refer to an existing checkpoint file created by PySCF; if the file is missing or not a valid PySCF chkfile, the underlying chkfile loader will raise an exception which is propagated to the caller.
        key (str): Case-insensitive selector of which orbital set to load from the checkpoint file. If key.lower() == 'mcscf', the function loads the molecular object with chkfile.load_mol(filename) and the multiconfigurational orbital coefficients from the checkpoint key 'mcscf/mo_coeff'. For any other value (including the default 'scf'), the function calls chkfile.load_scf(filename) to obtain (mol, mf) for a standard SCF calculation and extracts the orbital coefficients from mf['mo_coeff']. The default value 'scf' is provided for convenience when the checkpoint contains standard SCF results.
    
    Returns:
        None: This function does not return a value. Instead, it has the side effect of producing formatted output of the molecular orbital coefficient matrix by calling pyscf.tools.dump_mat.dump_mo(mol, mo_coeff). Any errors encountered while loading the checkpoint (file not found, malformed file, missing expected keys such as 'mcscf/mo_coeff' or 'mo_coeff') or while dumping the matrix (invalid array shape or other data issues) are not swallowed; they propagate as exceptions from the underlying chkfile and dump_mat routines so that calling code can handle or report them.
    """
    from pyscf.tools.chkfile_util import dump_mo
    return dump_mo(filename, key)


################################################################################
# Source: pyscf.tools.chkfile_util.molden
# File: pyscf/tools/chkfile_util.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_tools_chkfile_util_molden(filename: str, key: str = "scf"):
    """pyscf.tools.chkfile_util.molden: Read SCF or MC-SCF orbital information from a PySCF checkpoint file and write those orbitals in Molden format for visualization or interoperability with other quantum-chemistry tools.
    
    This convenience wrapper reads molecular orbital coefficients stored in a PySCF checkpoint file (chkfile) under the HDF5-like key path "<key>/mo_coeff" (where key is typically 'scf' for mean-field/self-consistent-field results or an MC-SCF block for multiconfigurational results). It then invokes pyscf.tools.molden.from_chkfile to create a Molden-format file that contains the orbital coefficients and header information required by visualization programs and other post-processing tools that accept the Molden format. The function is intended for users of the PySCF framework who want to export orbitals from an on-disk checkpoint into a widely supported text format for inspection, plotting, or interfacing with external software.
    
    Args:
        filename (str): Path to the PySCF checkpoint file to read and the base path used to create the output Molden file. This argument is passed as the checkpoint-file input to pyscf.tools.molden.from_chkfile, so it should refer to an existing PySCF chkfile (for example the path produced by pyscf.gto.Mole.dump or a call that wrote a chkfile). The function will produce an output file named filename + '.molden' in the same directory (for example, if filename is 'molecule.chk', the output will be 'molecule.chk.molden'). The filename controls both source (checkpoint) and the output base name; ensure the process has read access to the checkpoint and write permission in the target directory.
        key (str): Top-level key in the checkpoint file that selects which orbital block to export. By default this is 'scf', which directs the function to read the mean-field self-consistent-field orbital coefficients from the checkpoint path 'scf/mo_coeff'. For multiconfigurational calculations the caller may pass the appropriate block name (for example a mcscf block name used when the checkpoint was written). The string is concatenated with '/mo_coeff' and passed to pyscf.tools.molden.from_chkfile as the specific dataset path to extract orbital coefficients.
    
    Returns:
        None: This function does not return a Python value. Its primary effect is a side effect: writing a Molden-format file named filename + '.molden' to disk. On success the file contains the orbital coefficients and header information exported from the specified checkpoint key, suitable for visualization and downstream tools.
    
    Behavior and failure modes:
        The function delegates the work to pyscf.tools.molden.from_chkfile(filename + '.molden', filename, key + '/mo_coeff'). If the checkpoint file does not exist, lacks the requested key, is malformed, or if there are I/O permission errors when creating the output file, exceptions from the underlying I/O layer or from pyscf.tools.molden.from_chkfile (for example FileNotFoundError, KeyError, IOError, or ValueError) will propagate to the caller. Users should ensure the checkpoint was produced with the expected structure and that the runtime has appropriate read/write permissions. No changes are made to the checkpoint file itself; only a new Molden-format file is created.
    """
    from pyscf.tools.chkfile_util import molden
    return molden(filename, key)


################################################################################
# Source: pyscf.tools.qcschema.load_qcschema_go_final_json
# File: pyscf/tools/qcschema.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_tools_qcschema_load_qcschema_go_final_json(file_name: str):
    """pyscf.tools.qcschema.load_qcschema_go_final_json loads and returns the final optimized-geometry entry from a qcschema-format geometry-optimization (GO) JSON file used by PySCF.
    
    Args:
        file_name (str): Path to a qcschema-format JSON file produced by a geometry optimization (GO) workflow. This file is expected to contain a top-level "trajectory" key whose value is a sequence (list) of geometry frames or state dictionaries recorded during optimization. The function opens the file, parses it using the standard json loader, and extracts the last element of the "trajectory" sequence, which represents the optimized ("final") molecular geometry and associated qcschema metadata. The file is opened for reading and is closed automatically on return.
    
    Returns:
        dict: A Python dictionary containing the qcschema-format information for the optimized final geometry (the last element of the JSON "trajectory" list). This dictionary is the parsed JSON object for that trajectory frame and may include keys such as molecule geometry, atomic symbols, charge, multiplicity, provenance, and other qcschema metadata used in PySCF workflows. The returned dict is an in-memory object derived from the file contents; modifying it does not modify the source file.
    
    Behavior and side effects:
        This function performs a single read of the file at file_name and uses json.load to parse it. It does not perform schema validation beyond extracting temp["trajectory"][-1]; it assumes the file follows the qcschema GO layout described above. The function returns the last trajectory entry unchanged. The file is closed automatically by the context manager after parsing. No writing to disk or network activity is performed.
    
    Failure modes and exceptions:
        If the file cannot be opened, built-in exceptions such as FileNotFoundError or PermissionError will be raised. If the file contents are not valid JSON, json.JSONDecodeError will be raised. If the parsed JSON does not contain a "trajectory" key, a KeyError will be raised. If "trajectory" exists but is empty, accessing [-1] will raise IndexError. If the structure under "trajectory" is not subscriptable as a list, a TypeError or related exception may be raised. Callers should catch these exceptions where appropriate and ensure the input file conforms to the expected qcschema GO format.
    
    Practical significance in PySCF:
        Use this function in PySCF-based workflows to load the optimized molecular geometry produced by a prior geometry-optimization job saved in qcschema JSON form. The returned dict can be used as input for subsequent single-point calculations, property evaluations, or for converting into PySCF Mole or other in-memory representations.
    """
    from pyscf.tools.qcschema import load_qcschema_go_final_json
    return load_qcschema_go_final_json(file_name)


################################################################################
# Source: pyscf.tools.qcschema.load_qcschema_hessian
# File: pyscf/tools/qcschema.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_tools_qcschema_load_qcschema_hessian(qcschema_dict: dict):
    """Load a molecular Hessian from a QCSchema-formatted dictionary and return it as a 4D NumPy array suitable for PySCF vibrational and normal-mode workflows.
    
    Args:
        qcschema_dict (dict): A Python dictionary containing a QCSchema output JSON already loaded (for example via json.load). This dictionary is expected to follow the QCSchema structure used by PySCF integration and must contain the key "return_result" whose value is the flattened Hessian array and the nested key "molecule" -> "symbols" whose value is an iterable of atomic symbols. The function uses the length of qcschema_dict["molecule"]["symbols"] to determine the number of atoms N and uses qcschema_dict["return_result"] as a 1D sequence of length (3*N)**2 representing the Cartesian Hessian flattened in row-major order. qcschema_dict is not modified by this function.
    
    Returns:
        numpy.ndarray: A NumPy array with shape (N, N, 3, 3) where N is the number of atoms determined from qcschema_dict["molecule"]["symbols"]. The returned array contains the Cartesian block Hessian such that element [i, j, a, b] corresponds to the second derivative of the electronic energy with respect to Cartesian coordinate a (0..2 for x,y,z) of atom i and coordinate b of atom j. This 4D format is the form commonly used in PySCF for subsequent vibrational frequency calculations, normal mode analysis, and geometry-related post-processing. The numerical values and units are preserved exactly as provided in the QCSchema input; callers must ensure they understand and, if necessary, convert units.
    
    Behavior and side effects: The function constructs a NumPy array from qcschema_dict["return_result"] and reshapes it to (N, N, 3, 3) using NumPy's reshape semantics (row-major order). There are no side effects on the provided qcschema_dict; the function returns a new NumPy array.
    
    Failure modes and errors: If qcschema_dict is not a dict, a TypeError may arise earlier or downstream when indexing; if the required keys "return_result" or "molecule" / "symbols" are missing, a KeyError will be raised. If qcschema_dict["return_result"] cannot be interpreted as a 1D numeric sequence or its length does not equal (3*N)**2 where N is the number of symbols, NumPy will raise a ValueError during array construction/reshape. If numerical conversion fails because elements are not numeric, a TypeError or ValueError may occur from NumPy. Callers should validate the QCSchema contents and units before using the returned Hessian in analysis.
    """
    from pyscf.tools.qcschema import load_qcschema_hessian
    return load_qcschema_hessian(qcschema_dict)


################################################################################
# Source: pyscf.tools.chkfile_util.mulliken
# File: pyscf/tools/chkfile_util.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_tools_chkfile_util_mulliken(filename: str, key: str = "scf"):
    """pyscf.tools.chkfile_util.mulliken: Read SCF or MCSCF data from a PySCF checkpoint file and perform a Mulliken population analysis on the constructed one-particle density matrix.
    
    This function is intended for use within the PySCF (Python-based Simulations of Chemistry Framework) workflow to extract molecular and orbital data previously written to a PySCF checkpoint (chkfile) and to compute Mulliken populations from the resulting density matrix. It supports checkpoint entries produced by standard SCF calculations and by multiconfigurational SCF (mcscf) calculations.
    
    Args:
        filename (str): Path to a PySCF checkpoint file (chkfile) that contains stored calculation data. The file is expected to be in the format produced by PySCF's chkfile utilities and to contain the keys read below; providing a non-existent file or a file missing the required keys will raise the corresponding I/O or lookup error from the chkfile loader.
        key (str): Top-level checkpoint data type to read; case-insensitive. When key equals 'mcscf' (case-insensitive), the function loads the molecular structure via chkfile.load_mol(filename) and the multiconfigurational molecular orbital coefficients and occupations using chkfile.load(filename, 'mcscf/mo_coeff') and chkfile.load(filename, 'mcscf/mo_occ') respectively. For any other value (default 'scf'), the function calls chkfile.load_scf(filename) to obtain (mol, mf) and then extracts mo_coeff = mf['mo_coeff'] and mo_occ = mf['mo_occ']. The key selects whether the function interprets the checkpoint contents as a single-determinant SCF result or as MCSCF orbitals and occupations.
    
    Behavior and side effects:
        The function constructs the one-particle density matrix dm from the loaded molecular orbital coefficients (mo_coeff) and orbital occupations (mo_occ) using numpy.dot(mo_coeff * mo_occ, mo_coeff.T). Here mo_coeff is expected to be an array of molecular orbital coefficients (typically a 2-D array with basis-function rows and MO columns) and mo_occ an array of occupations (typically 1-D or broadcastable to the shape of mo_coeff's columns). After building dm, the function calls hf.mulliken_meta(mol, dm) to perform Mulliken population analysis for the molecule described by mol using the computed density matrix. The Mulliken analysis routine (hf.mulliken_meta) is responsible for computing and reporting population values; it typically writes human-readable output (textual population tables) to standard output or to the logging channel used by PySCF.
    
    Defaults:
        If key is not provided, it defaults to 'scf', meaning the function assumes the checkpoint contains single-determinant SCF data and uses chkfile.load_scf to obtain (mol, mf).
    
    Failure modes and exceptions:
        The function does not return a value and will propagate exceptions raised during file I/O or data extraction. Typical failures include OSError/IOError if filename does not exist or cannot be read; KeyError or similar from chkfile.load or chkfile.load_scf if expected keys ('mcscf/mo_coeff', 'mcscf/mo_occ', or mf['mo_coeff']/mf['mo_occ']) are missing; and ValueError or numpy.linalg-related errors if the arrays have incompatible shapes for the density matrix construction (numpy.dot). Any exceptions raised by hf.mulliken_meta (for example, due to an invalid mol or dm) are also propagated.
    
    Returns:
        None: This function does not return a Python value. Its primary effect is to perform Mulliken population analysis by calling hf.mulliken_meta(mol, dm) using data read from the specified PySCF checkpoint file; results are produced by the Mulliken routine (typically printed or logged).
    """
    from pyscf.tools.chkfile_util import mulliken
    return mulliken(filename, key)


################################################################################
# Source: pyscf.tools.qcschema.load_qcschema_json
# File: pyscf/tools/qcschema.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_tools_qcschema_load_qcschema_json(file_name: str):
    """pyscf.tools.qcschema.load_qcschema_json loads a QCSchema-format JSON file and returns its contents as a Python dictionary for use in PySCF quantum chemistry workflows. This function is intended to read JSON files that follow the QCSchema convention (a machine-readable schema for quantum-chemistry calculation metadata and results) so that downstream PySCF tools can access calculation inputs, outputs, and metadata as native Python objects.
    
    Args:
        file_name (str): Path to the input file. Must be a string representing the filesystem path of a QCSchema-format JSON file to read. In the context of PySCF (a Python-based Simulations of Chemistry Framework), this file typically contains serialized quantum chemistry calculation data (for example, molecular geometry, basis sets, method and driver metadata, and computed properties) that other PySCF modules or external tools consume.
    
    Returns:
        dict: A Python dictionary containing the parsed JSON content in QCSchema format. The returned dict structure directly reflects the JSON object stored in file_name and is suitable for programmatic inspection and use by PySCF workflows and tools that expect QCSchema-compliant data.
    
    Behavior and side effects:
        The function opens file_name for reading using the built-in open(...) call with mode 'r' and the platform default encoding, reads and parses the file with json.load(...), and automatically closes the file when done (context manager). No additional files are written or global state modified.
    
    Failure modes and exceptions:
        If file_name does not exist or is not accessible, open(...) will raise FileNotFoundError or PermissionError. If the file contents are not valid JSON, json.load(...) will raise json.JSONDecodeError. Callers should handle these exceptions when reading files from untrusted sources or when file availability is uncertain. No attempt is made to validate that the parsed JSON strictly conforms to the QCSchema specification beyond producing the corresponding Python dict.
    """
    from pyscf.tools.qcschema import load_qcschema_json
    return load_qcschema_json(file_name)


################################################################################
# Source: pyscf.tools.fcidump.from_integrals
# File: pyscf/tools/fcidump.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_tools_fcidump_from_integrals(
    filename: str,
    h1e: numpy.ndarray,
    h2e: numpy.ndarray,
    nmo: int,
    nelec: int,
    nuc: float = 0,
    ms: int = 0,
    orbsym: list = None,
    tol: float = 1e-15,
    float_format: str = " %.16g"
):
    """Convert the given one-electron and two-electron integrals into the FCIDUMP file format and write them to disk.
    
    This function is used in the PySCF quantum chemistry framework to export molecular-orbital representation integrals for interoperability with Full Configuration Interaction (FCI) programs and other post-Hartree–Fock tools that consume the FCIDUMP standard. It composes an FCIDUMP file by writing a header (orbital and symmetry metadata), the two-electron integrals (ERI), the one-electron (core) Hamiltonian integrals, and a final line containing the nuclear repulsion energy followed by four integer placeholders. The function opens filename for writing (overwriting any existing file at that path) and delegates integral formatting and thresholding to internal helpers write_head, write_eri, and write_hcore. The h1e and h2e arrays provided are forwarded to those helpers; any shape or content expectations enforced by those helpers (for example, matrix/tensor dimensionality or index ordering) will cause errors to be raised by the helpers if not satisfied.
    
    Args:
        filename (str): Path to the output FCIDUMP file. The function opens this path with mode 'w' and writes text according to the FCIDUMP convention. If the file cannot be created or written (for example due to permission or filesystem errors), an IOError/OSError will be raised by the underlying file operations.
        h1e (numpy.ndarray): One-electron integrals (core Hamiltonian) provided as a NumPy array. These are passed to write_hcore to be formatted into FCIDUMP lines. The array must be a numeric numpy.ndarray; if it is not, a TypeError or an error from the writer helper may occur. The writer may apply tol to omit values considered zero.
        h2e (numpy.ndarray): Two-electron integrals (electron repulsion integrals, ERI) provided as a NumPy array. These are passed to write_eri to be formatted into FCIDUMP lines. The array must be a numeric numpy.ndarray; if it is not, a TypeError or an error from the writer helper may occur. The writer may apply tol to omit values considered zero.
        nmo (int): Number of molecular orbitals. This integer is written into the FCIDUMP header via write_head and is used by the helper functions to interpret the integrals when producing output. If nmo does not match the expectations of the helper writers given the shape of h1e/h2e, those helpers will raise an error.
        nelec (int): Number of electrons (total, usually number of alpha plus beta electrons). This is recorded in the FCIDUMP header via write_head and is important metadata for FCI and other post-HF programs consuming the file.
        nuc (float): Nuclear repulsion energy to record in the FCIDUMP final line. Default is 0. This floating-point value is formatted using float_format and written as the last nonzero numeric entry, followed by four integer zeros as required by common FCIDUMP conventions.
        ms (int): Spin projection quantum number (Ms) to record in the FCIDUMP header. Default is 0. This integer helps downstream programs interpret the spin sector of the integrals.
        orbsym (list): Optional list of orbital symmetry labels to include in the FCIDUMP header. Default is None. When provided, the list is forwarded to write_head and used as header metadata; its expected contents (for example integers per orbital) are enforced by the header-writing helper if required.
        tol (float): Numerical tolerance used by the integral-writing helpers to decide which matrix/tensor elements are treated as zero and therefore omitted from the FCIDUMP file. Default is 1e-15. Values with absolute magnitude <= tol may be suppressed in the output; choosing too large a tol can drop physically relevant integrals, while too small a tol may write many near-zero values.
        float_format (str): Python percent-format string used to format floating-point numbers when writing numeric entries to the FCIDUMP file. Default is " %.16g". The string is used with the % operator (for example, (float_format % value) is applied internally), and therefore must be a valid format compatible with that operation; an invalid format will raise a formatting error at write time.
    
    Returns:
        None: This function does not return a value. Its observable effect is the creation (or overwriting) of the file at filename containing the FCIDUMP-formatted integrals and header. Exceptions that can be raised include file I/O errors (e.g., IOError/OSError) when opening or writing the file, and errors propagated from the internal writers (write_head, write_eri, write_hcore) if the provided arrays, nmo, nelec, or orbsym are inconsistent with the writers' expectations or have incorrect types.
    """
    from pyscf.tools.fcidump import from_integrals
    return from_integrals(
        filename,
        h1e,
        h2e,
        nmo,
        nelec,
        nuc,
        ms,
        orbsym,
        tol,
        float_format
    )


################################################################################
# Source: pyscf.tools.fcidump.read
# File: pyscf/tools/fcidump.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_tools_fcidump_read(
    filename: str,
    molpro_orbsym: bool = False,
    verbose: bool = True
):
    """Parse an FCIDUMP-format file and return a dictionary of molecular integrals and metadata suitable for use in PySCF workflows (for example, to seed FCI, CI, or other post-Hartree–Fock calculations). This function reads the FCIDUMP header and integral records produced by quantum chemistry programs, converts header tokens to Python types, optionally converts orbital symmetry labels from the Molpro convention to the PySCF convention, and assembles the one-electron integrals, packed two-electron integrals, and scalar parameters into a single dictionary that downstream PySCF code expects.
    
    Args:
        filename (str): Path to the FCIDUMP file to parse. The function opens this file for reading and closes it before returning. The file is expected to be a standard FCIDUMP text file where the header appears within the first ten lines (terminated by "&END" or a slash "/" on a line). If the file cannot be opened, Python I/O exceptions (e.g., FileNotFoundError, OSError) propagate to the caller.
        molpro_orbsym (bool): Whether the ORBSYM values in the FCIDUMP header use Molpro's numbering convention. When True, the function attempts to map those ORBSYM integers to PySCF's internal symmetry numbering using the ORBSYM_MAP heuristics found in the PySCF codebase: if the maximum ORBSYM value is >4 it assumes D2h-like numbering, if >2 it assumes C2v-like numbering, if max==2 or max==1 it applies the documented adjustments, and if the pattern cannot be recognized a RuntimeError is raised. When False (the default) the function expects ORBSYM values already in the PySCF convention (non-negative integers) and raises RuntimeError if any ORBSYM value is negative.
        verbose (bool): Whether to print minimal parsing/debugging information to standard output. If True (the default) the function prints a single line "Parsing <filename>" before parsing. This flag does not alter parsing semantics; it only controls user-visible logging.
    
    Behavior and failure modes:
        The function reads up to the first ten lines of the file to parse the FCIDUMP header tokens (case-insensitive). The header must contain "&FCI" and a terminator ("&END" or "/") within those lines; otherwise a RuntimeError("Problematic FCIDUMP header") is raised. Header tokens of interest (NORB, NELEC, MS2, ISYM, ORBSYM, etc.) are converted to Python types: integer tokens to int, ORBSYM to a list of ints, and other tokens to strings. Note: historically some documentation refers to an "MS" field; the implementation reads the header token "MS2" and stores it under that key.
        After the header, the function expects integral records in the usual FCIDUMP format: each data line contains a floating-point coefficient followed by four integer indices (i, j, k, l) using 1-based orbital numbering. Lines with k != 0 are treated as two-electron integrals (ij|kl) and are stored in a packed, triangular 1-D array; lines with k == 0 and j != 0 are treated as one-electron integrals and populate the H1 matrix; a line with k == 0 and j == 0 is taken as the scalar core energy (ECORE). If a line does not conform to this tokenization, Python value/conversion errors will propagate (ValueError).
        The function enforces Hermiticity/symmetry of the one-electron integral matrix by copying the nonzero triangle to the zero triangle when necessary (it checks the lower and upper triangles via numpy.linalg.norm and fills the missing triangle accordingly).
        The ORBSYM conversion performed when molpro_orbsym is True uses heuristics and may be incorrect if the FCIDUMP lacks sufficient point-group information or if orbital numbering does not follow the assumed high-symmetry ordering; in such cases the guess may be wrong and can lead to an incorrect ORBSYM list. If ORBSYM values are inconsistent with either convention, the function raises RuntimeError("Unknown orbsym" or "Unknown orbsym convention").
    
    Returns:
        dict: A dictionary containing the parsed integrals and parameters. The keys and their meanings/types (as produced by this function) are:
            NORB (int): Number of spatial orbitals read from the FCIDUMP header. Used to size H1 and to interpret H2 packing.
            NELEC (int): Number of electrons (spin-summed) read from the header; used by downstream correlation solvers.
            MS2 (int): Twice the spin projection (2*M_S) or related spin quantum number token from the FCIDUMP header; older documentation sometimes refers to "MS".
            ISYM (int): Integer symmetry label from the header when present; its interpretation depends on the FCIDUMP producer.
            ORBSYM (list of int): Orbital symmetry labels for each orbital, converted to PySCF convention when molpro_orbsym was True. Each list element is an integer symmetry index; negative values are not accepted unless molpro_orbsym conversion is intended.
            H1 (numpy.ndarray): Real-valued 2-D array of shape (norb, norb) containing the one-electron integrals in the orbital basis. The function attempts to ensure H1 is symmetric by copying between upper and lower triangles if one triangle is all zeros.
            H2 (numpy.ndarray): Real-valued 1-D packed array containing two-electron integrals in the FCIDUMP-packed triangular format. Its length equals norb_pair*(norb_pair+1)//2 where norb_pair = norb*(norb+1)//2. Orbital pair (i,j) with 1-based file indices is mapped to a single index using the same triangular indexing used in the code (ij_index = i*(i-1)//2 + j-1 for i>=j); two-electron matrix elements are stored according to the ij/kl triangular packing logic implemented in the source.
            ECORE (float): Scalar core (nuclear repulsion or frozen-core shift) energy read from the FCIDUMP (set when a record with k==0 and j==0 is encountered).
    
    Side effects:
        The function prints a single parsing message if verbose is True. It opens the file for reading and closes it before returning. It raises RuntimeError for malformed headers or unrecognized ORBSYM conventions, and will propagate I/O and parsing-related exceptions (e.g., FileNotFoundError, ValueError) to the caller. This function is intended to be used to import externally generated FCIDUMP files into PySCF for correlated-electron calculations.
    """
    from pyscf.tools.fcidump import read
    return read(filename, molpro_orbsym, verbose)


################################################################################
# Source: pyscf.tools.mo_mapping.mo_1to1map
# File: pyscf/tools/mo_mapping.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_tools_mo_mapping_mo_1to1map(s: numpy.ndarray):
    """Compute a one-to-one mapping from row indices i to column indices j using the absolute overlap matrix <i|j>, typically used in PySCF (Python-based Simulations of Chemistry Framework) to associate molecular orbitals from one set (bras) to the closest matching orbitals in another set (kets). In the quantum chemistry workflow of PySCF, this function is used to produce a simple, greedy correspondence between two orbital bases (for example, when comparing orbitals from two calculations or projecting orbitals between different basis sets) by selecting the largest absolute overlap for each row and preventing reuse of the same column index until all columns are exhausted.
    
    The algorithm is greedy: for each row i (0..s.shape[0]-1) it selects the column index k with the largest absolute value in that row, records k as the match for i, and then sets that entire column to zero in an internal working copy so that subsequent rows prefer different columns. The input array is not modified; the function operates on an absolute-value copy of s. Because the method is greedy rather than globally optimal, it may produce suboptimal assignments in cases of strongly tied overlaps or when the number of rows exceeds the number of columns.
    
    Args:
        s (numpy.ndarray): A 2-D numeric array representing overlaps <i|j>, where rows index the "bra" orbitals i and columns index the "ket" orbitals j. The function uses abs(s) internally, so negative values are treated by magnitude. The function expects a 2-D array; behavior for inputs that are not 2-D, contain NaNs or non-numeric entries, or otherwise violate the expected numeric array semantics is undefined and may raise numpy exceptions.
    
    Returns:
        list: A Python list of integer column indices. The returned list has length equal to s.shape[0]; the element at position i is the column index j chosen as the best match for row i (i.e., j is the column with the largest remaining absolute overlap for that row at the time of selection). Columns are selected uniquely while unselected columns remain available; if the number of rows exceeds the number of columns, columns will be exhausted and indices may repeat for later rows. No modification is performed on the input array s. Exceptions from numpy (e.g., due to malformed input) may propagate to the caller.
    """
    from pyscf.tools.mo_mapping import mo_1to1map
    return mo_1to1map(s)


################################################################################
# Source: pyscf.tools.molden.load
# File: pyscf/tools/molden.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_tools_molden_load(moldenfile: str, verbose: int = 0):
    """pyscf.tools.molden.load loads a molecular geometry and molecular orbital information from a Molden-format file into PySCF data structures for use in further electronic-structure computations or analysis.
    
    This function reads the text-based Molden file (a common quantum-chemistry interchange format for molecular geometries, basis sets and molecular orbitals) and returns a PySCF gto.Mole object plus the corresponding molecular orbital energies, coefficients, occupations, irreducible-representation labels, and spin labels as parsed from the file. The function updates the Mole.cart flag according to the angular-momentum section headers found in the Molden file, supports Molden files that encode either a single combined MO section (possibly containing spin orbitals) or separate MO sections for alpha and beta spins, and will build the returned Mole if it has not already been constructed. This loader is used within the PySCF framework (Python-based Simulations of Chemistry Framework) to import externally generated orbitals and geometry/basis information for visualization, analysis, or as inputs/initial guesses for PySCF calculations.
    
    Args:
        moldenfile (str): Path to the Molden-format input file. This is a filesystem path passed to open() and must point to a readable text file in Molden format. The function will raise an OSError (e.g., FileNotFoundError) if the file cannot be opened. The file is parsed section-by-section; unknown sections are written to sys.stderr but do not by themselves abort parsing. The caller is responsible for providing a Molden file that contains the expected sections (atoms/basis and MO blocks) used by PySCF.
        verbose (int): Verbosity level as an integer. This parameter is accepted for API compatibility with other PySCF IO routines but is not consulted by the current implementation; it is reserved for future use. Passing different integer values currently has no effect on parsing or output.
    
    Returns:
        mol (gto.Mole): A PySCF gto.Mole instance populated with the molecular geometry, atomic numbers, basis set information and the Mole.cart boolean indicating whether Cartesian (True) or spherical (False) Gaussian functions are expected. If the parsed data did not trigger building the Mole, the function calls mol.build(0, 0) before returning to ensure the Mole is ready for PySCF use.
        mo_energy (numpy.ndarray or tuple of numpy.ndarray): Orbital energies parsed from the Molden MO sections. If the Molden file encodes a single set of MOs for spin orbitals and they are separated into alpha/beta halves, this return value is a tuple (energies_alpha, energies_beta); otherwise it is a single numpy.ndarray of energies.
        mo_coeff (numpy.ndarray or tuple of numpy.ndarray): Molecular orbital coefficients in the atomic-orbital basis. For a single-spin-block Molden MO section this is a 2-D numpy.ndarray with shape (n_ao, n_mo). If the file encodes separate alpha and beta MO sections or the single section was split into alpha/beta halves, this is a tuple (coeff_alpha, coeff_beta), where each element is a numpy.ndarray shaped (n_ao, n_mo_alpha) and (n_ao, n_mo_beta) respectively. Note: if a single MO section encodes general spin orbitals that allow mixing of alpha and beta components (the implementation detects this when the coefficient matrix is square and spins include 'B'), the function raises NotImplementedError because such general spin-orbital mixing is not supported by this loader.
        mo_occ (numpy.ndarray or tuple of numpy.ndarray): Occupation numbers corresponding to the returned orbitals. The shape and tuple semantics mirror mo_energy and mo_coeff: either a single numpy.ndarray or (occ_alpha, occ_beta).
        irrep_labels (list or numpy.ndarray or tuple): Symmetry (irreducible representation) labels for each orbital as parsed from the Molden file. If spins are split into alpha/beta, irrep_labels is returned as a tuple (labels_alpha, labels_beta); otherwise it is a single sequence aligned with the orbitals in mo_coeff.
        spins (list or numpy.ndarray or tuple): Per-orbital spin labels parsed from the Molden MO blocks (for example elements beginning with 'A' or 'B' in Molden spin labels). If the file contains or is split into separate alpha/beta MO sections, spins is returned as a tuple (spins_alpha, spins_beta); otherwise it is a single sequence aligned with the returned orbitals. When two spin-blocks are returned as a tuple, the function also sets mol.spin = int(sum(occ_alpha) - sum(occ_beta)) to reflect the net spin multiplicity implied by occupations.
    
    Side effects and behavior details:
        - The function reads the specified file; any file I/O errors (permission, nonexistence) propagate as OSError/FileNotFoundError.
        - Unknown Molden sections encountered during parsing are reported to sys.stderr but do not necessarily stop parsing.
        - Angular-momentum section headers beginning with '5D', '7F', or '9G' set mol.cart = False (spherical harmonics); headers beginning with '6D', '10F', or '15G' set mol.cart = True (Cartesian). This affects how PySCF interprets AO components downstream.
        - If a single MO section is present but some spin labels indicate beta ('B') orbitals, the function attempts to treat the MO coefficient matrix as concatenated alpha and beta blocks and will split arrays into (alpha, beta) tuples. If the coefficient matrix indicates general spin-orbital mixing (detected when the coefficient matrix is square while spins contain 'B'), the function raises NotImplementedError because mixing of alpha and beta components within the same orbital is not supported by this loader.
        - If two MO sections are present, they are interpreted as distinct alpha and beta blocks and parsed independently.
        - If mo_occ is returned as a tuple (alpha, beta), mol.spin is set using the difference in total occupations: int(sum(alpha) - sum(beta)).
        - Before returning, if the Mole instance has not been built (mol._built is False), the function calls mol.build(0, 0) to finalize the Mole for use in PySCF routines.
    
    Failure modes and exceptions:
        - OSError/FileNotFoundError: if the input file cannot be opened.
        - NotImplementedError: if the Molden file encodes general spin orbitals that mix alpha and beta components in a way not supported by this loader.
        - ValueError or other parsing-related exceptions may be raised if the Molden file is malformed or contains inconsistent blocks (e.g., unexpected token structure); callers should validate input files or catch exceptions as appropriate.
    """
    from pyscf.tools.molden import load
    return load(moldenfile, verbose)


################################################################################
# Source: pyscf.tools.qcschema.recreate_mol_obj
# File: pyscf/tools/qcschema.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_tools_qcschema_recreate_mol_obj(qcschema_dict: dict, to_Angstrom: bool = False):
    """Recreate a PySCF Mole object from a QCSchema-format dictionary. This function is used in the PySCF tools.qcschema module to translate a QCSchema-compliant molecular description (the JSON-like dictionary used across quantum chemistry tools and data exchange) into an instantiated pyscf.gto.Mole object that can be used for PySCF electronic structure calculations. The routine extracts molecular charge, multiplicity, basis information, basis Cartesian/pure flag, and the atomic geometry (via load_qcschema_molecule), converts units if requested, constructs the pyscf.gto.Mole using the extracted settings, and calls mol.build(False, False) to finalize internal data structures required by downstream PySCF routines.
    
    Args:
        qcschema_dict (dict): A QCSchema-format dictionary describing the molecule and model. The function reads qcschema_dict["molecule"]["molecular_charge"] (converted to int) to set the PySCF charge; qcschema_dict["molecule"]["molecular_multiplicity"] (converted to int and then transformed to PySCF spin as multiplicity - 1) to set the PySCF spin (number of unpaired electrons); qcschema_dict["model"]["basis"] (converted to str) to set the basis name passed to both the Mole.basis and Mole.ecp arguments in the created Mole; and qcschema_dict["keywords"]["basisSet"]["cartesian"] (converted to bool) to set the cartesian flag indicating whether the basis uses Cartesian functions. The function also calls load_qcschema_molecule(qcschema_dict, to_Angstrom, False) to obtain the atom specification accepted by pyscf.gto.Mole. If qcschema_dict is missing required keys or contains values of unexpected types, the function will raise the corresponding KeyError or TypeError/ValueError coming from these extractions or from load_qcschema_molecule.
        to_Angstrom (bool): Optional flag (default False) that controls unit conversion for geometry. If False (default), the QCSchema geometry is interpreted in Bohr (QCSchema default) and the resulting pymol unit passed to pyscf.gto.Mole is 'B'. If True, the geometry is converted to Angstrom by load_qcschema_molecule and the unit passed to pyscf.gto.Mole is 'A'. Setting this flag affects only how the atomic coordinates are interpreted/converted; it does not otherwise change basis, charge, spin, or cartesian settings.
    
    Returns:
        pyscf.gto.Mole: A fully constructed pyscf.gto.Mole instance created with the extracted atom specification, basis (string passed to both basis and ecp arguments), charge (int), spin (int, multiplicity - 1), cartesian flag (bool), and unit ('A' or 'B'). The function calls mol.build(False, False) before returning, which finalizes internal data structures (integrals, basis mappings, and other internal bookkeeping) and suppresses interactive printing/logging by passing False for the first two positional build arguments. Typical failure modes include KeyError or ValueError when required QCSchema keys or values are missing or malformed, and exceptions raised by pyscf.gto.Mole.build if the provided basis/geometry/EC P combination is invalid for PySCF.
    """
    from pyscf.tools.qcschema import recreate_mol_obj
    return recreate_mol_obj(qcschema_dict, to_Angstrom)


################################################################################
# Source: pyscf.tools.qcschema.load_qcschema_molecule
# File: pyscf/tools/qcschema.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_tools_qcschema_load_qcschema_molecule(
    qcschema_dict: dict,
    to_Angstrom: bool = False,
    xyz: bool = False,
    mol_select: int = 1,
    step: int = 0
):
    """Loads a molecule description from a qcschema-format dictionary into a PySCF-friendly representation. This function is used in the PySCF (Python-based Simulations of Chemistry Framework) tools module pyscf.tools.qcschema to extract a single-point molecule or a specific geometry from a geometry optimization / trajectory result expressed as a qcschema dict. It reads element symbols and Cartesian coordinates from well-known qcschema keys, optionally converts coordinates from Bohr to Angstrom using the BOHR constant, reshapes the coordinate array into (N_atoms, 3), and returns either a Python list of (symbol, coordinates) pairs suitable for constructing a PySCF molecule or an xyz-format string for file output.
    
    Args:
        qcschema_dict (dict): A qcschema-format dictionary that contains molecular geometry information. In typical qcschema outputs the function expects keys such as "molecule" (single-point), "initial_molecule" and "final_molecule" (geometry optimization), or "trajectory" (list of steps where each step contains a "molecule"). Each molecule entry must provide "symbols" (sequence of element symbol strings) and "geometry" (flat sequence of numeric coordinates in x, y, z order). This argument is the primary input and must be a mapping containing these keys when requested by mol_select; otherwise the function will raise KeyError or related exceptions.
        to_Angstrom (bool): If True, convert coordinates from Bohr to Angstrom by multiplying the numeric geometry values by the BOHR constant defined in the module. Default is False, which leaves coordinates in Bohr. This option controls the physical units of the returned coordinates; callers should set this to True when downstream code or file formats expect Angstrom.
        xyz (bool): If False (default), return a Python list of tuples suitable for PySCF: each tuple contains an element symbol and a 1D numeric array (shape (3,)) of coordinates. If True, return a single string in xyz file format: the first line is the number of atoms, the second line is blank, and each subsequent line contains an element symbol and that atom's three Cartesian coordinates separated by commas. Note: the xyz-format string uses commas between coordinate components as produced by the implementation.
        mol_select (int): Selector that chooses which molecule entry to read from qcschema_dict. Default is 1. Accepted values and their meanings:
            1: use qcschema_dict["molecule"] (standard single-point qcschema),
            2: use qcschema_dict["initial_molecule"] (initial geometry in optimization/trajectory),
            3: use qcschema_dict["final_molecule"] (final geometry in optimization/trajectory),
            4: use a specific step from a trajectory or geometry optimization via qcschema_dict["trajectory"][step]["molecule"].
        step (int): When mol_select == 4, an integer index selecting which entry of the "trajectory" list to use. Default is 0. This index is used directly to index qcschema_dict["trajectory"]; if the index is out of range, an IndexError will be raised.
    
    Behavior, defaults, side effects, and failure modes:
        This function does not mutate the provided qcschema_dict; it constructs new numpy arrays for symbols and geometry values. It expects geometry arrays to have a length equal to 3 * N_atoms so that reshaping to (N_atoms, 3) succeeds; if the geometry length is not divisible by 3, numpy.reshape will raise a ValueError. If the selected qcschema key is missing (for example requesting mol_select=2 when "initial_molecule" is not present), the function will raise a KeyError. If mol_select is 4 and the "trajectory" key is missing or the given step index is invalid, a KeyError or IndexError will be raised. If qcschema_dict is not a dict-like mapping, normal Python type errors may occur. When to_Angstrom is True the function multiplies the numeric geometry values by the module-level BOHR constant; callers must ensure BOHR is defined and has the expected numeric conversion factor. The function relies on numpy for array handling and will raise numpy-related exceptions (TypeError, ValueError) if inputs are malformed.
    
    Returns:
        list or str: If xyz is False (default), returns a list of tuples [(symbol, coordinates_array), ...] where symbol is a string element symbol and coordinates_array is a numeric 1D array of length 3 giving Cartesian coordinates in the unit determined by to_Angstrom (Bohr if to_Angstrom=False, Angstrom if to_Angstrom=True). This list format is practical for constructing PySCF molecule objects or programmatic manipulation of atom lists. If xyz is True, returns a single string formatted as an xyz file: the first line is the number of atoms, the second line is blank, and each subsequent line contains "element x, y, z" with commas between coordinate components as produced by the implementation; this form is suitable for writing to an .xyz file for visualization or interoperability with programs that accept plain xyz text.
    
    Practical significance in the PySCF domain:
        Use this function when importing molecular geometries produced by quantum chemistry programs that expose results in qcschema format (for example outputs from QCArchive/QCElemental-compliant workflows) into PySCF calculations. It allows convenient extraction of the intended geometry (single-point, initial/final optimization geometry, or a specific trajectory frame), unit conversion to Angstrom when needed for display or external file formats, and direct construction of the simple atom list representation commonly used by PySCF routines.
    """
    from pyscf.tools.qcschema import load_qcschema_molecule
    return load_qcschema_molecule(qcschema_dict, to_Angstrom, xyz, mol_select, step)


################################################################################
# Source: pyscf.tools.fcidump.from_chkfile
# File: pyscf/tools/fcidump.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_tools_fcidump_from_chkfile(
    filename: str,
    chkfile: str,
    tol: float = 1e-15,
    float_format: str = " %.16g",
    molpro_orbsym: bool = False,
    orbsym: list = None
):
    """Read SCF results from a PySCF checkpoint file (chkfile), transform the one-electron
    and two-electron integrals into the SCF molecular orbital (MO) basis defined in the
    checkpoint, and write the transformed integrals to an FCIDUMP-format file. This function
    is used in quantum chemistry workflows within the PySCF framework to convert SCF outputs
    into the FCIDUMP format required by many post-Hartree–Fock solvers (for example full
    configuration interaction or external codes that consume FCIDUMP). The function loads
    molecule and SCF records from the checkpoint (via scf.chkfile.load_scf), extracts MO
    coefficients, checks orbital orthonormality against the AO overlap integrals, optionally
    computes orbital symmetry labels if the molecule has symmetry, and delegates the integral
    transformation and file writing to pyscf.tools.fcidump.from_mo while passing the molecular
    spin (ms=mol.spin) to the writer.
    
    Args:
        filename (str): Path to the output FCIDUMP file to be written. Practical significance:
            this is the file that downstream FCI/quantum chemistry codes will read. If a file
            with the same name exists, it may be overwritten by this function, depending on
            the underlying writer behavior.
        chkfile (str): Path to the PySCF checkpoint file that contains SCF results produced
            by PySCF (the file consumed by scf.chkfile.load_scf). The checkpoint must contain
            the molecular object and an SCF record with the key 'mo_coeff' (MO coefficient
            matrix). This chkfile is the source of orbitals and molecular metadata used to
            transform integrals into the MO basis.
        tol (float): Numerical tolerance passed to the integral transformation/writer
            (default 1e-15). In practice this tolerance is used to decide whether very small
            integrals should be treated as zero or formatted with full precision when writing
            the FCIDUMP; it controls numerical screening and precision-related decisions in
            pyscf.tools.fcidump.from_mo called by this function.
        float_format (str): Format string used to serialize floating point numbers in the
            written FCIDUMP (default " %.16g"). This controls textual representation of
            integrals in the output file so that consumers of the FCIDUMP receive numbers in
            the specified format.
        molpro_orbsym (bool): If True, dump orbital symmetry labels in the Molpro convention
            documented at https://www.molpro.net/info/current/doc/manual/node36.html.
            Practical significance: some post-processing or external codes expect Molpro-style
            orbsym numbering; setting this flag ensures compatibility with those conventions.
        orbsym (list): Optional list of orbital-symmetry labels to be written to the FCIDUMP.
            If the molecular object loaded from the chkfile has symmetry (mol.symmetry is True),
            this argument will be ignored and orbital symmetry labels are recomputed from the
            molecule and MO coefficients via pyscf.symm.label_orb_symm. If provided and the
            molecule has no symmetry, these labels are used when writing the FCIDUMP.
    
    Behavior, side effects, defaults, and failure modes:
        - The function loads the molecule and SCF record from chkfile using scf.chkfile.load_scf.
          The SCF record must contain the key 'mo_coeff' with a two-dimensional array-like
          object; this matrix is used as the MO coefficient matrix for the integral
          transformation.
        - The function computes the MO overlap s = C^T S C where S is the AO overlap
          integrals obtained from mol.intor_symmetric('int1e_ovlp') and C is the MO coefficient
          matrix. If the maximum absolute deviation of s from the identity matrix exceeds
          1e-6, the function raises RuntimeError('Non-orthogonal orbitals found in chkfile').
          This check prevents use of non-orthogonal orbitals (for example checkpoint files
          generated by periodic boundary condition calculations) because the integral
          transformation implemented here requires orthonormal MO coefficients.
        - If mol.symmetry is True for the loaded molecule, orbital symmetry labels are
          recomputed with symm.label_orb_symm(mol, mol.irrep_id, mol.symm_orb, mo_coeff,
          check=False) and assigned to orbsym; any orbsym passed by the caller is then ignored.
        - The function calls pyscf.tools.fcidump.from_mo with the loaded molecule, the
          computed MO coefficients, and the provided tol, float_format, molpro_orbsym, and the
          orbital symmetry labels (or the recomputed labels). The molecular spin value
          mol.spin from the checkpoint is passed as ms to the writer. The primary side effect
          is creation (or overwriting) of the file specified by filename containing integrals
          in FCIDUMP format.
        - Exceptions propagated from scf.chkfile.load_scf, numpy array operations, or the
          underlying writer (from_mo) are not suppressed; callers should handle IO errors,
          malformed checkpoint files, or other runtime exceptions accordingly.
        - The function does not support checkpoint files from periodic-boundary-condition
          SCF calculations as those typically yield non-orthogonal MO representations.
    
    Returns:
        None: This function does not return a Python value. Its practical effect is the side
        effect of writing the transformed one- and two-electron integrals (and associated
        metadata such as orbital occupations, nuclear repulsion, and optionally orbital
        symmetries) to the specified FCIDUMP file so that downstream FCI or external
        quantum-chemistry programs can consume them.
    """
    from pyscf.tools.fcidump import from_chkfile
    return from_chkfile(filename, chkfile, tol, float_format, molpro_orbsym, orbsym)


################################################################################
# Source: pyscf.tools.qcschema.load_qcschema_scf_info
# File: pyscf/tools/qcschema.py
# Category: fix_args
# Reason: Missing type hints for some parameters
################################################################################

def pyscf_tools_qcschema_load_qcschema_scf_info(qcschema_dict: dict):
    """Loads SCF (self-consistent field) result information from a QCSchema-format dictionary and returns a PySCF-style SCF information dictionary suitable for downstream use in the PySCF (Python-based Simulations of Chemistry Framework) codebase. This function is used when PySCF needs to import SCF results that were serialized with the QCSchema convention (a common JSON schema for quantum chemistry results) and convert those values and array shapes into the conventions PySCF expects for total energy, molecular orbital coefficients, occupations, and eigenvalues.
    
    Args:
        qcschema_dict (dict): A QCSchema-format dictionary containing SCF/wavefunction and calculation properties. In practical use this dict must include the nested keys used by this function: "keywords"->"scf"->"method" (a string indicating the SCF method), "properties"->"calcinfo_nbasis" (number of atomic orbitals, nao), optional "properties"->"calcinfo_nmo" (number of molecular orbitals, nmo), "properties"->"return_energy" (total electronic energy), and "wavefunction" entries "scf_orbitals_a", "scf_occupations_a", "scf_eigenvalues_a". For unrestricted/alpha+beta cases the corresponding "_b" entries ("scf_orbitals_b", "scf_occupations_b", "scf_eigenvalues_b") are required. The function interprets these fields according to the QCSchema semantics: occupations in restricted wavefunctions are commonly 0 or 1 and are scaled when converting to PySCF occupancy conventions.
    
    Returns:
        dict: A dictionary scf_dic with the keys required by PySCF to represent SCF results:
            e_tot (float): Total electronic energy converted from qcschema_dict["properties"]["return_energy"] to Python float. This is the scalar energy value used in PySCF summaries and further electronic-structure calculations.
            mo_energy (numpy.ndarray): Molecular orbital eigenvalues (energies). For restricted or generalized single-spin cases this will be a 1-D array of length nmo. For unrestricted (alpha+beta) cases this will be a 2-D array with alpha first and beta second (shape (2, nmo)).
            mo_occ (numpy.ndarray): Molecular orbital occupations. For restricted or generalized single-spin cases this is a 1-D array of length nmo. For unrestricted cases this is a 2-D array with alpha occupations in row 0 and beta occupations in row 1. For restricted methods (rks, roks, rhf, rohf) the function multiplies the QCSchema occupations (typically 0 or 1) by 2.0 to match PySCF occupied-electron counts per spatial orbital; for unrestricted methods occupations are left with OccFactor 1.0.
            mo_coeff (numpy.ndarray): Molecular orbital coefficient matrix. For single-spin cases this is reshaped to shape (nao, nmo) where nao is qcschema_dict["properties"]["calcinfo_nbasis"] and nmo is qcschema_dict["properties"]["calcinfo_nmo"] when present (otherwise assumed equal to nao). For unrestricted alpha+beta cases this is stacked so the returned array has shape (2, nao, nmo) with alpha first then beta.
    
    Behavior, defaults, and failure modes:
        - Method detection: The SCF method string is read from qcschema_dict["keywords"]["scf"]["method"]. Recognized method strings are exactly: 'rks', 'roks', 'rhf', 'rohf' (treated as restricted with OccFactor = 2.0 and no separate beta spin), 'uks', 'uhf' (treated as unrestricted with OccFactor = 1.0 and beta present), and 'gks', 'ghf' (treated as generalized with OccFactor = 1.0 and no separate beta spin). If the method string is not one of these values the function raises RuntimeError('qcschema: cannot determine method..exit').
        - nmo handling: The function reads nao = qcschema_dict["properties"]["calcinfo_nbasis"]. It attempts to read nmo = qcschema_dict["properties"]["calcinfo_nmo"]; if that key is missing the function sets nmo = nao as a pragmatic default (this mirrors the source behavior and the comment that linear dependencies or other details may make this assumption invalid). Immediately after this the function asserts nmo == nao; if this assertion fails an AssertionError is raised. This means the function will not proceed when nmo differs from nao and the caller must provide a consistent calcinfo_nmo when they differ.
        - Array reshaping and stacking: The function reshapes qcschema_dict["wavefunction"]["scf_orbitals_a"] into shape (nao, nmo) for mo_coeff. If have_beta is True, it similarly reshapes the "_b" coefficients and stacks them into a final shape (2, nao, nmo). If the source arrays do not have the expected lengths for the reshapes, a numpy ValueError (or similar) will be raised during reshape/stack operations.
        - Missing keys and types: If required keys are missing from the nested QCSchema dictionary, Python will raise KeyError. If numeric conversions fail (e.g., return_energy cannot be converted to float) a TypeError or ValueError may be raised. The function does not perform type coercion beyond float(...) for return_energy and numpy conversions for arrays.
        - No side effects: The function does not modify qcschema_dict in-place and has no external side effects; it constructs and returns a new dictionary scf_dic.
    
    Practical significance in PySCF workflow:
        - This function is intended to bridge external QCSchema-serialized SCF outputs (for example produced by other quantum-chemistry programs or a QCSchema-compliant I/O pipeline) into PySCF's internal representation so that energies, orbital coefficients, occupations, and eigenvalues can be used by PySCF routines (e.g., for post-SCF methods, property evaluation, or restarting calculations).
        - The mapping of occupation scaling (OccFactor) and the arrangement of alpha/beta arrays matches PySCF conventions so that subsequent PySCF code can rely on shapes and occupancy semantics without additional conversion.
    """
    from pyscf.tools.qcschema import load_qcschema_scf_info
    return load_qcschema_scf_info(qcschema_dict)


from typing import Dict, Any


def get_tools() -> Dict[str, Dict[str, Any]]:
    """Extract JSON schemas for all functions in this module."""
    import sys
    import os
    
    # Add project root to path to import our json_schema module
    # Try multiple possible paths
    possible_paths = [
        os.path.join(os.path.dirname(__file__), '..', '..', 'utils'),
        '/app/utils',
        '/app/project/utils',
    ]
    
    json_schema_path = None
    for path in possible_paths:
        abs_path = os.path.abspath(path)
        if os.path.exists(os.path.join(abs_path, 'json_schema.py')):
            if abs_path not in sys.path:
                sys.path.insert(0, abs_path)
            json_schema_path = abs_path
            break
    
    if json_schema_path:
        from json_schema import get_json_schema
    else:
        # Fallback to transformers if our module not found
        from transformers.utils import get_json_schema
    
    tools = {}
    failed_count = 0
    
    for name, func in get_lib().items():
        try:
            tools[name] = get_json_schema(func)
        except Exception as e:
            failed_count += 1
            # Only print first few errors to avoid spam
            if failed_count <= 3:
                print(f"Failed to get schema for {name}: {type(e).__name__}: {e}", file=sys.stderr)
            continue
    
    if failed_count > 0:
        print(f"Warning: Failed to extract schemas for {failed_count} out of {len(get_lib())} functions", file=sys.stderr)
    
    return tools


def get_lib():
    """Get all functions defined in this module."""
    import inspect
    global_vars = inspect.currentframe().f_globals
    
    functions = {
        name: obj for name, obj in global_vars.items()
        if inspect.isfunction(obj) and obj.__module__ == __name__
    }
    functions.pop("get_lib", None)
    functions.pop("get_tools", None)
    return functions
