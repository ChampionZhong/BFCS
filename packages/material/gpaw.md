# gpaw

[ðŸ”™ Back to Main Repo](../../../README.md) | [ðŸ”— Original Repo](https://gitlab.com/gpaw/gpaw)

![Tool Count](https://img.shields.io/badge/Agent_Tools-263-blue?style=flat-square)
![Category](https://img.shields.io/badge/Category-Material-green?style=flat-square)
![Status](https://img.shields.io/badge/Import_Test-Passed-success?style=flat-square)

## ðŸ“– Overview

GPAW is a Python-based density-functional theory (DFT) electronic-structure code using the projector-augmented wave (PAW) method and ASE to run atomistic simulations with plane waves, localized basis sets, or real-space grids.

> **Note**: This documentation lists the **agent-ready wrapper functions** generated for this package. These functions have been strictly typed, docstring-enhanced, and tested for import stability within a standardized Apptainer environment.

## ðŸ› ï¸ Available Agent Tools

Below is the list of **263** functions optimized for LLM tool-use.

| **Tool Name (Wrapper)**   | **Source**          | **File Path**     | **Arguments (Type)**        | **Description**                |
| ------------------------- | ------------------- | ----------------- | --------------------------- | ------------------------------ |
| `gpaw_benchmark_parse_git_status` | `gpaw.benchmark.parse_git_status` | `gpaw/benchmark/__init__.py` | `text: str` | `Parse the branch name from the textual output of the git status command. This function is used in GPAW's benchmarking and logging code to determine which Git branch produced a particular run or result. It accepts the complete multi-line output of the git status command as a single string and extracts the branch name by looking for the first line that begins with the exact, case-sensitive prefix "On branch". It is a pure, side-effect-free parser and does not invoke Git or perform any I/O; it only examines the provided text.` |
| `gpaw_atom_configurations_core_states` | `gpaw.atom.configurations.core_states` | `gpaw/atom/configurations.py` | `symbol: str` | `gpaw.atom.configurations.core_states returns the number of core states (Njcore) associated with a given chemical element symbol as parsed from the module-level GPAW configuration data. In the GPAW DFT/PAW context (see README: GPAW uses the PAW method and ASE), this function is used by atomic-configuration parsing routines to determine how many core electronic states are defined for an element; this number influences how core electrons and projector-augmentation channels are handled when building atomic datasets and initializing calculations.` |
| `gpaw_analyse_vdwradii_vdWradii` | `gpaw.analyse.vdwradii.vdWradii` | `gpaw/analyse/vdwradii.py` | `symbols: list, xc: str` | `gpaw.analyse.vdwradii.vdWradii finds atomic van der Waals radii using the Tkatchenkoâ€“Scheffler scheme implemented in GPAW. It computes a cutoff electron density from a rare-gas reference atom and locates the radius at which the target atom's radial electron density equals that cutoff. The radii are returned in units of Angstrom and are suitable for use in DFT post-processing and dispersion-correction schemes within the GPAW/ASE workflow.` |
| `gpaw_benchmark_gs_and_move_atoms` | `gpaw.benchmark.gs_and_move_atoms` | `gpaw/benchmark/__init__.py` | `long_name: str, calc_info: dict` | `gpaw.benchmark.gs_and_move_atoms Calculates one geometry-relaxation-like step for a GPAW benchmark: evaluates energy and forces, moves atoms by a fraction of the forces (or applies a small strain if forces are negligible), records timings for the two evaluation phases, and returns the initial energy together with the forces measured after the move and timing metadata. This function is intended for automated benchmarking of GPAW/ASE geometry-step performance and reproduces the typical sequence used in a geometry relaxation: evaluate, take a small step toward the minimum, wrap positions, re-evaluate. It uses benchmark_atoms_and_calc(long_name, calc_info) to obtain an ASE Atoms object and its GPAW calculator according to the provided benchmark configuration.` |
| `gpaw_benchmark_parse_nvidia_smi` | `gpaw.benchmark.parse_nvidia_smi` | `gpaw/benchmark/__init__.py` | `dct: dict, out: str` | `Parse output from nvidia-smi and count GPU models for gpaw.benchmark.parse_nvidia_smi. Parses the textual output produced by the NVIDIA command-line tool nvidia-smi to extract the advertised GPU model name and increment a counter for that model in the supplied dictionary. This function is used within GPAW benchmarking and environment-detection code to record how many GPUs of each model are present on the system where the nvidia-smi output was collected. The implementation expects the nvidia-smi output to contain lines with the substring "NVIDIA " and a tokenized layout where the GPU name tokens follow at least three initial tokens on the line; tokens are collected until a delimiter token ('\|', 'On', or 'Off') is encountered.` |
| `gpaw_benchmark_parse_mem` | `gpaw.benchmark.parse_mem` | `gpaw/benchmark/__init__.py` | `memstr: str` | `Parse a human-readable memory size string and convert it to a number of bytes using binary (base-2) multipliers. This function is used in GPAW benchmarking and configuration code to interpret short memory specifications such as those found in job configuration, command-line options, or benchmark descriptions. The input string must end with one of the exact uppercase suffixes 'G', 'M', or 'K' to indicate gibibytes, mebibytes, or kibibytes respectively. The numeric portion preceding the suffix is parsed and multiplied by the corresponding binary multiplier (G -> 1024**3, M -> 1024**2, K -> 1024**1). The result is returned as a float representing the number of bytes; this numeric byte value can be used for memory allocation decisions, resource reporting, or performance comparisons in the GPAW DFT benchmarking and runtime configuration contexts.` |
| `gpaw_benchmark_benchmark_atoms_and_calc` | `gpaw.benchmark.benchmark_atoms_and_calc` | `gpaw/benchmark/__init__.py` | `long_name: str, calc_info: str` | `Create an ASE Atoms object and a GPAW calculator from a combined long name and calculator information string for use in GPAW benchmarking and test workflows. This function is used in the gpaw.benchmark module to construct the atomic system and the corresponding GPAW calculator configuration from a compact identifier string. The function expects long_name to encode both the atomic system and a parameter set (joined by a single '-' character), parses these components with parse_system and parse_parameters, selects the GPAW interface implementation according to calc_info ('new' selects gpaw.new.ase_interface.GPAW, 'old' selects gpaw.GPAW), instantiates the calculator with the parsed parameters, assigns it to the ASE Atoms object (atoms.calc), and returns both the Atoms object and the calculator instance. The GPAW calculator is created with a text-log file named "{long_name}-{calc_info}.log". Parameter dictionaries are pretty-printed on rank 0 of the global MPI communicator (world) using pp.` |
| `gpaw_atom_radialgd_fsbt` | `gpaw.atom.radialgd.fsbt` | `gpaw/atom/radialgd.py` | `l: int, f_g: numpy.ndarray, r_g: numpy.ndarray, G_k: numpy.ndarray` | `Fast spherical Bessel transform used in GPAW's radial-grid routines. Computes the spherical Bessel transform âˆ«_0^âˆž r dr j_l(G r) f(r) for a radial function f(r) sampled on a discrete radial grid r_g, returning the transform sampled on the provided G_k radial-frequency points. The implementation is a fast algorithm that uses l+1 real FFTs (numpy.fft.rfft) and algebraic recurrence factors to build the transform for order l, which is useful in GPAW/PAW routines when converting atom-centered radial functions between real-space radial grids and reciprocal-space (G) representation.` |
| `gpaw_atom_basis_make_split_valence_basis_function` | `gpaw.atom.basis.make_split_valence_basis_function` | `gpaw/atom/basis.py` | `r_g: numpy.ndarray, psi_g: numpy.ndarray, l: int, gcut: int` | `Make a split-valence radial basis function by smoothly joining a low-radius polynomial to a given atomic orbital on a radial grid.` |
| `gpaw_benchmark_parse_name` | `gpaw.benchmark.parse_name` | `gpaw/benchmark/__init__.py` | `name: str` | `Parse a benchmark name string used by the GPAW benchmarking utilities and extract a canonical (long) benchmark identifier, an optional nickname, and the calculation mode indicator.` |
| `gpaw_benchmark_parse_processor` | `gpaw.benchmark.parse_processor` | `gpaw/benchmark/__init__.py` | `text: str` | `gpaw.benchmark.parse_processor parses the processor model string from the output of the Unix lscpu command for use in GPAW benchmarking and performance metadata.` |
| `gpaw_benchmark_parse_parameters` | `gpaw.benchmark.parse_parameters` | `gpaw/benchmark/__init__.py` | `parameter_sets: str` | `Parses a compact parameter-set descriptor string used by gpaw.benchmark into a single dictionary of configuration parameters. This function is used by GPAW benchmarking and configuration code to convert a human-readable, compact descriptor (for example "pw.high:gamma:parallel.gpu" or "lcao.dzp:kpt.density4:noscalapack") into a concrete mapping of parameters that can be passed to GPAW calculators or benchmarking routines. The descriptor language treated here is specific to gpaw.benchmark and documented by the repository examples: individual parameter sets are concatenated with ":" (colon) and refinements of a single set are given after the main set name separated by "." (dot). The function looks up predefined presets in the global gpaw_parameter_sets mapping, deep-copies the preset defaults, and merges them into a single dictionary using recursive_update so that more specific entries override earlier or more general ones. The function prints a one-line debug representation of each parsed main set and its first-level subset components to stdout (via print(firstsplit)) as a side effect.` |
| `gpaw_atom_all_electron_shoot` | `gpaw.atom.all_electron.shoot` | `gpaw/atom/all_electron.py` | `u: numpy.ndarray, l: int, vr: numpy.ndarray, e: float, r2dvdr: numpy.ndarray, r: numpy.ndarray, dr: numpy.ndarray, c10: numpy.ndarray, c2: numpy.ndarray, scalarrel: bool, gmax: int = None` | `Shoot the radial SchrÃ¶dinger equation for a guessed trial eigenenergy in the GPAW all-electron atomic solver. This function integrates the radial SchrÃ¶dinger (or scalar-relativistic modified) differential equation for a single radial channel on a radial grid used by GPAW's projector-augmented wave (PAW) all-electron routines. It is used during eigenvalue shooting: for a trial eigenenergy e the routine integrates the wavefunction u(r) from both asymptotic boundaries (r -> 0 and r -> infinity) toward the classical turning point, counts the number of radial nodes, and computes a measure A of the derivative discontinuity at the turning point. The returned node count and discontinuity A are used by higher-level routines to adjust e until the physical eigenstate (correct node count and vanishing A) is found. The function modifies the input array u in-place to contain the integrated radial wavefunction on the provided radial mesh.` |
| `gpaw_basis_data_parse_basis_name` | `gpaw.basis_data.parse_basis_name` | `gpaw/basis_data.py` | `name: str` | `Parse a GPAW basis type identifier string and return the numeric zeta and polarization counts encoded in that identifier. This function is used by GPAW when interpreting atom-centered basis-function specifications (see GPAW README references to "atom-centered basis-functions"). Basis identifiers encode how many radial basis functions ("zeta" functions) and how many additional polarization functions to include. Typical identifiers look like 'sz', 'dzp', 'qztp', or '4z3p'. The first character encodes the zeta count (either a decimal digit or a letter looked up in the module-level mapping _basis_letter2number). The second character must be the literal 'z'. The identifier optionally contains a polarization part: either absent (no polarization), a trailing 'p' (one polarization), or a third character (letter or digit) followed by 'p' (explicit polarization count).` |
| `gpaw_benchmark_benchmark_from_dict` | `gpaw.benchmark.benchmark_from_dict` | `gpaw/benchmark/__init__.py` | `dct: dict` | `gpaw.benchmark.benchmark_from_dict creates a compact, human- and machine-readable summary dictionary from the full JSON-like output of a GPAW benchmark run. This function is used by GPAW benchmarking and reporting code to extract the most important performance and system metadata (timings, hardware, MPI counts, Git revision) from the verbose benchmark output so downstream tools, plots, or tables can display and compare results without parsing the full log.` |
| `gpaw_atom_all_electron_shoot_confined` | `gpaw.atom.all_electron.shoot_confined` | `gpaw/atom/all_electron.py` | `u: numpy.ndarray, l: int, vr: numpy.ndarray, e: float, r2dvdr: numpy.ndarray, r: numpy.ndarray, dr: numpy.ndarray, c10: numpy.ndarray, c2: numpy.ndarray, scalarrel: bool, gmax: int = None, rc: float = 10.0, beta: float = 7.0` | `This function integrates a radial, confined all-electron differential equation by the shooting method and is used by the solve_confined routine in the GPAW all-electron atomic solver. It advances a provided radial wavefunction array u on a given radial grid r with spacing dr, using potential-related arrays (vr, r2dvdr) and finite-difference coefficients (c10, c2) to perform inward and outward integrations, locate the classical turning point, count nodes, and compute the derivative discontinuity A at the turning point. This information is used in the confined eigenvalue search to adjust the trial energy e until the radial wavefunction satisfies boundary conditions for bound states in GPAW's confined-atom calculations.` |
| `gpaw_benchmark_parse_requirement` | `gpaw.benchmark.parse_requirement` | `gpaw/benchmark/__init__.py` | `req: str` | `Parses a benchmark resource requirement string used by gpaw.benchmark to specify the minimum and maximum compute resources required to run a benchmark or job. The function accepts a requirement string in the format "core_range:memory[:gpu_range]" (colon-separated). In the GPAW benchmarking and test-selection domain this string encodes the allowed CPU core count range (core_range), the minimum memory requirement (memory), and optionally the allowed GPU count range (gpu_range). This parser converts that textual specification into a structured dictionary that downstream benchmark selection and scheduling code can use to match available hardware to benchmark requirements.` |
| `gpaw_benchmark_parse_range` | `gpaw.benchmark.parse_range` | `gpaw/benchmark/__init__.py` | `s: str` | `Parse a CPU or GPU range string used by gpaw.benchmark utilities and return the numeric lower and upper bounds. This function is used in GPAW benchmarking/selection code to interpret simple range expressions that specify which CPU or GPU indices should be used for a benchmark run. The input is a short string that may contain the substring "GPU" (case-sensitive) and a hyphen-separated range. Behavior follows the exact rules implemented in the source: the literal substring "GPU" is removed, a single integer denotes an exact index (both bounds equal), a missing lower bound (a leading hyphen) implies 0, and a missing upper bound (a trailing hyphen) implies an unbounded upper limit represented by numpy.inf. There are no side effects; the function only parses and returns numeric bounds. Examples and their results: "0-1" -> (0, 1), "5" -> (5, 5), "-4GPU" -> (0, 4).` |
| `gpaw_bztools_get_lattice_symmetry` | `gpaw.bztools.get_lattice_symmetry` | `gpaw/bztools.py` | `cell_cv: numpy.ndarray, tolerance: float = 1e-07` | `Return a gpaw.symmetry object that describes the lattice (space) symmetry of a unit cell used in GPAW periodic calculations.` |
| `gpaw_bztools_get_smallest_Gvecs` | `gpaw.bztools.get_smallest_Gvecs` | `gpaw/bztools.py` | `cell_cv: numpy.ndarray, n: int = 5` | `Find smallest reciprocal lattice vectors for a centered integer grid of Miller indices.` |
| `gpaw_bztools_convex_hull_volume` | `gpaw.bztools.convex_hull_volume` | `gpaw/bztools.py` | `pts: list` | `gpaw.bztools.convex_hull_volume calculates the volume of the convex hull of a collection of 3D points. Calculates the geometric volume enclosed by the convex hull of a set of three-dimensional points. In the GPAW/ASE/DFT context this function is typically used to evaluate the spatial volume occupied by atomic coordinates, point clouds, or sets of k-points (for example to estimate cell or Brillouin-zone related volumes). The implementation builds the convex hull with scipy.spatial.ConvexHull, constructs a Delaunay triangulation of the hull vertices, computes volumes of the resulting tetrahedra with tetrahedron_volume, and returns their sum as the total hull volume. The result is expressed in the cubic units of the input coordinates (for example, if coordinates are in Ã…, the returned volume is in Ã…^3).` |
| `gpaw_bztools_get_symmetry_operations` | `gpaw.bztools.get_symmetry_operations` | `gpaw/bztools.py` | `U_scc: numpy.ndarray, time_reversal: bool` | `gpaw.bztools.get_symmetry_operations Return point symmetry operations used by GPAW Brillouin-zone tools. This function prepares a set of 3x3 point-group symmetry operation matrices that are used throughout GPAW to reduce Brillouin-zone sampling, apply symmetry to k-points, and otherwise exploit spatial symmetries in density-functional-theory calculations (see GPAW README for general context). The function accepts an existing collection of Cartesian 3x3 symmetry matrices or None and optionally augments that collection with time-reversal counterparts. The implementation ensures sensible defaults and prevents adding time-reversal operations when a pure spatial inversion operation is already present.` |
| `gpaw_bztools_get_ibz_vertices` | `gpaw.bztools.get_ibz_vertices` | `gpaw/bztools.py` | `cell_cv: numpy.ndarray, U_scc: numpy.ndarray = None, time_reversal: bool = None, origin_c: numpy.ndarray = None` | `gpaw.bztools.get_ibz_vertices determines the vertices of the irreducible Brillouin zone (IBZ) for a given unit cell and its crystal symmetry operations. In the GPAW DFT context this function is used to reduce k-point sampling by exploiting spatial and optional time-reversal symmetries: it generates symmetry-equivalent k-points, constructs a Voronoi cell around a representative point and returns the coordinates of the IBZ vertices used for Brillouin-zone partitioning and k-point mesh construction.` |
| `gpaw_bztools_find_high_symmetry_monkhorst_pack` | `gpaw.bztools.find_high_symmetry_monkhorst_pack` | `gpaw/bztools.py` | `calc: str, density: float` | `Find a Monkhorst-Pack k-point grid that contains the corners of the irreducible Brillouin zone (IBZ). This function is used in the GPAW density-functional-theory (DFT) workflow to produce a high-symmetry Monkhorstâ€“Pack (MP) k-point grid that explicitly includes the IBZ corner points. Including IBZ corners ensures that when k-point sampling is later reduced or symmetrically reduced, the full irreducible Brillouin zone remains represented and key high-symmetry points are preserved for band-structure and symmetry-sensitive calculations. The routine performs a brute-force search over MP-grid sizes starting from a minimum grid density determined by the supplied density parameter, requests gamma-centred and even grids where appropriate, consults the calculator restart file to obtain the atomic cell and wavefunction grid, and maps candidate MP grids into the first Brillouin zone using the calculator's cell information.` |
| `gpaw_bztools_unfold_points` | `gpaw.bztools.unfold_points` | `gpaw/bztools.py` | `points: numpy.ndarray, U_scc: numpy.ndarray, tol: float = 1e-08, mod: int = None` | `Unfold k-points using a set of symmetry operators to produce the full set of symmetry-equivalent k-points for Brillouin-zone sampling and band-structure unfolding in GPAW DFT calculations.` |
| `gpaw_bztools_unique_rows` | `gpaw.bztools.unique_rows` | `gpaw/bztools.py` | `ain: numpy.ndarray, tol: float = 1e-10, mod: int = None, aglomerate: bool = True` | `gpaw.bztools.unique_rows returns the unique rows of a 2D NumPy array, treating rows as k-point vectors in GPAW's Brillouin-zone utilities. It is used to reduce lists of k-points by identifying rows that represent the same point within a given numerical tolerance, optionally taking periodicity (full reciprocal-lattice-vector equivalence) and local clustering into account. The function preserves the original row values in the returned array but orders the unique rows according to a lexicographic sort applied after internal normalization and rounding.` |
| `gpaw_coding_style_function` | `gpaw.coding_style.function` | `gpaw/coding_style.py` | `a: numpy.ndarray, b: numpy.ndarray` | `gpaw.coding_style.function performs an elementwise addition of two NumPy arrays and returns the result. This small utility is used in the GPAW DFT codebase to combine array-valued quantities that appear in electronic-structure calculations (for example densities, potentials or components of wavefunctions) while respecting NumPy broadcasting rules and MPI-aware debug printing conventions used in GPAW scripts and modules. This function creates and returns a new numpy.ndarray that is the elementwise sum of the inputs. As implemented in the source, the function also has a side effect: when the module-level boolean flag debug is true and the MPI world communicator indicates the current process has rank 0 (mpi.world.rank == 0), the function prints the computed result scaled by the module-level constant Ha. The scaling and printing are only for human-readable diagnostic output and do not alter the returned array. Because the function relies on module-level globals (debug, mpi, Ha), its printing behavior depends on the GPAW runtime environment and MPI configuration.` |
| `gpaw_bztools_tetrahedron_volume` | `gpaw.bztools.tetrahedron_volume` | `gpaw/bztools.py` | `a: numpy.ndarray, b: numpy.ndarray, c: numpy.ndarray, d: numpy.ndarray` | `gpaw.bztools.tetrahedron_volume â€” Calculate volume of a tetrahedron or volumes of many tetrahedra. Calculate the (unsigned) volume using the scalar triple product formula employed in Brillouin-zone tetrahedron methods and other tetrahedral integrations that appear in density-functional theory (DFT) workflows with GPAW and ASE. This routine computes \|(a - d) Â· ((b - d) Ã— (c - d))\| / 6 in a vectorized manner. It is used in gpaw.bztools for geometric operations such as computing tetrahedral volumes for k-point or real-space partitioning needed in electronic-structure integration schemes and post-processing utilities that rely on tetrahedral decomposition.` |
| `gpaw_convergence_criteria_dict2criterion` | `gpaw.convergence_criteria.dict2criterion` | `gpaw/convergence_criteria.py` | `dictionary: dict` | `Converts a dictionary specification into a GPAW convergence criterion object. This function is used in GPAW (the DFT/PAW code) to translate a serialized or user-provided dictionary representation of a convergence criterion into a runtime criterion object that controls iterative convergence checks (for example, SCF energy or density convergence or geometry optimization tolerances). The input dictionary may be the output of a criterion's todict() method (containing a 'name' key and other keyword arguments), or a compact user shortcut mapping a criterion name to a value (for example {'energy': 0.005} or {'energy': (0.005, 3)}). dict2criterion uses get_criterion(name) to obtain the criterion factory/class and constructs an instance either by passing keyword arguments (when the dictionary contains 'name') or by passing a single positional argument (when a criterion name maps to a scalar/tuple). The function copies the input dictionary before modification so the original argument is not mutated.` |
| `gpaw_core_matrix_suggest_blocking` | `gpaw.core.matrix.suggest_blocking` | `gpaw/core/matrix.py` | `N: int, ncpus: int` | `Suggest blocking (process grid and block size) for an NxN matrix used in parallel linear-algebra routines.` |
| `gpaw_convergence_criteria_get_criterion` | `gpaw.convergence_criteria.get_criterion` | `gpaw/convergence_criteria.py` | `name: str` | `Retrieve a built-in GPAW convergence criterion by its registered .name attribute. This function is used within the GPAW DFT code to select one of the pre-defined convergence criteria that control when iterative algorithms stop (for example self-consistent field iterations, eigenstate/eigenvalue convergence checks, force-based stopping in geometry relaxations, or iteration limits). The function looks up a mapping constructed from the module's built-in criterion classes and returns the class/object associated with the provided name. No global state is modified by this lookup; the mapping is created from the fixed list of built-in criterion classes present in the module: Energy, Density, Eigenstates, Eigenvalues, Forces, WorkFunction, MinIter and MaxIter.` |
| `gpaw_directmin_derivatives_mgs` | `gpaw.directmin.derivatives.mgs` | `gpaw/directmin/derivatives.py` | `vin: numpy.ndarray` | `gpaw.directmin.derivatives.mgs: Modified Gramâ€“Schmidt orthonormalization routine used in GPAW direct-minimization derivatives. Performs the modified Gramâ€“Schmidt procedure on a set of input vectors to produce an orthonormal set. In the GPAW codebase this is used when orthonormalizing collections of vectors such as trial wavefunction coefficient arrays, search directions, or basis vectors inside direct-minimization algorithms for density-functional theory (DFT) calculations. The routine normalizes vectors and removes components along previously processed vectors so that the output vectors are orthonormal with respect to the standard Euclidean inner product.` |
| `gpaw_directmin_etdm_lcao_convert_constraints` | `gpaw.directmin.etdm_lcao.convert_constraints` | `gpaw/directmin/etdm_lcao.py` | `constraints: list, n_dim: int, n_occ: int, representation: str` | `Parses and validates a user-supplied list of orbital constraints for one k-point used by the ETDM LCAO direct-minimization workflow in GPAW. This function accepts the raw constraints as provided by a caller (typically from input files or higher-level code that configures constrained electronic degrees of freedom), expands any single-orbital indices into all orbital pairs that include that orbital, enforces ordering rules for pair indices depending on the chosen representation, validates index ranges against the provided dimensions and occupation counts, and returns a converted list that contains only orbital pairs suitable for downstream constraint enforcement (for example, constraining density-matrix or orbital-matrix elements during constrained minimization).` |
| `gpaw_directmin_sd_etdm_multiply` | `gpaw.directmin.sd_etdm.multiply` | `gpaw/directmin/sd_etdm.py` | `x: dict, const: float = 1.0` | `gpaw.directmin.sd_etdm.multiply scales each value in a dictionary by a scalar and returns a new dictionary containing the scaled values. This utility is used in the GPAW direct minimization (sd_etdm) code path to produce a scaled copy of a state or step vector representation where state vectors or numeric containers are stored as dictionary values keyed by their identifiers. The function implements y[k] = const * x[k] for every key k present in x without mutating the input dictionary x itself.` |
| `gpaw_directmin_functional_lcao_pz_constrain_grad` | `gpaw.directmin.functional.lcao.pz.constrain_grad` | `gpaw/directmin/functional/lcao/pz.py` | `grad: numpy.ndarray, constraints: list, ind_up: tuple` | `constrain_grad zeros components of a gradient vector that correspond to constrained degrees of freedom for LCAO PZ direct minimization used in GPAW DFT calculations. It enforces constraints by setting the matching gradient entries to 0.0 so that optimization steps do not change those degrees of freedom (the code would ideally avoid computing these components in the first place). This function is intended for use in the direct minimization ("directmin") workflow for localized atomic-orbital (LCAO) based functionals in GPAW. In that context, grad is the flattened 1D gradient (for example, derivative of the energy or functional with respect to a list of paired indices), constraints enumerate the specific index pairs to hold fixed during optimization, and ind_up provides the ordered mapping from index-pair tuples to positions in the grad array. The function modifies grad in-place and also returns it for convenience.` |
| `gpaw_directmin_ls_etdm_is_descent_and_approximate_wolfe_conditions` | `gpaw.directmin.ls_etdm.is_descent_and_approximate_wolfe_conditions` | `gpaw/directmin/ls_etdm.py` | `der_phi_0: float, phi_0: float, der_phi_j: float, phi_j: float, eps: float = 1e-06, delta: float = 0.1, sigma: float = 0.9` | `Check whether a trial step simultaneously satisfies a descent test and the approximate Wolfe conditions used in line-search implementations for direct energy minimization (ETDM) in GPAW. This function implements the test described by William W. Hager and Hongchao Zhang (SIAM J. Optim., 16(1), 170-192) and is intended for use inside the line-search routine of the direct-minimization solver (gpaw.directmin.ls_etdm). It combines a call to is_descent(...) for sufficient decrease in the objective (phi) with an inequality check on directional derivatives that enforces the approximate Wolfe conditions (AWC) via the parameters delta and sigma.` |
| `gpaw_directmin_functional_lcao_ks_constrain_grad` | `gpaw.directmin.functional.lcao.ks.constrain_grad` | `gpaw/directmin/functional/lcao/ks.py` | `grad: list, constraints: list, ind_up: tuple` | `gpaw.directmin.functional.lcao.ks.constrain_grad zeros gradient components corresponding to constrained degrees of freedom used in LCAO Kohnâ€“Sham direct minimization in GPAW. This function is used in the direct-minimization functional code path to prevent optimization steps along specified constrained index pairs by setting those gradient components to 0.0, so optimizers (line-search, conjugate-gradient, etc.) do not change the associated degrees of freedom during a DFT/LCAO optimization step.` |
| `gpaw_directmin_tools_array_to_dict` | `gpaw.directmin.tools.array_to_dict` | `gpaw/directmin/tools.py` | `x: numpy.ndarray, dim: list` | `gpaw.directmin.tools.array_to_dict: Convert a concatenated numpy.ndarray into a dictionary of component arrays indexed by integers. This function is used in GPAW's direct minimization utilities (gpaw.directmin.tools) to split a single long solution or parameter vector into separate parts (for example, per-variable coefficient blocks, atom-centered values, or grid function segments) so that routines such as component-wise updates, preconditioning, or line searches can operate on each part independently.` |
| `gpaw_directmin_tools_expm_ed` | `gpaw.directmin.tools.expm_ed` | `gpaw/directmin/tools.py` | `a_mat: numpy.ndarray, evalevec: bool = False` | `Compute the matrix exponential of a square numpy.ndarray using an eigendecomposition of 1j * a_mat. This function is provided in gpaw.directmin.tools and is used in the GPAW DFT code (for example by direct-minimization routines) to form exponentials of matrices that generate unitary or orthogonal updates (typical use case: a_mat is a real antisymmetric generator so that 1j * a_mat is Hermitian and exp(a_mat) is a unitary/orthogonal update). The implementation computes eigenpairs of 1j * a_mat with numpy.linalg.eigh and reconstructs the matrix exponential via the eigenbasis, returning a contiguous numpy array and optionally the eigenvectors and eigenvalues used for the construction.` |
| `gpaw_directmin_etdm_lcao_find_all_pairs` | `gpaw.directmin.etdm_lcao.find_all_pairs` | `gpaw/directmin/etdm_lcao.py` | `ind: int, n_dim: int, n_occ: int, representation: str` | `Creates a list of orbital-index pairs that correspond to the degrees of freedom (orbital-rotation constraints) associated with a given orbital index in the electronic-structure direct energy minimization (ETDM) LCAO workflow used by GPAW. In the GPAW DFT context (see README), the total number of single-particle orbitals is n_dim and the first n_occ of these are treated as occupied; orbital-rotation degrees of freedom connect occupied (o) and unoccupied (v) subspaces and may include rotations within the occupied subspace (oo). This function is used by gpaw.directmin.etdm_lcao to enumerate which index pairs participate in constraints or parametrizations of orbital rotations for a single orbital index ind, given a choice of representation that controls which types of rotations count as degrees of freedom.` |
| `gpaw_directmin_tools_dict_to_array` | `gpaw.directmin.tools.dict_to_array` | `gpaw/directmin/tools.py` | `x: dict` | `Converts a dictionary whose keys are integers into a single one-dimensional NumPy array by appending the values for use in linear-algebra operations in GPAW direct-minimization utilities. This function is intended for assembling separate components (for example, per-atom or per-grid blocks of degrees of freedom used in density-functional theory (DFT) computations implemented in GPAW) into a single contiguous vector suitable for minimization, matrix-vector products, and other numerical linear-algebra routines. It does not modify the input dictionary; it constructs new Python objects and returns a NumPy array whose data buffer is created from the concatenated values.` |
| `gpaw_directmin_tools_gramschmidt_lcao` | `gpaw.directmin.tools.gramschmidt_lcao` | `gpaw/directmin/tools.py` | `C_nM: numpy.ndarray, S_MM: numpy.ndarray` | `Gram-Schmidt orthonormalization for linear-combination-of-atomic-orbitals (LCAO) using a Cholesky decomposition of the projected overlap matrix. This function is used in GPAW's LCAO/direct-minimization context to convert a set of LCAO expansion coefficients into an orthonormal set with respect to the atomic-basis overlap. Concretely, it forms the projected overlap matrix S_nn = C_nM @ S_MM.conj() @ C_nM.T.conj(), performs a lower-triangular Cholesky factorization S_nn = L_nn L_nn^H, and returns X = L_nn^{-1} C_nM. The returned coefficient matrix X satisfies X @ S_MM.conj() @ X.T.conj() = Identity_n within numerical precision, which is required before diagonaliza- tion or other operations that assume an orthonormal set of states.` |
| `gpaw_directmin_tools_d_matrix` | `gpaw.directmin.tools.d_matrix` | `gpaw/directmin/tools.py` | `omega: numpy.ndarray` | `gpaw.directmin.tools.d_matrix: Compute the complex "d-matrix" used in direct-minimization gradient formulas for skew-Hermitian generators. This helper constructs the m-by-m complex matrix u_m whose (i, j) element is 1j*(exp(-1j*(omega_i - omega_j)) - 1)/(omega_i - omega_j), with the diagonal (and any zero-difference) entries set to the analytic limit value 1. The function implements Eq. 40 from A. V. Ivanov et al., Comput. Phys. Commun., 267, 108047 (2021) (arXiv:2101.12597), and is used in GPAW's direct-minimization machinery to assemble factors that appear when computing the gradient of an energy functional with respect to a skew-Hermitian generator (i.e., an anti-Hermitian matrix that parameterizes unitary rotations of electronic states). In practice, omega contains the set of state-dependent scalar parameters (for example phase angles or eigenvalue-like quantities) whose pairwise differences enter these gradient expressions.` |
| `gpaw_directmin_tools_expm_ed_unit_inv` | `gpaw.directmin.tools.expm_ed_unit_inv` | `gpaw/directmin/tools.py` | `a_upp_r: numpy.ndarray, oo_vo_blockonly: bool = False` | `gpaw.directmin.tools.expm_ed_unit_inv computes a unitary matrix by evaluating the matrix exponential formula given in Eq. (6) of J. Hutter, M. Parrinello, and S. Vogel, J. Chem. Phys., 101, 3862 (1994). This routine is used in GPAW's direct-minimization tools to construct occupied/virtual rotation operators (unitary updates) from the block X (called a_upp_r here) that couples occupied and virtual subspaces during wavefunction optimization in density-functional theory (DFT) calculations.` |
| `gpaw_directmin_lcao_etdm_helper_lcao_rotate_subspace` | `gpaw.directmin.lcao.etdm_helper_lcao.rotate_subspace` | `gpaw/directmin/lcao/etdm_helper_lcao.py` | `h_mm: numpy.ndarray, c_nm: numpy.ndarray` | `rotate_subspace selects canonical orbitals for an LCAO subspace by forming the projected (n-by-n) Hamiltonian in the subspace, diagonalizing it, and rotating the input coefficient matrix into the basis of its eigenvectors. This routine is used in the gpaw.directmin.lcao.etdm_helper_lcao workflow to obtain energy-diagonal (canonical) orbitals and their eigenvalues when performing direct minimization or subspace rotations in the LCAO (linear combination of atomic orbitals) representation within GPAW's DFT calculations.` |
| `gpaw_directmin_etdm_lcao_check_indices` | `gpaw.directmin.etdm_lcao.check_indices` | `gpaw/directmin/etdm_lcao.py` | `ind1: int, ind2: int, n_dim: int, n_occ: int, representation: str` | `gpaw.directmin.etdm_lcao.check_indices validates a pair of user-supplied integer indices that specify a constraint between electronic states used by the ETDM (energy-targeted direct minimization) LCAO (linear combination of atomic orbitals) routines in GPAW. The function ensures the indices are distinct and lie in the ranges required by the chosen representation so that downstream direct-minimization code does not attempt illegal array or orbital accesses.` |
| `gpaw_directmin_tools_loewdin_lcao` | `gpaw.directmin.tools.loewdin_lcao` | `gpaw/directmin/tools.py` | `C_nM: numpy.ndarray, S_MM: numpy.ndarray` | `Loewdin-based orthonormalization of LCAO coefficients used in GPAW direct-minimization tools. This function implements the symmetric (Loewdin) orthonormalization for linear-combination-of-atomic-orbitals (LCAO) coefficient matrices that appear in GPAW's direct minimization and LCAO modes. Given a set of LCAO coefficients C_nM and the basis-function overlap matrix S_MM, it constructs a unitary-like transformation that maps the input coefficients to a new set of coefficients that are orthonormal with respect to S_MM. In practical DFT/LCAO workflows this is used to ensure that the resulting orbitals satisfy C_new.conj() @ S_MM @ C_new.T = I (the Kronecker delta), which is required by many numerical algorithms inside GPAW for stable and correct eigenvalue/energy computations. The routine follows these steps (as implemented in the source): 1. Form the Hermitian matrix C^â€  S C = C_nM.conj() @ S_MM @ C_nM.T with shape (n, n), where n is the number of rows in C_nM (typically number of states/orbitals). 2. Diagonalize this Hermitian matrix to obtain eigenvalues ev and eigenvectors U (called S_overlapp in code). 3. Build the inverse square-root in the eigenbasis: U (1/sqrt(ev)) U^â€ . 4. Apply the resulting transformation to the input coefficients: C_new = (U (1/sqrt(ev)) U^â€ ).T @ C_nM, returning an array with the same shape as C_nM and with orthonormality C_new.conj() @ S_MM @ C_new.T = I.` |
| `gpaw_directmin_tools_minimum_cubic_interpol` | `gpaw.directmin.tools.minimum_cubic_interpol` | `gpaw/directmin/tools.py` | `x_0: float, x_1: float, f_0: float, f_1: float, df_0: float, df_1: float` | `gpaw.directmin.tools.minimum_cubic_interpol computes the position of the minimum of a cubic polynomial that interpolates function values and derivatives at the two endpoints of an interval [x_0, x_1]. This function is used in GPAW's direct minimization and line-search utilities to suggest a scalar step length along a search direction by fitting a cubic to the objective (for example, DFT total energy) and its directional derivatives at the interval boundaries. The inputs x_0 and x_1 define the interval in the independent variable (e.g., a line-search parameter or displacement along a geometry-optimization direction). The values f_0 and f_1 are the function values at those endpoints (for example, energies in ASE/GPAW units) and df_0 and df_1 are the corresponding first derivatives with respect to x (for example, directional derivatives of the energy). All inputs are floats and the function returns a float x_min that is the location of the cubic interpolant's minimum constrained to the closed interval [min(x_0, x_1), max(x_0, x_1)]. The routine swaps endpoints internally if x_0 > x_1 so the order of the inputs does not matter. It constructs the unique cubic f(x) = a x^3 + b x^2 + c x + d in the local coordinate measured from x_0 using the standard formulae derived from the two function values and two derivatives. It then inspects the cubic's stationary points by forming the discriminant D = b^2 - 3 a c. If D < 0 there are no real stationary points for the derivative inside the real line and the function returns the endpoint (x_0 or x_1) with the smaller provided function value. If D >= 0 the routine computes one candidate stationary point r0 = (-b + sqrt(D)) / (3 a) + x_0 (the code uses the + root) and accepts r0 as the minimum if r0 lies strictly inside the open interval (x_0, x_1) and the interpolated cubic value at r0 is smaller than both endpoint values; otherwise it returns the endpoint with smaller f. The cubic is evaluated with a helper that expects the local coordinate (r0 - x_0). The function never modifies external state.` |
| `gpaw_doctools_aamath_block` | `gpaw.doctools.aamath.block` | `gpaw/doctools/aamath.py` | `lines: list[str]` | `Find superscript/subscript blocks in a columnar ASCII-art math fragment used by gpaw.doctools.aamath. This function scans a multi-line ASCII representation of a math expression (provided as a list of equally long strings) column by column to detect vertically stacked regions that represent superscripts or subscripts. It is used by the doctools.aamath subsystem of GPAW to locate and extract these stacked blocks so they can be converted (via cut() and parse()) into TeX-like math strings for inclusion in generated documentation or math rendering. The function does not modify the input list; it only reads characters to determine block boundaries and then calls the local cut() and parse() helpers to produce the returned fragments.` |
| `gpaw_directmin_tools_update_constraints_kpt` | `gpaw.directmin.tools.update_constraints_kpt` | `gpaw/directmin/tools.py` | `constraints: list, ind: list` | `gpaw.directmin.tools.update_constraints_kpt updates constraint indices for a single k-point to match a new indexation (for example, after sorting orbitals or reordering wavefunctions). This function is used in the GPAW direct minimization workflow to ensure that constraint references (which select orbitals or states at a given k-point) remain valid after the underlying index order has changed; failing to update these indices would cause constraints to refer to the wrong orbitals and lead to incorrect constrained minimization behavior.` |
| `gpaw_doctools_aamath_autodoc_process_docstring` | `gpaw.doctools.aamath.autodoc_process_docstring` | `gpaw/doctools/aamath.py` | `lines: list` | `gpaw.doctools.aamath.autodoc_process_docstring processes a list of documentation/source lines in-place to detect custom aamath code blocks annotated with a trailing ':::' marker and replace those blocks with Sphinx-compatible math directives. This hook-function is intended for use when building GPAW project documentation with Sphinx: it finds aamath blocks, converts their contents to LaTeX using the local parse(...) function, and inserts the resulting ".. math:: <latex>" directive into the provided lines so that Sphinx will render the math in the generated documentation.` |
| `gpaw_dos_gaussian_dos` | `gpaw.dos.gaussian_dos` | `gpaw/dos.py` | `eig_kn: numpy.ndarray, weight_kn: numpy.ndarray, weight_k: numpy.ndarray, energies: numpy.ndarray, width: float` | `gpaw.dos.gaussian_dos computes a one-dimensional density of states (DOS) on a supplied energy grid by broadening discrete Kohnâ€“Sham eigenvalues with normalized Gaussian functions and summing their weighted contributions across k-points and bands. This function is used in the GPAW DFT workflow to transform discrete eigenvalue spectra (per k-point and band) into a smooth DOS suitable for plotting, integration, and analysis (for example to locate peaks or integrate states around the Fermi level).` |
| `gpaw_eigensolvers_eigensolver_reshape` | `gpaw.eigensolvers.eigensolver.reshape` | `gpaw/eigensolvers/eigensolver.py` | `a_x: numpy.ndarray, shape: tuple` | `gpaw.eigensolvers.eigensolver.reshape: Construct and return a numpy.ndarray of the requested shape by taking elements from a flattened buffer array.` |
| `gpaw_ffbt_rescaled_bessel_limit` | `gpaw.ffbt.rescaled_bessel_limit` | `gpaw/ffbt.py` | `l: int` | `gpaw.ffbt.rescaled_bessel_limit Get the x -> 0 limit of a rescaled spherical Bessel function j_l(x)/x^l used in radial function handling. Calculates the closed-form value of the limit lim_{x->0} j_l(x) / x^l = 2^l * l! / (2*l + 1)! for a given angular momentum quantum number l. In the GPAW DFT codebase this quantity is useful when working with spherical Bessel functions that appear in radial integrals, projector-augmented wave (PAW) components, and plane-wave / atom-centered basis treatments described in the project README: it provides the finite small-argument normalization constant that prevents singular behavior and aids numerical stability when evaluating radial basis functions or expansions near the origin.` |
| `gpaw_ffbt_generate_bessel_coefficients` | `gpaw.ffbt.generate_bessel_coefficients` | `gpaw/ffbt.py` | `lmax: int` | `Generate spherical Bessel function expansion coefficients up to angular momentum lmax. This function computes the complex expansion coefficients c_lm used to express spherical Bessel functions in a polynomial-like expansion. The implementation follows the recurrence relation for spherical Bessel functions (see Marco Vanin, 2008) and uses the closed-form solution implied by that recurrence. In the context of GPAW (a DFT code using the PAW method and real-space / plane-wave representations), these coefficients are used by the gpaw.ffbt module to build Bessel-based expansions required in radial integrals, projector functions, and fast Fourierâ€“Bessel transforms. The returned data structure is organized for direct indexing by angular momentum l and magnetic quantum number m.` |
| `gpaw_external_create_external_potential` | `gpaw.external.create_external_potential` | `gpaw/external.py` | `name: str, **kwargs` | `Construct an external potential instance identified by name and configured with the provided keyword parameters. This function is part of GPAW's external potential framework and is used to create external potentials (for example potentials that will be added to the Kohnâ€“Sham Hamiltonian or represented on real-space grids) from a registry of known potential factories. The registry is the module-level mapping known_potentials; if the registry is empty, this function calls the internal _register_known_potentials() to populate it before construction. The function looks up a factory or constructor by the string key name in known_potentials and calls it with the supplied keyword arguments, returning whatever object that factory produces. Typical usage in GPAW is to call this function when an external potential is described in input data (often parsed into dictionaries) and must be turned into a runtime object used by the calculator.` |
| `gpaw_elph_gpts_obtain_gpts_suggestion` | `gpaw.elph.gpts.obtain_gpts_suggestion` | `gpaw/elph/gpts.py` | `cell_cv: numpy.ndarray, ecut: float, h: float, print_suggestions: bool = False` | `Compare plane-wave (PW) and localized-basis (LCAO) grid-point suggestions and return a conservative (tighter) grid-point setting suitable for use when two separate GPAW calculators must share the same real-space grid (for example in electronâ€“phonon coupling workflows where PW and LCAO modes run separately but need identical gpts=(...) settings). This function is used in GPAW DFT workflows to compute and reconcile the number of real-space grid points ("gpts") required by a PW calculation with cutoff ecut and an LCAO calculation with target maximal grid spacing h, for a simulation cell described by cell_cv. It calls gpaw.elph.gpts.get_number_of_grid_points with PW(ecut) and LCAO() modes to obtain the per-axis integer grid-point counts required by the two modes, and then constructs a recommended grid Nopt_c that is (a) at least as large as the LCAO requirement and (b) the PW requirement rounded to the nearest multiple of 4 (implemented as (Npw_c/4 + 0.5).astype(int) * 4), ensuring compatibility with GPAW internals that prefer multiples of 4 for plane-wave related grids. The result is intended to be used as the gpts=... argument supplied to calculators so that separate PW and LCAO runs use identical real-space grids.` |
| `gpaw_ffbt_ffbt` | `gpaw.ffbt.ffbt` | `gpaw/ffbt.py` | `l: int, f_g: numpy.ndarray, r_g: numpy.ndarray, k_q: numpy.ndarray` | `gpaw.ffbt.ffbt: Fast Fourierâ€“Bessel transform of a radial real-space function f(r) used in GPAW density-functional calculations. This routine computes the radial transform g(k) = k^{l+1} âˆ«_0^{rc} r dr j_l(kr) r f(r) by expanding the spherical Bessel function j_l(x) into a finite polynomial series and evaluating the resulting radial integrals using discrete Fast Fourier Transforms (FFTs). It is intended for transforming radial parts of quantities (for example radial components of wavefunctions, densities, or potentials in spherical coordinates) from a uniform real-space radial grid r_g to a uniform radial reciprocal-space grid k_q; the implementation performs l+1 FFTs on a 2Q-length grid and returns only the Q positive-frequency values corresponding to k_q.` |
| `gpaw_gaunt_gaunt` | `gpaw.gaunt.gaunt` | `gpaw/gaunt.py` | `lmax: int = 2` | `Gaunt coefficients for products of three spherical harmonics used in GPAW's angular integrals and PAW projector coupling.` |
| `gpaw_gaunt_nabla` | `gpaw.gaunt.nabla` | `gpaw/gaunt.py` | `lmax: int = 2` | `Create the array of derivative integrals used by GPAW's Gaunt/spherical-harmonics machinery. This function constructs a 3D array of derivative integrals Y_LLv[L1, L2, v] that are used in GPAW (a DFT code based on the PAW method and ASE) when coupling spherical-harmonic channels and evaluating gradients/derivative coupling terms. The implementation expands the precomputed spherical-harmonic coefficient lists YL (from gpaw.spherical_harmonics) and accumulates contributions of the form n2[v] * c1 * c2 * gam(n0, n1, n2) where n = n1 + n2 with a decrement of the v-th Cartesian exponent in n2. The result is stored in a module-level cache (_nabla) to avoid recomputation for the same lmax. The default lmax is 2 (suitable for low angular-momentum expansions commonly used in PAW projector constructs).` |
| `gpaw_fftw_check_fft_size` | `gpaw.fftw.check_fft_size` | `gpaw/fftw.py` | `n: int, factors: list = [2, 3, 5, 7]` | `Check if an integer grid length n is an efficient FFT size for FFT-based operations. This function is used in GPAW to decide whether a grid dimension length n is suitable for efficient fast Fourier transform (FFT) algorithms (for example the FFTW library) that perform best when the transform length factors into small primes. In the GPAW domain this influences choices of plane-wave / real-space grid dimensions and multigrid operations: a return value of True indicates that n can be reduced to 1 by successive division by the allowed small prime factors (default [2, 3, 5, 7]), and therefore n is likely to give efficient FFT performance.` |
| `gpaw_ffbt_spherical_bessel` | `gpaw.ffbt.spherical_bessel` | `gpaw/ffbt.py` | `l: int, x_g: numpy.ndarray` | `gpaw.ffbt.spherical_bessel computes the spherical Bessel function j_l(x) for a given integer order l and a NumPy array of non-negative radial arguments x_g. This implementation is used in the gpaw.ffbt module for radial/plane-wave integrals and expansions that appear in GPAW density-functional-theory calculations (for example, in radial parts of PAW/projector expansions and Fourierâ€“Bessel transforms). The routine evaluates j_l(x) using the finite expansion j_l(x) = x^{-(l+1)} sum_{m=0}^l Re{ c_lm[l][m] * x^m * exp(-i x) } based on the coefficients c_lm (see Marco Vanin, 2008). The function returns a real-valued NumPy array with the same shape as x_g containing elementwise values of j_l(x).` |
| `gpaw_gaunt_super_gaunt` | `gpaw.gaunt.super_gaunt` | `gpaw/gaunt.py` | `lmax: int = 2` | `super_gaunt computes the contracted (product) Gaunt coefficients needed to express the product of three spherical harmonics as a single spherical-harmonic expansion. In the GPAW/PAW context (density-functional theory, projector-augmented wave method), these coefficients are used when combining angular parts of atomic-like functions (spherical harmonics) that appear in integrals and projections; the function returns the 4-dimensional tensor G_L_L1_L2_L3 defined by the contraction over an intermediate angular-momentum index L' of two Gaunt tensors.` |
| `gpaw_fftw_get_efficient_fft_size` | `gpaw.fftw.get_efficient_fft_size` | `gpaw/fftw.py` | `N: int, n: int = 1, factors: list = [2, 3, 5, 7]` | `Return the smallest efficient FFT size that is greater than or equal to N and divisible by n. This function is used in GPAW to select array/grid sizes for FFT-based operations (for example FFTW transforms used in plane-wave or real-space DFT calculations). An "efficient" size is one that passes the check_fft_size test: its prime-factorization is restricted to the small primes listed in factors (by default [2, 3, 5, 7]), which typically yields good performance in FFT libraries such as FFTW. The returned size is therefore suitable for high-performance FFTs and for distribution constraints that require sizes to be multiples of n (for example MPI domain decomposition or block-alignment requirements in GPAW).` |
| `gpaw_hybrids_parse_name` | `gpaw.hybrids.parse_name` | `gpaw/hybrids/__init__.py` | `name: str` | `Parse known hybrid functional names and return the libxc semi-local functional name and numerical parameters that GPAW uses to configure hybrid-exchange calculations. This function is used in GPAW (a density-functional theory Python package) to map a small set of canonical hybrid functional identifiers to the concrete parameters required by GPAW's hybrid/exact-exchange implementation. The returned values are used when setting up the exchange-correlation treatment in calculations that mix exact (Hartreeâ€“Fock) exchange with a semi-local functional, for example when constructing PBE0, HSE03, HSE06, B3LYP or Yukawa-screened PBE0 hybrids.` |
| `gpaw_hyperfine_delta` | `gpaw.hyperfine.delta` | `gpaw/hyperfine.py` | `r: numpy.ndarray, rT: float` | `Extended delta function used in hyperfine-related real-space operations in GPAW. This function evaluates an analytic, smoothly decaying "extended delta" function defined by the expression 2 / rT / (1 + 2 * r / rT)**2. In the GPAW DFT/hyperfine context this function is used to model a localized contact-like distribution (centered at r = 0) with a finite range controlled by the parameter rT; it is suitable for use on real-space radial grids (numpy arrays) when constructing or analyzing hyperfine coupling terms and other localized operators. The amplitude at r = 0 is 2/rT and the large-r asymptotic decay is proportional to 1/r^2, so rT controls both the spatial extent (range) and the peak magnitude of the distribution. In practical GPAW/ASE workflows the radial distances r are typically expressed in the same length units used elsewhere in the calculation (e.g., Ã… when interacting with ASE structures and outputs).` |
| `gpaw_fulldiag_fulldiag` | `gpaw.fulldiag.fulldiag` | `gpaw/fulldiag.py` | `filename: str, bands: int = None, scalapack: int = 1` | `Set up full Hamiltonian (H) and overlap (S) matrices from a saved GPAW calculation file and compute all or a subset of eigenvalues and eigenvectors using ScaLAPACK. This function is intended for post-processing/analysis in the GPAW density-functional theory (DFT) codebase. It reads a saved calculation contained in a .gpw file, constructs the full H and S matrices from the wavefunction data, calls GPAW's full diagonalization routine to obtain eigenpairs for the requested number of bands, writes a new gpw file containing the computed eigenvectors, and prints an estimate of the maximum dense matrix size and memory footprint for the diagonalization. The function uses the GPAW API and the GPAW parallelization keyword 'band' to request a ScaLAPACK parallel layout for the diagonalization.` |
| `gpaw_hubbard_aoom` | `gpaw.hubbard.aoom` | `gpaw/hubbard.py` | `D_ii: numpy.ndarray, l: int, l_j: List[int], n_j: List[int], N0_q: numpy.ndarray, scale: bool = True` | `gpaw.hubbard.aoom returns the atomic orbital occupation matrix (aoom) for a specified angular momentum quantum number l and a companion scaling matrix used in GPAW's DFT+U Hubbard correction. The function selects the block(s) of the full partial-wave density matrix D_ii that correspond to the specified l, combines these block(s) according to radial inner products of bounded and unbounded partial waves, and returns the resulting orbital occupation submatrix N_mm together with a dHU_ii matrix that contains the scaling factors placed in the corresponding sub-block positions of the full matrix. In GPAW and DFT+U calculations this aoom (N_mm) is used to compute orbital occupations for the Hubbard energy and to build the Hubbard potential, while dHU_ii encodes the same radial scaling factors in the full partial-wave index space for later use when assembling the DFT+U correction.` |
| `gpaw_dos_linear_tetrahedron_dos` | `gpaw.dos.linear_tetrahedron_dos` | `gpaw/dos.py` | `eig_kn: numpy.ndarray, weight_kn: numpy.ndarray, energies: numpy.ndarray, cell: numpy.ndarray, size: tuple, bz2ibz_map: numpy.ndarray = None` | `Linear-tetrahedron density-of-states (DOS) evaluator used in GPAW DFT post-processing. This function computes the electronic density of states (DOS) on a supplied energy grid using the linear tetrahedron integration (LTI) method over a k-point grid defined by `size` and `cell`. It is intended for use with eigenvalue data produced by GPAW or compatible DFT calculations: `eig_kn` contains eigenvalues for k-points and bands, `weight_kn` contains optional k-point weights, and `energies` is the energy grid where the DOS is evaluated. The implementation reshapes flattened eigenvalue/weight arrays to match the k-point grid dimensions, optionally remaps data from a full Brillouin-zone ordering to an irreducible-zone ordering using `bz2ibz_map`, and then calls the underlying LTI routine `lti(cell, eig_kn, energies, weight_kn)` to produce the DOS. This function performs no I/O and returns the DOS array for further analysis (for example, plotting or integrating to obtain number of states).` |
| `gpaw_hybrids_eigenvalues_idle` | `gpaw.hybrids.eigenvalues.idle` | `gpaw/hybrids/eigenvalues.py` | `n: int, s: int` | `Idle fraction for packing eigenvalues into fixed-size blocks used by gpaw.hybrids.eigenvalues.layout(). Computes the fraction of unused ("idle") slots when n discrete items (for example, eigenvalues or bands in a GPAW DFT calculation) are arranged into b contiguous blocks of size s. The function is a small, pure helper used by the layout() function in the hybrids.eigenvalues module to quantify packing inefficiency when distributing eigenvalue-related data structures into blocks of length s for parallelization or memory layout purposes in GPAW (a DFT code). Internally, b is computed as the integer ceiling of n / s using b = (n + s - 1) // s, and the idle fraction is returned as 1 - n / (b * s).` |
| `gpaw_hyperfine_expand` | `gpaw.hyperfine.expand` | `gpaw/hyperfine.py` | `D_ii: numpy.ndarray, l_j: List[int], l: int` | `Get expansion coefficients of a block-structured matrix in a spherical-harmonic multipole basis used for hyperfine/atomic-projector couplings in GPAW. This function is used inside the gpaw.hyperfine code path to transform a two-dimensional, block-partitioned matrix D_ii (for example a matrix of projector overlaps or density-matrix blocks arranged by angular-momentum channels) into multipole components labelled by the target angular momentum l. The operation contracts each (2*l1+1) x (2*l2+1) block of D_ii corresponding to pairs of angular-momentum channels l1, l2 (given in l_j) with the corresponding Gaunt coupling coefficients to produce coefficients D_mjj for the 2*l+1 magnetic components m of the multipole l. In GPAW this expansion is relevant for evaluating hyperfine interactions and other quantities that couple pairs of spherical harmonics to a definite multipole order.` |
| `gpaw_hybrids_paw_python_pawexxvv` | `gpaw.hybrids.paw.python_pawexxvv` | `gpaw/hybrids/paw.py` | `M_pp: numpy.ndarray, D_ii: numpy.ndarray` | `gpaw.hybrids.paw.python_pawexxvv: Compute the PAW (projector-augmented wave) correction matrix for valence-valence exact-exchange (EXX) energy used in GPAW hybrid functional routines. This function builds a valence-space potential-like matrix V_ii by contracting a packed-pair interaction matrix M_pp with a valence density matrix D_ii using the packed_index(i, j, ni) mapping that is used elsewhere in the gpaw.hybrids.paw implementation.` |
| `gpaw_gpu_as_xp` | `gpaw.gpu.as_xp` | `gpaw/gpu/__init__.py` | `array: numpy.ndarray, xp: numpy.ndarray` | `Transfer an array between CPU (NumPy) and GPU (CuPy) backends for use in GPAW's numerical kernels. This function is used in the GPAW DFT code to ensure that numerical data structures (for example real-space grid arrays that represent wavefunctions, electron density, potentials, or basis coefficients used by plane-wave, atom-centered or real-space multigrid methods) reside on the requested device before being passed to device-specific computational kernels. The routine will either return the array unchanged (if already on the requested backend) or perform an explicit device/host transfer using CuPy conversion helpers. Transfers allocate memory on the destination device and copy data between host and device, which may be expensive; CuPy must be available for GPU transfers.` |
| `gpaw_ibz2bz_get_phase_shifted_overlap_coefficients` | `gpaw.ibz2bz.get_phase_shifted_overlap_coefficients` | `gpaw/ibz2bz.py` | `dO_aii: dict, spos_ac: numpy.ndarray, K_c: numpy.ndarray` | `gpaw.ibz2bz.get_phase_shifted_overlap_coefficients applies a Bloch-phase shift to per-atom overlap coefficients. This function is used in GPAW (a DFT/PAW code) when transforming or assembling overlap coefficients that are defined per atom for a single k-point in the irreducible Brillouin zone into their phase-shifted form appropriate for a given scaled wave vector K_c (for example when expanding quantities from the IBZ to the full Brillouin zone). For each atomic index a present in dO_aii, the function multiplies the stored overlap coefficients by the complex Bloch phase factor exp(2j * pi * (K_c Â· R_a)), where R_a is the scaled atomic position spos_ac[a] and K_c is the input scaled wave vector. The operation preserves the keys of the input dictionary and does not modify dO_aii in-place; a new dictionary is returned.` |
| `gpaw_inducedfield_inducedfield_base_zero_pad` | `gpaw.inducedfield.inducedfield_base.zero_pad` | `gpaw/inducedfield/inducedfield_base.py` | `a: numpy.ndarray` | `Add a one-cell zero padding on both sides of the last three axes of a numpy.ndarray. This function is intended for use in GPAW induced-field and real-space grid code paths (for example when preparing arrays for finite-difference stencils, multigrid operations, or FFTs in induced-field calculations) where a one-cell layer of zeros ("ghost" or padding cells) is required on each side of the three spatial axes. The function returns a newly allocated array; the input is not modified. Not parallel safe: it performs a full local allocation/copy and does not coordinate padding across distributed (MPI) decompositions.` |
| `gpaw_gauss_I` | `gpaw.gauss.I` | `gpaw/gauss.py` | `R: list, a: tuple, b: tuple, alpha: float, beta: float` | `Calculate the 3D integral of a product of two Gaussian functions multiplied by Cartesian monomials, and return that integral together with its Cartesian derivatives with respect to the displacement vector R. This function is used in GPAW's Gaussian integral utilities (gpaw.gauss) to evaluate integrals that appear when forming overlap, moment, and projector matrix elements in the PAW/DFT context. Concretely, it computes the integral value = âˆ« x^(a0+b0) y^(a1+b1) z^(a2+b2) exp(-alpha * r^2) exp(-beta * \|r - R\|^2) dr over all space (r âˆˆ â„^3), and returns the integral value together with the partial derivatives of that integral with respect to the Cartesian components of the vector R (âˆ‚/âˆ‚Rx, âˆ‚/âˆ‚Ry, âˆ‚/âˆ‚Rz). The implementation evaluates the integral by calling the internal helper I1 and uses standard recurrence relations (raising and lowering of Cartesian polynomial exponents) to form the derivatives efficiently.` |
| `gpaw_hgh_parse_local_part` | `gpaw.hgh.parse_local_part` | `gpaw/hgh.py` | `string: str` | `Parse a whitespace-separated description of the local part of an HGH (Hartwigsenâ€“Goedeckerâ€“Hutter) pseudopotential and return the parsed components needed to initialize an HGHParameterSet in GPAW. This function is used in the GPAW DFT codebase when reading or constructing HGH pseudopotential parameter sets. It tokenizes the input string with str.split(), interprets the first token as a symbol (optionally containing a suffix after a '.' which is ignored for chemical identity), looks up the atomic number from the module-level atomic_numbers mapping, and parses the subsequent tokens as the number of valence electrons, the local radius parameter, and any remaining floating-point coefficients for the local potential. The returned values are suitable for creating or initializing the local part of an HGHParameterSet object elsewhere in the codebase.` |
| `gpaw_kpt_descriptor_to1bz` | `gpaw.kpt_descriptor.to1bz` | `gpaw/kpt_descriptor.py` | `bzk_kc: numpy.ndarray, cell_cv: numpy.ndarray` | `Wrap k-points to the first Brillouin zone (1. BZ) used by GPAW. This function is used in GPAW to map a set of k-points given in units of the reciprocal-lattice basis vectors to their nearest images inside the first Brillouin zone. It is intended for k-point handling in density-functional-theory workflows where k-points are represented as coordinates relative to the reciprocal lattice vectors derived from the real-space unit cell (cell_cv). The routine computes the Cartesian reciprocal vectors from cell_cv, evaluates the distances to the 27 nearest reciprocal-lattice images (integer shifts in {-1,0,1} along each reciprocal axis), and subtracts the integer shift that places each input k-point closest to the origin image. To avoid nondeterministic choice when distances are nearly equal, differences between the shortest distances are rounded to 6 decimal places and the lowest-index image is chosen.` |
| `gpaw_lcao_local_orbitals_get_plane_dirs` | `gpaw.lcao.local_orbitals.get_plane_dirs` | `gpaw/lcao/local_orbitals.py` | `plane: str` | `Get normal and in-plane directions for a plane identifier used in GPAW's local-orbital and plane-related utilities.` |
| `gpaw_lcao_generate_ngto_augmented_read_gaussian_basis_file` | `gpaw.lcao.generate_ngto_augmented.read_gaussian_basis_file` | `gpaw/lcao/generate_ngto_augmented.py` | `fname: str` | `gpaw.lcao.generate_ngto_augmented.read_gaussian_basis_file reads a Gaussian basis set file and returns the first element/atom entry found in the file together with a textual description and a list of contracted Gaussian-type orbital (CGTO) dictionaries suitable for use in GPAW's LCAO/NGTO augmentation workflow. This function is used in the gpaw.lcao.generate_ngto_augmented pipeline to import atom-centered Gaussian basis definitions (common in quantum chemistry basis set libraries) and convert them into the internal CGTO representation consumed by GPAW for density-functional theory (DFT) calculations that use atom-centered basis functions.` |
| `gpaw_kpt_refine_get_reduced_monkhorst` | `gpaw.kpt_refine.get_reduced_monkhorst` | `gpaw/kpt_refine.py` | `size: tuple, N_c: int` | `Find a Monkhorst-Pack k-point grid for a refined reciprocal-space grid and shrink it to the reciprocal-space volume of a single original k-point cell. This function is used in k-point refinement and folding workflows within GPAW (a DFT code using plane-waves/real-space grids) to generate the Monkhorst-Pack sampling for a refined grid specified by size and then scale (shrink) those k-point coordinates so they lie inside the volume corresponding to one original coarse k-point. It calls monkhorst_pack(size) to produce the refined-grid k-point coordinates and returns those coordinates divided by N_c so that the refined mesh is represented within a single original k-point cell. This is useful when mapping refined k-point sampling onto the Brillouin-zone volume of a coarse k-point for tasks such as supercell unfolding, k-point folding, or constructing reduced k-point sets for symmetry/reduction.` |
| `gpaw_kpt_refine_get_fine_bzkpts` | `gpaw.kpt_refine.get_fine_bzkpts` | `gpaw/kpt_refine.py` | `center_ic: numpy.ndarray, size: numpy.ndarray, bzk_coarse_kc: numpy.ndarray, kwargs: dict` | `Return list of reducible refined k-points and the indexes of the selected coarse-grid points that serve as refinement centers, for use in k-point refinement in GPAW (DFT/PAW code). This function implements the practical procedure used in GPAW to refine a Monkhorstâ€“Pack coarse k-point grid by replacing, for a number of neighbour "shells" around specified coarse-grid centers, each coarse point by a small reduced Monkhorstâ€“Pack patch. The output is suitable for subsequent integrations or symmetry-reduced k-point sums in plane-wave or real-space calculations performed by GPAW.` |
| `gpaw_kpt_refine_construct_neighbours_by_shells` | `gpaw.kpt_refine.construct_neighbours_by_shells` | `gpaw/kpt_refine.py` | `nshells: int, N_c: numpy.ndarray` | `gpaw.kpt_refine.construct_neighbours_by_shells constructs a grouped list of neighbour translation vectors arranged in concentric "shells" around the center point. This function is used in GPAW's k-point refinement utilities to generate the fractional translations (relative to a discrete grid N_c) for points at increasing shell indices; each shell contains the grid points whose maximum absolute component equals the shell index, so shells form cube-like layers around the center in grid-index space.` |
| `gpaw_lcao_tools_collect_orbitals` | `gpaw.lcao.tools.collect_orbitals` | `gpaw/lcao/tools.py` | `a_xo: numpy.ndarray, coords: list, root: int = 0` | `Collect array data distributed over the orbital axis (last axis) from all MPI ranks to a single root CPU. This function is used in GPAW's LCAO tooling to gather orbital-related arrays that are distributed across MPI processes. In typical GPAW DFT workflows the orbital coefficients or orbital-dependent data are split so that the last axis of a per-rank array corresponds to a subset of orbitals owned by that rank. collect_orbitals gathers those per-rank pieces and assembles a full array on the designated root CPU for purposes such as writing orbitals to disk, performing serial postprocessing, or diagnostics. The function preserves the input dtype and produces an array whose leading dimensions match the input except that the final axis equals the total number of orbitals given by sum(coords). The function relies on a global MPI-like communicator object named world that provides size, rank, ssend and receive; it uses synchronous sends (tag 112) and explicit receives on the root.` |
| `gpaw_lcao_tools_basis_subset2` | `gpaw.lcao.tools.basis_subset2` | `gpaw/lcao/tools.py` | `symbols: list, largebasis: str = "dzp", smallbasis: str = "sz"` | `gpaw.lcao.tools.basis_subset2 returns a boolean mask selecting basis functions when reducing an LCAO (linear combination of atomic orbitals) basis set for an entire list of atoms. This function is used in GPAW DFT workflows to generate a per-basis-function selection mask that maps a larger, more complete atomic basis (for example, 'dzp' double-zeta-polarized) to a smaller basis (for example, 'sz' single-zeta) for all atoms in a calculation. The mask can be applied to packed LCAO coefficient vectors or basis-function arrays to truncate or test reduced-basis representations for performance or analysis.` |
| `gpaw_lcao_tools_basis_subset` | `gpaw.lcao.tools.basis_subset` | `gpaw/lcao/tools.py` | `symbol: str, largebasis: str, smallbasis: str` | `gpaw.lcao.tools.basis_subset: Determine which basis-function indices in a larger atom-centered LCAO basis are present in a smaller basis for the same atomic symbol. This helper is used in the GPAW LCAO tooling to create a boolean mask that selects orbitals belonging to the smaller basis out of the larger basis representation so matrices (overlap, Hamiltonian, density) defined on the large basis can be restricted or sliced to the smaller basis. This function looks up basis descriptions with Basis.find(symbol, basisname) and extracts counts of radial (zeta) and polarization (pol) functions using zeta_pol(basis). The code and ordering convention used here (as in the LCAO implementation in GPAW) assume that the Basis object arranges atomic orbitals such that the first zeta entries are the radial (single-particle) functions followed immediately by polarization functions. The returned boolean mask has length equal to the number of atomic orbitals in the large basis (blarge.nao) and is True exactly for those indices that correspond to orbitals present in smallbasis.` |
| `gpaw_lcaotddft_magneticmomentwriter_parse_header` | `gpaw.lcaotddft.magneticmomentwriter.parse_header` | `gpaw/lcaotddft/magneticmomentwriter.py` | `line: str` | `gpaw.lcaotddft.magneticmomentwriter.parse_header parses a single header line that encodes the name, numeric version, and JSON keyword arguments for a writer used in the gpaw.lcaotddft.magnetic-moment writer subsystem. The function extracts these three pieces of information and returns them as a tuple (name, version, kwargs) for downstream use when reconstructing or selecting the appropriate writer implementation in GPAW's real-space/time-dependent DFT workflows. The expected header format is exactly: NameOfWriter[version=1](**{"arg1": "abc", ...}) where NameOfWriter is an identifier matching Python word characters, version is a non-negative integer, and the argument map is a JSON object literal (the literal appears after the literal characters '(**' and before the final ')'). This format is used by the gpaw.lcaotddft.magneticmomentwriter module to serialize writer selection and configuration in text output or checkpoint files.` |
| `gpaw_lcaotddft_qed_forward_finite_difference` | `gpaw.lcaotddft.qed.forward_finite_difference` | `gpaw/lcaotddft/qed.py` | `coefficients: list[int], data_tx: numpy.ndarray` | `gpaw.lcaotddft.qed.forward_finite_difference computes a forward finite-difference linear combination along the first axis (time axis) of a time-dependent data array using an explicit integer coefficient stencil.` |
| `gpaw_lcaotddft_qed_calculate_third_derivative` | `gpaw.lcaotddft.qed.calculate_third_derivative` | `gpaw/lcaotddft/qed.py` | `timestep: float, data_tx: numpy.ndarray` | `gpaw.lcaotddft.qed.calculate_third_derivative calculates the third time derivative of time-dependent data using a forward finite-difference stencil and returns an array with the same shape as the input data_tx. This function is used in the GPAW LCAO TDDFT QED context to obtain the third temporal derivative of time-series quantities (axis 0 is time), where timestep is the uniform time increment used during time propagation.` |
| `gpaw_lcaotddft_qed_calculate_first_derivative` | `gpaw.lcaotddft.qed.calculate_first_derivative` | `gpaw/lcaotddft/qed.py` | `timestep: float, data_tx: numpy.ndarray` | `Calculate the first time derivative of time-dependent data using a first-order forward finite difference. This function is used in the LCAO-TDDFT QED parts of GPAW to obtain time derivatives of time-dependent quantities (for example dipole moments, densities, or density-matrix elements) during real-time propagation or analysis of time-series output. It computes the forward first-order finite-difference approximation (coefficients [-1, 1]) so that the discrete derivative at time t is approximated by (f(t+dt) - f(t)) / dt. To preserve the original array shape along the time axis, the implementation repeats the last-time sample as required by the underlying forward_finite_difference routine; this ensures the returned array has the same shape as data_tx and can be used directly in subsequent GPAW time-stepping or post-processing code.` |
| `gpaw_lrtddft_apmb_sqrt_matrix` | `gpaw.lrtddft.apmb.sqrt_matrix` | `gpaw/lrtddft/apmb.py` | `a: numpy.ndarray, preserve: bool = False` | `Get the symmetric matrix square root of a (diagonalization is used). This function is intended for use in GPAW's linear-response / TDDFT code paths (gpaw.lrtddft.apmb) where square roots of symmetric matrices (e.g. overlap, density, or response matrices that arise in DFT/PAW calculations) are required. The operation performed is sqrt(a) = Z * sqrt(D) * Z^T where a = Z * D * Z^T is the eigen-decomposition computed with a Hermitian eigensolver. If preserve is False the result overwrites the input array a in-place for memory efficiency; if preserve is True the input is copied and left unchanged.` |
| `gpaw_lrtddft_dielectric_get_dielectric` | `gpaw.lrtddft.dielectric.get_dielectric` | `gpaw/lrtddft/dielectric.py` | `exlist: list, volume: float, emin: float = 0, emax: float = None, de: float = None, energyunit: str = "eV", width: float = 0.08, comment: str = None, form: str = "v"` | `Evaluate the macroscopic dielectric function from a list of electronic excitations produced by GPAW's linear-response routines.` |
| `gpaw_lrtddft_spectrum_rotatory_spectrum` | `gpaw.lrtddft.spectrum.rotatory_spectrum` | `gpaw/lrtddft/spectrum.py` | `exlist: list = None, filename: str = None, emin: float = None, emax: float = None, de: float = None, energyunit: str = "eV", folding: str = "Gauss", width: float = 0.08, comment: str = None` | `gpaw.lrtddft.spectrum.rotatory_spectrum writes a folded rotatory spectrum produced by linear-response time-dependent density-functional theory (TD-DFT) calculations performed with GPAW. The function takes a list of excitation objects (produced by GPAW linear-response routines), extracts excitation energies and rotatory strengths, optionally converts energy units to wavelength (nm), applies a spectral folding/broadening kernel (Gaussian or Lorentzian) to produce a continuous spectrum on an energy (or wavelength) grid, and writes a two-column text output (energy or wavelength and rotatory strength) either to a file or to standard output. The output includes a header identifying the spectrum type, the GPAW version, the folding and width used (if any), and the column units ("om [energyunit]" and "R [cgs]"). The function is used in the GPAW DFT/TD-DFT workflow to produce rotatory (optical activity) spectra from discrete excitation results: exlist should contain excitation objects that implement get_energy() and get_rotatory_strength(), where get_energy() returns excitation energy in atomic units (Hartree) as produced by GPAW linear-response solvers, and get_rotatory_strength() returns rotatory strength in cgs units consistent with the output header. Energies are converted to electronvolts (eV) by multiplying by the module-level Hartree conversion factor, and if energyunit is 'nm' energies are converted to wavelength (nanometers) using fundamental constants. If folding is provided (default 'Gauss'), the function constructs a Folder(width, folding) and calls its fold(x, y, de, emin, emax) method to obtain a sampled spectrum; if folding is None, the function writes the raw discrete energies and rotatory strengths. Behavior and side effects: - If filename is provided, the function opens that file for writing and writes the header and spectrum lines; if filename is None the function writes the same output to sys.stdout. If comment is provided it is written as an initial commented line. - The function prints a header that includes the folding method and width (with the energyunit) and the GPAW version string obtained from the module-level variable version. - The numeric output format is two whitespace-separated columns per line: energy (formatted with 10.5f) and rotatory strength (formatted with 12.7e). - The function does not return a value; its primary effect is to write the spectrum to the chosen output stream or file. Failure modes and error conditions: - energyunit must be exactly 'eV' (default) or 'nm'. Any other value causes a RuntimeError('currently only eV and nm are supported'). - exlist must be an iterable list of excitation objects. If exlist is None or not iterable, a TypeError or similar iteration error will occur. If any excitation object does not implement get_energy() or get_rotatory_strength(), an AttributeError will be raised. - I/O errors can occur when opening or writing to the given filename (e.g., permission or filesystem errors). - Errors raised by the Folder(width, folding).fold(...) call (for example due to invalid folding string, incompatible width, or missing/invalid de/emin/emax) will propagate from that routine. - The function assumes get_energy() returns energies in Hartree atomic units (so multiplication by the module-level Hartree constant yields energies in eV) and that get_rotatory_strength() returns rotatory strengths in cgs units consistent with the header.` |
| `gpaw_matrix_suggest_blocking` | `gpaw.matrix.suggest_blocking` | `gpaw/matrix.py` | `N: int, ncpus: int` | `Suggest blocking of an NxN matrix for distributed linear algebra in GPAW. This function is used inside GPAW (a DFT code that supports parallel calculations via MPI and ScaLAPACK) to choose a processor grid and a block size for distributing an NxN dense matrix across ncpus MPI ranks. The returned values (nprow, npcol, blocksize) are intended for use with ScaLAPACK-style block-cyclic distribution: nprow and npcol define the 2D process grid (rows and columns of MPI processes) and blocksize is the linear block dimension used to partition the matrix. The heuristic aims to make the processor grid as square as possible (minimizing imbalance between nprow and npcol), to guarantee at least one whole block per process dimension and at least two blocks in total, and to choose a power-of-two block size (for performance and compatibility), capped at 64.` |
| `gpaw_lrtddft2_tools_isocubes` | `gpaw.lrtddft2.tools.isocubes` | `gpaw/lrtddft2/tools.py` | `filename: str, isoval: float, scale: float` | `gpaw.lrtddft2.tools.isocubes converts a plain-text volumetric grid file produced by GPAW-related workflows into three 2D projection PNG images (XY, XZ, YZ) that visualize positive and negative isosurface contributions on orthogonal planes. This function is intended for use in the lrtddft2 tools of the GPAW package to create simple visual summaries of scalar fields (for example, charge density differences or response densities computed on a real-space grid) by projecting values that exceed a threshold magnitude and mapping them to RGB pixels using a small built-in color scheme. The function expects a specific plain-text grid layout produced by some GPAW tools: the first two lines are ignored, the third line begins with an integer number of atoms, the next three lines begin with the integer grid dimensions nx, ny, nz (each line may contain extra values that are ignored by this routine), followed by natom lines (which are skipped), and then nx*ny*nz lines each containing a single floating-point scalar value. The value ordering read in the nested loops is x outermost, y middle, z innermost: z varies fastest in the file. For each grid point the routine compares the floating value against the threshold isoval and accumulates projected contributions onto the XY, XZ and YZ planes. The accumulated projections are scaled, clamped, converted to 8-bit RGB triples and written to three PNG files named filename + '_iso_xy.png', filename + '_iso_xz.png' and filename + '_iso_yz.png'. The function requires the Python Imaging Library (PIL / Pillow) Image module to be importable as Image.` |
| `gpaw_lrtddft_spectrum_spectrum` | `gpaw.lrtddft.spectrum.spectrum` | `gpaw/lrtddft/spectrum.py` | `exlist: list = None, filename: str = None, emin: float = None, emax: float = None, de: float = None, energyunit: str = "eV", folding: str = "Gauss", width: float = 0.08, comment: str = None, form: str = "r"` | `Write out a folded photoabsorption spectrum computed by linear-response time-dependent DFT (TD-DFT) and save it to a file or STDOUT. This function is used in the GPAW code base to produce a 1D spectrum from an excitation list produced by a TD-DFT calculation (ExcitationList), fold the discrete transitions with a chosen broadening function (Gaussian or Lorentzian) into a continuous spectrum, and write a human- and machine-readable text file containing a header and five columns: energy (in the chosen energy unit), total oscillator strength density and the three Cartesian components. The output can be used for analysis, plotting, or comparison with experiment; the function itself does not perform the TD-DFT calculation but relies on the provided excitation data and the helper get_folded_spectrum to compute the folded spectrum.` |
| `gpaw_lcao_tools_lead_kspace2realspace` | `gpaw.lcao.tools.lead_kspace2realspace` | `gpaw/lcao/tools.py` | `h_skmm: numpy.ndarray, s_kmm: numpy.ndarray, bzk_kc: numpy.ndarray, weight_k: numpy.ndarray, direction: str = "x", symmetry: dict = {'point_group': False}` | `Convert a k-dependent lead Hamiltonian and overlap matrices (provided in reciprocal space) into a real-space tight-binding representation suitable for transport calculations. This function is part of GPAW's LCAO (linear combination of atomic orbitals) tools and is used when building lead Hamiltonians for density-functional-theory based quantum transport: for each transverse k-point it produces a real-space tight-binding Hamiltonian of doubled size that represents two principal layers plus the coupling between them, preserving the original complex dtype and k-point weighting used in GPAW calculations.` |
| `gpaw_lrtddft_spectrum_get_folded_spectrum` | `gpaw.lrtddft.spectrum.get_folded_spectrum` | `gpaw/lrtddft/spectrum.py` | `exlist: list = None, emin: float = None, emax: float = None, de: float = None, energyunit: str = "eV", folding: str = "Gauss", width: float = 0.08, form: str = "r"` | `Return a folded (convoluted) spectrum computed from a list of linear-response excitations. This function is used in the GPAW linear-response TDDFT (lrtddft) context to convert a list of excitation objects (each providing an excitation energy and an oscillator strength) into a spectrum suitable for comparison with experiment or plotting. It extracts excitation energies from each excitation object using ex.get_energy(), converts those energies to the requested unit (default 'eV'), extracts oscillator strengths using ex.get_oscillator_strength(form), and either returns the raw (energy, intensity) pairs or convolves them with a spectral kernel (folding) using Folder(width, folding).fold(...). The convolution (folding) produces a continuous spectrum on a specified energy/wavelength grid and is commonly used to simulate finite experimental broadening (e.g., Gaussian or Lorentzian line shapes).` |
| `gpaw_mpi_run` | `gpaw.mpi.run` | `gpaw/mpi.py` | `iterators: list` | `Run through list of iterators one step at a time. This function is a small synchronization helper used in GPAW (a DFT code that supports MPI parallelism) to advance multiple iterator-like objects in lockstep. In GPAW workflows it can be used to drive multiple per-process or per-task generators (for example, work queues, streaming results, or synchronized producers) so that each call to next() on every iterator corresponds to the same logical step across the collection. The function consumes (advances) the supplied iterator objects and returns the last complete set of values produced by all iterators when the iteration stops.` |
| `gpaw_new_gpw_as_single_precision` | `gpaw.new.gpw.as_single_precision` | `gpaw/new/gpw.py` | `array: numpy.ndarray` | `gpaw.new.gpw.as_single_precision converts a NumPy array holding 64-bit real or complex floating-point numbers into a newly allocated NumPy array using 32-bit single-precision storage. This function is used in the GPAW DFT codebase to reduce memory footprint and communication volume (e.g., in MPI-parallel calculations) by casting double-precision arrays (numpy.float64 or numpy.complex128) to the corresponding single-precision types (numpy.float32 or numpy.complex64) while preserving array shape and numeric values to the extent representable in single precision.` |
| `gpaw_new_gpw_as_double_precision` | `gpaw.new.gpw.as_double_precision` | `gpaw/new/gpw.py` | `array: numpy.ndarray` | `Convert an array of 32-bit floating-point numbers to 64-bit (double) precision for use in GPAW numerical routines. This utility is used in the GPAW DFT codebase to promote single-precision numeric arraysâ€”such as wavefunction coefficients, densities, potentials, or other real/complex arrays used in Hamiltonian and multigrid operationsâ€”to double precision before performing calculations that require higher numerical accuracy and stability. The function preserves the numeric values while returning a new NumPy array with the promoted dtype. If a None value is passed (commonly used to denote the absence of data in calling code), None is returned unchanged.` |
| `gpaw_lrtddft_spectrum_polarizability` | `gpaw.lrtddft.spectrum.polarizability` | `gpaw/lrtddft/spectrum.py` | `exlist: list, omega: numpy.ndarray, form: str = "v", tensor: bool = False, index: int = 0` | `Evaluate the frequency-dependent polarizability tensor or its projected components using a sum-over-states representation produced by a linear-response TDDFT ExcitationList from GPAW. This function is used in the gpaw.lrtddft.spectrum module to convert an ExcitationList (collection of excited-state transition objects computed by GPAW linear-response TDDFT) into a complex polarizability as a function of photon energy omega. The result can be used to build optical spectra (absorption, dielectric response) or to extract static and frequency-dependent polarizabilities. The implementation performs the sum-over-states alpha(omega) = sum_ex F_ex / ((E_ex * Hartree)^2 - omega^2) and multiplies by Bohr**2 * Hartree to yield the units reported below. Use this function when you have an ExcitationList where each excitation object exposes an energy attribute (exc.energy, in atomic units of Hartree) and methods get_oscillator_strength(form) and get_dipole_tensor(form) that return oscillator strengths and dipole tensors in the expected form.` |
| `gpaw_matrix_matrix_matrix_multiply` | `gpaw.matrix.matrix_matrix_multiply` | `gpaw/matrix.py` | `alpha: float, a: numpy.ndarray, opa: str, b: numpy.ndarray, opb: str, beta: float = 0.0, c: numpy.ndarray = None, symmetric: bool = False` | `matrix-matrix multiplication wrapper that follows BLAS conventions and is used throughout GPAW for dense linear algebra operations (for example, forming products of Hamiltonian, overlap, and density matrices during DFT/PAW calculations). This function dispatches to the appropriate BLAS routine (dgemm, zgemm, dsyrk, zherk, dsyr2k, zher2k) or PBLAS equivalents for distributed matrices to provide high-performance, possibly parallel, implementations of the operation. This routine multiplies matrices a and b with optional transposition or conjugate-transposition controlled by opa and opb, scales the product by the real scalar alpha, adds beta times c, and returns the resulting matrix. alpha and beta are real scalars (type float) even when the matrix elements are complex; a, b and c must all have the same element type (all real or all complex) and compatible shapes for the requested operations. Use symmetric=True when the mathematical result is known to be symmetric/hermitian so that only the lower triangle of c is computed and written (this can reduce work and communicate less data for distributed matrices).` |
| `gpaw_new_brillouin_ranks` | `gpaw.new.brillouin.ranks` | `gpaw/new/brillouin.py` | `N: int, K: int` | `gpaw.new.brillouin.ranks computes a deterministic mapping from k-point indices to MPI rank indices for parallel k-point distribution used in GPAW's Brillouin-zone (k-point) parallelization logic. This function is used by the gpaw.new.brillouin module to assign each of K k-points to one of N MPI ranks so that the k-point workload is distributed as evenly as possible across ranks in density-functional theory (DFT) calculations.` |
| `gpaw_new_zips` | `gpaw.new.zips` | `gpaw/new/__init__.py` | `*iterables, strict: bool = True` | `gpaw.new.zips returns a generator that yields tuples of items taken in lockstep from each of the provided input iterables, following the behavior specified in PEP 618. It is intended for use in GPAW workflows (DFT calculations, geometry and property loops, parallel processing helpers) where multiple sequences (for example atom positions and corresponding forces, arrays of k-points and weights, or parallel chunk descriptors) must be advanced together and strict length agreement between those sequences is required by default.` |
| `gpaw_new_lcao_forces_add_den_mat_paw_term` | `gpaw.new.lcao.forces.add_den_mat_paw_term` | `gpaw/new/lcao/forces.py` | `b: int, dO_ii: numpy.ndarray, P_Mi: numpy.ndarray, dPdR_vMi: numpy.ndarray, erhoT_MM: numpy.ndarray, indices: list, F_av: numpy.ndarray, my_row_range: tuple` | `gpaw.new.lcao.forces.add_den_mat_paw_term: Calculate and add the PAW density-matrix contribution to atomic forces. This function implements the PAW (projector-augmented wave) correction to the forces that arises from the density-matrix term in GPAW's LCAO code path. In density-functional theory calculations using the PAW method (as described in the repository README), the total atomic forces include a contribution from the PAW augmentation that depends on derivatives of the projector functions and the density matrix. add_den_mat_paw_term computes that contribution for a block of projector rows (my_row_range), accumulates per-projector quantities using a BLAS-like routine (mmm), contracts them with a precomputed erhoT_MM tensor, and then distributes the resulting force increments to the atomic force accumulator F_av for the involved atoms. The implementation loops over the three Cartesian directions (v = 0,1,2) and updates F_av in-place.` |
| `gpaw_new_gpw_convert_to_new_packing_convention` | `gpaw.new.gpw.convert_to_new_packing_convention` | `gpaw/new/gpw.py` | `a_asp: dict, density: bool = False` | `Convert arrays from the old packing convention to the new packing convention used in GPAW. This function is used in the GPAW codebase (a DFT code based on the PAW method and NumPy arrays) to change how matrix-like, packed data are stored inside a dictionary of arrays. For each value array in the input dictionary a_asp, the function reconstructs a full 2D (or higher-dimensional) representation using either unpack_hermitian (for Hermitian-packed data) or unpack_density (for density-specific packing) and then replaces the original packed storage in-place with the elements taken from the lower-triangular indices of the reconstructed array. This implements the following illustrative re-ordering of a 3x3 example from the old convention (left) to the new convention (right): 1 2 3 1 2 4 . 4 5 -> . 3 5 . . 6 . . 6` |
| `gpaw_new_magma_eigh_magma_cpu` | `gpaw.new.magma.eigh_magma_cpu` | `gpaw/new/magma.py` | `matrix: numpy.ndarray, UPLO: str` | `Wrapper for MAGMA symmetric/Hermitian eigensolvers (CPU version) that diagonalizes a real symmetric or complex Hermitian matrix and returns its eigenvalues and orthonormal eigenvectors. In the GPAW DFT codebase this function is used to obtain eigenvalues (for example Kohnâ€“Sham energies) and eigenvectors (orbitals represented in the computational basis) from Hermitian matrices such as Hamiltonians or overlap matrices; it delegates the heavy lifting to MAGMA via the cgpaw interface and adapts MAGMA's output to NumPy conventions.` |
| `gpaw_new_orbmag_calculate_orbmag_from_density` | `gpaw.new.orbmag.calculate_orbmag_from_density` | `gpaw/new/orbmag.py` | `D_asii: dict, n_aj: list, l_aj: list` | `Calculate orbital magnetic moment vectors for each atom from atomic density matrices. This function is used within the GPAW DFT codebase (projector-augmented wave method) to extract the atomic orbital contribution to the magnetic moment from per-atom PAW/partial-wave density matrices. It assumes D_asii is present on every MPI rank (the function is not parallelised) and computes, for each atom a, the 3 Cartesian components of the orbital magnetic moment by evaluating traces of the atomic electron-density block with precomputed angular-momentum operator matrices for each radial partial wave.` |
| `gpaw_new_symmetry_mat` | `gpaw.new.symmetry.mat` | `gpaw/new/symmetry.py` | `rot_cc: list` | `gpaw.new.symmetry.mat converts a 3x3 matrix (typically a rotation matrix used in GPAW's symmetry utilities) into a compact, human-readable string representation. This function is intended for producing deterministic textual forms of small integer or numeric matrices for logging, comparison, or inclusion in text output generated by GPAW symmetry code paths.` |
| `gpaw_new_lcao_forces_add_den_mat_term` | `gpaw.new.lcao.forces.add_den_mat_term` | `gpaw/new/lcao/forces.py` | `erhoT_MM: numpy.ndarray, dThetadR_vMM: numpy.ndarray, F_av: numpy.ndarray, indices: list, mya: list, my_row_range: tuple` | `gpaw.new.lcao.forces.add_den_mat_term computes and adds the density-matrix (erho) contribution arising from basis-function overlap (the dTheta/dR term) to the atomic force accumulator used in the LCAO (linear combination of atomic orbitals) implementation in GPAW. This function implements the loop over matrix block indices and performs in-place updates to the per-atom force array F_av by contracting the derivative-of-overlap tensor with the transposed density-matrix block using a NumPy einsum and taking the real part with the -2 prefactor that appears in the LCAO expression for the overlap contribution to forces. It is intended to be called during force evaluation (for geometry optimization, molecular dynamics, or force reporting) and is compatible with GPAW's MPI/domain-decomposed data layout when mya and my_row_range restrict the work to the local process.` |
| `gpaw_new_symmetry_safe_id` | `gpaw.new.symmetry.safe_id` | `gpaw/new/symmetry.py` | `magmom_av: list, tolerance: float = 0.001` | `Convert a sequence of per-atom magnetic moments into stable integer identifiers used for grouping atoms by magnetic moment in symmetry-related processing within GPAW. This function is used in gpaw.new.symmetry to mitigate small rounding differences in magnetic moments produced by density-functional theory (DFT) calculations. It assigns an integer identifier to each magnetic moment in magmom_av such that the first occurrence of a distinct magnetic moment value defines a new identifier and any later magnetic moments within the symmetric tolerance range of that first occurrence are assigned the same identifier. The comparison uses the Euclidean norm of the difference between two moment values (so for scalar moments this is the absolute difference). This produces reproducible, compact integer ids that can be used to group atoms in symmetry detection and other analyses where per-atom magnetic moments should be considered equivalent up to a small numerical tolerance. Example: safe_id([1.01, 0.99, 0.5], tolerance=0.025) -> [0, 0, 2].` |
| `gpaw_nlopt_shg_shg_length_gauge` | `gpaw.nlopt.shg.shg_length_gauge` | `gpaw/nlopt/shg.py` | `w_l: numpy.ndarray, f_n: numpy.ndarray, E_n: numpy.ndarray, r_vnn: numpy.ndarray, rd_vvnn: numpy.ndarray, D_vnn: numpy.ndarray, pol_v: list, band_n: list = None, ftol: float = 0.0001, Etol: float = 1e-06, eshift: float = 0` | `Compute length-gauge two- and three-band contributions for second-harmonic generation (SHG) by looping over electronic bands. This function is used in GPAW's nonlinear optics (nlopt) SHG module to assemble the frequency-dependent two-band and three-band terms in the length gauge. It loops over pairs and triplets of electronic bands, applies time-reversal symmetry to reduce the summation, and accumulates complex-valued contributions as functions of the input complex frequency array w_l. The routine expects inputs from a DFT/PAW calculation: band energies, Fermi occupations, interband matrix elements and generalized derivatives. The optional eshift allows a uniform band-gap correction (in eV) commonly used in post-processing GW or scissor-corrected results.` |
| `gpaw_nlopt_shg_make_output` | `gpaw.nlopt.shg.make_output` | `gpaw/nlopt/shg.py` | `gauge: str, sum2_l: numpy.ndarray, sum3_l: numpy.ndarray` | `make_output(gauge, sum2_l, sum3_l) Concise summary: Compute and return the second-order nonlinear susceptibility chi (chi_l) in SI units [m / V] for second-harmonic-generation (SHG) calculations in GPAW by multiplying the precomputed 2-band and 3-band band-sum contributions with the appropriate physical prefactor and combining them according to the chosen gauge. This function is used in the gpaw.nlopt.shg module, which assembles microscopic band-sum contributions (sum2_l and sum3_l) produced by electronic-structure evaluations into a macroscopic second-order response suitable for analysis or comparison with experiment.` |
| `gpaw_occupations_fermi_dirac` | `gpaw.occupations.fermi_dirac` | `gpaw/occupations.py` | `eig: numpy.ndarray, fermi_level: float, width: float` | `Compute Fermiâ€“Dirac occupations, their energy derivatives, and per-state electronic entropy contributions used for electronic smearing in GPAW. This routine implements the Fermiâ€“Dirac distribution used in GPAW for converting single-particle eigenvalues (energies) into occupation numbers for finite electronic temperature (smearing). It is typically used in self-consistent-field DFT calculations to obtain fractional occupations for metallic or thermally-broadened systems, and to evaluate the entropic contribution to the electronic free energy. The implementation is numerically stabilized by clipping the reduced energy argument to the range [-100, 100] to avoid overflow in the exponential. The function is pure (no side effects) and returns three numpy arrays corresponding to the occupation, its derivative with respect to eigenvalue, and a per-state entropy-related energy term.` |
| `gpaw_nlopt_matrixel_get_rml` | `gpaw.nlopt.matrixel.get_rml` | `gpaw/nlopt/matrixel.py` | `E_n: numpy.ndarray, p_vnn: numpy.ndarray, pol_v: list, Etol: float = 1e-06` | `get_rml computes position and velocity-difference matrix elements used in GPAW DFT calculations.` |
| `gpaw_nlopt_matrixel_get_derivative` | `gpaw.nlopt.matrixel.get_derivative` | `gpaw/nlopt/matrixel.py` | `E_n: numpy.ndarray, r_vnn: numpy.ndarray, D_vnn: numpy.ndarray, pol_v: list, Etol: float = 1e-06` | `Compute the generalised derivative of position matrix elements used in response calculations (optical and transport properties) within the GPAW density-functional theory framework. This function combines band energies, momentum matrix elements and velocity-difference matrix elements to produce the complex generalized derivative tensor rd_vvnn that is used when evaluating derivatives of position-dependent operators and related response tensors in band-structure based calculations.` |
| `gpaw_nlopt_shg_shg_velocity_gauge` | `gpaw.nlopt.shg.shg_velocity_gauge` | `gpaw/nlopt/shg.py` | `w_l: numpy.ndarray, f_n: numpy.ndarray, E_n: numpy.ndarray, p_vnn: numpy.ndarray, pol_v: list, band_n: list = None, ftol: float = 0.0001, Etol: float = 1e-06, eshift: float = 0` | `Loop over bands to compute velocity-gauge second-harmonic generation (SHG) terms used in GPAW's nonlinear optical response routines. This function computes the frequency-dependent two-band (sum2_l) and three-band (sum3_l) contributions to the SHG response in the velocity gauge. It is intended for use inside GPAW (a DFT/PAW code) postprocessing or response modules that evaluate second-order susceptibilities from single-particle band energies, occupations and momentum matrix elements. The implementation follows the band-sum formulas: it loops over specified bands, applies time-reversal symmetry to halve the work (skip m <= n), uses occupation differences and energy denominators with optional scissors-like bandgap correction (eshift), and discards contributions that are numerically singular or degenerate according to the provided tolerances (ftol and Etol). The outputs are complex frequency-dependent arrays suitable for constructing SHG spectra or further combination with prefactors to yield macroscopic susceptibilities.` |
| `gpaw_occupations_marzari_vanderbilt` | `gpaw.occupations.marzari_vanderbilt` | `gpaw/occupations.py` | `eig: numpy.ndarray, fermi_level: float, width: float` | `Marzari-Vanderbilt cold-smearing occupation function used in GPAW to compute smeared electronic occupations, their energy derivatives, and per-state entropy energy corrections. This implements the Marzari-Vanderbilt "cold smearing" distribution (see DOI 10.1103/PhysRevLett.82.3296) and is intended for use in electronic-structure (DFT) calculations within GPAW to stabilize convergence for metallic or partially occupied systems by smoothing the occupation step at the Fermi level. This function evaluates the Marzariâ€“Vanderbilt analytic expressions in a vectorized NumPy form. Given an array of single-particle eigenvalues and a chemical potential (fermi_level), it returns: (1) occupation numbers between 0 and 1 that replace the zero-temperature step function; (2) the derivative of these occupations with respect to the eigenvalue, useful for response or density-derivative calculations; and (3) a per-state energy-like entropy correction term that is used when computing the smeared free-energy correction to the total energy in DFT workflows. All returned arrays have the same shape as the input eig array. The algorithm uses width as the smearing parameter and performs elementwise operations (no in-place modification of inputs).` |
| `gpaw_occupations_methfessel_paxton` | `gpaw.occupations.methfessel_paxton` | `gpaw/occupations.py` | `eig: numpy.ndarray, fermi_level: float, width: float, order: int = 0` | `gpaw.occupations.methfessel_paxton computes the Methfesselâ€“Paxton smearing distribution used in GPAW to obtain partial electronic occupations, their energy derivatives, and the per-state electronic entropy contribution for metallic or partially occupied systems. This function implements the standard Methfesselâ€“Paxton expansion: a base Fermi-like occupation given by the complementary error function plus higher-order corrections constructed from Hermite polynomials and coff_function coefficients. It is used in GPAW/ASE workflows to stabilize self-consistent-field (SCF) convergence by smearing occupations near the Fermi level.` |
| `gpaw_new_symmetry_find_lattice_symmetry` | `gpaw.new.symmetry.find_lattice_symmetry` | `gpaw/new/symmetry.py` | `cell_cv: numpy.ndarray, pbc_c: numpy.ndarray, tol: float, _backwards_compatible: bool = False` | `gpaw.new.symmetry.find_lattice_symmetry determines the set of lattice symmetry operations (3x3 integer matrices with elements in {-1, 0, 1}) that conserve the metric of a given unit cell and that do not swap axes with different periodic boundary conditions. This function is used in GPAW's symmetry handling to identify candidate point-group operations that map the cell basis vectors onto each other while preserving inter-vector lengths and respecting periodicity, which is important for exploiting symmetry in DFT calculations (for example reducing k-point sampling or identifying equivalent atoms).` |
| `gpaw_point_groups_check_sphere` | `gpaw.point_groups.check.sphere` | `gpaw/point_groups/check.py` | `radius: float, grid_spacing: float` | `gpaw.point_groups.check.sphere: Return Cartesian coordinates of grid points that lie inside or on a sphere of given radius centered at the origin in a uniform real-space grid. This helper is used by GPAW routines that need a discrete sampling of a spherical region on a regular grid (for example, symmetry checks, point-group operations, or localized real-space operations on the PAW grid).` |
| `gpaw_nlopt_linear_calc_chi` | `gpaw.nlopt.linear.calc_chi` | `gpaw/nlopt/linear.py` | `w_l: numpy.ndarray, f_n: numpy.ndarray, E_n: numpy.ndarray, p_vnn: numpy.ndarray, pol_v: tuple, band_n: list = None, ftol: float = 0.0001, Etol: float = 1e-06, eshift: float = 0` | `calc_chi computes the band-summed linear-response quantity chi(omega) used in GPAW optical and response calculations. This function loops over pairs of electronic bands to accumulate a frequency-dependent response sum_l(omega) for the complex frequency points in w_l. It uses Fermi occupations f_n, band energies E_n, and momentum matrix elements p_vnn together with a polarization selector pol_v to form the contribution from each band pair. Time-reversal symmetry is used to reduce the double sum to pairs with m > n and the code multiplies by the appropriate symmetry and real-part factors. The routine is intended for use in GPAW workflows that compute optical properties or susceptibilities from PAW momentum matrix elements and Kohnâ€“Sham eigenvalues.` |
| `gpaw_nlopt_shift_shift_current` | `gpaw.nlopt.shift.shift_current` | `gpaw/nlopt/shift.py` | `eta: float, w_l: numpy.ndarray, f_n: numpy.ndarray, E_n: numpy.ndarray, r_vnn: numpy.ndarray, rd_vvnn: numpy.ndarray, pol_v: tuple, band_n: list = None, ftol: float = 0.0001, Etol: float = 1e-06, eshift: float = 0.0` | `gpaw.nlopt.shift.shift_current computes the frequency-dependent, length-gauge two-band contribution to an optical response (commonly used as part of shift-current or similar nonlinear optical calculations) by looping over pairs of electronic bands. It is intended for use inside the GPAW density-functional-theory codebase where band energies, occupations and matrix elements are provided by a GPAW calculation. The routine constructs a 1D complex frequency-dependent array by summing imaginary parts of products of momentum matrix elements and generalized position-derivative tensors, weighted by Fermi occupation differences and Lorentzian broadening centered at interband transition energies.` |
| `gpaw_pseudopotential_get_radial_hartree_energy` | `gpaw.pseudopotential.get_radial_hartree_energy` | `gpaw/pseudopotential.py` | `r_g: numpy.ndarray, rho_g: numpy.ndarray` | `Get energy of the l=0 (spherically symmetric) compensation charge on an equidistant radial grid used in GPAW pseudopotential/PAW routines. This function is used in the GPAW pseudopotential machinery to compute the electrostatic (Hartree) self-energy associated with the l=0 component of a compensation charge represented on a 1D radial grid. The routine assumes an equidistant radial grid and constructs the integrand used by the Hartree solver (hartree_solve) to obtain r*V_H(r) (where V_H is the Hartree potential). The final Hartree energy is obtained by integrating 2*pi * âˆ« rho(r) V_H(r) r dr using the simple trapezoid-like scaling implemented in the source code.` |
| `gpaw_response_chiks_create_get_temporal_part` | `gpaw.response.chiks.create_get_temporal_part` | `gpaw/response/chiks.py` | `bandsummation: str` | `gpaw.response.chiks.create_get_temporal_part selects and returns the function that implements the temporal part of a band-summation based response calculation used in GPAW's response.chiks code path for density-functional theory (DFT) response/susceptibility evaluations.` |
| `gpaw_quiz_encode` | `gpaw.quiz.encode` | `gpaw/quiz.py` | `text: str` | `gpaw.quiz.encode encodes a Unicode text string by performing a per-character substitution using the module-level mapping used to reproduce the transformation in the Python "The Zen of Python" (this.py). This function is part of the gpaw.quiz utilities and is intended for simple, deterministic text transformations (for example, quiz or Easter-egg style encodings that mirror the encoding used by Python's this module).` |
| `gpaw_pw_descriptor_pad` | `gpaw.pw.descriptor.pad` | `gpaw/pw/descriptor.py` | `array: numpy.ndarray, N: int` | `Pad a 1-D complex array with zeros up to a specified length N. This function is a small utility used in GPAW's plane-wave / descriptor code paths to ensure 1-D arrays of complex coefficients (for example plane-wave coefficients, Fourier components, or descriptor vectors) have a consistent length for further operations such as FFTs, vectorized linear algebra, or GPU-backed computations. The function preserves the original array object when no padding is required, otherwise it allocates a new 1-D complex array of length N and copies the original elements into the beginning, filling the remainder with zeros.` |
| `gpaw_response_chiks_get_ecut_to_encompass_centered_sphere` | `gpaw.response.chiks.get_ecut_to_encompass_centered_sphere` | `gpaw/response/chiks.py` | `q_v: numpy.ndarray, ecut: float` | `gpaw.response.chiks.get_ecut_to_encompass_centered_sphere computes the minimal plane-wave kinetic-energy cutoff (ecut) required so that a plane-wave basis centered at a reciprocal-space shift q_v contains all reciprocal lattice vectors G that lie inside the original gamma-centered sphere defined by \|G\|^2 < 2 * ecut. This function is used in GPAW's plane-wave response routines (gpaw.response.chiks) to adjust the energy cutoff when the plane-wave basis is translated by a q-vector so that no G-vectors are lost from the spherical cutoff region.` |
| `gpaw_occupations_occupation_numbers` | `gpaw.occupations.occupation_numbers` | `gpaw/occupations.py` | `occ: dict, eig_skn: numpy.ndarray, weight_k: numpy.ndarray, nelectrons: float` | `Calculate occupation numbers from eigenvalues in eV and return occupations, Fermi level and related quantities. This function is deprecated; it issues a DeprecationWarning and delegates the actual calculation to an OccupationNumbers implementation created from the provided occ dictionary. It is used in the GPAW DFT workflow to convert band eigenvalues on IBZ k-points and a total electron count into per-spin, per-k-point, per-band occupation numbers (f_skn), the Fermi level in Hartree, the total magnetic moment, and the electronic entropy term (-S*T) in Hartree. The implementation flattens eigenvalues for use by the occupation routine, applies IBZ k-point weights, and reconstructs a (nspins, nibzkpts, nbands)-shaped occupation array consistent with eig_skn.` |
| `gpaw_raman_raman_plot_raman` | `gpaw.raman.raman.plot_raman` | `gpaw/raman/raman.py` | `figname: str, RIsuffix: list, relative: bool = False, w_min: float = None, w_max: float = None` | `gpaw.raman.raman.plot_raman plots one or more Raman spectra from NumPy ".npy" Raman intensity files and saves the resulting matplotlib figure to disk. This function is used in the GPAW DFT workflow to visualize Raman intensities (for example, intensities computed from vibrational analyses or other post-processing steps) stored in files named with the pattern "RI_<suffix>.npy". The function loads the Raman-shift axis and intensity arrays from these files, optionally scales intensities to their maxima (relative plotting), locates spectral peaks in the first file, overlays vertical lines at significant peak positions, and writes a high-resolution figure (dpi=300) to the given filename. The Raman shift axis is treated in units of cm^-1 and intensities are treated as arbitrary units, consistent with typical GPAW/ASE post-processing conventions.` |
| `gpaw_response_chiks_get_smat_components` | `gpaw.response.chiks.get_smat_components` | `gpaw/response/chiks.py` | `spincomponent: tuple, s1_t: int, s2_t: int` | `Compute the product Ïƒ^Î¼_ss' Ïƒ^Î½_s's for a specified pair of spin-component indices (Î¼, Î½). This function is part of the gpaw.response.chiks routines used in GPAW (a DFT code based on the PAW method) to assemble spin-dependent contributions to response quantities. It retrieves two spin matrices corresponding to the two entries of spincomponent using the local smat(...) accessor and returns the product of the matrix element from the first matrix at row s1_t, column s2_t with the matrix element from the second matrix at row s2_t, column s1_t. In practical GPAW workflows this scalar enters sums over spin indices when building spin-resolved response tensors or kernels used in linear-response or susceptibility calculations.` |
| `gpaw_pseudopotential_screen_potential` | `gpaw.pseudopotential.screen_potential` | `gpaw/pseudopotential.py` | `r: numpy.ndarray, v: numpy.ndarray, charge: float, rcut: float = None, a: float = None` | `gpaw.pseudopotential.screen_potential splits a long-range, spherically symmetric radial potential into a short-ranged screened potential and a localized compensation charge density suitable for use in PAW/pseudopotential constructions and Hartree potential evaluation.` |
| `gpaw_response_fxc_kernels_create_add_fxc` | `gpaw.response.fxc_kernels.create_add_fxc` | `gpaw/response/fxc_kernels.py` | `fxc: str, spincomponent: str` | `Create and return an add_fxc function configured for a requested exchange-correlation kernel (fxc) and spin component (spincomponent) used by the GPAW linear-response module to assemble the exchange-correlation kernel contributions to response matrices. In the GPAW DFT/PAW response context (see gpaw.response), this factory binds the requested ALDA-type functional identifier to an internal implementation that adds either density-density or transverse spin f_xc contributions, so the returned callable can be invoked by response routines to modify the kernel.` |
| `gpaw_raman_raman_calculate_raman_intensity` | `gpaw.raman.raman.calculate_raman_intensity` | `gpaw/raman/raman.py` | `w_ph: numpy.ndarray, d_i: int, d_o: int, suffix: str, T: float = 300` | `Calculate Raman intensities from a precomputed Raman tensor and phonon frequencies. This function is part of the GPAW Raman utilities and implements the post-processing step that converts mode-resolved Raman matrix elements (R_lab) into frequency-dependent Raman intensities using phonon frequencies, a Boseâ€“Einstein occupation factor at a given temperature, and a Gaussian broadening. It reads and writes NumPy .npy files following the naming convention used by the GPAW Raman workflow and is intended to be used after a Raman tensor calculation that produced Rlab files.` |
| `gpaw_response_chiks_get_temporal_part` | `gpaw.response.chiks.get_temporal_part` | `gpaw/response/chiks.py` | `spincomponent: int, hz_z: numpy.ndarray, kptpair: tuple, bandsummation: str` | `Get the temporal part of a causal linear susceptibility x_t^Î¼Î½(Ä§z) for a single spin component, evaluated at one or more complex frequency points. This function is part of GPAW's linear-response/response.chiks machinery used in DFT-based response calculations (for example optical or many-body response evaluations) and serves as a thin wrapper that selects a bands-summation implementation and evaluates it for the requested spin component, frequency points (Ä§z) and k-point pair.` |
| `gpaw_response_df_read_response_function` | `gpaw.response.df.read_response_function` | `gpaw/response/df.py` | `filename: str` | `Read a stored frequency-dependent response function file produced for use with GPAW's frequency-domain response analyses (gpaw.response.df). This function parses a CSV-like text file (comma-separated values) that encodes a frequency grid and two response functions: the "noninteracting" response rf0_w and the "interacting" response rf_w. It is intended for post-processing or plotting of response data produced by GPAW linear-response or dielectric calculations and returns NumPy arrays suitable for numerical analysis in the GPAW/ASE workflow.` |
| `gpaw_response_heisenberg_get_q0_index` | `gpaw.response.heisenberg.get_q0_index` | `gpaw/response/heisenberg.py` | `q_qc: numpy.ndarray` | `gpaw.response.heisenberg.get_q0_index: Find and return the index of the zero wavevector (q = [0., 0., 0.]) in a q-vector array used in GPAW Heisenberg/response calculations. This function is used in GPAW's response.heisenberg routines to identify the q = 0 (Gamma) entry in an array of q-vectors (for example when assembling response functions or evaluating Heisenberg exchange parameters at the zero momentum transfer). It searches the provided NumPy array for a row that is exactly equal to [0., 0., 0.] and returns the integer index of the first matching row. The function performs an elementwise exact equality check, so callers should ensure that the zero vector is represented exactly (or preprocess the array to set small numerical values to zero) before calling.` |
| `gpaw_response_mpa_sampling_semi_homogenous_partition` | `gpaw.response.mpa_sampling.semi_homogenous_partition` | `gpaw/response/mpa_sampling.py` | `npoles: int` | `Semi-homogenous partition generator used in GPAW response MPA sampling to place n-poles (sampling points) between 0 and 1. This function constructs a semi-homogenous one-dimensional partition (grid) of npoles points on the interval [0, 1] following Eq. (18) of Ref. [1] and Eq. (11) of Ref. [2]. In the GPAW code base this partition is used by the multipole approximation (MPA) sampling of response functions to distribute sampling points such that smaller intervals are concentrated near zero (improving resolution where response functions typically vary rapidly) while retaining larger intervals further from zero. The returned array has length exactly npoles and represents the positions of the n-poles normalized to the unit interval.` |
| `gpaw_response_heisenberg_calculate_fm_magnon_energies` | `gpaw.response.heisenberg.calculate_fm_magnon_energies` | `gpaw/response/heisenberg.py` | `J_qabx: numpy.ndarray, q_qc: numpy.ndarray, mm_ax: numpy.ndarray` | `gpaw.response.heisenberg.calculate_fm_magnon_energies computes magnon eigenmode energies for a ferromagnetic system with an arbitrary number of magnetic sites in the unit cell, using isotropic exchange constants as a function of wave vector q. This function is used in the GPAW response/Heisenberg utilities to obtain the spin-wave (magnon) spectrum from isotropic exchange matrices J(q) for each q-point. It first constructs the dynamic spin-wave matrix H^ab(q) = g Î¼_B / sqrt(M_a M_b) [Î£_c J^ac(0) Î´_ab - J^ab(q)] by calling generate_fm_dynamic_spin_wave_matrix, then diagonalizes H(q) for each q and any independent extra dimensions x to produce magnon eigenmode energies. The output energies correspond to the eigenvalues of the dynamic spin-wave matrix and are provided for each q-vector and mode index.` |
| `gpaw_response_heisenberg_calculate_single_site_magnon_energies` | `gpaw.response.heisenberg.calculate_single_site_magnon_energies` | `gpaw/response/heisenberg.py` | `J_qx: numpy.ndarray, q_qc: numpy.ndarray, mm: float` | `Compute magnon energies for a system with a single magnetic site in the unit cell from isotropic exchange constants J(q). This function is used in GPAW's response/heisenberg workflow to convert isotropic exchange constants computed as functions of wave vector q into magnon energies (Ä§Ï‰(q)) for single-sublattice magnetic systems. The implementation assumes an isotropic exchange interaction and a single magnetic site per unit cell; under these assumptions the magnon energy is evaluated as the prefactor 2/mm times the difference J(0) - J(q), consistent with the common expression Ä§Ï‰(q) = (g Î¼_B / M) [J(0) - J(q)] when one uses g â‰ˆ 2 and M expressed in units of Î¼_B.` |
| `gpaw_response_integrators_czher` | `gpaw.response.integrators.czher` | `gpaw/response/integrators.py` | `alpha: float, x: numpy.ndarray, A: numpy.ndarray` | `gpaw.response.integrators.czher performs an in-place Hermitian rank-1 update of the upper triangular part of a square matrix A used in GPAW response integrators. In the context of GPAW (a density-functional theory code), this function is a low-level, BLAS-backed operation that adds a scaled outer product of a complex vector with its conjugate to an existing matrix, a common operation when updating density, response, or overlap matrices in iterative integrators.` |
| `gpaw_response_heisenberg_generate_fm_dynamic_spin_wave_matrix` | `gpaw.response.heisenberg.generate_fm_dynamic_spin_wave_matrix` | `gpaw/response/heisenberg.py` | `J_qabx: numpy.ndarray, q_qc: numpy.ndarray, mm_ax: numpy.ndarray` | `gpaw.response.heisenberg.generate_fm_dynamic_spin_wave_matrix: Generate the dynamic spin-wave matrix H_qabx for a collinear ferromagnet from isotropic exchange constants J_qabx. This routine implements the relation used in spin-wave (magnon) calculations for ferromagnets: H^ab(q) = (g Î¼_B) / sqrt(M_a M_b) [Î£_c J^ac(0) Î´_ab - J^ab(q)], but in the implementation the magnetic-moment prefactor is computed explicitly as 2. / sqrt(M_a M_b) (see code). The function is intended for use inside GPAW's linear-response / Heisenberg-model utilities where J_qabx represents isotropic exchange interactions between sublattices a and b as a function of crystal momentum q and optional extra parameter dimensions x. The resulting H_qabx is the dynamic spin-wave matrix used to obtain spin-wave spectra and mode analysis for a ferromagnetic system within the assumptions of a collinear magnetic ground state and no spin-orbit coupling.` |
| `gpaw_response_pair_functions_read_susceptibility_array` | `gpaw.response.pair_functions.read_susceptibility_array` | `gpaw/response/pair_functions.py` | `filename: str` | `Read a stored dynamic susceptibility array file produced by GPAW response calculations.` |
| `gpaw_response_pair_functions_read_pair_function` | `gpaw.response.pair_functions.read_pair_function` | `gpaw/response/pair_functions.py` | `filename: str` | `gpaw.response.pair_functions.read_pair_function: Read a stored pair function file and return the frequency/contour points and the complex pair function values as numpy arrays used by GPAW response calculations. Reads a comma-separated values (CSV) file produced by GPAW or compatible tools that store a pair function on a horizontal contour in the complex-frequency plane. In the GPAW response context, a "pair function" is a two-point response quantity used in many-body / linear-response routines; this function loads a saved representation so that response modules can reconstruct the frequency/contour-dependent complex pair function for further processing (integration, interpolation, or analytic continuation). The implementation uses numpy.loadtxt with delimiter=',' to parse numeric data and expects exactly three columns: the first column is the contour coordinate (omega), the second column is the real part of the pair function, and the third column is the imaginary part. The function constructs a 1-D floating array of contour points and a 1-D complex array of pair function values by combining the second and third columns.` |
| `gpaw_response_pair_transitions_transitions_in_composite_index` | `gpaw.response.pair_transitions.transitions_in_composite_index` | `gpaw/response/pair_transitions.py` | `n1_M: numpy.ndarray, n2_M: numpy.ndarray, s1_S: numpy.ndarray, s2_S: numpy.ndarray` | `gpaw.response.pair_transitions.transitions_in_composite_index: Build flattened index arrays that enumerate transitions (n, s) -> (n', s') using a composite index t for use in GPAW response and pair-transition routines. This function constructs two meshgrids, one for the initial-state indices (n1_M with s1_S) and one for the final-state indices (n2_M with s2_S), and returns the four flattened arrays. In the context of GPAW response calculations (density-functional theory using the PAW method), this utility is used to vectorize and enumerate all combinations of band (n) and spin (s) indices for subsequent assembly of response matrices, transition lists, or batched linear-algebra operations. The function does not modify its inputs and has no side effects beyond allocating and returning new numpy arrays.` |
| `gpaw_response_pair_transitions_remove_null_transitions` | `gpaw.response.pair_transitions.remove_null_transitions` | `gpaw/response/pair_transitions.py` | `n1_M: numpy.ndarray, n2_M: numpy.ndarray, nocc1: int = None, nocc2: int = None` | `Remove pairs of bands for which electronic transitions are impossible within a DFT/PAW calculation context. This function filters two parallel arrays of band indices that represent paired initial and final bands (for example, occupied -> unoccupied transitions used in response or excitation calculations). It removes any pair (n1, n2) where both bands are considered fully occupied or both are considered completely unoccupied based on the provided occupation thresholds. The function is used in GPAW response code to avoid forming transitions that are physically forbidden or irrelevant for response function assembly and subsequent linear-response calculations.` |
| `gpaw_response_site_data_maximize` | `gpaw.response.site_data.maximize` | `gpaw/response/site_data.py` | `x_x: numpy.ndarray, f_x: numpy.ndarray` | `Maximize a sampled function f(x) on a given interval and return the x-coordinate of a detected interior maximum together with the function value at that maximum. This routine is intended for use inside GPAW response/site_data analysis where one works with discrete samples of a function (for example a response function, density-related quantity, or any scalar site data obtained from a DFT calculation) and needs to locate a local peak inside the sampled interval.` |
| `gpaw_response_site_kernels_cylindrical_geometry_factor` | `gpaw.response.site_kernels.cylindrical_geometry_factor` | `gpaw/response/site_kernels.py` | `Q_Qv: numpy.ndarray, ez_v: numpy.ndarray, rc: float, hc: float` | `Calculate the site-centered geometry factor Theta(Q) for a cylindrical site kernel (gpaw.response.site_kernels.cylindrical_geometry_factor). This function evaluates the Fourier-space integral of a uniform cylinder indicator function used by GPAW response kernels (the site kernel for a cylinder) and returns the geometry factor Theta(Q) for input wave vectors Q. In the GPAW DFT/response context this factor is the Fourier transform of a cylinder of radius rc and height hc aligned along the unit vector ez_v, multiplied by the cylinder volume V_cylinder = pi * rc**2 * hc. The returned array is used when constructing or applying site-centered response kernels in reciprocal space (for example, evaluating matrix elements of localized kernels or form-factors for cylindrical projector regions). The mathematical form implemented is Theta(Q) = V_cylinder * (2 J_1(Q_rho * rc) / (Q_rho * rc)) * sinc(Q_z * hc / 2), with Q_rho = \|Q x ez_v\| and Q_z = Q . ez_v, where J_1 is the Bessel function of the first kind of order one and sinc(x) = sin(x)/x. The code enforces the limiting value Theta(Q)/V_cylinder -> 1 for Q -> 0 by handling the Q_rho * rc -> 0 limit explicitly.` |
| `gpaw_response_site_kernels_spherical_geometry_factor` | `gpaw.response.site_kernels.spherical_geometry_factor` | `gpaw/response/site_kernels.py` | `Q_Qv: numpy.ndarray, rc: float` | `gpaw.response.site_kernels.spherical_geometry_factor â€” Calculate the site-centered geometry factor for a spherical site kernel used in GPAW response calculations. Computes the Fourier-space integral Î˜(Q) = âˆ« d^3r e^{-i QÂ·r} Î¸(\|r\| < r_c) for a sphere of radius rc and returns the geometry factor per wave-vector multiplied by the sphere volume. This function is used in the GPAW response/site_kernels code to construct site-centered spherical kernels in reciprocal space (e.g., when evaluating structure factors or site contributions to response functions in density-functional-theory simulations). The analytic expression implemented is Î˜(Q) = V_sphere * 3 [sinc(\|Q\| r_c) - cos(\|Q\| r_c)] / (\|Q\| r_c)^2 with the limiting value Î˜(Q) â†’ V_sphere for \|Q\| r_c â†’ 0. The implementation uses the Euclidean norm of the cartesian Q vectors, a small tolerance to avoid division by zero, and returns a real-valued array of geometry factors (units of volume, since the dimensionless factor is multiplied by the sphere volume).` |
| `gpaw_response_susceptibility_read_eigenmode_lineshapes` | `gpaw.response.susceptibility.read_eigenmode_lineshapes` | `gpaw/response/susceptibility.py` | `filename: str` | `gpaw.response.susceptibility.read_eigenmode_lineshapes: Read a stored eigenmode lineshapes file produced by GPAW response/susceptibility calculations and return the frequency grid and the per-eigenmode lineshape amplitudes as NumPy arrays.` |
| `gpaw_response_susceptibility_read_full_spectral_weight` | `gpaw.response.susceptibility.read_full_spectral_weight` | `gpaw/response/susceptibility.py` | `filename: str` | `gpaw.response.susceptibility.read_full_spectral_weight reads a stored full spectral weight file produced by GPAW susceptibility/response calculations and returns the frequency grid and corresponding spectral weight values as NumPy arrays. This function is used in the context of GPAW's linear-response and susceptibility analysis where a "full spectral weight" file stores pairs of frequency (omega) and spectral weight A(omega) values. The returned arrays can be used to reconstruct response functions, to plot spectral features, or to perform subsequent numerical integrations or convolutions in DFT-based response analyses.` |
| `gpaw_response_site_kernels_sinc` | `gpaw.response.site_kernels.sinc` | `gpaw/response/site_kernels.py` | `x: numpy.ndarray` | `gpaw.response.site_kernels.sinc computes the mathematical sinc function sin(x)/x elementwise for a NumPy array. In the GPAW codebase (a DFT package using real-space uniform grids and site-centered kernels), this routine is used by response.site_kernels to build sinc-shaped kernels or interpolation/filter functions on grid-based representations. The implementation uses NumPy's normalized numpy.sinc (which implements sin(pi*y)/(pi*y)) and therefore evaluates numpy.sinc(x / numpy.pi) to produce sin(x)/x.` |
| `gpaw_response_site_kernels_parallelepipedic_geometry_factor` | `gpaw.response.site_kernels.parallelepipedic_geometry_factor` | `gpaw/response/site_kernels.py` | `Q_Qv: numpy.ndarray, cell_cv: numpy.ndarray` | `Calculate the site-centered geometry factor Theta(Q) for a parallelepipedic site kernel used in GPAW response calculations. This function evaluates the Fourier transform of the indicator function of a parallelepiped: Theta(Q) = âˆ«_V e^{-i QÂ·r} dr = V_parallelepiped * sinc(QÂ·a1 / 2) * sinc(QÂ·a2 / 2) * sinc(QÂ·a3 / 2), where a1, a2 and a3 are the parallelepipedic cell vectors. In the GPAW response context this geometry factor is used to represent a site-centered kernel in reciprocal space when assembling response functions or multiplying site contributions in Fourier space.` |
| `gpaw_response_susceptibility_write_eigenmode_lineshapes` | `gpaw.response.susceptibility.write_eigenmode_lineshapes` | `gpaw/response/susceptibility.py` | `filename: str, omega_w: numpy.ndarray, a_wm: numpy.ndarray` | `gpaw.response.susceptibility.write_eigenmode_lineshapes writes frequency-dependent eigenmode lineshapes a^Î¼Î½_n(Ï‰) produced by GPAW response/susceptibility calculations to a plain-text file. This function is intended for post-processing and analysis workflows in density-functional theory (DFT) response calculations performed with GPAW: it exports the frequency axis (omega, in electronvolts) together with the corresponding eigenmode amplitudes for each mode so they can be inspected, plotted, or consumed by other tools.` |
| `gpaw_response_susceptibility_write_full_spectral_weight` | `gpaw.response.susceptibility.write_full_spectral_weight` | `gpaw/response/susceptibility.py` | `filename: str, omega_w: numpy.ndarray, A_w: numpy.ndarray` | `Write the sum of spectral weights A(Ï‰) to a plain-text file for use in post-processing, plotting, or archival storage. This function is used in the GPAW response/susceptibility workflow to persist the computed frequency-dependent spectral weight A(Ï‰) evaluated on a frequency grid Ï‰ for later analysis (for example, plotting optical or electronic response functions computed within density-functional theory using GPAW).` |
| `gpaw_response_tool_get_degeneracy_matrix` | `gpaw.response.tool.get_degeneracy_matrix` | `gpaw/response/tool.py` | `eps_n: numpy.ndarray, tol: float = 0.001` | `gpaw.response.tool.get_degeneracy_matrix generates a degeneracy-selection matrix and a list of representative energies for groups of (nearly) degenerate single-particle eigenvalues. This function is used in GPAW response and transition-summing code to identify and sum contributions from degenerate Kohnâ€“Sham states: it produces a matrix whose rows select the members of each degenerate group and an array of one representative energy per group.` |
| `gpaw_response_site_kernels_create_geometry_factor` | `gpaw.response.site_kernels.create_geometry_factor` | `gpaw/response/site_kernels.py` | `shape: str` | `Creator function for the geometry factor factory used by gpaw.response.site_kernels. This function selects and returns a geometry-specific geometry-factor creator given a symbolic shape name. In the GPAW DFT/PAW response-kernel context, a "geometry factor" encodes the shape-dependent spatial weighting or kernel prefactor used by site kernels when computing local response contributions (for example, integrals or projections that depend on the region shape). create_geometry_factor is the factory selector component: it maps the exact string names used throughout gpaw.response.site_kernels to the corresponding geometry-factor implementation functions so that higher-level response code can obtain the correct shape-dependent routine.` |
| `gpaw_response_tool_lorz_fit` | `gpaw.response.tool.lorz_fit` | `gpaw/response/tool.py` | `x: numpy.ndarray, y: numpy.ndarray, npeak: int = 1, initpara: numpy.ndarray = None` | `gpaw.response.tool.lorz_fit fits one or two Lorentzian peak profiles to 1D data arrays using a least-squares optimizer. It is intended for analyzing spectral or response-like curves (for example peaks in density-of-states, spectral functions, or response spectra produced in GPAW DFT workflows) by returning a fitted curve and the optimized Lorentzian parameters. The implementation currently supports only a single Lorentzian (npeak == 1) or two Lorentzians (npeak == 2) and uses scipy.optimize.leastsq with a maximum of 2000 function evaluations. The fitted model for one Lorentzian peak is defined pointwise as: lorz(x) = A * w / ((x - x0)**2 + w**2) + y0 where A is the peak amplitude scale, w is the half-width parameter controlling the peak width, x0 is the peak center in the same units as x, and y0 is a constant baseline offset. For two peaks the model is a sum of two such terms, each with its own set of parameters in the parameter vector described below.` |
| `gpaw_rotation_Y_matrix` | `gpaw.rotation.Y_matrix` | `gpaw/rotation.py` | `l: int, U_vv: numpy.ndarray` | `Compute the matrix of spherical-harmonic values for angular momentum l evaluated at a set of rotated sample points. This function is used in GPAW's rotation utilities to build the matrix of values of the internal Y(...) function (spherical-harmonic-like evaluator used in this module) for 2*l+1 sample points on the unit sphere. The sample points are taken from the module-level list sphere_lm[l] (one point per m1 = 0,...,2*l). Each sample point is rotated by the 3D linear transformation U_vv (typically a 3Ã—3 rotation matrix in GPAW applications), and for each rotated point the function evaluates Y at indices L = l**2 + m2 for m2 = 0,...,2*l. The resulting matrix Y_mm has rows enumerating the input sample points (m1) and columns enumerating the evaluated Y indices derived from m2. In GPAW this matrix is a building block for constructing rotation operators in the angular-momentum-l subspace (for example when rotating PAW projectors, atomic-like basis functions, or related quantities between coordinate frames).` |
| `gpaw_sphere_integrate_find_two_closest_grid_points` | `gpaw.sphere.integrate.find_two_closest_grid_points` | `gpaw/sphere/integrate.py` | `r_g: numpy.ndarray, rcut: float` | `gpaw.sphere.integrate.find_two_closest_grid_points finds the two grid-point indices in a radial grid array that are closest in absolute distance to a specified radial cutoff rcut. This function is used in GPAW's spherical integration utilities to map a physical radial cutoff (for example, the radius of a sphere around an atom used in PAW or real-space integrations) to the two nearest discrete grid points on the radial grid so that subsequent interpolation or selection of grid points can be performed. Detailed behavior: the function computes the absolute differences between each entry of the radial grid array r_g and the scalar cutoff rcut, then uses NumPy's partition to identify the two smallest absolute differences and the corresponding indices. The returned indices are the first occurrences in r_g that match those two smallest absolute differences. The implementation uses vectorized NumPy operations (abs and partition) and then numpy.where to locate indices.` |
| `gpaw_sphere_integrate_find_volume_conserving_lambd` | `gpaw.sphere.integrate.find_volume_conserving_lambd` | `gpaw/sphere/integrate.py` | `rcut: float, drcut: float, r_g: numpy.ndarray = None` | `Determine the scaling factor Î» (lambda) that makes a radial truncation function conserve the spherical volume. This function is used in GPAW's spherical integration and truncation utilities to find a multiplicative scaling parameter Î» such that the numerically integrated, truncated radial weight function Î¸(r) yields the same total volume as an ideal sphere of radius rcut. In practice this is important when constructing smooth truncation/mask functions for spherical regions (for example PAW augmentation spheres or localized real-space cutoffs) on a radial grid: the function adjusts the truncation so that 4Ï€ âˆ«_0^rcut r^2 Î¸(r) dr = 4Ï€ rcut^3 / 3 within numerical tolerance.` |
| `gpaw_sphere_integrate_integrate_lebedev` | `gpaw.sphere.integrate.integrate_lebedev` | `gpaw/sphere/integrate.py` | `f_nx: numpy.ndarray` | `gpaw.sphere.integrate.integrate_lebedev integrates a function defined on a spherical grid over angular coordinates using a Lebedev quadrature appropriate for GPAW calculations (density-functional theory with PAW and real-space/atom-centered grids). This routine performs the angular part of a surface integral on the unit sphere and is typically used in GPAW to obtain angular averages or to reduce a function defined on a spherical angular grid to its radial or non-angular dependence.` |
| `gpaw_rotation_rotation` | `gpaw.rotation.rotation` | `gpaw/rotation.py` | `l: int, U_vv: numpy.ndarray` | `gpaw.rotation.rotation: compute the rotation (transformation) matrix for spherical harmonics of angular momentum l. Compute the transformation matrix that maps coefficients of one set of spherical harmonic basis functions Y_lm (denoted here as Y_lm1) to another rotated set Y_lm2 according to the rotation described by U_vv. This function is used in GPAW's PAW/atomic-basis infrastructure to rotate angular-momentum-resolved quantities (for example atomic orbitals, projector functions, or density-matrix blocks) when applying a symmetry operation or a spatial rotation. Internally the function constructs the rotation in the spherical-harmonic representation by calling Y_matrix(l, U_vv) and then applies the precomputed iY_lmm[l] transformation, returning the combined transformation matrix used to rotate coefficients associated with angular momentum l.` |
| `gpaw_sphere_integrate_integrate_radial_grid` | `gpaw.sphere.integrate.integrate_radial_grid` | `gpaw/sphere/integrate.py` | `f_xg: numpy.ndarray, r_g: numpy.ndarray, rcut: float = None` | `Integrate radial functions on a spherical radial grid. Computes the radial integral âˆ« r^2 dr f(r) for each function represented on the input radial grid r_g. This routine is used in GPAW's spherical/atom-centered integration routines (e.g., when integrating radial parts of densities, projectors or other atom-centered quantities in the PAW framework). The function optionally truncates the grid at a cutoff radius rcut before performing the integration. Integration is performed with the radial trapezoidal rule implemented by radial_trapz; truncation (when requested) is performed by truncate_radial_grid.` |
| `gpaw_setup_correct_occ_numbers` | `gpaw.setup.correct_occ_numbers` | `gpaw/setup.py` | `f_j: numpy.ndarray, degeneracy_j: numpy.ndarray, jsorted: list, correction: float, eps: float = 1e-12` | `gpaw.setup.correct_occ_numbers: Modify a per-state occupation array in-place to distribute a specified total electron correction across eigenstates used in a DFT (GPAW) calculation. This function is used in the GPAW electronic-structure code to adjust occupation numbers f_j (the number of electrons occupying each eigenstate) so that the total electron count matches a desired correction. The routine implements a simple, deterministic redistribution: for a positive correction it fills lowest-energy eigenstates first (up to each state's degeneracy), and for a negative correction it empties highest-energy eigenstates first (down to zero). This is commonly used when enforcing an integer change in electron number or when correcting occupations after population analysis or mixing steps.` |
| `gpaw_sphere_integrate_radial_trapz` | `gpaw.sphere.integrate.radial_trapz` | `gpaw/sphere/integrate.py` | `f_xg: numpy.ndarray, r_g: numpy.ndarray` | `gpaw.sphere.integrate.radial_trapz computes the integral of r^2 f(r) over a radial grid using a piecewise linear (trapezoidal) rule tailored for radial integrals used in GPAW DFT calculations. This function is used in the GPAW code base to accumulate radial integrals (for example, integrals of radial parts of densities, projectors or basis-function contributions) by assuming that the radial function f(r) is sampled on a one-dimensional radial grid r_g and is linearly interpolated between consecutive grid points. For each interval r0 <= r <= r1 the integral of r^2 f(r) is evaluated analytically for the linear interpolant and the contributions from all intervals are summed. The method is exact for piecewise-linear f(r) and otherwise is an approximation whose accuracy depends on the radial grid resolution.` |
| `gpaw_sphere_integrate_radial_truncation_function_spline` | `gpaw.sphere.integrate.radial_truncation_function_spline` | `gpaw/sphere/integrate.py` | `rcut: float, drcut: float, lambd: float = None` | `Generate a spline representation of the radial truncation function Î¸(r < rcut) suitable for spherical-harmonic expansions used in GPAW's sphere integration routines. This function constructs a radial grid governed by rcut and drcut, evaluates the radial truncation function on that grid using the provided or volume-conserving lambda parameter, and returns a Spline object that encodes the l=0 spherical-harmonic expansion coefficient of the truncation. In the context of GPAW (a DFT code using the PAW method and atom-centered spherical integrations), this spline is used to smoothly truncate atom-centered functions within the cutoff radius rcut, with drcut controlling the transition width of the truncation and lambd controlling the shape so that physically important properties (for example, the truncated volume) can be conserved.` |
| `gpaw_sphere_integrate_radial_truncation_function` | `gpaw.sphere.integrate.radial_truncation_function` | `gpaw/sphere/integrate.py` | `r_g: numpy.ndarray, rcut: float, drcut: float = None, lambd: float = None` | `Generate a smooth radial truncation function Î¸(r < rc) on a radial grid and return its values on that grid. This function is used in GPAW's spherical integration and PAW-related routines to smoothly truncate radial functions at a cutoff radius rc while preserving the spherical integration volume (4Ï€ rc^3 / 3) when requested. The truncation is piecewise: the returned function Î¸(r) equals 1 well inside the cutoff, equals 0 well outside the cutoff, and interpolates smoothly in a transition region of width Î”rc centered on r = rc. The interpolation uses a nonanalytic but infinitely differentiable bump function f(x) = exp(-1/x) for x > 0 and f(x) = 0 otherwise so that all derivatives of Î¸(r) are continuous across the transition region. If drcut is not provided, a default Î”rc is chosen to match twice the local sampling spacing of the input radial grid near rcut. If lambd is not provided, it is computed to conserve the spherical integration volume using find_volume_conserving_lambd. The function performs several input validity checks and will raise AssertionError if they fail.` |
| `gpaw_sphere_integrate_truncate_radial_grid` | `gpaw.sphere.integrate.truncate_radial_grid` | `gpaw/sphere/integrate.py` | `f_xg: numpy.ndarray, r_g: numpy.ndarray, rcut: float` | `Truncate the radial-grid representation of a radial function f(r) at r = rcut. This function is used in GPAW's spherical integration utilities (gpaw.sphere.integrate) to restrict a radial sampling of a function to the interior of a sphere of radius rcut. In the context of the GPAW DFT code (which uses atom-centered spherical integrations for PAW and related operations), f_xg typically encodes values of a radial-dependent quantity (for example, radial parts of basis functions, densities or integrands) sampled on a 1D radial grid r_g; truncating at rcut is required when performing integrals or applying sphere-localized operations up to a specified cutoff radius.` |
| `gpaw_spherical_harmonics_Y0` | `gpaw.spherical_harmonics.Y0` | `gpaw/spherical_harmonics.py` | `l: int, m: int` | `Y0(l, m) A SymPy-based constructor for the spherical harmonic Y_l^m expressed in Cartesian symbols (x, y, z). This function returns a simplified SymPy expression for the angular function used in atomic, orbital and projector definitions inside GPAW's PAW and atom-centered basis-function machinery. The expression is written in the SymPy symbols x, y, z (from sympy.abc) and is normalized by the factor c = sqrt((2*l + 1) * fac(l - m) / fac(l + m) / 4 / pi) computed with SymPy's factorial and sqrt. For typical use on the unit sphere, z corresponds to cos(theta) and x,y to the Cartesian components on the unit sphere; to obtain the usual theta/phi form substitute x = sin(theta)*cos(phi), y = sin(theta)*sin(phi), z = cos(theta).` |
| `gpaw_sphere_rshe_calculate_reduced_rshe` | `gpaw.sphere.rshe.calculate_reduced_rshe` | `gpaw/sphere/rshe.py` | `rgd: tuple, f_ng: numpy.ndarray, Y_nL: numpy.ndarray, lmax: int = -1, wmin: float = None` | `gpaw.sphere.rshe.calculate_reduced_rshe Expand a scalar function sampled on a spherical grid into a RealSphericalHarmonicsExpansion and reduce the number of expansion coefficients according to significance criteria. This function is used in the GPAW DFT codebase (projector-augmented wave / atom-centered representations) to compress angular expansions of functions defined on spherical grids (for example atom-centered radial/angular functions), reducing memory use and computational cost while preserving the most significant real spherical harmonic components.` |
| `gpaw_response_tool_find_peaks` | `gpaw.response.tool.find_peaks` | `gpaw/response/tool.py` | `x: numpy.ndarray, y: numpy.ndarray, threshold: tuple = None` | `gpaw.response.tool.find_peaks locates local maxima (peaks) in a 1D curve defined by paired arrays x and y and returns their (x, y) coordinates as a numpy array. This function is intended for use in GPAW response/spectral analysis workflows (for example, finding peaks in spectra, density-of-states, or response functions computed by the GPAW DFT code) where one needs to extract positions and magnitudes of local maxima within optional x/y ranges.` |
| `gpaw_sphere_rshe_get_reduction_info_string` | `gpaw.sphere.rshe.get_reduction_info_string` | `gpaw/sphere/rshe.py` | `L_M: list, fw_gL: numpy.ndarray, rshew_L: list` | `gpaw.sphere.rshe.get_reduction_info_string: Construct a human-readable information string that summarizes which coefficients of a reduced real-spherical-harmonic expansion are included, how individual coefficients contribute, and how much of the surface norm square is covered on average by the selected subset.` |
| `gpaw_spherical_harmonics_Yarr` | `gpaw.spherical_harmonics.Yarr` | `gpaw/spherical_harmonics.py` | `L_M: list, R_Av: numpy.ndarray` | `gpaw.spherical_harmonics.Yarr computes polynomial spherical-harmonic functions identified by angular indices L_M at a batch of position vectors R_Av and returns their values as a NumPy array. This function is used in GPAWâ€™s PAW/atomic-basis machinery to evaluate monomial-based spherical harmonics (assembled from coefficient/exponent terms stored in the module-level YL table) on arrays of Cartesian coordinates for building atom-centered basis functions, projector functions, or multipole moments in DFT calculations.` |
| `gpaw_sphere_rshe_get_rshe_coefficient_info_string` | `gpaw.sphere.rshe.get_rshe_coefficient_info_string` | `gpaw/sphere/rshe.py` | `L: int, included: bool, rshew: float, fw_g: numpy.ndarray` | `Construct and return a single-line, human-readable info string describing the weight and inclusion status of one RSHE (real-space spherical-harmonic) coefficient used in GPAW reporting. This function is used in GPAW's sphere.rshe routines to present per-coefficient diagnostic information for density / potential expansions (e.g. in PAW or grid-based analyses) in text output or log files.` |
| `gpaw_spherical_harmonics_fix_exponents` | `gpaw.spherical_harmonics.fix_exponents` | `gpaw/spherical_harmonics.py` | `coeffs: dict, l: int` | `Fix exponents so every multi-index has total degree l. This function is used in the GPAW spherical harmonics code to convert a dictionary representation of polynomial/spherical-harmonic coefficients into an equivalent representation where every multi-index (nx, ny, nz) has nx + ny + nz == l. In the GPAW/PAW context, polynomial monomials or projector expansions are often organized by total angular momentum (degree) l; this routine ensures that the coefficient dictionary is expressed only in terms of multi-indices whose total degree equals the requested angular momentum l. The routine preserves symbolic coefficients (the implementation uses sympy.Number(0) as a neutral element) and accumulates contributions to the same multi-index.` |
| `gpaw_symmetry_sfrac` | `gpaw.symmetry.sfrac` | `gpaw/symmetry.py` | `f: float` | `Format a floating-point number as a simple rational fraction string for use in GPAW symmetry and crystallographic output. This function is a utility used in gpaw.symmetry to produce human-readable fractional values commonly encountered in crystallography and density-functional theory workflows (for example when writing fractional atomic coordinates, symmetry operation parameters, or lattice fractions). It returns a short textual representation: the exact string "0" when the input is exactly zero, and otherwise a "numerator/denominator" representation computed by the internal frac(f) helper. The output is intended for formatting and printing in text output files and logs produced by GPAW and related ASE-based workflows.` |
| `gpaw_spherical_harmonics_nablarlYL` | `gpaw.spherical_harmonics.nablarlYL` | `gpaw/spherical_harmonics.py` | `L: int, R: tuple` | `Compute the Cartesian gradient (partial derivatives with respect to x, y and z) of a real solid spherical harmonic of degree L evaluated at the 3D Cartesian position R. This function is part of gpaw.spherical_harmonics and is used in the GPAW codebase (a DFT/PAW electronic-structure package) wherever analytic gradients of real solid spherical harmonics are required, for example when forming angular derivatives for atom-centered basis functions, PAW augmentation terms, multipole expansions, or other operations that require âˆ‡Y_L(r) in Cartesian coordinates.` |
| `gpaw_spherical_harmonics_poly_coeffs` | `gpaw.spherical_harmonics.poly_coeffs` | `gpaw/spherical_harmonics.py` | `l: int, m: int` | `gpaw.spherical_harmonics.poly_coeffs: Compute SymPy polynomial coefficients for the spherical harmonic S(l, m) expanded as a polynomial in the Cartesian coordinates x, y and z. This function evaluates the symbolic spherical harmonic S(l, m) (as provided by the enclosing gpaw.spherical_harmonics module) and returns the non-zero coefficients of its polynomial expansion in the Cartesian variables x, y and z. In the context of GPAW (a DFT/PAW code), these coefficients are used when converting angular parts of spherical harmonics to Cartesian polynomial form, for example when constructing atom-centered projectors or basis-function angular parts. The returned mapping lists only non-zero coefficients; each key is the triple of non-negative integer exponents (nx, ny, nz) for x**nx * y**ny * z**nz and the corresponding value is the SymPy coefficient multiplying that monomial.` |
| `gpaw_tddft_spectrum_photoabsorption_spectrum` | `gpaw.tddft.spectrum.photoabsorption_spectrum` | `gpaw/tddft/spectrum.py` | `dipole_moment_file: str, spectrum_file: str, folding: str = "Gauss", width: float = 0.2123, e_min: float = 0.0, e_max: float = 30.0, delta_e: float = 0.05` | `Calculates and writes a photoabsorption spectrum (dipole strength function) from a time-dependent dipole moment file produced by a time-dependent DFT (TDDFT) simulation in the GPAW code. In the GPAW/TDDFT context this function reads a file containing the time-dependent dipole moment, computes the frequency-domain dipole strength function (units of 1/eV) that should integrate to the number of valence electrons, applies a spectral folding (broadening) kernel, converts atomic units to electronvolts (division by au_to_eV), and writes the resulting spectrum to an output file. The function performs printing and file-writing only on the MPI root process (world.rank == 0). It delegates the numerical transform and folding to helper routines (calculate_photoabsorption and write_spectrum) and prints a measure of sinc contamination computed during the processing.` |
| `gpaw_spherical_harmonics_S` | `gpaw.spherical_harmonics.S` | `gpaw/spherical_harmonics.py` | `l: int, m: int` | `gpaw.spherical_harmonics.S: SymPy representation of the real-valued spherical harmonic S_lm. This function constructs a real-valued angular function S(l,m) by forming specific real linear combinations of the complex spherical harmonics Y0(l,m) and Y0(l,-m) using SymPy objects. In the GPAW DFT/PAW context (see README), these real spherical harmonics are used as angular parts of atomic orbitals, projector functions, and PAW partial waves when a real angular basis is required instead of complex spherical harmonics. Behavior summary: for m > 0 the function returns the normalized real combination (Y0(l,m) + (-1)**m Y0(l,-m))/sqrt(2) times the phase (-1)**m; for m < 0 it returns the normalized imaginary combination -(Y0(l,m) - (-1)**m Y0(l,-m)) / (sqrt(2)*I); for m == 0 it returns Y0(l,0) unchanged. The implementation imports SymPy symbols I, Number, and sqrt at call time and depends on a module-level function or callable Y0(l, m) that provides complex spherical harmonics as SymPy expressions.` |
| `gpaw_tddft_spectrum_read_dipole_moment_file` | `gpaw.tddft.spectrum.read_dipole_moment_file` | `gpaw/tddft/spectrum.py` | `fname: str, remove_duplicates: bool = True` | `gpaw.tddft.spectrum.read_dipole_moment_file reads a time-dependent dipole moment data file produced for time-dependent density-functional theory (TDDFT) calculations in GPAW and returns the recorded kicks (applied perturbations), the time grid, the norm time series, and the dipole moment components needed for spectrum analysis. This function is used when processing TDDFT propagation outputs to build spectra or analyze time-dependent response: it calls lower-level readers (read_td_file_data and read_td_file_kicks) to parse a file containing a time column, a norm column, and one or more dipole-component columns, plus any recorded "kicks" (instantaneous perturbations). The first data column after the time column is interpreted as the norm and subsequent columns as dipole moment components. No file writing occurs; the function only reads and returns in-memory Python objects that can be consumed by post-processing routines in the GPAW TDDFT spectrum workflow.` |
| `gpaw_test_findpeak` | `gpaw.test.findpeak` | `gpaw/test/__init__.py` | `x: numpy.ndarray, y: numpy.ndarray` | `gpaw.test.findpeak finds the sub-sample peak location and peak value by fitting a quadratic (second-degree) polynomial to the three sampled points around the maximum sample. This function is used in GPAW tests and utilities to refine the location and value of a peak (for example, a spectral peak, a maximum in an energy curve, or any locally peaked 1D sampled quantity produced by DFT calculations) from discrete samples without requiring a denser grid.` |
| `gpaw_tddft_spectrum_read_td_file_kicks` | `gpaw.tddft.spectrum.read_td_file_kicks` | `gpaw/tddft/spectrum.py` | `fname: str` | `Read kicks from a GPAW time-dependent data file produced by real-time TDDFT runs and return them as a list of parsed kick records.` |
| `gpaw_tetrahedron_bja1` | `gpaw.tetrahedron.bja1` | `gpaw/tetrahedron.py` | `e1: numpy.ndarray, e2: numpy.ndarray, e3: numpy.ndarray, e4: numpy.ndarray` | `Compute the scalar and vector quantities defined in Eqs. (A2) and (C2) of BlÃ¶chl, Jepsen and Andersen. This function implements the algebraic form used in the tetrahedron integration method commonly employed in density functional theory (DFT) to obtain energy-dependent weights from the four vertex energies of a tetrahedron. It returns a scalar combination (the negative dot product of e1**3 with an intermediate factor) and a vector proportional to e1**2 times the same intermediate factor; both quantities are returned exactly as computed in the source implementation: x = 1.0/((e2 - e1)*(e3 - e1)*(e4 - e1)) and the function returns (-(e1**3).dot(x), 3 * e1**2 * x).` |
| `gpaw_symmetry_frac` | `gpaw.symmetry.frac` | `gpaw/symmetry.py` | `f: float, n: int = 120, tol: float = 1e-06` | `gpaw.symmetry.frac converts a floating-point number to a simplified rational fraction (numerator, denominator) suitable for use in symmetry and fractional-coordinate handling inside GPAW, the DFT/PAW code. The function is intended to take a float that represents a fractional coordinate or rational symmetry parameter and return small integer numerator and denominator pairs that are exact rationals used by symmetry routines and other parts of GPAW that require rational representations.` |
| `gpaw_tddft_spectrum_polarizability_spectrum` | `gpaw.tddft.spectrum.polarizability_spectrum` | `gpaw/tddft/spectrum.py` | `dipole_moment_file: str, spectrum_file: str, folding: str = "Gauss", width: float = 0.2123, e_min: float = 0.0, e_max: float = 30.0, delta_e: float = 0.05` | `gpaw.tddft.spectrum.polarizability_spectrum computes and writes a frequency-domain polarizability spectrum from a time-dependent dipole moment file produced by a real-time TDDFT calculation within GPAW. The routine reads the dipole vs time data, Fourier-transforms and folds (broadens) the raw spectrum with a chosen kernel (Gaussian or Lorentzian), converts the computed polarizability from atomic units to eV-based units, and writes the resulting energy-dependent polarizability to a text file. This function is typically used to obtain optical response quantities (absorption, polarizability) from real-time propagation outputs for analysis and plotting.` |
| `gpaw_tetrahedron_bja2b` | `gpaw.tetrahedron.bja2b` | `gpaw/tetrahedron.py` | `e1: numpy.ndarray, e2: numpy.ndarray, e3: numpy.ndarray, e4: numpy.ndarray` | `gpaw.tetrahedron.bja2b computes the four tetrahedron-integration weights (w1, w2, w3, w4) from four vertex energies using the analytic formulas given in Eq. (B7)â€“(B10) of BlÃ¶chl, Jepsen and Andersen. This function is used in GPAW's tetrahedron integration routines for density-functional theory (DFT) calculations (projector-augmented wave method) to obtain the contribution of a single tetrahedron to integrated quantities such as the density of states or band energy by linear interpolation inside the tetrahedron.` |
| `gpaw_tetrahedron_bja1b` | `gpaw.tetrahedron.bja1b` | `gpaw/tetrahedron.py` | `e1: numpy.ndarray, e2: numpy.ndarray, e3: numpy.ndarray, e4: numpy.ndarray` | `gpaw.tetrahedron.bja1b computes the BlÃ¶chlâ€“Jepsenâ€“Andersen (BJA) tetrahedron coefficients (Eq. (B2)â€“(B5) in the referenced paper) used in GPAW's tetrahedron integration routines. This function implements the algebraic form of the BJA weights: it computes the common prefactor C and the four vertex weights w1, w2, w3 and w4 from four input energy arrays corresponding to the tetrahedron vertex energies. In the context of GPAW (a density-functional theory code), these weights are used to distribute contributions (for example to density of states, occupations, or integrals over the Brillouin zone) from a tetrahedron to its four vertices.` |
| `gpaw_tddft_spectrum_read_td_file_data` | `gpaw.tddft.spectrum.read_td_file_data` | `gpaw/tddft/spectrum.py` | `fname: str, remove_duplicates: bool = True` | `gpaw.tddft.spectrum.read_td_file_data reads a whitespace-separated text file produced by a time-dependent (TD) GPAW calculation and returns the time axis and corresponding recorded observables. The function is used when processing TDDFT time-series output (for example, dipole moment components or other time-dependent observables) to prepare input arrays for spectrum analysis routines in the gpaw.tddft.spectrum workflow.` |
| `gpaw_tetrahedron_bja2` | `gpaw.tetrahedron.bja2` | `gpaw/tetrahedron.py` | `e1: numpy.ndarray, e2: numpy.ndarray, e3: numpy.ndarray, e4: numpy.ndarray` | `gpaw.tetrahedron.bja2 computes coefficient and coefficient-derivative arrays used in the analytic tetrahedron integration following Eqs. (A3) and (C3) of BlÃ¶chl, Jepsen and Andersen. This function is used in GPAW's tetrahedron-method routines for evaluating contributions to integrals over the Brillouin zone in density-functional theory (DFT) calculations: given energies at the four corners of a tetrahedron (for a set of bands or sampling points represented as 1-D arrays), it returns a scalar combination used as a weight and a 1-D array of related coefficients that enter the tetrahedron integration formulas.` |
| `gpaw_tddft_spectrum_read_magnetic_moment_file` | `gpaw.tddft.spectrum.read_magnetic_moment_file` | `gpaw/tddft/spectrum.py` | `fname: str, remove_duplicates: bool = True` | `Read time-dependent magnetic moment data file used by GPAW time-dependent DFT (TDDFT) spectrum analysis. This function parses a file produced for TD magnetic-moment time evolution and returns the recorded perturbation (kick) events and the sampled magnetic moment time series. It is used in GPAW's gpaw.tddft.spectrum workflow to load previously saved time-dependent magnetic moment data for post-processing, e.g. calculating response spectra from time-domain magnetic moments. Internally this function calls read_td_file_data(fname, remove_duplicates) to obtain the time and magnetic-moment arrays and read_td_file_kicks(fname) to obtain the list of kicks.` |
| `gpaw_tddft_spectrum_clean_td_data` | `gpaw.tddft.spectrum.clean_td_data` | `gpaw/tddft/spectrum.py` | `kick_i: list, time_t: numpy.ndarray, data_ti: numpy.ndarray` | `gpaw.tddft.spectrum.clean_td_data prunes and aligns time-dependent TDDFT data to a single perturbation ("kick") used in real-time propagation calculations. In the GPAW TDDFT spectrum workflow this function enforces that exactly one kick is present, discards all time and data samples that occur before the kick, and shifts the time axis so that the kick occurs at time zero. This alignment is necessary for correct post-processing of the time-dependent response (for example, constructing Fourier transforms to obtain excitation spectra).` |
| `gpaw_tddft_spectrum_rotatory_strength_spectrum` | `gpaw.tddft.spectrum.rotatory_strength_spectrum` | `gpaw/tddft/spectrum.py` | `magnetic_moment_files: list, spectrum_file: str, folding: str = "Gauss", width: float = 0.2123, e_min: float = 0.0, e_max: float = 30.0, delta_e: float = 0.05` | `gpaw.tddft.spectrum.rotatory_strength_spectrum calculates a rotatory strength spectrum from real-time time-dependent magnetic moment files produced by GPAW real-time TDDFT propagations. The function reads magnetic moment traces for kicks in the x, y and z directions, checks consistency of the kicks and kick strengths, folds the frequency-resolved response with a specified lineshape (Gaussian or Lorentzian), converts atomic-unit results to the CGS units used for optical rotatory strength reporting, and writes a two-column spectrum file (energy in eV and rotatory strength in 1e-40 cgs / eV) with a human-readable header describing propagation parameters and folding.` |
| `gpaw_tetrahedron_bja3` | `gpaw.tetrahedron.bja3` | `gpaw/tetrahedron.py` | `e1: numpy.ndarray, e2: numpy.ndarray, e3: numpy.ndarray, e4: numpy.ndarray` | `gpaw.tetrahedron.bja3 computes coefficients from Equations (A4) and (C4) of BlÃ¶chl, Jepsen and Andersen used in the tetrahedron integration scheme in density-functional theory (DFT) calculations performed by GPAW. The function produces one scalar and one array of coefficients that are used to form tetrahedron integration weights (for example when integrating the density of states or occupancy-related quantities over tetrahedra in reciprocal space). This implementation follows the algebra in the cited BJA equations: it forms the reciprocal of the product (e4 - e1)*(e4 - e2)*(e4 - e3) elementwise and then returns a scalar formed as len(e1) - x.dot(e4**3) together with an array 3*x*e4**2. These quantities are directly used by the GPAW tetrahedron routines to assemble integrals over energy within a tetrahedron.` |
| `gpaw_tetrahedron_count` | `gpaw.tetrahedron.count` | `gpaw/tetrahedron.py` | `fermi_level: float, eig_in: numpy.ndarray, i_ktq: numpy.ndarray` | `Count electrons using the tetrahedron interpolation method in GPAW. This function is used within GPAW (a density-functional theory code) to determine the number of electrons and the derivative of the electron count with respect to the Fermi level by evaluating eigenvalue occupations with a tetrahedron-based interpolation across k-points and bands. The routine expects raw single-particle eigenvalues (in the same energy units as the provided fermi_level) and an index array that maps tetrahedra to eigenvalue entries. The result is typically used in metallic/partial-occupation electronic-structure calculations to obtain a smooth electron count and its sensitivity to changes in the Fermi level for self-consistent-field or post-processing steps.` |
| `gpaw_tetrahedron_triangulate_everything` | `gpaw.tetrahedron.triangulate_everything` | `gpaw/tetrahedron.py` | `size_c: numpy.ndarray, ABC_tqc: numpy.ndarray, i_k: numpy.ndarray` | `Triangulate the whole Brillouin zone (BZ) by constructing a mapping from every BZ k-point and tetrahedron corner to the corresponding irreducible BZ (IBZ) k-point index. This function is used in GPAW's tetrahedron-based Brillouin zone integration machinery where the full BZ is generated from a small set of tetrahedron corner offsets (ABC_tqc) and grid sizes (size_c), and where each full-BZ k-point is mapped to an IBZ index via i_k. The practical significance is that the returned mapping i_ktq can be used to assemble integrals over all tetrahedra for properties such as density of states or BZ integrals in DFT calculations performed by GPAW.` |
| `gpaw_tetrahedron_triangulate_submesh` | `gpaw.tetrahedron.triangulate_submesh` | `gpaw/tetrahedron.py` | `rcell_cv: numpy.ndarray` | `gpaw.tetrahedron.triangulate_submesh: Compute the fixed triangulation of a hexahedral cell (the unit cube mapped by the provided real-space cell matrix) into six tetrahedra and return the Cartesian coordinates of the tetrahedra vertices. This function is used inside GPAW's tetrahedron-related routines to produce a stable decomposition of a parallelepiped cell (defined by the real-space cell matrix rcell_cv) into six non-degenerate tetrahedra. The decomposition is obtained by Delaunay triangulation of the eight corner points of the unit cube after mapping them to Cartesian coordinates with rcell_cv, followed by removal of any zero-volume (degenerate) tetrahedra. The resulting array of tetrahedra can be used for mesh generation, numerical integration, interpolation, or any other algorithm in GPAW that requires a tetrahedral subdivision of a simulation cell.` |
| `gpaw_tetrahedron_bja3b` | `gpaw.tetrahedron.bja3b` | `gpaw/tetrahedron.py` | `e1: numpy.ndarray, e2: numpy.ndarray, e3: numpy.ndarray, e4: numpy.ndarray` | `gpaw.tetrahedron.bja3b computes the elementwise tetrahedron interpolation weights w1, w2, w3 and w4 using the analytic formulas given in BlÃ¶chl, Jepsen and Andersen (Eqs. B14â€“B17). These weights are used in GPAW's tetrahedron-method integrations (for example k-point integrations and density-of-states calculations) to distribute contributions from a tetrahedron's four vertices according to their vertex energies. The implementation is vectorized and operates on NumPy arrays to produce weights for one or many energy points in a single call.` |
| `gpaw_unfold_find_K_from_k` | `gpaw.unfold.find_K_from_k` | `gpaw/unfold.py` | `k: numpy.ndarray, M: numpy.ndarray` | `Gets a k vector in scaled (fractional) coordinates and returns a mapped K vector and the unfolding integer vector G, both in scaled coordinates. This function is used in GPAW's band-structure unfolding routines to map k-points between cells (for example between a primitive cell and a supercell) and to record which reciprocal-lattice integer vector was added or subtracted during the mapping.` |
| `gpaw_tetrahedron_weights` | `gpaw.tetrahedron.weights` | `gpaw/tetrahedron.py` | `eig_in: numpy.ndarray, i_ktq: numpy.ndarray, improved: bool = False` | `Calculate occupation numbers using the tetrahedron integration scheme used in GPAW for Brillouin-zone integration and density-functional theory (DFT) calculations.` |
| `gpaw_unfold_make_colormap` | `gpaw.unfold.make_colormap` | `gpaw/unfold.py` | `main_color: str` | `Create a matplotlib LinearSegmentedColormap tailored for GPAW unfolding plots. This function constructs a custom colormap named 'mymap' that is used by gpaw.unfold plotting utilities such as plot_spectral and plot_band_structure. The colormap maps normalized scalar values in the range [0.0, 1.0] to RGBA colors by defining per-channel control points (position, left-value, right-value) at normalized positions 0.0, 0.25, 0.5 and 1.0. The selected main_color selects which RGB channel is emphasized and determines the per-channel control-point dictionary (cdict). The 'green' variant additionally defines an 'alpha' channel to introduce a varying transparency across the colormap. This function performs an import from matplotlib.colors and returns a LinearSegmentedColormap instance suitable for use with matplotlib plotting routines that visualize electronic densities, spectral functions, or band weights produced by GPAW.` |
| `gpaw_upf_parse_upf` | `gpaw.upf.parse_upf` | `gpaw/upf.py` | `fname: str` | `Parse UPF pseudopotential file and return a dictionary of parsed pseudopotential data used by GPAW for PAW/DFT calculations. This function reads a UPF (Unified Pseudopotential Format) file from the path given by fname and produces a structured dictionary containing header metadata, radial meshes, local and non-local potentials, projector data, pseudo-wavefunctions, and atomic reference density. GPAW uses these parsed fields when constructing pseudopotentials and projector-augmented-wave components for plane-wave, real-space, or atom-centered-basis calculations. The parser accepts both (mostly) XML-like UPF files and the older non-well-formed FORTRAN-style variants: when the root XML parsing fails the file is wrapped in a synthetic <xml>â€¦</xml> root and reparsed. The parser also recognizes files marked version "2.0.1" (v201) and applies version-specific conversions and type coercions.` |
| `gpaw_unfold_plot_spectral_function` | `gpaw.unfold.plot_spectral_function` | `gpaw/unfold.py` | `filename: str, color: str = "blue", eref: float = None, emin: float = None, emax: float = None, scale: float = 1` | `Plot the spectral function corresponding to a band-structure k-point path and display/save it as a PNG image. This function is used in the GPAW unfolding context to visualize the spectral function A(k, E) along a path of k-points (the same quantity used to interpret band-structure and many-body spectral features in density-functional-theory (DFT) workflows). It reads precomputed data from a pickle file produced by the unfolding routines, normalizes and (optionally) shifts the energy axis, converts the spectral function to an image using a colormap, draws k-point tick marks and special-point labels, saves the image to disk, and opens a matplotlib window showing the result. The spectral intensity is normalized to its maximum and then multiplied by the provided scale factor so intensities are shown between 0 and 1 (colormap vmin/vmax = 0/1).` |
| `gpaw_utilities_divrl` | `gpaw.utilities.divrl` | `gpaw/utilities/__init__.py` | `a_g: numpy.ndarray, l: int, r_g: numpy.ndarray` | `gpaw.utilities.divrl: divide a radial-array by r**l with safe extrapolation to the origin. This utility is used in GPAW (a DFT code based on the PAW method and real-space/ radial grids) to convert a radial quantity that scales as r**l into a regular function at the origin by dividing by r**l on the nonzero radial grid points and estimating the value at the origin by a small-r extrapolation. In practical GPAW workflows this is useful for processing radial parts of partial waves, projector functions, augmentation quantities or any spherical-harmonic component that behaves like r**l times a smooth function near r = 0.` |
| `gpaw_unfold_plot_band_structure` | `gpaw.unfold.plot_band_structure` | `gpaw/unfold.py` | `e_mK: numpy.ndarray, P_mK: numpy.ndarray, x: numpy.ndarray, X: list, points_name: list, weights_mK: numpy.ndarray = None, color: str = "red", fit: bool = True, nfit: int = 200` | `Plot band structure using projection weights P_mK and show each band-state as a filled circle whose color and size encode projection weight information used in unfolding analyses in density-functional theory (DFT) calculations performed with GPAW.` |
| `gpaw_utilities_h2gpts` | `gpaw.utilities.h2gpts` | `gpaw/utilities/__init__.py` | `h: float, cell_cv: numpy.ndarray, idiv: int = 4` | `Convert a desired real-space grid spacing into a number of grid points per cell direction used by GPAW. This utility function is part of gpaw.utilities and is used by GPAW (a DFT code using real-space uniform grids and multigrid methods) to convert a target real-space grid spacing (h) and a Cartesian unit cell (cell_cv) into an integer number of grid points along each of the three cell directions. The returned grid-point counts are rounded to the nearest multiple of idiv and are enforced to be at least idiv. This is important in GPAW for constructing real-space grids that match desired spatial resolution, for ensuring compatibility with multigrid coarsening/solver levels and with algorithms that require grid dimensions divisible by a small integer block size.` |
| `gpaw_utilities_method` | `gpaw.utilities.method` | `gpaw/utilities/__init__.py` | `A: numpy.ndarray` | `gpaw.utilities.method: Pack off-diagonal sum used by GPAW to compress Hermitian 2D arrays (for example density or overlap matrices) into a 1D vector by summing symmetric off-diagonal elements. This packing is used in GPAW (a density-functional theory code) to reduce storage and to prepare matrix data for communication, serialization, or algorithms that operate on the independent elements of a Hermitian matrix. This function expects a square, two-dimensional numpy array that represents a Hermitian matrix (real or complex). It transforms an n x n matrix A into a 1D numpy.ndarray of length n*(n+1)//2 by iterating over the upper triangular part (including diagonal) and, for off-diagonal elements, storing the sum a_ij + a_ji. For example, the 3x3 matrix / a00 a01 a02 \| a10 a11 a12 \| \ a20 a21 a22 / is transformed to the vector (a00, a01 + a10, a02 + a20, a11, a12 + a21, a22) which corresponds to scanning rows i = 0..n-1 and for each i appending elements for j = i..n-1: a_ij + a_ji (with diagonal elements appearing unchanged).` |
| `gpaw_utilities_uncamelcase` | `gpaw.utilities.uncamelcase` | `gpaw/utilities/__init__.py` | `name: str` | `gpaw.utilities.uncamelcase converts a CamelCase identifier into a space-separated, human-readable string of words. This is used in the GPAW DFT codebase to turn programmatic names (for example class names, mode identifiers, or option keys) into labels suitable for log output, user-facing messages, simple GUIs, or documentation where readable words are preferred over concatenated identifiers. The function uses the regular expression pattern '([A-Z]{1}[a-z]+)' to split the input string into segments consisting of an uppercase letter followed by one or more lowercase letters; it then joins the non-empty segments with a single ASCII space. Because of this pattern, acronyms or runs of consecutive uppercase letters that are not followed by lowercase letters remain attached to adjacent segments (for example, "XMLParser" becomes "XML Parser" because "Parser" matches the pattern while "XML" does not). The function makes no modifications to digits, underscores, punctuation, or existing spaces beyond the splitting described here.` |
| `gpaw_utilities_element_from_packed` | `gpaw.utilities.element_from_packed` | `gpaw/utilities/__init__.py` | `M: numpy.ndarray, i: int, j: int` | `gpaw.utilities.element_from_packed returns a single matrix element from a packed array created by the corresponding pack routine used in GPAW. It reconstructs the (i, j) entry of a square matrix stored in a compact 1D packed format that represents the diagonal and off-diagonal elements of symmetric or Hermitian matrices that commonly appear in density-functional theory (DFT) calculations (for example, overlap, density, or Hamiltonian matrices in GPAW). This function computes the matrix dimension n from the length of the packed array, looks up the packed index for the (i, j) pair using packed_index, and then returns the stored diagonal value or the appropriately scaled/conjugated off-diagonal value so that the returned value corresponds to the original full matrix element. It performs no in-place modifications of M.` |
| `gpaw_utilities_acwf_work` | `gpaw.utilities.acwf.work` | `gpaw/utilities/acwf.py` | `structure: str, symbol: str, setup_name: str = "", mode: str = "pw"` | `Do single equation-of-state (EOS) calculations using the PBE exchange-correlation functional and write results to a JSON file.` |
| `gpaw_utilities_pack_hermitian` | `gpaw.utilities.pack_hermitian` | `gpaw/utilities/__init__.py` | `M2: numpy.ndarray, tolerance: float = 1e-10` | `Pack Hermitian matrices into a compact 1D representation used in GPAW for storage and transport of Hermitian operators (for example density matrices, Hamiltonians, overlap matrices) where only the independent upper-triangle elements and diagonals are needed. This function is used in the GPAW code base to reduce memory and communication costs by converting an n x n Hermitian matrix into a packed vector of length n*(n+1)//2. When given a 3D array it applies the same packing to each 2D slice (useful for batches of matrices, e.g., k-point or spin channels).` |
| `gpaw_utilities_packed_index` | `gpaw.utilities.packed_index` | `gpaw/utilities/__init__.py` | `i1: int, i2: int, ni: int` | `gpaw.utilities.packed_index returns a single integer index corresponding to a pair of matrix indices (i1, i2) when a symmetric ni x ni matrix is stored in packed one-dimensional form. This function is used within GPAW (a density-functional theory code) to reduce memory and improve cache locality by storing only the triangular part of symmetric or Hermitian matrices (for example, overlap, density or Hamiltonian blocks) in a linear array. The mapping is symmetric: the pair (i1, i2) and (i2, i1) produce the same packed index so that a single stored value represents both symmetric matrix elements.` |
| `gpaw_utilities_acwf_reference_structure` | `gpaw.utilities.acwf.reference_structure` | `gpaw/utilities/acwf.py` | `symbol: str, name: str` | `Create and return an ASE Atoms object for a specified ACWF structure scaled to the WIEN2K reference volume. This function gpaw.utilities.acwf.reference_structure selects an ACWF structure template from the module-level acwf_structures mapping using the provided name, makes a copy of that template to avoid mutating the global template, and scales the unit cell and atomic positions so that the resulting cell volume matches the WIEN2K reference volume for the given chemical element symbol as stored in the module-level volumes mapping. For two oxygen-containing ACWF names ('X4O10' and 'XO') a cube-root-of-two correction is applied to the linear scaling factor to account for a difference in formula-unit convention in the stored WIEN2K volumes. After scaling, any placeholder atomic numbers equal to 0 in the structure template are replaced with the atomic number for the provided element symbol using the module-level atomic_numbers mapping. The returned Atoms object is suitable for use in GPAW DFT calculations and ASE-based workflows where a standardized reference lattice (WIEN2K volume) is required.` |
| `gpaw_utilities_unpack_hermitian` | `gpaw.utilities.unpack_hermitian` | `gpaw/utilities/__init__.py` | `M: numpy.ndarray` | `gpaw.utilities.unpack_hermitian unpacks a 1D packed representation of a Hermitian matrix (produced by the companion pack_hermitian routine) into a full 2D numpy.ndarray. This routine is used in GPAW to reconstruct full Hermitian matrices that are compressed for storage or communication (for example, when storing triangular matrix elements such as overlap, density, or Hamiltonian blocks in DFT workflows). The function accepts either a single packed 1D array or a 2D array whose rows are independent packed arrays and returns the corresponding full Hermitian matrix or a stack of matrices.` |
| `gpaw_utilities_unpack_density` | `gpaw.utilities.unpack_density` | `gpaw/utilities/__init__.py` | `M: numpy.ndarray` | `Unpack a packed density representation into a full 2D Hermitian density matrix. This function is used in GPAW to reconstruct density matrices (Hermitian arrays used in density-functional theory calculations) from a compact packed representation produced by the corresponding pack_density routine. The packed representation is typically used for compact storage or communication of the independent elements of a Hermitian density matrix. unpack_density reverses that packing by first calling unpack_hermitian on the packed data and then applying a fixed rescaling: all matrix elements are multiplied by 0.5 and the diagonal elements are multiplied by 2 to restore the original diagonal magnitudes. For batch inputs (2D arrays), each row is treated as a separate packed vector and unpacked independently into a full Hermitian matrix; the result is a stacked array of unpacked matrices.` |
| `gpaw_utilities_unpacked_indices` | `gpaw.utilities.unpacked_indices` | `gpaw/utilities/__init__.py` | `p: int, ni: int` | `gpaw.utilities.unpacked_indices returns the pair of 0-based matrix indices (i, j) that correspond to a linear packed index p into the upper triangle (including the diagonal) of an ni-by-ni square matrix. This function is used in GPAW to map a single packed index used for memory- and performance-efficient storage of symmetric matrices (for example, density or overlap matrices in DFT calculations) back to its two-dimensional coordinates in the full matrix. The packed ordering enumerates entries row by row for the upper triangle: (0,0), (0,1), ..., (0,ni-1), (1,1), (1,2), ..., (ni-1,ni-1).` |
| `gpaw_utilities_blas_axpy` | `gpaw.utilities.blas.axpy` | `gpaw/utilities/blas.py` | `alpha: float, x: numpy.ndarray, y: numpy.ndarray` | `gpaw.utilities.blas.axpy: In-place BLAS-style axpy operation that updates a target vector y with a scaled source vector x according to y <- alpha * x + y. This routine is a small, performance-critical building block used throughout GPAW for linear-algebra vector updates (for example in iterative solvers, multigrid operations and other routines that rely on BLAS semantics) and dispatches to a type-specific implementation based on the NumPy dtype of x. This function performs the numeric operation elementwise and modifies y in-place. It requires both x and y to be contiguous NumPy arrays (C- or Fortran-contiguous as indicated by x.flags.contiguous / y.flags.contiguous) and flattens them with ravel() before calling the backend implementation. If x has zero elements the function returns immediately and y is left unchanged.` |
| `gpaw_utilities_blas_gemmdot` | `gpaw.utilities.blas.gemmdot` | `gpaw/utilities/blas.py` | `a: numpy.ndarray, b: numpy.ndarray, alpha: float = 1.0, beta: float = 1.0, out: numpy.ndarray = None, trans: str = "n"` | `Matrix multiplication using BLAS GEMM for GPAW linear-algebra operations. This function performs the operation out <- alpha * a . b + beta * out using a BLAS gemm routine (via the internal mmmx wrapper) and is intended for dense linear algebra operations that occur throughout GPAW (for example, multiplying blocks of arrays that represent coefficients, density matrices, or intermediate operators in DFT calculations). The implementation maps inputs with arbitrary leading dimensions to 2D matrices, calls a high-performance GEMM implementation, and then reshapes the result back to the appropriate multi-dimensional shape expected by GPAW code paths.` |
| `gpaw_utilities_blas_to2d` | `gpaw.utilities.blas.to2d` | `gpaw/utilities/blas.py` | `array: numpy.ndarray` | `gpaw.utilities.blas.to2d returns a 2D NumPy array view (or copy when necessary) by preserving the original array's first axis and flattening all remaining axes into the second axis. This utility is used in GPAW's BLAS-related code to present multidimensional data (for example, blocks of wavefunction coefficients, density matrices, or batched vectors) as 2D matrices suitable for BLAS/ScaLAPACK routines and other linear-algebra operations required by the DFT calculations described in the README.` |
| `gpaw_utilities_blas_gpu_dotu` | `gpaw.utilities.blas.gpu_dotu` | `gpaw/utilities/blas.py` | `a: numpy.ndarray, b: numpy.ndarray` | `gpaw.utilities.blas.gpu_dotu: Compute the element-wise dot product on the GPU without conjugating the first vector for complex inputs. Performs the operation sum_ijk... a[ijk...] * b[ijk...] using the GPU-backed C routine cgpaw.dotu_gpu. This function is intended for high-performance linear-algebra kernels inside GPAW (a DFT code that relies on BLAS and optional GPU acceleration) where a bilinear dot product (no conjugation of the first argument) is required rather than the Hermitian inner product. The computation delegates to the underlying GPU implementation and reads raw device pointers from the NumPy array buffer objects (a.data.ptr and b.data.ptr). Behavior and side effects: This function assumes that the input arrays refer to memory laid out contiguously in a single buffer and that both arrays have identical shapes and compatible numeric dtypes. In debug builds (module-level debug is True) these conditions are asserted: both arrays must be contiguous and both must have either a floating or a complex dtype, and their shapes must match. When debug is False the function does not perform Python-level validation and invalid inputs (non-contiguous arrays, mismatched shapes, or incompatible dtypes) will be passed directly to the C/GPU routine, which may raise an exception or produce undefined results. The function calls the C extension cgpaw.dotu_gpu and therefore requires that the corresponding native extension is available; if it is not available, calling this function will raise an ImportError or other exception from the underlying call.` |
| `gpaw_utilities_blas_gpu_dotc` | `gpaw.utilities.blas.gpu_dotc` | `gpaw/utilities/blas.py` | `a: numpy.ndarray, b: numpy.ndarray` | `gpaw.utilities.blas.gpu_dotc computes the dot product of two equally-shaped NumPy arrays, conjugating the first array when the arrays have complex dtype, and performs the computation using the GPAW GPU BLAS backend (cgpaw.dotc_gpu). This function is used in GPAW DFT codepath to obtain inner products/overlaps of discretized wavefunctions or other field arrays stored as NumPy arrays; using the GPU implementation accelerates linear-algebra operations in high-performance electronic-structure calculations. This function computes the scalar sum_{ijk...} conj(a[ijk...]) * b[ijk...] where conj() denotes complex conjugation applied to elements of a when a is complex. For real-valued arrays the operation reduces to the standard dot product sum_{ijk...} a[ijk...] * b[ijk...]. The operation is performed over all elements of the arrays; multi-dimensional arrays are treated elementwise and collapsed into a single scalar result.` |
| `gpaw_utilities_blas_gpu_r2k` | `gpaw.utilities.blas.gpu_r2k` | `gpaw/utilities/blas.py` | `alpha: float, a: numpy.ndarray, b: numpy.ndarray, beta: float, c: numpy.ndarray, trans: str = "c"` | `gpaw.utilities.blas.gpu_r2k launches the compiled cgpaw.r2k_gpu routine to perform a BLAS-like rank-2k update using either the GPU or CPU implementation available in the cgpaw extension. In the GPAW DFT codebase this function is used to accelerate linear-algebra kernels (for example updates of density- or Hamiltonian-related matrices) by forwarding raw numpy array memory and shape information to the low-level C/CUDA implementation.` |
| `gpaw_utilities_blas_gpu_gemv` | `gpaw.utilities.blas.gpu_gemv` | `gpaw/utilities/blas.py` | `alpha: float, a: numpy.ndarray, x: numpy.ndarray, beta: float, y: numpy.ndarray, trans: str = "t"` | `gpaw.utilities.blas.gpu_gemv performs a GPU-accelerated general matrix-vector product (BLAS level-2) used throughout GPAW for operations such as applying matrix operators to state vectors in density-functional theory workflows. The function computes the in-place update y <- alpha * a.x + beta * y where the meaning of the matrix-vector product a.x depends on the trans parameter and the dimensionality of a. This routine delegates the heavy work to the underlying cgpaw.gemv_gpu implementation and is intended to provide a fast, device-accelerated alternative to NumPy dot for the specific array/layout conventions used in GPAW.` |
| `gpaw_utilities_blas_gpu_mmm` | `gpaw.utilities.blas.gpu_mmm` | `gpaw/utilities/blas.py` | `alpha: float, a: numpy.ndarray, opa: str, b: numpy.ndarray, opb: str, beta: float, c: numpy.ndarray` | `gpaw.utilities.blas.gpu_mmm launches the compiled C extension implementation of a general dense matrix-matrix multiplication (GEMM) used by GPAW linear-algebra code. The function delegates the work to cgpaw.mmm_gpu which typically executes a GPU-accelerated kernel when GPAW was built with GPU support; otherwise the compiled extension may execute a CPU implementation. This routine implements the BLAS-like operation C <- alpha * op(A) * op(B) + beta * C and is used inside GPAW for performance-critical dense linear-algebra operations that appear, for example, in Hamiltonian and overlap matrix manipulations.` |
| `gpaw_utilities_blas_gpu_rk` | `gpaw.utilities.blas.gpu_rk` | `gpaw/utilities/blas.py` | `alpha: float, a: numpy.ndarray, beta: float, c: numpy.ndarray, trans: str = "c"` | `gpaw.utilities.blas.gpu_rk launches the GPAW C-extension implementation of the rank-k update routine (rk) and dispatches it to a CPU or GPU backend. This wrapper is used inside GPAW's linear-algebra/BLAS utilities to perform a scaled rank-k update on the matrix represented by c using data from a, enabling accelerated dense-matrix operations that occur frequently in density-functional-theory (DFT) calculations implemented by GPAW. The function is a thin Python wrapper that passes raw array pointers, shapes, and dtype information to the cgpaw.rk_gpu routine; it therefore enforces requirements on the provided NumPy arrays (memory layout and pointer accessibility) and performs the update in-place on c.` |
| `gpaw_utilities_ekin_dekindecut` | `gpaw.utilities.ekin.dekindecut` | `gpaw/utilities/ekin.py` | `G: numpy.ndarray, de: numpy.ndarray, ecut: float` | `gpaw.utilities.ekin.dekindecut: Compute a linear interpolation of the array de at the reciprocal-space magnitude corresponding to a plane-wave kinetic-energy cutoff and return the value normalized by that magnitude. This function is used in GPAW's plane-wave related utilities to estimate the slope/value of a spectral quantity (de) at the cutoff boundary defined by ecut; in the GPAW codebase this helps determine contributions at the kinetic energy cutoff when working with plane-wave expansions and related extrapolations.` |
| `gpaw_utilities_dos_delta` | `gpaw.utilities.dos.delta` | `gpaw/utilities/dos.py` | `x: numpy.ndarray, x0: float, width: float, mode: str = "Gauss"` | `Return a normalized approximation to the Dirac delta function centered at x0 on a numerical grid. This function is used in GPAW's DOS (density of states) and spectral-broadening utilities to convert discrete eigenvalues into a smooth spectral distribution. Given a numerical grid x (for example an energy grid in eV when using ASE/GPAW energy units), delta(x, x0, width, mode) produces a normalized kernel (area = 1) located at x0 with a controllable broadening width and choice of functional form. The default mode 'Gauss' is the common Gaussian broadening used to smooth DOS; 'Lorentz' gives the Lorentzian (Cauchy) shape often used to model lifetime broadening.` |
| `gpaw_utilities_dos_fold` | `gpaw.utilities.dos.fold` | `gpaw/utilities/dos.py` | `energies: list, weights: list, npts: int, width: float, mode: str = "Gauss"` | `gpaw.utilities.dos.fold: Compute a broadened density-of-states (DOS) by placing a weighted delta kernel at each supplied energy and summing them on a uniform energy grid. This function is used in the GPAW DFT post-processing workflow to convert a discrete set of eigenvalues (energies) and their spectral weights into a continuous DOS by folding each discrete level with a finite-width kernel. The output energy axis and DOS are suitable for plotting, further analysis, or comparison with experiments. The routine determines the energy window automatically from the supplied energies and the broadening width, constructs an evenly spaced grid with npts points, and calls the module-local delta(e, e0, width, mode=mode) routine to generate the broadened contribution of each level.` |
| `gpaw_utilities_hardware_dhms` | `gpaw.utilities.hardware.dhms` | `gpaw/utilities/hardware.py` | `secs: float` | `gpaw.utilities.hardware.dhms converts a duration given in seconds into a four-element list representing days, hours, minutes and seconds. This utility is intended for formatting and reporting elapsed wall-clock or CPU time (for example in GPAW calculation logs and performance messages) where a human-readable decomposition of a floating-point seconds value is required.` |
| `gpaw_utilities_gl_quadrature_gauss` | `gpaw.utilities.gl_quadrature.gauss` | `gpaw/utilities/gl_quadrature.py` | `xmin: float, xmax: float, funct: int, ng: int = 10` | `gpaw.utilities.gl_quadrature.gauss computes a one-dimensional Gauss (Gaussian) quadrature approximation of the definite integral of an integrand over a finite interval. This function is used in the GPAW codebase (a DFT package) for numerically evaluating integrals that arise in electronic-structure calculations where a high-accuracy weighted sum over predefined Gauss nodes and weights on the reference interval [-1, 1] is mapped to the target interval [xmin, xmax]. The implementation uses precomputed node and weight tables (_nodes and _weights) and applies the linear change of variables x = 0.5*(dx*y + xmin + xmax), with weight factor 0.5*dx, where dx = xmax - xmin. The weight function is 1.0 (i.e., ordinary Gauss-Legendre quadrature).` |
| `gpaw_utilities_hardware_hms_string` | `gpaw.utilities.hardware.hms_string` | `gpaw/utilities/hardware.py` | `secs: float` | `Return a human-readable hours:minutes:seconds string for a duration given in seconds. This utility is used throughout GPAW's timing and logging utilities to present elapsed wall-clock or CPU time in a compact, human-readable form (for example in progress output, log files, and test diagnostics). The function converts a duration expressed in seconds into integer hours, minutes and seconds using the internal helper hms(secs) and then formats each component as a two-digit field when appropriate.` |
| `gpaw_utilities_hilbert_analytic_transforms` | `gpaw.utilities.hilbert.analytic_transforms` | `gpaw/utilities/hilbert.py` | `x: numpy.ndarray` | `gpaw.utilities.hilbert.analytic_transforms returns a pair of analytic example functions and their Hilbert transforms evaluated elementwise on a real-valued numpy array of sample points. This utility is intended for use in the GPAW code base (e.g., for testing and validating numerical Hilbert-transform routines used in DFT-related frequency-domain analyses and Kramersâ€“Kronig relations) by providing known, closed-form transforms. The function evaluates four analytic functions at every entry of the input array x and returns two lists of numpy.ndarray: the first list contains the function values and the second list contains the corresponding Hilbert transforms in the same order. The four function/Hilbert-transform pairs (in order) are: - sin(x) and cos(x) - cos(x) and -sin(x) - sinc(x) = sin(x)/x (with the analytic limit 1 at x == 0) and (cos(x) - 1)/x (with the analytic limit 0 at x == 0) - 1/(1 + x**2) and -x/(1 + x**2)` |
| `gpaw_utilities_hilbert_hilbert_kernel_simple` | `gpaw.utilities.hilbert.hilbert_kernel_simple` | `gpaw/utilities/hilbert.py` | `n: int` | `gpaw.utilities.hilbert.hilbert_kernel_simple constructs the discrete Hilbert-transform kernel in Fourier space for a grid of n points. It returns the array that represents the discrete Fourier transform of 1/x on a uniform grid and is intended for use in GPAW utilities that perform Hilbert transforms or analytic-signal operations via FFTs on real-space or reciprocal-space grids.` |
| `gpaw_utilities_hardware_hms` | `gpaw.utilities.hardware.hms` | `gpaw/utilities/hardware.py` | `secs: float` | `gpaw.utilities.hardware.hms converts a time interval given in seconds into a three-component list representing hours, minutes and seconds, intended for human-readable timing and logging within the GPAW hardware/timing utilities. This utility computes hours by floor-dividing the input seconds by 3600, computes remaining whole minutes from the remainder, and computes seconds by taking the remaining fractional seconds and rounding to the nearest integer using the int(s + 0.5) rule. The function is pure (no side effects) and returns a short list of integers that callers can format for display in GPAW logs, test output, or timing summaries.` |
| `gpaw_utilities_hilbert_hilbert_kernel_interpolate` | `gpaw.utilities.hilbert.hilbert_kernel_interpolate` | `gpaw/utilities/hilbert.py` | `n: int` | `gpaw.utilities.hilbert.hilbert_kernel_interpolate constructs the discrete Hilbert transform kernel on a periodic grid of n points. The kernel produced is the discrete Hilbert transform of the linear interpolation kernel L(s) = (1 - \|s\|) Heaviside(1 - \|s\|), and is returned in the Fourier/spectral representation used by GPAW utilities for Hilbert-transform-based interpolation and convolution operations in DFT-related real-space grid routines. This function is used within the GPAW code base to generate a spectral operator that implements the Hilbert transform corresponding to a linear interpolation kernel. In practical terms, the returned array can be multiplied with the FFT of a sampled function on an n-point grid to apply the Hilbert-transform interpolation operator in spectral space. The implementation builds a compact finite-difference-like representation on the real-space grid, computes its discrete Fourier transform, and returns the Fourier-domain kernel scaled by -1/pi, consistent with the continuous Hilbert transform normalization used in GPAW utilities.` |
| `gpaw_utilities_hilbert_hilbert` | `gpaw.utilities.hilbert.hilbert` | `gpaw/utilities/hilbert.py` | `f: numpy.ndarray, ker: numpy.ndarray = None, nfft: int = None, axis: int = 0, kerneltype: str = "interpolate", translate: float = 0` | `Compute the Hilbert transform of an array along a specified axis by performing a convolution with a Hilbert kernel in Fourier space. This utility is part of the gpaw.utilities package used within the GPAW density-functional-theory codebase for array-level operations that arise in DFT post-processing (for example, Fourier-domain convolutions of frequency- or grid-dependent response functions). The function computes the convolution via FFTs, optionally generating a Hilbert kernel appropriate for the chosen kerneltype, applying an optional (possibly non-integer) translation of the input along the transform axis, and returning the transformed array truncated to the original grid length along that axis.` |
| `gpaw_utilities_gl_quadrature_gaussLog` | `gpaw.utilities.gl_quadrature.gaussLog` | `gpaw/utilities/gl_quadrature.py` | `xmin: float, xmax: float, funct: int, ng: int = 10` | `Gauss quadrature integration on [xmin, xmax] tailored for integrands with a logarithmic singularity at x = xmin, used in GPAW for numerical integration tasks where a log singularity occurs at the lower integration boundary. This function evaluates a Gauss-type quadrature that accounts for a log singularity at the left endpoint of the integration interval. It maps precomputed logarithm-aware quadrature nodes and weights from module-level arrays (_nodesLog and _weightsLog) to the interval [xmin, xmax], calls the provided integrand at each mapped node, and returns the weighted sum multiplied by the interval length. It is used in GPAW numerical routines where integrals contain log(x - xmin)-type singular behavior and where accurate, fixed-order quadrature is required.` |
| `gpaw_utilities_scalapack_pblas_symm` | `gpaw.utilities.scalapack.pblas_symm` | `gpaw/utilities/scalapack.py` | `alpha: float, a_MM: numpy.ndarray, b_MN: numpy.ndarray, beta: float, c_MN: numpy.ndarray, desca: tuple, descb: tuple, descc: tuple, side: str = "L", uplo: str = "L"` | `gpaw.utilities.scalapack.pblas_symm performs a distributed symmetric matrixâ€“matrix product using the PBLAS/ScaLAPACK interface used in GPAW for parallel linear algebra. It wraps the corresponding PBLAS routines (pzsymm for complex matrices and pdsymm for real matrices) and applies the operation C <- alpha*A*B + beta*C when side == 'L', or C <- alpha*B*A + beta*C when side == 'R'. Only the lower or upper triangle of the symmetric matrix a_MM is read, as controlled by the uplo argument. This function is intended for use in GPAW workflows that rely on ScaLAPACK/BLACS distributed matrices and descriptors for parallel DFT/linear-algebra computations.` |
| `gpaw_utilities_blas_gpu_gemm` | `gpaw.utilities.blas.gpu_gemm` | `gpaw/utilities/blas.py` | `alpha: float, a: numpy.ndarray, b: numpy.ndarray, beta: float, c: numpy.ndarray, transa: str = "n"` | `General Matrix Multiply executed on GPU for GPAW internal linear algebra. Performs the blocked/general matrix multiplication and accumulation used throughout GPAW's linear-algebra kernels and DFT routines. The operation performed is c <- alpha * (b.a) + beta * c where the binary operation (b.a) depends on the value of transa (see below). This function is a thin Python wrapper that forwards raw array pointers to the low-level cgpaw.gemm_gpu routine; it is intended to accelerate BLAS-level GEMM operations on GPU hardware within GPAW's numerical workflows (for example, updates of block matrices or application of operators in plane-wave/real-space representations). Behavior and practical significance: This function multiplies and accumulates multi-dimensional arrays used in GPAW's matrix algebra. The layout conventions and contiguity requirements are important for correct and efficient GPU execution: the arrays are expected to expose C-contiguous memory and a .data.ptr pointer (used by the underlying cgpaw.gemm_gpu call). When used with debug checks enabled in the GPAW build (global debug flag True), a number of assertions verify dtype, contiguity, and shape compatibility and will raise AssertionError on mismatch. On success the result is written in-place into c; the function does not return a new array. Index definitions of b.a: If transa == 'n', b.a denotes the matrix multiplication with implicit summation over index p: (b.a)_{ijkl...} = sum_p b_{ip} * a_{pjkl...} This corresponds to multiplying a 2-D matrix b on the left of a possibly higher-rank array a when a is treated with its first axis as the contracted dimension. If transa == 't' or transa == 'c', b.a denotes the multiplication (b.a)_{ij} = sum_{klm...} b_{iklm...} * a_{jklm...} and if transa == 'c' the complex conjugate of a is taken before contraction. This mode is used when b and a share trailing dimensions and the contraction is over those trailing dimensions.` |
| `gpaw_utilities_scalapack_scalapack_tri2full` | `gpaw.utilities.scalapack.scalapack_tri2full` | `gpaw/utilities/scalapack.py` | `desc: tuple, array: numpy.ndarray, conj: bool = True` | `Write the lower triangular part of a ScaLAPACK-distributed matrix into its upper triangular part so that the full matrix becomes symmetric or Hermitian. This function is used in GPAW's ScaLAPACK utilities when a distributed routine produces only the lower-triangular half of a matrix (common in parallel linear-algebra workflows such as distributed eigenvalue or density-matrix construction) and the full matrix (symmetric or Hermitian) is required. The implementation is an explicit three-step procedure: zero the current upper triangle, copy the local array, clear the diagonal in the copy, and then transpose-add the copy into the original array. This produces A := A + transpose_or_conjtranspose(A_with_zero_diag) so that the lower-triangular data are reflected into the upper triangle.` |
| `gpaw_utilities_tools_dagger` | `gpaw.utilities.tools.dagger` | `gpaw/utilities/tools.py` | `a: numpy.ndarray, copy: bool = True` | `gpaw.utilities.tools.dagger â€” Return Hermitian conjugate of input array Compute the Hermitian conjugate (conjugate transpose) of a NumPy array. In the GPAW codebase (a DFT/PAW/ASE-based electronic-structure package), this operation is commonly used in linear-algebra manipulations such as forming bra/kets, overlap matrices, and conjugate-transpose operations on coefficient or operator matrices. By default the function returns a new NumPy array containing the conjugated transpose. For performance-sensitive internal code paths, an in-place variant is available that may overwrite the original array memory (use with care).` |
| `gpaw_utilities_tools_cutoff2gridspacing` | `gpaw.utilities.tools.cutoff2gridspacing` | `gpaw/utilities/tools.py` | `E: float` | `gpaw.utilities.tools.cutoff2gridspacing converts a plane-wave kinetic energy cutoff to the equivalent real-space uniform grid spacing used in GPAW real-space calculations.` |
| `gpaw_utilities_tools_gram_schmidt` | `gpaw.utilities.tools.gram_schmidt` | `gpaw/utilities/tools.py` | `U: numpy.ndarray` | `gpaw.utilities.tools.gram_schmidt: Orthonormalize the columns of a matrix U in-place using the classical Gram-Schmidt procedure. This function implements the classical Gram-Schmidt algorithm to produce a set of orthonormal column vectors from the columns of the input array U. In the context of GPAW (a density-functional theory code that works with wavefunction coefficient matrices, basis-function coefficients, and real-space discretizations), this routine is used to convert a collection of (possibly non-orthogonal) vectors into an orthonormal basis suitable for subsequent linear-algebra operations such as projections, subspace diagonalization, or construction of orthonormalized wavefunctions. The implementation uses the complex-conjugate inner product (numpy.dot(col2.conj(), col)) and normalizes with numpy.linalg.norm, so it supports real or complex-valued arrays.` |
| `gpaw_utilities_tools_normalize` | `gpaw.utilities.tools.normalize` | `gpaw/utilities/tools.py` | `U: numpy.ndarray` | `Normalize columns of U. This function normalizes each column vector of the input array U in place using the Euclidean (L2) norm. In the GPAW DFT codebase (which represents physical quantities such as wavefunction coefficient matrices, basis-function coefficients, or other column-wise vector sets as NumPy arrays), this utility ensures each column has unit length, which is often required before or after linear-algebra operations (for example, when preparing coefficient matrices for orthonormalization, projection, or numerical stabilization in plane-wave, atom-centered, or real-space grid representations).` |
| `gpaw_utilities_timelimit_time_to_seconds` | `gpaw.utilities.timelimit.time_to_seconds` | `gpaw/utilities/timelimit.py` | `timestr: str` | `Convert gpaw.utilities.timelimit.time_to_seconds input to a number of seconds. This function is used in GPAW (a DFT/PAW code) to normalize user-specified time limits or timeout specifications into a single floating-point value representing seconds. It accepts either a numeric value (interpreted directly as seconds) or a formatted time string and returns the total elapsed time in seconds as a float so that other parts of the GPAW code (for example job scheduling, timeouts for calculations, or logging) can perform numeric comparisons and arithmetic.` |
| `gpaw_utilities_tools_symmetrize` | `gpaw.utilities.tools.symmetrize` | `gpaw/utilities/tools.py` | `matrix: numpy.ndarray` | `Symmetrize input matrix by replacing it with its Hermitian (conjugate-transpose) average. This function is used in GPAW (a DFT code) to enforce the physical requirement that many operator matrices (e.g., Hamiltonian, density matrix, overlap) are Hermitian (for complex-valued arrays) or symmetric (for real-valued arrays). It performs the operation matrix <- (matrix + matrix^â€ ) / 2 in-place, where matrix^â€  is the conjugate transpose of matrix (computed by dagger(matrix) in the source). The implementation uses NumPy in-place operations (numpy.add and numpy.multiply) to avoid extra allocations, which is important for large matrices common in plane-wave, real-space, or atom-centered basis computations in GPAW.` |
| `gpaw_utilities_tools_split_formula` | `gpaw.utilities.tools.split_formula` | `gpaw/utilities/tools.py` | `formula: str` | `gpaw.utilities.tools.split_formula: Expand a chemical formula string into a flat list of element symbols by repeating each element according to its numeric count. This function is used in GPAW utilities to translate simple chemical formulas (used e.g. in tests, quick input parsing, or stoichiometry checks) into an explicit list of atom symbols that can be passed to ASE/GPAW routines that expect per-atom entries.` |
| `gpaw_utilities_tools_lowdin` | `gpaw.utilities.tools.lowdin` | `gpaw/utilities/tools.py` | `U: numpy.ndarray, S: numpy.ndarray = None` | `gpaw.utilities.tools.lowdin orthonormalizes the columns of a coefficient matrix U using the LÃ¶wdin (symmetric) orthogonalization procedure. In the GPAW density-functional-theory (DFT) context this is used to convert a set of non-orthogonal basis-function coefficient vectors or molecular-orbital coefficient columns into a symmetric orthonormal set suitable for subsequent linear-algebra operations (for example, when working with PAW projector/basis representations or overlap-corrected coefficient sets). If an overlap matrix S is provided it is used directly; otherwise the overlap is formed from U as S = dagger(U) @ U, where dagger denotes the conjugate-transpose used elsewhere in GPAW. The implementation computes the Hermitian eigen-decomposition of S, forms the symmetric inverse square root of S from the eigenvectors and eigenvalues, and left-multiplies U by that inverse square root so that the columns of U become orthonormal with respect to the standard inner product.` |
| `gpaw_utilities_tools_pick` | `gpaw.utilities.tools.pick` | `gpaw/utilities/tools.py` | `a_ix: numpy.ndarray, i: numpy.ndarray` | `gpaw.utilities.tools.pick selects either a single entry along the first axis of a NumPy array or computes a linear combination of the slices along the first axis. This utility is used in GPAW's data-manipulation code to extract per-index data (for example, a specific band, projector, or grid component) or to form weighted sums over that axis (for example, applying coefficients or projections to combine contributions from several indices).` |
| `gpaw_utilities_tools_project` | `gpaw.utilities.tools.project` | `gpaw/utilities/tools.py` | `a: numpy.ndarray, b: numpy.ndarray` | `gpaw.utilities.tools.project computes the component of the numpy array b along the direction of the numpy array a as implemented in GPAW utilities for operations such as projecting one wavefunction or coefficient vector onto another in density-functional-theory (DFT) workflows.` |
| `gpaw_xc_xc_string_to_dict` | `gpaw.xc.xc_string_to_dict` | `gpaw/xc/__init__.py` | `string: str` | `Parse an exchangeâ€“correlation (XC) specification string used by GPAW into a dictionary. This function is used within the GPAW DFT codebase to interpret the xc argument (exchangeâ€“correlation functional specification) supplied when configuring a GPAW calculator (for example, the common usage xc='PBE' or xc='B3LYP:alpha=0.2'). It converts a compact, colon-separated specification of the form 'name:key1=value1:key2=value2:...' into a Python dictionary that downstream GPAW code (and LibXC/backends) can consume to select the functional and its numeric parameters.` |
| `gpaw_xc_ri_spherical_hse_kernel_Phi` | `gpaw.xc.ri.spherical_hse_kernel.Phi` | `gpaw/xc/ri/spherical_hse_kernel.py` | `n: int, mu: float, R: numpy.ndarray, r: numpy.ndarray` | `Compute the official spherical kernel expansion used by GPAW's resolution-of-identity (ri) spherical HSE kernel implementation. This function implements the spherical-kernel expansion for range-separated hybrid (HSE) exchange integrals as used in gpaw.xc.ri.spherical_hse_kernel. It evaluates the radial part of the spherical expansion (see the comments referring to "Scaling as given by Eq. 16" and "Eq. 21" in the source) by combining the helper functions Fn, Hn and Phinj and applying a small-xi threshold replacement. The result is multiplied by the screening parameter mu so that the returned array is the mu-scaled spherical kernel contribution for pairs of radial distances R and r. This routine is intended for use inside GPAW's real-space RI evaluation of screened exchange kernels in density-functional calculations.` |
| `gpaw_xc_ri_spherical_hse_kernel_Hn` | `gpaw.xc.ri.spherical_hse_kernel.Hn` | `gpaw/xc/ri/spherical_hse_kernel.py` | `n: int, Xi: numpy.ndarray, xi: numpy.ndarray` | `Compute the H_n function used in the spherical HSE (Heydâ€“Scuseriaâ€“Ernzerhof) screened-exchange kernel (Eq. 24 in the implementation). This helper implements the closed-form combination of powers and complementary error functions used by the spherical HSE kernel in gpaw.xc.ri.spherical_hse_kernel. In the GPAW DFT codebase this function appears as an inner radial integrand evaluator for constructing the short-range screened exchange kernel on spherical coordinates; it therefore plays the practical role of producing elementwise numerical values of H_n for arrays of radial or transformed variables used in spherical integration.` |
| `gpaw_zero_field_splitting_convert_tensor` | `gpaw.zero_field_splitting.convert_tensor` | `gpaw/zero_field_splitting.py` | `D_vv: numpy.ndarray, unit: str = "eV"` | `gpaw.zero_field_splitting.convert_tensor converts a 3x3 zeroâ€‘fieldâ€‘splitting (ZFS) tensor (given in electronvolts) into the scalar D and E ZFS parameters, the principal "easy" axis (unit eigenvector), and the full tensor expressed in a requested output unit. This function is used in GPAW DFT workflows to extract the common spin-Hamiltonian parameters (D and E) and the principal axis from the computed ZFS tensor for reporting or comparison with experiment. The input tensor must represent a real symmetric 3x3 ZFS tensor in eV; the function diagonalizes the tensor, selects the principal eigenvalue by largest absolute magnitude, and computes D and E from the ordered eigenvalues. Supported output units are "eV", "ueV" (microelectronvolt), "MHz" (megahertz), and "1/cm" (wavenumbers); conversion to MHz and 1/cm uses the electron charge, Planck's constant and the speed of light as implemented in the module.` |
| `gpaw_xc_ri_spherical_hse_kernel_Fn` | `gpaw.xc.ri.spherical_hse_kernel.Fn` | `gpaw/xc/ri/spherical_hse_kernel.py` | `n: int, Xi: numpy.ndarray, xi: numpy.ndarray` | `gpaw.xc.ri.spherical_hse_kernel.Fn computes the radial helper function used in the spherical HSE kernel evaluation (referenced as Eq. 22 in the implementation notes of the module). This function is a low-level numerical routine used inside GPAW's exchange-correlation (XC) range-separated integrals machinery to evaluate a contribution that depends on an integer order n and two radial variables Xi and xi. It implements the finite summation form (with the summation corrected to start at p = 0 for correct results) and switches to a Taylor-series approximation for numerical stability when the product Xi * xi is very small.` |
| `gpaw_xc_gga_add_gradient_correction` | `gpaw.xc.gga.add_gradient_correction` | `gpaw/xc/gga.py` | `grad_v: list, gradn_svg: numpy.ndarray, sigma_xg: list, dedsigma_xg: numpy.ndarray, v_sg: list` | `gpaw.xc.gga.add_gradient_correction: Add the gradient-dependent part of the exchange-correlation (XC) potential to spin-resolved potential arrays used in GPAW's generalized gradient approximation (GGA) machinery. This routine implements the operation shown in the original code comment, updating the spin potentials v_sg in-place by applying gradient operators (provided in grad_v) weighted by derivatives of the XC energy density with respect to the density gradient invariant sigma. It is used inside GPAW's XC evaluation to accumulate the -2 * divergence(d e / d sigma * grad n) contribution to the XC potential on real-space grids or equivalent buffers.` |
| `gpaw_xc_vdw_hRPS` | `gpaw.xc.vdw.hRPS` | `gpaw/xc/vdw.py` | `x: numpy.ndarray, xc: float = 1.0` | `Cutoff function from the RomÃ¡n-PÃ©rezâ€“Soler (RPS) paper used in the gpaw.xc.vdw implementation of nonlocal van der Waals correlation. This function evaluates a pair of array-valued quantities derived from the dimensionless argument x/xc: a cutoff-modified kernel value and an auxiliary weight. In the GPAW DFT/van-der-Waals context (see gpaw.xc.vdw), these arrays are used when constructing the RPS convolution kernel for efficient evaluation of the nonlocal correlation energy; xc acts as the characteristic length (scaling) parameter that controls the position of the cutoff in the dimensionless argument.` |
| `gpaw_xc_vdw_phi` | `gpaw.xc.vdw.phi` | `gpaw/xc/vdw.py` | `d: float, dp: float` | `vdW-DF kernel used by GPAW for non-local van der Waals correlation calculations. This function evaluates the scalar kernel value phi(d, dp) for the vdW-DF (van der Waals density functional) non-local correlation term by performing a nested two-dimensional numerical integration of a module-level integrand function f. The implementation is written for use inside the GPAW DFT codebase (see README) where phi(d, dp) appears as a building block when assembling the nonlocal correlation energy and potential in vdW-DF type functionals. The integrand f must be defined in the same module and is called with the signature f(x, y, d, dp) by the integrator. The nested integration uses scipy.integrate.quad with hard-coded tolerances and integration bounds appropriate for typical vdW-DF kernel evaluations inside GPAW.` |
| `gpaw_xc_vdw_phi_asymptotic` | `gpaw.xc.vdw.phi_asymptotic` | `gpaw/xc/vdw.py` | `d: numpy.ndarray, dp: numpy.ndarray` | `gpaw.xc.vdw.phi_asymptotic computes the asymptotic form of the van der Waals density-functional (vdW-DF) kernel used in GPAW's vdW-DF implementation. This function evaluates the algebraic large-separation limit of the kernel as implemented in gpaw.xc.vdw, returning the scalar kernel value computed elementwise from the provided NumPy arrays. It is used internally in vdW-DF energy and potential evaluations where the asymptotic tail of the kernel is required for long-range correlation contributions in density-functional theory (DFT) calculations performed with GPAW.` |
| `gpaw_xc_sic_ortho` | `gpaw.xc.sic.ortho` | `gpaw/xc/sic.py` | `W_nn: numpy.ndarray, maxerr: float = 1e-10` | `gpaw.xc.sic.ortho: Orthogonalize column vectors of a matrix using the symmetric LÃ¶wdin procedure. Performs Symmetric-LÃ¶wdin orthogonalization of the column vectors contained in a square numpy.ndarray. This function is intended for use within GPAW's self-interaction-correction (gpaw.xc.sic) code paths where a set of (typically localized) orbital-like column vectors must be transformed into an orthonormal set before further processing. The routine computes the Hermitian overlap matrix O = W_nn @ W_nn.T.conj() and either applies a second-order perturbative approximation of O^{-1/2} when O is already close to the identity (faster, avoids diagonalization), or computes the exact inverse square root via diagonalization of O (stable, more expensive). The returned matrix has the same shape as W_nn and its columns are orthonormal within numerical tolerance: the overlap of the returned columns with their Hermitian conjugates is (approximately) the identity.` |
| `gpaw_xc_sic_matrix_exponential` | `gpaw.xc.sic.matrix_exponential` | `gpaw/xc/sic.py` | `G_nn: numpy.ndarray, dlt: float` | `gpaw.xc.sic.matrix_exponential computes the matrix exponential U = exp(i * dlt * G) for an anti-Hermitian generator G used in GPAW's self-interaction-correction (sic) code path. In the GPAW DFT/PAW context this routine is used to construct a unitary rotation operator from an anti-Hermitian generator matrix G_nn (for example to rotate orbitals or apply small unitary updates in SIC procedures). The routine diagonalizes a Hermitian matrix derived from G_nn, forms phase factors exp(i*dlt*w) from the real eigenvalues w, and reconstructs the exponential by back-transforming the diagonal phase matrix with the eigenvectors.` |

## âš–ï¸ License

Original Code License: GPLv3+

Wrapper Code & Documentation: Apache-2.0

*This file was automatically generated on February 26, 2026.*
