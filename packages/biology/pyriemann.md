# pyriemann

[üîô Back to Main Repo](../../../README.md) | [üîó Original Repo](https://github.com/pyRiemann/pyRiemann)

![Tool Count](https://img.shields.io/badge/Agent_Tools-100-blue?style=flat-square)
![Category](https://img.shields.io/badge/Category-Biology-green?style=flat-square)
![Status](https://img.shields.io/badge/Import_Test-Passed-success?style=flat-square)

## üìñ Overview

pyRiemann is a scikit-learn‚Äìstyle Python library for processing and classifying multivariate data by estimating covariance matrices and applying Riemannian-geometry methods on symmetric/Hermitian positive definite matrices, commonly used in biosignal (e.g., EEG/BCI) and remote-sensing applications.

> **Note**: This documentation lists the **agent-ready wrapper functions** generated for this package. These functions have been strictly typed, docstring-enhanced, and tested for import stability within a standardized Apptainer environment.

## üõ†Ô∏è Available Agent Tools

Below is the list of **100** functions optimized for LLM tool-use.

| **Tool Name (Wrapper)**   | **Source**          | **File Path**     | **Arguments (Type)**        | **Description**                |
| ------------------------- | ------------------- | ----------------- | --------------------------- | ------------------------------ |
| `pyriemann_classification_class_distinctiveness` | `pyriemann.classification.class_distinctiveness` | `pyriemann/classification.py` | `X: numpy.ndarray, y: numpy.ndarray, exponent: int = 1, metric: dict = "riemann", return_num_denom: bool = False` | `pyriemann.classification.class_distinctiveness measures the separability of classes of symmetric/Hermitian positive definite (SPD/HPD) matrices using Riemannian geometry. It implements the class distinctiveness criterion used in biosignal and brain‚Äëcomputer interface (BCI) applications to quantify how far apart class centers are relative to their within‚Äëclass dispersion when matrices represent covariance estimates (for example, covariance matrices estimated from multichannel EEG, MEG or EMG epochs). The function computes the ratio of between‚Äëclass dispersion to within‚Äëclass dispersion using a user‚Äëspecified exponent on distances and user‚Äëselectable Riemannian metrics for mean and distance estimation.` |
| `pyriemann_datasets_sampling_sample_gaussian_spd` | `pyriemann.datasets.sampling.sample_gaussian_spd` | `pyriemann/datasets/sampling.py` | `n_matrices: int, mean: numpy.ndarray, sigma: float, random_state: int = None, n_jobs: int = 1, sampling_method: str = "auto"` | `Sample a Riemannian Gaussian distribution of symmetric positive definite (SPD) matrices. This function generates n_matrices SPD samples drawn from the Riemannian Gaussian distribution defined in the literature [Said et al., 2017]. It is intended for use when simulating covariance matrices or SPD observations in applications supported by pyRiemann (for example EEG/MEG covariance simulation for brain‚Äìcomputer interfaces, or covariance over spatial patches in hyperspectral/remote-sensing imaging). The sampling is performed in the spectral parameterization of SPD matrices: each sample is created by sampling an orthogonal eigenvector matrix (U-parameters) and the log of eigenvalues (r-parameters), forming a centered SPD sample in the tangent space, and then transporting it to be centered at the provided mean via the congruence mean_sqrt @ X @ mean_sqrt where mean_sqrt is the matrix square root of mean. Internally the dispersion sigma is corrected by 1/sqrt(n_dim) to account for dimensional scaling. The function performs an SPD validity check and warns if some generated matrices are numerically ill-conditioned.` |
| `pyriemann_datasets_simulated_make_masks` | `pyriemann.datasets.simulated.make_masks` | `pyriemann/datasets/simulated.py` | `n_masks: int, n_dim0: int, n_dim1_min: int, rs: int = None` | `Generate a list of semi-orthogonal matrices ("masks") used to simulate linear mixing of multivariate signals.` |
| `pyriemann_datasets_simulated_make_matrices` | `pyriemann.datasets.simulated.make_matrices` | `pyriemann/datasets/simulated.py` | `n_matrices: int, n_dim: int, kind: str, rs: int = None, return_params: bool = False, evals_low: float = 0.5, evals_high: float = 2.0, eigvecs_same: bool = False, eigvecs_mean: float = 0.0, eigvecs_std: float = 1.0` | `Generate square matrices with controlled spectral properties for testing and simulation in pyRiemann algorithms (for example, to synthesize covariance-like SPD matrices used in biosignal processing and BCI pipelines). The function constructs real, symmetric, complex, Hermitian, positive-(semi)definite matrices or general complex matrices by drawing random eigenvectors and eigenvalues under specified distributions, optionally returning the eigen-parameters used to build the matrices for reproducibility and analysis.` |
| `pyriemann_datasets_simulated_make_outliers` | `pyriemann.datasets.simulated.make_outliers` | `pyriemann/datasets/simulated.py` | `n_matrices: int, mean: numpy.ndarray, sigma: float, outlier_coeff: float = 10, random_state: int = None` | `Generate outlier SPD matrices for a Riemannian Gaussian distribution with a fixed mean and dispersion. This function is used in the pyRiemann simulated datasets context to create covariance-like symmetric positive definite (SPD) matrices that lie far from a given Riemannian Gaussian center. Such outliers are useful to test robustness of Riemannian classifiers and processing pipelines (for example in biosignal/BCI or remote sensing applications where covariance matrices are processed on the SPD manifold). The generation procedure (used internally by pyRiemann) is: compute the matrix square root of the provided mean, draw random SPD matrices O_i, compute a scalar exponent epsilon from outlier_coeff, sigma and the Riemannian squared distance between O_i and the identity, then map O_i to the tangent-scaled outlier by conjugation outlier = mean_sqrt @ O_i**epsilon @ mean_sqrt. The resulting matrices are SPD and have shape (n_matrices, n_dim, n_dim).` |
| `pyriemann_stats_multiset_perm_number` | `pyriemann.stats.multiset_perm_number` | `pyriemann/stats.py` | `y: numpy.ndarray` | `pyriemann.stats.multiset_perm_number returns the number of unique permutations of the provided multiset array. This function is used in pyRiemann statistical utilities to quantify how many distinct orderings exist for a multiset of elements such as class labels or categorical epoch identifiers (for example in EEG/BCI permutation tests or combinatorial counts applied to covariance matrix labels).` |
| `pyriemann_stats_unique_permutations` | `pyriemann.stats.unique_permutations` | `pyriemann/stats.py` | `elements: list` | `pyriemann.stats.unique_permutations returns a generator that yields all unique permutations of the input list elements as tuples. This function is a utility suitable for use in pyRiemann workflows where enumerating distinct orderings of items is needed (for example, generating distinct channel index orders, enumerating label permutations for nonparametric testing in BCI experiments, or exhaustive combinations in small-scale combinatorial search over feature orderings). It produces each permutation lazily (one at a time) and avoids emitting duplicate permutations when the input list contains repeated values.` |
| `pyriemann_utils_ajd_ajd` | `pyriemann.utils.ajd.ajd` | `pyriemann/utils/ajd.py` | `X: numpy.ndarray, method: str = "ajd_pham", init: numpy.ndarray = None, eps: float = 1e-06, n_iter_max: int = 100, **kwargs` | `pyriemann.utils.ajd.ajd computes an approximate joint diagonalization (AJD) of a set of symmetric matrices using a selected AJD algorithm implementation. In the pyRiemann workflow for multivariate biosignal processing (for example EEG/MEG covariance-based BCI pipelines), this function is used to estimate a joint diagonalizer matrix V that approximately diagonalizes a set of covariance (SPD) or symmetric matrices X; the diagonalizer V can be interpreted as an unmixing/spatial filter matrix and the returned quasi-diagonal matrices D contain the per-matrix component powers that are useful for downstream classification or feature extraction.` |
| `pyriemann_utils_ajd_ajd_pham` | `pyriemann.utils.ajd.ajd_pham` | `pyriemann/utils/ajd.py` | `X: numpy.ndarray, init: numpy.ndarray = None, eps: float = 1e-06, n_iter_max: int = 20, sample_weight: numpy.ndarray = None` | `pyriemann.utils.ajd.ajd_pham computes an approximate joint diagonalization (AJD) of a set of symmetric positive definite (SPD) or Hermitian positive definite (HPD) matrices using Pham's optimization of a log-likelihood criterion based on the Kullback-Leibler divergence. In the pyRiemann context, this function is used to find an invertible diagonalizer matrix V that transforms a batch of covariance matrices (e.g., covariance matrices estimated from multichannel biosignals such as EEG/MEG/EMG in brain‚Äìcomputer interface workflows, or covariance patches in hyperspectral/remote sensing applications) into approximately diagonal form D = V X V^H. The diagonalizer V and the transformed quasi-diagonal matrices D are commonly used downstream for Riemannian geometry processing, tangent-space embedding, or classifiers such as MDM.` |
| `pyriemann_utils_ajd_rjd` | `pyriemann.utils.ajd.rjd` | `pyriemann/utils/ajd.py` | `X: numpy.ndarray, init: numpy.ndarray = None, eps: float = 1e-08, n_iter_max: int = 100` | `pyriemann.utils.ajd.rjd: Orthogonal approximate joint diagonalization based on the JADE algorithm. This function implements the orthogonal AJD algorithm (JADE) using Jacobi rotations to find an orthogonal diagonalizer V that jointly (approximately) diagonalizes a set of symmetric matrices X. In the pyRiemann project this routine is used to diagonalize collections of symmetric positive definite covariance matrices (for example covariance estimates from multichannel biosignals such as EEG/MEG used in brain-computer interface applications) so that subsequent Riemannian processing, feature extraction, or transfer-learning operations can operate on quasi-diagonal representations.` |
| `pyriemann_utils_ajd_uwedge` | `pyriemann.utils.ajd.uwedge` | `pyriemann/utils/ajd.py` | `X: numpy.ndarray, init: numpy.ndarray = None, eps: float = 1e-07, n_iter_max: int = 100` | `pyriemann.utils.ajd.uwedge performs approximate joint diagonalization of a set of symmetric matrices using the U-WEDGE algorithm (Uniformly Weighted Exhaustive Diagonalization using Gauss iterations). This routine is used in pyRiemann for processing collections of symmetric (typically covariance) matrices arising from multichannel biosignals (e.g., EEG, MEG, EMG) or other applications where joint diagonalization aids source separation, dimensionality reduction, or Riemannian-based classification pipelines.` |
| `pyriemann_utils_base_ctranspose` | `pyriemann.utils.base.ctranspose` | `pyriemann/utils/base.py` | `X: numpy.ndarray` | `pyriemann.utils.base.ctranspose: Conjugate transpose operator for complex-valued arrays used in pyRiemann for handling Hermitian or real symmetric matrices.` |
| `pyriemann_utils_base_ddexpm` | `pyriemann.utils.base.ddexpm` | `pyriemann/utils/base.py` | `X: numpy.ndarray, Cref: numpy.ndarray` | `pyriemann.utils.base.ddexpm: Compute the directional derivative of the matrix exponential at a reference SPD/HPD matrix. Computes the directional derivative of the matrix exponential at a reference symmetric positive definite (SPD) or Hermitian positive definite (HPD) matrix Cref in the direction(s) X. This function implements the formula used in Riemannian geometry of positive definite matrices (see Matrix Analysis) and is provided for algorithms that require the sensitivity of the matrix exponential with respect to perturbations of a reference covariance or scatter matrix. In the pyRiemann context, Cref typically represents a covariance matrix estimated from multichannel biosignal data (EEG/MEG/EMG) or remote sensing (hyperspectral/SAR) and X represents one or several perturbation directions (for example, differences between epoch covariances and the reference). The implementation obtains the eigen-decomposition of Cref, evaluates the first divided difference of the exponential on the eigenvalues, and reconstructs the directional derivative via conjugation by the eigenvectors.` |
| `pyriemann_utils_base_ddlogm` | `pyriemann.utils.base.ddlogm` | `pyriemann/utils/base.py` | `X: numpy.ndarray, Cref: numpy.ndarray` | `pyriemann.utils.base.ddlogm computes the directional derivative of the matrix logarithm at a reference SPD/HPD matrix. This function implements the directional derivative defined for symmetric (real SPD) or Hermitian (complex HPD) positive-definite matrices and used in pyRiemann when manipulating covariance or scatter matrices that arise in biosignal processing (EEG/MEG/EMG) and remote sensing workflows. Practically, ddlogm(X, Cref) returns the linearized change of logm(C) at C = Cref in the direction X, as given by Eq. (V.13) in R. Bhatia, "Matrix Analysis" (1997). The implementation performs an eigen-decomposition of the reference matrix Cref (Cref = V diag(d) V^H) and applies the first divided difference of the scalar logarithm to the eigenvalues; the result is V (fddlogm(diag(d)) ‚äô (V^H X V)) V^H. This quantity is commonly used in Riemannian geometry operations on SPD/HPD matrices such as tangent-space mappings, gradients, and differential corrections when classifying covariance matrices in brain-computer interface (BCI) pipelines or when processing covariance descriptors in hyperspectral/SAR remote-sensing applications.` |
| `pyriemann_utils_base_expm` | `pyriemann.utils.base.expm` | `pyriemann/utils/base.py` | `C: numpy.ndarray` | `Exponential of SPD/HPD matrices. Compute the matrix exponential of one or several symmetric positive-definite (SPD) or Hermitian positive-definite (HPD) matrices. This function implements the symmetric/Hermitian matrix exponential commonly used in Riemannian-geometry-based processing of covariance matrices: given an input matrix C with eigendecomposition C = V Lambda V^H, the result is D = V exp(Lambda) V^H where exp() is applied elementwise to the eigenvalues. In the pyRiemann project this routine is used to map matrices from the tangent/log domain back to the manifold (for example, reconstructing covariance matrices after tangent-space operations) and is therefore directly relevant for biosignal applications (EEG/MEG/EMG) and remote-sensing workflows that operate on SPD/HPD covariance matrices.` |
| `pyriemann_utils_base_invsqrtm` | `pyriemann.utils.base.invsqrtm` | `pyriemann/utils/base.py` | `C: numpy.ndarray` | `pyriemann.utils.base.invsqrtm ‚Äî Inverse square root of SPD/HPD matrices. Compute the matrix inverse square root of one or more symmetric positive definite (SPD) or Hermitian positive definite (HPD) matrices. This function is used throughout pyRiemann for operations on covariance matrices (for example whitening, normalization, and steps in Riemannian geometry-based classification pipelines for biosignals such as EEG/MEG/EMG in brain-computer interface applications). Given an input matrix C, the result D is defined by the eigen-decomposition of C: C = V Lambda V^H and D = V Lambda^{-1/2} V^H, where Lambda is the diagonal matrix of eigenvalues and V the matrix of corresponding eigenvectors. The elementwise operator applied to the eigenvalues is 1 / sqrt(lambda), implemented via a call to the internal matrix operator used by pyRiemann.` |
| `pyriemann_utils_base_logm` | `pyriemann.utils.base.logm` | `pyriemann/utils/base.py` | `C: numpy.ndarray` | `pyriemann.utils.base.logm: Compute the matrix logarithm of symmetric/Hermitian positive-definite (SPD/HPD) matrices. Computes the symmetric (for real-valued SPD) or Hermitian (for complex-valued HPD) matrix logarithm of the input matrix or batch of matrices using an eigendecomposition. The computation follows the spectral formula D = V log(Œõ) V^H where Œõ is the diagonal matrix of eigenvalues of C and V the corresponding eigenvectors. In the pyRiemann library this operation is used to map covariance matrices (SPD) or Hermitian positive-definite matrices (HPD) to their matrix-log domain as part of Riemannian-geometry-based processing pipelines (for example, TangentSpace mapping, distance computations, or preprocessing of EEG/MEG covariance matrices for BCI and remote sensing applications).` |
| `pyriemann_utils_base_nearest_sym_pos_def` | `pyriemann.utils.base.nearest_sym_pos_def` | `pyriemann/utils/base.py` | `X: numpy.ndarray, reg: float = 1e-06` | `Find the nearest symmetric positive definite (SPD) matrices to a batch of square matrices. This function is a NumPy port of John D'Errico's nearestSPD MATLAB code and implements a per-matrix projection to the nearest SPD matrix, following the approach credited to N. J. Higham. In the pyRiemann project, this routine is used to ensure that estimated covariance matrices (for example, covariance matrices computed from multichannel biosignals such as EEG, MEG, EMG in BCI applications, or covariance patches from hyperspectral / SAR imagery in remote sensing) are valid symmetric positive definite matrices so they can be processed safely with Riemannian-geometry-based methods (for example, distance computations, tangent-space mapping, or classifiers like MDM). The function processes each matrix in the input batch independently and returns a new array; the input array is not modified in-place.` |
| `pyriemann_utils_base_powm` | `pyriemann.utils.base.powm` | `pyriemann/utils/base.py` | `C: numpy.ndarray, alpha: float` | `Compute the matrix power of symmetric positive definite (SPD) or Hermitian positive definite (HPD) matrices. This function computes the matrix power D = V Lambda^alpha V^H for each input matrix C, where Lambda is the diagonal matrix of eigenvalues of C, V are the corresponding eigenvectors, and V^H denotes the conjugate transpose of V. In the pyRiemann project this operation is used on covariance matrices estimated from multichannel biosignals (EEG, MEG, EMG) and on HPD matrices from complex-valued data (e.g., SAR), for tasks such as whitening, computing matrix square roots or inverse square roots, normalization, and other Riemannian-geometry-based preprocessing steps used in brain-computer interface (BCI) pipelines and remote sensing workflows. The implementation applies the scalar power alpha to the eigenvalues and reconstructs the matrix; it supports batched inputs by treating leading dimensions as batch dimensions and preserving the final two dimensions as square matrices.` |
| `pyriemann_utils_base_sqrtm` | `pyriemann.utils.base.sqrtm` | `pyriemann/utils/base.py` | `C: numpy.ndarray` | `pyriemann.utils.base.sqrtm computes the symmetric (or Hermitian) matrix square root of one or multiple symmetric positive definite (SPD) or Hermitian positive definite (HPD) matrices using an eigen-decomposition-based formula D = V sqrt(Lambda) V^H. This function is used in pyRiemann workflows that manipulate covariance or scattering matrices derived from multivariate biosignals (EEG, MEG, EMG) or remote sensing images, for example when applying Riemannian geometry operations, whitening, or tangent-space mappings on SPD/HPD matrices.` |
| `pyriemann_utils_covariance_block_covariances` | `pyriemann.utils.covariance.block_covariances` | `pyriemann/utils/covariance.py` | `X: numpy.ndarray, blocks: list, estimator: str = "cov", **kwds` | `Compute block diagonal covariance matrices by estimating covariances on channel subsets. This function is used in multivariate signal processing (for example EEG/MEG/EMG in brain-computer interface workflows or spatial covariance estimation in remote sensing) to compute a block-diagonal covariance matrix for each epoch/trial/observation in X. Each block of the returned matrix is computed as the covariance of a contiguous subset of channels (a group of sensors) whose sizes are given by blocks. The estimator argument selects the covariance estimator applied to each block; additional keyword arguments are forwarded to that estimator. The function validates that the sum of the block sizes equals the number of channels and that X has three dimensions (n_matrices, n_channels, n_times). If these conditions are not met, the function raises an error rather than returning a result.` |
| `pyriemann_utils_covariance_coherence` | `pyriemann.utils.covariance.coherence` | `pyriemann/utils/covariance.py` | `X: numpy.ndarray, window: int = 128, overlap: float = 0.75, fmin: float = None, fmax: float = None, fs: float = None, coh: str = "ordinary"` | `pyriemann.utils.covariance.coherence computes the squared coherence between all pairs of channels of a multichannel time series across frequency bins. This function is intended for spectral connectivity analysis of biosignals (for example EEG, MEG, EMG) commonly used in brain‚Äìcomputer interface (BCI) and related pipelines described in the pyRiemann README. It first estimates the cross-spectral density via an FFT-based windowed estimator (cross_spectrum), then builds a 3D array of squared coherence values for each channel pair and frequency. Different coherence variants ("ordinary", "instantaneous", "lagged", "imaginary") implement formulas used in connectivity analysis and correspond to the coherence types exposed by pyriemann.estimation.Coherences.` |
| `pyriemann_utils_covariance_cospectrum` | `pyriemann.utils.covariance.cospectrum` | `pyriemann/utils/covariance.py` | `X: numpy.ndarray, window: int = 128, overlap: float = 0.75, fmin: float = None, fmax: float = None, fs: float = None` | `Compute co-spectral matrices (the real part of cross-spectra) from a multi-channel time-series. This function is intended for frequency-domain covariance estimation used in applications such as biosignal processing (EEG, MEG, EMG) and brain-computer interfaces (BCI). It segments the input signal into FFT windows, computes the cross-spectral density per frequency bin via cross_spectrum, and returns the real part of those cross-spectra (co-spectral matrices) together with the associated frequency vector. These co-spectral matrices provide frequency-specific estimates of linear dependencies between channels and can be used as features for classification, connectivity analysis, or as inputs to Riemannian geometry-based algorithms described in the project README.` |
| `pyriemann_utils_covariance_covariance_mest` | `pyriemann.utils.covariance.covariance_mest` | `pyriemann/utils/covariance.py` | `X: numpy.ndarray, m_estimator: str, init: numpy.ndarray = None, tol: float = 0.01, n_iter_max: int = 50, assume_centered: bool = False, q: float = 0.9, nu: int = 5, norm: str = "trace"` | `Compute a robust M-estimator of the covariance (scatter) matrix from a multichannel time series using a fixed-point algorithm. This function implements robust M-estimator covariance matrix estimation described in the literature on complex elliptically symmetric distributions and M-estimators (Huber, Student-t, Tyler). It is intended for estimating covariance (or scatter) matrices from multivariate time series such as biosignals (EEG, MEG, EMG) used in brain‚Äìcomputer interfaces or from spatial windows in remote sensing applications. The estimator downweights samples according to their squared Mahalanobis distance to provide robustness to outliers; the exact weighting depends on the chosen m_estimator ("hub", "stu", or "tyl"). The algorithm iterates a fixed-point update until the relative change in Frobenius norm meets tol or until n_iter_max iterations. Note that when assume_centered is False the input X is centered in place (modified).` |
| `pyriemann_utils_covariance_covariance_sch` | `pyriemann.utils.covariance.covariance_sch` | `pyriemann/utils/covariance.py` | `X: numpy.ndarray` | `Schaefer-Strimmer shrinkage covariance estimator for multichannel time series. This function computes a shrunk estimate of the sample covariance matrix using the Schaefer-Strimmer method: the shrinkage estimator is a weighted average between the sample covariance matrix (SCM) and a diagonal target matrix formed from the SCM diagonal. The optimal shrinkage intensity gamma is estimated using the authors' analytical estimator and then clipped to [0, 1]. The implementation centers the data (subtracts per-channel mean), uses the unbiased scaling factor n_times / (n_times - 1) on the SCM, and returns the final covariance matrix. This estimator is commonly used in domains supported by pyRiemann, including biosignal processing (EEG, MEG, EMG) for brain‚Äìcomputer interface (BCI) pipelines and in remote sensing for covariance estimation over spatial windows; the shrunk covariance improves conditioning and downstream Riemannian-geometry-based classification or signal processing.` |
| `pyriemann_utils_covariance_covariance_scm` | `pyriemann.utils.covariance.covariance_scm` | `pyriemann/utils/covariance.py` | `X: numpy.ndarray, assume_centered: bool = False` | `pyriemann.utils.covariance.covariance_scm estimates the sample (empirical) covariance matrix from a multichannel time series. It is used in pyRiemann to convert multichannel signals (for example EEG/MEG/EMG epochs in brain‚Äìcomputer interface workflows or spatial patches in remote sensing) into symmetric (real) or Hermitian (complex) positive semidefinite matrices that can be processed by Riemannian geometry-based algorithms (for example MDM, TangentSpace, or other covariance-based classifiers and pipelines).` |
| `pyriemann_utils_covariance_covariances` | `pyriemann.utils.covariance.covariances` | `pyriemann/utils/covariance.py` | `X: numpy.ndarray, estimator: str = "cov", **kwds` | `pyriemann.utils.covariance.covariances: Estimate covariance matrices from multichannel time-series for Riemannian-geometry based analysis. Estimates covariance (or correlation / robust / shrunk) matrices for each epoch/trial/patch in a 3D array of multichannel time-series. This function is commonly used in biosignal applications (EEG, MEG, EMG) and remote sensing (hyperspectral, SAR) to produce symmetric (or Hermitian for complex data) positive definite matrices that are the input to downstream pyRiemann algorithms such as TangentSpace, MDM, and other classifiers or manifolds-based pipelines. The function supports real and complex-valued data and delegates the per-epoch estimation to a selectable estimator implementation. The output array has dtype equal to X.dtype and contains one covariance matrix per input time-series.` |
| `pyriemann_utils_covariance_covariances_EP` | `pyriemann.utils.covariance.covariances_EP` | `pyriemann/utils/covariance.py` | `X: numpy.ndarray, P: numpy.ndarray, estimator: str = "cov", **kwds` | `Special covariance-matrix estimator that concatenates a time-aligned prototype P with each multichannel epoch in X and computes the covariance of the concatenated signals. This function is used in pyRiemann workflows (for example ERP / event-related potential processing in BCI pipelines) to augment each trial with a prototype/template signal and produce covariance matrices on the combined channel set for downstream Riemannian processing and classification.` |
| `pyriemann_utils_covariance_covariances_X` | `pyriemann.utils.covariance.covariances_X` | `pyriemann/utils/covariance.py` | `X: numpy.ndarray, estimator: str = "cov", alpha: float = 0.2, **kwds` | `Special-form covariance matrix estimator that embeds a multichannel time-series into a block SPD matrix combining channel and time information for Riemannian processing. This function implements the "special form" covariance construction introduced for interpretation and visualization of multivariate time-series in the pyRiemann project (see README). It is intended for use with biosignals (e.g., EEG, MEG, EMG) or other multivariate time series where each epoch/trial is given as a matrix of channels by time samples. The resulting covariance matrices have shape (n_channels + n_times, n_channels + n_times) and are suitable for downstream Riemannian-geometry based algorithms (classification, averaging, tangent-space mapping) used in brain-computer interface (BCI) and remote sensing workflows.` |
| `pyriemann_utils_covariance_cross_spectrum` | `pyriemann.utils.covariance.cross_spectrum` | `pyriemann/utils/covariance.py` | `X: numpy.ndarray, window: int = 128, overlap: float = 0.75, fmin: float = None, fmax: float = None, fs: float = None` | `pyriemann.utils.covariance.cross_spectrum computes the complex cross-spectral matrices of a real multichannel time series using short-time Fourier transform windows and returns the frequency bins associated with those spectra. This function is used in pyRiemann to obtain frequency-domain covariance estimates from biosignals (for example EEG, MEG, EMG) for downstream Riemannian geometry processing and classification in brain-computer interface (BCI) and remote sensing workflows.` |
| `pyriemann_utils_covariance_eegtocov` | `pyriemann.utils.covariance.eegtocov` | `pyriemann/utils/covariance.py` | `sig: numpy.ndarray, window: int = 128, overlapp: float = 0.5, padding: bool = True, estimator: str = "cov"` | `Convert an EEG continuous multichannel time series into a sequence of covariance matrices using a sliding window. This function is used in pyRiemann workflows for BCI and biosignal processing to estimate covariance matrices from EEG signals over time, enabling subsequent Riemannian-geometry-based processing and classification (for example, in motor imagery or ERP paradigms). It applies a sliding window of fixed length over the input signal, optionally pads the signal at both ends with zeros to allow windows centered on the original edges, resolves the string identifier of a covariance estimator via check_function against cov_est_functions, and calls that estimator on each window. Each window is passed to the estimator transposed as an array of shape (n_channels, window_length) so the estimator receives channels on the first axis and time samples on the second axis.` |
| `pyriemann_utils_covariance_get_nondiag_weight` | `pyriemann.utils.covariance.get_nondiag_weight` | `pyriemann/utils/covariance.py` | `X: numpy.ndarray` | `Compute non-diagonality weights of a set of square matrices. This function computes a scalar weight for each square matrix provided in X that quantifies how non-diagonal the matrix is, following Eq(B.1) in [1]. In the context of pyRiemann and covariance-based multivariate analysis (for example EEG/MEG covariance matrices used in brain-computer interface pipelines and approximate joint diagonalization algorithms), these weights measure the relative energy of the off-diagonal elements compared to the diagonal elements and can be used to down-weight matrices that are nearly diagonal during joint-diagonalization or other aggregation steps.` |
| `pyriemann_utils_covariance_normalize` | `pyriemann.utils.covariance.normalize` | `pyriemann/utils/covariance.py` | `X: numpy.ndarray, norm: str` | `pyriemann.utils.covariance.normalize normalizes a batch of square matrices (covariance or similar) using one of three normalization schemes ("corr", "trace", "determinant"). This function is typically used in pyRiemann preprocessing pipelines to make covariance or Hermitian positive-definite matrices comparable across epochs, channels, sensors, or acquisitions before applying Riemannian geometry-based methods (for example, MDM classification, TangentSpace mapping, or other covariance-based BCI and remote sensing workflows described in the README). The normalization choices produce correlation matrices ("corr"), unit-trace matrices ("trace"), or matrices with determinant equal to +/-1 ("determinant"), which can help stabilize numerical processing and remove scale differences between matrices coming from different trials, sessions, or sensors.` |
| `pyriemann_utils_distance_distance` | `pyriemann.utils.distance.distance` | `pyriemann/utils/distance.py` | `A: numpy.ndarray, B: numpy.ndarray, metric: str = "riemann", squared: bool = False` | `Distance between matrices according to a chosen metric, used for computing pairwise dissimilarities between symmetric/Hermitian positive definite (SPD/HPD) matrices such as covariance matrices estimated from multichannel biosignals (EEG/MEG/EMG) in brain-computer interface (BCI) workflows or covariance descriptors in remote sensing and hyperspectral imaging. This function accepts either a single pair of matrices A and B (both shape (n, n)) or a stack of matrices A with shape (n_matrices, n, n) and a single matrix B (n, n), and returns the scalar distance or a column vector of distances computed by the specified metric. The metric can be one of the predefined string identifiers implemented in the pyriemann distance module (for example "riemann", "euclid", "kullback", "wasserstein", etc.) or a user-provided callable implementing the same distance signature.` |
| `pyriemann_utils_distance_distance_chol` | `pyriemann.utils.distance.distance_chol` | `pyriemann/utils/distance.py` | `A: numpy.ndarray, B: numpy.ndarray, squared: bool = False` | `Cholesky distance between two symmetric/Hermitian positive-definite (SPD/HPD) matrices. This function computes the Cholesky distance used in applications of Riemannian geometry to covariance matrices (for example, covariance matrices estimated from multichannel biosignals such as EEG, MEG or EMG in brain‚Äìcomputer interfaces, or local covariance estimates in remote sensing). The Cholesky distance between two SPD/HPD matrices A and B is defined as the Frobenius norm of the difference between their Cholesky factors: the function computes chol(A) and chol(B) using NumPy's Cholesky factorization and then returns the Frobenius norm (or its square) of their difference. Internally this function delegates to the Euclidean distance on the Cholesky factors (distance_euclid on np.linalg.cholesky(A) and np.linalg.cholesky(B)).` |
| `pyriemann_utils_distance_distance_harmonic` | `pyriemann.utils.distance.distance_harmonic` | `pyriemann/utils/distance.py` | `A: numpy.ndarray, B: numpy.ndarray, squared: bool = False` | `Harmonic distance between invertible matrices. Compute the harmonic distance d(A, B) = \|\|A^{-1} - B^{-1}\|\|_F between two invertible matrices A and B. In the pyRiemann library this distance quantifies dissimilarity between precision matrices (inverses of covariance matrices) that are commonly estimated from multichannel biosignals (for example EEG/MEG in brain‚Äìcomputer interface applications) or from spatial patches in remote sensing. The function inverts each input matrix using numpy.linalg.inv and delegates the Frobenius-norm computation to the Euclidean-distance implementation (distance_euclid), so it is effectively the Euclidean distance applied to the inverses of the inputs.` |
| `pyriemann_utils_distance_distance_kullback` | `pyriemann.utils.distance.distance_kullback` | `pyriemann/utils/distance.py` | `A: numpy.ndarray, B: numpy.ndarray, squared: bool = False` | `pyriemann.utils.distance.distance_kullback computes the left Kullback-Leibler divergence between two symmetric/Hermitian positive definite (SPD/HPD) matrices. This function evaluates the information-theoretic left Kullback-Leibler divergence d(A,B) = 0.5*(tr(B^{-1}A) - n + log(det(B)/det(A))) for one or a batch of SPD/HPD matrices A and B. In the pyRiemann package this distance is commonly used to compare covariance matrices estimated from multichannel biosignals (e.g., EEG, MEG, EMG) for brain-computer interface (BCI) workflows and is also applicable to covariance-like matrices in remote sensing applications. The implementation computes the trace term via solving linear systems (effectively B^{-1}A), obtains signed log-determinants via numpy.linalg.slogdet, and returns the real, non-negative divergence values. The function accepts real-valued SPD and complex-valued Hermitian positive definite (HPD) matrices and supports broadcasting over leading batch dimensions to process multiple matrices at once.` |
| `pyriemann_utils_distance_distance_kullback_right` | `pyriemann.utils.distance.distance_kullback_right` | `pyriemann/utils/distance.py` | `A: numpy.ndarray, B: numpy.ndarray, squared: bool = False` | `Summary: Compute the right Kullback-Leibler divergence between two covariance matrices. This function is a thin wrapper that implements the "right" version of the Kullback-Leibler divergence used in pyRiemann for comparing symmetric (or Hermitian) positive definite (SPD/HPD) covariance matrices commonly estimated from multichannel biosignals (e.g., EEG, MEG, EMG) or remote sensing data. Concretely, it calls the underlying distance_kullback function with its arguments swapped so that the divergence is evaluated as D_right(A, B) = distance_kullback(B, A, squared=squared). The returned value quantifies how much the distribution characterized by A diverges from that characterized by B in the context of Riemannian geometry on SPD/HPD matrices and can be used as a dissimilarity measure in classification, clustering, or transfer-learning pipelines described in the project README.` |
| `pyriemann_utils_distance_distance_kullback_sym` | `pyriemann.utils.distance.distance_kullback_sym` | `pyriemann/utils/distance.py` | `A: numpy.ndarray, B: numpy.ndarray, squared: bool = False` | `pyriemann.utils.distance.distance_kullback_sym computes the symmetrized Kullback-Leibler divergence (also known as the Jeffreys divergence) between two symmetric/Hermitian positive definite (SPD/HPD) matrices. This function is used in pyRiemann to quantify dissimilarity between covariance matrices arising from multivariate biosignals (e.g., EEG, MEG, EMG) and in other applications such as hyperspectral or SAR image processing where covariance/HPD matrices represent local statistics.` |
| `pyriemann_utils_distance_distance_logchol` | `pyriemann.utils.distance.distance_logchol` | `pyriemann/utils/distance.py` | `A: numpy.ndarray, B: numpy.ndarray, squared: bool = False` | `Log-Cholesky distance between two symmetric/Hermitian positive definite (SPD/HPD) matrices. This function computes the Log-Cholesky distance used in pyRiemann to compare SPD/HPD matrices such as covariance matrices estimated from multichannel biosignals (EEG, MEG, EMG) or from remote sensing data. The distance is computed by taking the Cholesky decomposition of each input matrix, extracting the strictly lower triangular entries and the diagonal entries, applying a natural logarithm to the diagonal entries, and then computing the Euclidean norm of the concatenated differences. Concretely, for matrices A and B, if L_A and L_B are their (lower) Cholesky factors, the squared distance equals the squared Frobenius norm of the difference of the strictly lower triangular parts plus the squared Frobenius norm of the difference of the elementwise logarithms of the diagonals. Returning the non-squared distance takes the square root of this sum. This representation is useful in Riemannian processing pipelines (e.g., covariance estimation and classification in BCI) because it provides a vectorized representation of SPD/HPD matrices that can be used with standard Euclidean methods.` |
| `pyriemann_utils_distance_distance_logdet` | `pyriemann.utils.distance.distance_logdet` | `pyriemann/utils/distance.py` | `A: numpy.ndarray, B: numpy.ndarray, squared: bool = False` | `Compute the log-det (Burg) distance between two symmetric/Hermitian positive-definite (SPD/HPD) matrices. This function implements the log-det distance d(A, B) = sqrt(log det((A + B) / 2) - 0.5 * log det(A B)) widely used in the Riemannian geometry of SPD/HPD matrices. In the pyRiemann library this distance is used to compare covariance matrices estimated from multivariate biosignals (e.g., EEG, MEG, EMG) in brain‚Äìcomputer interface and related applications, and forms a building block for classifiers and pipelines (for example, Minimum Distance to Mean (MDM) and other Riemannian methods). The implementation is numerically stable: it uses numpy.linalg.slogdet to compute logarithms of determinants and clips negative squared-distance values caused by floating-point rounding to zero before taking the square root.` |
| `pyriemann_utils_distance_distance_mahalanobis` | `pyriemann.utils.distance.distance_mahalanobis` | `pyriemann/utils/distance.py` | `X: numpy.ndarray, cov: numpy.ndarray, mean: numpy.ndarray = None, squared: bool = False` | `pyriemann.utils.distance.distance_mahalanobis Compute the Mahalanobis distance between column vectors and a multivariate Gaussian distribution. This function computes the Mahalanobis distance between each column vector x in X and a multivariate Gaussian distribution N(mu, C) defined by mean vector mu and covariance matrix C. The computation follows d(x, N(mu, C)) = sqrt((x - mu)^H C^{-1} (x - mu)). It is used in pyRiemann for comparing feature vectors (for example, signal or covariance-derived features from EEG/MEG/EMG in BCI pipelines or patch vectors in remote sensing) to a Gaussian model, which is a common operation in classification, outlier detection, and distance-based algorithms that operate on covariance or multivariate data.` |
| `pyriemann_utils_distance_distance_riemann` | `pyriemann.utils.distance.distance_riemann` | `pyriemann/utils/distance.py` | `A: numpy.ndarray, B: numpy.ndarray, squared: bool = False` | `Affine-invariant Riemannian distance between two symmetric/Hermitian positive definite (SPD/HPD) matrices. This function computes the affine-invariant Riemannian metric used throughout pyRiemann for comparing covariance or similar SPD/HPD matrices arising in multivariate signal processing (for example EEG/MEG/EMG covariance matrices in brain‚Äìcomputer interface workflows, and covariance descriptors in remote sensing). Concretely, for two input matrices A and B the distance is computed as sqrt(sum_i (log(lambda_i))^2) where lambda_i are the joint (generalized) eigenvalues of the matrix pair (A, B). The value quantifies the geometric difference between A and B on the manifold of SPD/HPD matrices and is commonly used as a metric in classification (e.g., MDM), clustering, or embedding procedures in pyRiemann pipelines.` |
| `pyriemann_utils_distance_distance_wasserstein` | `pyriemann.utils.distance.distance_wasserstein` | `pyriemann/utils/distance.py` | `A: numpy.ndarray, B: numpy.ndarray, squared: bool = False` | `pyriemann.utils.distance.distance_wasserstein computes the Wasserstein (Bures) distance between two symmetric/Hermitian positive semidefinite (SPSD/HPSD) matrices. In the pyRiemann context this function is used to measure dissimilarity between covariance or covariance-like matrices (for example, covariance matrices estimated from EEG/MEG/EMG epochs in brain‚Äìcomputer interface pipelines or covariance estimates in remote sensing applications) and can be employed in classification, clustering, or pipeline evaluation where Riemannian-aware distances are required.` |
| `pyriemann_utils_distance_pairwise_distance` | `pyriemann.utils.distance.pairwise_distance` | `pyriemann/utils/distance.py` | `X: numpy.ndarray, Y: numpy.ndarray = None, metric: str = "riemann", squared: bool = False` | `pyriemann.utils.distance.pairwise_distance computes the full pairwise distance matrix between two sets of square matrices (typically covariance matrices used in pyRiemann for biosignals such as EEG/MEG/EMG in BCI or remote-sensing applications). It supports the Riemannian metric by default ("riemann") and several other metrics implemented in pyriemann.utils.distance, and returns either the matrix of distances between all pairs in X (when Y is None) or between each element of X and each element of Y.` |
| `pyriemann_utils_geodesic_geodesic` | `pyriemann.utils.geodesic.geodesic` | `pyriemann/utils/geodesic.py` | `A: numpy.ndarray, B: numpy.ndarray, alpha: float, metric: str = "riemann"` | `pyriemann.utils.geodesic.geodesic: Compute the matrix located at a given position along the geodesic between two square matrices according to a chosen metric. Compute the matrix at position alpha on the geodesic connecting matrices A and B according to a specified metric. This function is used in pyRiemann for interpolating or extrapolating between matrices that represent multivariate descriptors such as covariance matrices arising in biosignal processing (EEG/MEG/EMG) and remote sensing applications. The common practical use is to interpolate between symmetric/Hermitian positive definite (SPD/HPD) matrices on a Riemannian manifold (for example, when working with covariance matrices in brain-computer interface pipelines), but other metrics are available and a user-provided callable can be used to implement custom geodesics.` |
| `pyriemann_utils_geodesic_geodesic_logchol` | `pyriemann.utils.geodesic.geodesic_logchol` | `pyriemann/utils/geodesic.py` | `A: numpy.ndarray, B: numpy.ndarray, alpha: float = 0.5` | `pyriemann.utils.geodesic.geodesic_logchol computes the Log-Cholesky geodesic point between two symmetric/Hermitian positive definite matrices and reconstructs the corresponding SPD/HPD matrix at a given position alpha on that geodesic. This function implements the Log-Cholesky interpolation introduced in Z. Lin (2019) and is used in pyRiemann workflows to interpolate or extrapolate covariance/HPD matrices (for example, covariance matrices estimated from multichannel biosignals such as EEG/MEG in BCI applications) in a manner consistent with Riemannian geometry.` |
| `pyriemann_utils_geodesic_geodesic_riemann` | `pyriemann.utils.geodesic.geodesic_riemann` | `pyriemann/utils/geodesic.py` | `A: numpy.ndarray, B: numpy.ndarray, alpha: float = 0.5` | `Affine-invariant Riemannian geodesic between symmetric/Hermitian positive-definite (SPD/HPD) matrices. Computes the matrix at position alpha on the affine-invariant Riemannian geodesic between two SPD/HPD matrices A and B using the formula C = A^{1/2} (A^{-1/2} B A^{-1/2})^alpha A^{1/2}. In the pyRiemann context, A and B typically represent covariance (SPD) or Hermitian positive-definite (HPD) matrices estimated from multichannel biosignals (EEG/MEG/EMG) or from spatial patches in remote sensing; this function is used when interpolating or moving along the Riemannian manifold of such covariance matrices (for example when computing midpoints for averaging, interpolation for data augmentation, or paths used in transfer learning and classification pipelines like MDM or tangent-space methods). The operation is affine-invariant: applying the same invertible linear transform to A and B yields the congruent transform on C.` |
| `pyriemann_utils_geodesic_geodesic_wasserstein` | `pyriemann.utils.geodesic.geodesic_wasserstein` | `pyriemann/utils/geodesic.py` | `A: numpy.ndarray, B: numpy.ndarray, alpha: float = 0.5` | `Wasserstein geodesic between two symmetric/Hermitian positive-definite (SPD/HPD) matrices. Compute the matrix C located at position alpha on the Wasserstein geodesic between two SPD/HPD matrices A and B using the closed-form expression implemented in this function. Concretely, for each pair of matching square matrices A and B of shape (..., n, n), the result C is computed as C = (1 - alpha)^2 * A + alpha^2 * B + alpha * (1 - alpha) * ( (A^(1/2) B A^(1/2))^(1/2) + its conjugate-transpose ), where A^(1/2) denotes the matrix square root of A and the inner square root is taken after conjugation by A^(1/2). This interpolation is the Wasserstein (optimal-transport) geodesic between Gaussian covariances and is commonly used in the pyRiemann workflow to interpolate or average covariance matrices estimated from multichannel biosignals (e.g., EEG, MEG, EMG) for BCI or remote-sensing applications. The returned matrices maintain SPD/HPD structure when inputs are SPD/HPD.` |
| `pyriemann_utils_kernel_kernel` | `pyriemann.utils.kernel.kernel` | `pyriemann/utils/kernel.py` | `X: numpy.ndarray, Y: numpy.ndarray = None, Cref: numpy.ndarray = None, metric: str = "riemann", reg: float = 1e-10` | `pyriemann.utils.kernel.kernel computes a kernel matrix of pairwise inner products between two sets of square matrices by projecting them to the tangent space at a reference matrix using a specified metric. This function is used in pyRiemann for building kernel matrices from symmetric/Hermitian positive definite (SPD/HPD) matrices (for example covariance matrices estimated from multichannel biosignals such as EEG, MEG or EMG) so they can be used with kernel methods (SVM, kernel ridge regression) or other algorithms that expect a kernel matrix. The function maps each input matrix to the tangent space at Cref according to metric and then computes inner products between the resulting tangent-space vectors to form the kernel matrix. If Y is None the kernel is computed between X and itself. If Cref is None a metric-specific reference (typically a mean on the manifold) is estimated from the input data according to the chosen metric. The regularization parameter reg is applied to mitigate numerical instabilities and to help ensure the resulting kernel matrix is positive-definite for downstream kernel algorithms commonly used in BCI and remote-sensing workflows.` |
| `pyriemann_utils_kernel_kernel_riemann` | `pyriemann.utils.kernel.kernel_riemann` | `pyriemann/utils/kernel.py` | `X: numpy.ndarray, Y: numpy.ndarray = None, Cref: numpy.ndarray = None, reg: float = 1e-10` | `Affine-invariant Riemannian kernel between two sets of SPD matrices. Computes the affine-invariant Riemannian kernel matrix K between two collections of symmetric positive-definite (SPD) matrices by mapping each SPD matrix to the tangent space at a reference SPD matrix Cref and taking pairwise inner products there. Concretely, each matrix X_i (and Y_j) is congruence-transformed by Cref^{-1/2}, the matrix logarithm is applied, and kernel entries are computed as the trace of the product of the resulting log-mapped matrices: K_{i,j} = tr( log(Cref^{-1/2} X_i Cref^{-1/2}) ¬∑ log(Cref^{-1/2} Y_j Cref^{-1/2}) ). This kernel is used in pyRiemann to compare covariance matrices estimated from multichannel biosignals (e.g., EEG/MEG/EMG) for applications such as brain‚Äìcomputer interfaces (BCI) and remote sensing; it provides an inner product in the tangent space at Cref that enables kernel methods (SVM, kernel PCA, etc.) to operate on SPD matrices using Riemannian geometry.` |
| `pyriemann_utils_mean_maskedmean_riemann` | `pyriemann.utils.mean.maskedmean_riemann` | `pyriemann/utils/mean.py` | `X: numpy.ndarray, masks: list, tol: float = 1e-08, maxiter: int = 100, init: numpy.ndarray = None, sample_weight: numpy.ndarray = None` | `Masked Riemannian mean of SPD/HPD matrices using semi-orthogonal projection masks and a gradient-descent solver tailored for partially observed covariance matrices in applications such as EEG/BCI and remote sensing.` |
| `pyriemann_utils_mean_mean_ale` | `pyriemann.utils.mean.mean_ale` | `pyriemann/utils/mean.py` | `X: numpy.ndarray, tol: float = 1e-06, maxiter: int = 50, sample_weight: numpy.ndarray = None, init: numpy.ndarray = None` | `AJD-based log-Euclidean (ALE) mean of SPD/HPD matrices. Compute the ALE mean of a set of symmetric (resp. Hermitian) positive definite matrices using approximate joint diagonalization (AJD) followed by a log-Euclidean update. This function is used in pyRiemann for aggregating covariance (SPD) or covariance-like (HPD) matrices estimated from multichannel biosignals (e.g., EEG, MEG, EMG) or spatial patches in remote sensing, where a robust and computationally efficient surrogate of the Riemannian geometric mean is required. The algorithm performs an AJD (via ajd_pham) to obtain an initial diagonalizing transform (unless an explicit initializer is provided), iteratively updates a diagonal correction in the log-domain using matrix log/exponential (logm/expm), and reconstructs the mean by conjugation with the inverse AJD transform.` |
| `pyriemann_utils_mean_mean_alm` | `pyriemann.utils.mean.mean_alm` | `pyriemann/utils/mean.py` | `X: numpy.ndarray, tol: float = 1e-14, maxiter: int = 100, sample_weight: numpy.ndarray = None` | `Ando-Li-Mathias (ALM) mean of SPD/HPD matrices. Computes the recursive geometric mean of a set of symmetric (real) positive definite (SPD) or Hermitian positive definite (HPD) matrices using the Ando-Li-Mathias (ALM) algorithm [Ando et al., 2004]. In the pyRiemann ecosystem this function is intended to average covariance matrices estimated from multichannel time series (for example EEG/MEG/EMG in brain-computer interface applications or covariance patches in remote sensing). The ALM mean is computed recursively and reduces to a geodesic interpolation for two matrices. The implementation is intentionally exact but computationally expensive: it requires many recursive calls and thus is extremely slow for large numbers of matrices.` |
| `pyriemann_utils_mean_mean_covariance` | `pyriemann.utils.mean.mean_covariance` | `pyriemann/utils/mean.py` | `X: numpy.ndarray, *args, metric: str = "riemann", sample_weight: numpy.ndarray = None, **kwargs` | `Mean of a set of square matrices according to a chosen metric or divergence and return their mean matrix computed with the metric-specific mean estimator. This function is a high-level dispatcher used throughout pyRiemann for summarizing sets of symmetric (or Hermitian) positive definite matrices such as covariance matrices estimated from multichannel biosignals (EEG, MEG, EMG) in brain-computer interface (BCI) workflows or covariance patches in remote sensing. It selects the appropriate mean implementation for the requested metric, handles legacy metric names via internal deprecation handling, forwards additional positional and keyword parameters to the selected mean routine, and supports weighted means via sample_weight.` |
| `pyriemann_utils_mean_mean_harmonic` | `pyriemann.utils.mean.mean_harmonic` | `pyriemann/utils/mean.py` | `X: numpy.ndarray, sample_weight: numpy.ndarray = None` | `pyriemann.utils.mean.mean_harmonic computes the harmonic mean of a collection of invertible square matrices. Computes the weighted harmonic mean defined by the matrix identity M = (sum_i w_i X_i^{-1})^{-1}. This function is intended for use in pyRiemann pipelines where sets of symmetric positive definite (SPD) covariance matrices (for example, covariance estimates from multichannel biosignals such as EEG, MEG, or EMG used in brain-computer interface workflows) need to be averaged using the harmonic operator. The implementation inverts each input matrix, computes the (weighted) Euclidean mean of these inverses via mean_euclid, then inverts the result to produce the harmonic mean. The operation returns a new numpy.ndarray and does not modify the input X in-place.` |
| `pyriemann_utils_mean_mean_kullback_sym` | `pyriemann.utils.mean.mean_kullback_sym` | `pyriemann/utils/mean.py` | `X: numpy.ndarray, sample_weight: numpy.ndarray = None` | `Mean of SPD/HPD matrices according to the symmetrized Kullback-Leibler divergence. This function computes the symmetrized Kullback-Leibler mean (also called the Kullback symmetrized mean) of a set of symmetric positive-definite (SPD) or Hermitian positive-definite (HPD) matrices. The symmetrized Kullback-Leibler mean is implemented as the geometric midpoint (Riemannian geodesic at t=0.5) between the Euclidean mean and the harmonic mean: it first calls mean_euclid(X, sample_weight) and mean_harmonic(X, sample_weight) and then computes their Riemannian geodesic midpoint via geodesic_riemann(..., 0.5). In pyRiemann this is used to aggregate covariance or scatter matrices (for example EEG/MEG covariance matrices in brain‚Äìcomputer interface pipelines or windowed covariance matrices in remote sensing) into a single representative SPD/HPD matrix that is meaningful under information-geometric criteria. The returned matrix is suitable as a central estimator on the SPD/HPD manifold and can be used downstream in Riemannian algorithms such as MDM classification or tangent-space projection.` |
| `pyriemann_utils_mean_mean_logchol` | `pyriemann.utils.mean.mean_logchol` | `pyriemann/utils/mean.py` | `X: numpy.ndarray, sample_weight: numpy.ndarray = None` | `Mean of SPD/HPD matrices according to the log-Cholesky metric. This function computes the log-Cholesky mean M of a set of symmetric (real) positive definite (SPD) or Hermitian (complex) positive definite (HPD) matrices X. The log-Cholesky mean is useful in pyRiemann for averaging covariance matrices estimated from multichannel biosignals (for example EEG, MEG or EMG) in brain‚Äìcomputer interface (BCI) and remote sensing workflows. The returned mean matrix M has the same matrix size as each input matrix and preserves the SPD/HPD structure by construction (M = L @ L.conj().T where L is a lower-triangular matrix whose diagonal is computed in the log-domain and whose off-diagonal entries are averaged linearly).` |
| `pyriemann_utils_mean_mean_logdet` | `pyriemann.utils.mean.mean_logdet` | `pyriemann/utils/mean.py` | `X: numpy.ndarray, tol: float = 0.0001, maxiter: int = 50, init: numpy.ndarray = None, sample_weight: numpy.ndarray = None` | `pyriemann.utils.mean.mean_logdet computes the log-det (Log-Determinant) mean of a set of symmetric positive definite (SPD) or Hermitian positive definite (HPD) matrices using the iterative log-det metric. This mean is commonly used in pyRiemann when averaging covariance matrices arising from multivariate biosignals (e.g., EEG, MEG, EMG) for brain‚Äìcomputer interface (BCI) pipelines and remote sensing applications where Riemannian geometry of SPD/HPD matrices is required.` |
| `pyriemann_utils_mean_mean_power` | `pyriemann.utils.mean.mean_power` | `pyriemann/utils/mean.py` | `X: numpy.ndarray, p: float, sample_weight: numpy.ndarray = None, zeta: float = 1e-09, maxiter: int = 100, init: numpy.ndarray = None` | `pyriemann.utils.mean.mean_power computes the power mean (fixed-point power mean) of a set of symmetric/Hermitian positive definite (SPD/HPD) matrices. This function implements the order-p matrix power mean described in the pyRiemann README and the referenced literature: it returns the unique SPD/HPD matrix M that satisfies the fixed-point relation M = sum_i w_i (M #_p X_i), where A #_p B denotes the geodesic (matrix geometric interpolation) between A and B. In the pyRiemann context this routine is used to average covariance matrices estimated from multichannel biosignals (EEG/MEG/EMG) or spatial covariance descriptors in remote sensing: the output M is a single SPD/HPD covariance matrix summarizing the input set according to the chosen exponent p. The implementation uses a fixed-point iteration that reduces to standard means for special values of p (Euclidean when p == 1, Riemannian/Karcher when p == 0, harmonic when p == -1).` |
| `pyriemann_utils_mean_mean_riemann` | `pyriemann.utils.mean.mean_riemann` | `pyriemann/utils/mean.py` | `X: numpy.ndarray, tol: float = 1e-08, maxiter: int = 50, init: numpy.ndarray = None, sample_weight: numpy.ndarray = None` | `Mean of SPD/HPD matrices according to the affine-invariant Riemannian metric. This function computes the affine-invariant Riemannian mean (also called Karcher mean) of a set of symmetric (or Hermitian) positive-definite (SPD/HPD) matrices. In the context of pyRiemann and the README use-cases, X typically contains covariance matrices estimated from multichannel biosignals (EEG/MEG/EMG) or covariance-like matrices from remote sensing; the returned matrix M is the Riemannian average used by downstream algorithms (for example MDM classification, tangent-space projection, or transfer learning). The implementation performs an iterative gradient-descent-like update on the manifold using matrix square-roots, inverse-square-roots, matrix logarithm and exponential to minimize the sum of squared affine-invariant Riemannian distances to the input matrices. The stopping criterion implemented is the one described in Congedo et al. (PLOS ONE, 2015).` |
| `pyriemann_utils_mean_mean_wasserstein` | `pyriemann.utils.mean.mean_wasserstein` | `pyriemann/utils/mean.py` | `X: numpy.ndarray, tol: float = 1e-08, maxiter: int = 50, init: numpy.ndarray = None, sample_weight: numpy.ndarray = None` | `Mean of SPD/HPD matrices according to the Wasserstein metric. Computes the Bures-Wasserstein barycenter (Wasserstein mean) of a set of symmetric positive definite (SPD) or Hermitian positive definite (HPD) matrices using the inductive mean algorithm. This function is intended for use on covariance or structured positive-definite matrices that arise in multivariate signal processing and machine learning workflows described in the pyRiemann README, for example covariance matrices estimated from multichannel biosignals (EEG, MEG, EMG) in brain‚Äìcomputer interface (BCI) applications or covariance descriptors in remote sensing and hyperspectral imaging. The implementation follows the inductive mean approach and uses the same convergence criterion convention as the Riemannian mean implementation in this package. The algorithm iterates using Wasserstein log and exponential maps (log_map_wasserstein and exp_map_wasserstein) and supports optional sample weighting.` |
| `pyriemann_utils_mean_nanmean_riemann` | `pyriemann.utils.mean.nanmean_riemann` | `pyriemann/utils/mean.py` | `X: numpy.ndarray, tol: float = 1e-08, maxiter: int = 100, init: numpy.ndarray = None, sample_weight: numpy.ndarray = None` | `Compute the Riemannian NaN-mean of SPD/HPD matrices, i.e., the masked Riemannian mean applied to a set of symmetric (or Hermitian) positive definite matrices that may contain symmetric NaN entries. This function is used in pyRiemann to average covariance (SPD) or Hermitian positive definite (HPD) matrices estimated from multichannel biosignals (e.g., EEG/MEG/EMG) or remote-sensing windows when some entries are missing or masked by NaN values, producing a single representative SPD/HPD matrix on the manifold while respecting the geometry of SPD/HPD matrices.` |
| `pyriemann_utils_median_median_riemann` | `pyriemann.utils.median.median_riemann` | `pyriemann/utils/median.py` | `X: numpy.ndarray, tol: float = 1e-05, maxiter: int = 50, init: numpy.ndarray = None, weights: numpy.ndarray = None, step_size: float = 1` | `Compute the affine-invariant Riemannian geometric median of a set of SPD/HPD matrices. This function implements the iterative estimator described in the literature for the Riemannian geometric median on the manifold of symmetric (or Hermitian) positive definite matrices. In the pyRiemann package this is used as a robust central tendency estimator for covariance or scatter matrices that commonly arise from multichannel biosignals (EEG/MEG/EMG) or from local covariance descriptors in remote sensing and hyperspectral imaging. The median returned is affine-invariant (it respects congruent transformations) and is more robust to outliers than the Riemannian mean.` |
| `pyriemann_utils_tangentspace_exp_map` | `pyriemann.utils.tangentspace.exp_map` | `pyriemann/utils/tangentspace.py` | `X: numpy.ndarray, Cref: numpy.ndarray, metric: str = "riemann"` | `Project matrices in a tangent space back onto the symmetric positive-definite (SPD) manifold using the exponential map at a given reference matrix. This function is part of pyRiemann's tangent-space utilities and is used to convert tangent-space representations (for example, tangent vectors obtained from covariance matrices of biosignals such as EEG, MEG or EMG) back to manifold-valued matrices prior to downstream processing (classification, visualization, or saving). The selected metric determines the definition of the exponential map and thus how tangent displacements are re-applied to the reference matrix Cref.` |
| `pyriemann_utils_tangentspace_exp_map_logchol` | `pyriemann.utils.tangentspace.exp_map_logchol` | `pyriemann/utils/tangentspace.py` | `X: numpy.ndarray, Cref: numpy.ndarray` | `Project matrices back to SPD/HPD manifold using the log-Cholesky exponential map. This function implements the log-Cholesky exponential map described in Table 2 of Lin (2019) to move a batch of matrices X from the tangent space at a reference SPD/HPD matrix Cref back onto the SPD/HPD manifold. In the context of pyRiemann, this operation is used when working with covariance matrices (real symmetric positive definite, SPD) or Hermitian positive definite (HPD) matrices arising from multivariate biosignal (EEG/MEG/EMG) processing and BCI pipelines: for example, after projecting covariance matrices to a tangent space for classification or transfer learning, exp_map_logchol reconstructs manifold-valued covariance matrices from their tangent representations. The implementation performs a Cholesky-based reconstruction: it computes the Cholesky factor of Cref, forms a normalized tangent increment, enforces the upper-triangular/log-Cholesky structure, exponentiates diagonal log-parameters, builds a modified Cholesky factor, and returns the reconstructed SPD/HPD matrices as L @ L^H.` |
| `pyriemann_utils_tangentspace_exp_map_riemann` | `pyriemann.utils.tangentspace.exp_map_riemann` | `pyriemann/utils/tangentspace.py` | `X: numpy.ndarray, Cref: numpy.ndarray, Cm12: bool = False` | `pyriemann.utils.tangentspace.exp_map_riemann projects matrices from a tangent space back onto the manifold of symmetric (SPD) or Hermitian (HPD) positive-definite matrices using the Riemannian exponential map; it is used in pyRiemann for converting tangent-space representations (e.g., produced by TangentSpace transformer) back to covariance-like SPD/HPD matrices for downstream algorithms (MDM, visualization, or re-injection into pipelines).` |
| `pyriemann_utils_tangentspace_exp_map_wasserstein` | `pyriemann.utils.tangentspace.exp_map_wasserstein` | `pyriemann/utils/tangentspace.py` | `X: numpy.ndarray, Cref: numpy.ndarray` | `Project matrices back to SPD/HPD manifold using the Wasserstein exponential map. This function implements the Wasserstein Riemannian exponential map that takes a perturbation in the tangent space at a reference symmetric (or Hermitian) positive definite (SPD/HPD) matrix and returns the corresponding matrix on the SPD/HPD manifold. In pyRiemann pipelines for biosignal processing and brain‚Äìcomputer interfaces (BCI), this is used to map tangent-space representations (for example, results of a TangentSpace transform or a gradient update) back to covariance matrices (SPD) or Hermitian positive definite matrices (HPD) so they can be interpreted or further processed as covariance estimates for multichannel time series. The implementation follows Eq.(36) in the referenced Wasserstein geometry paper and uses the eigen-decomposition of the reference matrix Cref to compute the map.` |
| `pyriemann_utils_tangentspace_log_map` | `pyriemann.utils.tangentspace.log_map` | `pyriemann/utils/tangentspace.py` | `X: numpy.ndarray, Cref: numpy.ndarray, metric: str = "riemann"` | `Project SPD/HPD matrices into the tangent space at a reference matrix using a selectable logarithmic map. This function is part of pyriemann.utils.tangentspace and is used to convert a collection of symmetric (or Hermitian) positive definite matrices‚Äîcommonly covariance matrices estimated from multichannel biosignals such as EEG/MEG/EMG in brain-computer interface (BCI) workflows‚Äîinto their representation in the tangent space at a provided reference matrix. The tangent-space representation produced by this logarithmic map is typically used as a Euclidean feature space for downstream machine learning algorithms (for example, TangentSpace transformer or MDM classifier described in the pyRiemann README and examples). The choice of metric controls the geometry used for projection and therefore affects distances, averaging, and the performance of classifiers or regressors operating on the transformed data.` |
| `pyriemann_utils_tangentspace_log_map_logchol` | `pyriemann.utils.tangentspace.log_map_logchol` | `pyriemann/utils/tangentspace.py` | `X: numpy.ndarray, Cref: numpy.ndarray` | `pyriemann.utils.tangentspace.log_map_logchol projects SPD/HPD matrices to the tangent space at a reference matrix using the log-Cholesky logarithmic map (see Lin 2019, Table 2). This implementation is intended for use with covariance or Hermitian positive definite matrices encountered in multivariate biosignal processing and remote sensing workflows (for example EEG/MEG covariance matrices used in BCI pipelines) where one needs a Euclidean representation (tangent vector) of SPD/HPD matrices relative to a chosen reference.` |
| `pyriemann_utils_tangentspace_log_map_riemann` | `pyriemann.utils.tangentspace.log_map_riemann` | `pyriemann/utils/tangentspace.py` | `X: numpy.ndarray, Cref: numpy.ndarray, C12: bool = False` | `Project SPD/HPD matrices to the tangent space at a reference matrix using the Riemannian logarithmic map. This function implements the Riemannian logarithmic map used in pyRiemann to embed symmetric positive definite (SPD) or Hermitian positive definite (HPD) matrices into the tangent space associated with a reference SPD/HPD matrix. The mapping is commonly used in biosignal and remote-sensing workflows provided by pyRiemann (for example, to project covariance matrices estimated from multichannel EEG/MEG/EMG recordings into a vector space suitable for classical machine learning classifiers). Mathematically, for each matrix X in the input batch the default output is X_new = log(Cref^{-1/2} X Cref^{-1/2}), where log denotes the matrix logarithm and Cref^{-1/2} the inverse square root of the reference matrix. If C12 is True the function returns the full Riemannian logarithmic map X_new = Cref^{1/2} log(Cref^{-1/2} X Cref^{-1/2}) Cref^{1/2}, which yields a matrix expressed in the original ambient space but carrying the tangent-space displacement relative to Cref. The function is pure (no in-place modification of inputs) and returns a new array.` |
| `pyriemann_utils_tangentspace_log_map_wasserstein` | `pyriemann.utils.tangentspace.log_map_wasserstein` | `pyriemann/utils/tangentspace.py` | `X: numpy.ndarray, Cref: numpy.ndarray` | `pyriemann.utils.tangentspace.log_map_wasserstein: Project SPD/HPD matrices to the tangent space using the Wasserstein logarithmic map.` |
| `pyriemann_utils_tangentspace_tangent_space` | `pyriemann.utils.tangentspace.tangent_space` | `pyriemann/utils/tangentspace.py` | `X: numpy.ndarray, Cref: numpy.ndarray, metric: str = "riemann"` | `pyriemann.utils.tangentspace.tangent_space: Transform symmetric/Hermitian matrices (typically covariance matrices) into tangent-space vectors using a logarithmic map around a reference matrix. Transforms input matrices X into vectors in the tangent space at a reference matrix Cref by applying a matrix logarithmic map (log_map) with respect to Cref and then vectorizing the upper-triangular part (upper). This mapping is commonly used in pyRiemann pipelines for brain-computer interface (BCI) and hyperspectral/remote-sensing workflows to convert symmetric positive definite (SPD) covariance or Hermitian positive definite (HPD) matrices into fixed-length feature vectors for classifiers (for example, SVM in TangentSpace).` |
| `pyriemann_utils_tangentspace_transport` | `pyriemann.utils.tangentspace.transport` | `pyriemann/utils/tangentspace.py` | `X: numpy.ndarray, A: numpy.ndarray, B: numpy.ndarray` | `pyriemann.utils.tangentspace.transport: Parallel transport of tangent-space matrices between two positive-definite base points under the affine-invariant metric. This function implements the parallel transport of symmetric (real) or Hermitian (complex) matrices X that live in the tangent space of the manifold of symmetric/Hermitian positive definite (SPD/HPD) matrices. It moves tangent vectors defined at a source base point A to the tangent space at a target base point B along the geodesic given by the affine-invariant metric and Levi-Civita connection. In the pyRiemann workflow this is used when comparing or combining tangent-space representations of covariance/HPD matrices computed from multichannel biosignals (e.g., EEG, MEG, EMG) or remote sensing data across different sessions or subjects, where covariance matrices have been mapped to tangent space by a matrix logarithm and must be transported to a common reference base point before classification or transfer learning.` |
| `pyriemann_utils_tangentspace_untangent_space` | `pyriemann.utils.tangentspace.untangent_space` | `pyriemann/utils/tangentspace.py` | `T: numpy.ndarray, Cref: numpy.ndarray, metric: str = "riemann"` | `Transform tangent vectors back to matrices using an exponential map referenced to a base matrix. This function is the inverse operation of the tangent-space mapping used in pyRiemann's TangentSpace pipeline: it takes vectorized tangent representations (typically obtained from covariance matrices in biosignal/BCI processing) and reconstructs matrices on the manifold by first rebuilding a symmetric matrix from the upper-triangular vector and then applying an exponential map centered at the provided reference matrix Cref. It is commonly used to convert features used by Euclidean classifiers (vectors in tangent space) back to symmetric positive-definite (SPD) matrices for interpretation, visualization, or further manifold-valued processing in applications such as EEG/MEG/BCI or hyperspectral/remote-sensing covariance analysis.` |
| `pyriemann_utils_tangentspace_unupper` | `pyriemann.utils.tangentspace.unupper` | `pyriemann/utils/tangentspace.py` | `T: numpy.ndarray` | `Inverse upper triangular unpacking for symmetric/Hermitian matrices. This function reconstructs symmetric (for real-valued data) or Hermitian (for complex-valued data) matrices from their weighted upper triangular vectorized representations. It is the inverse operation of pyriemann.utils.tangentspace.upper and is used in pyRiemann workflows that convert between matrix and vector representations (for example, the TangentSpace transformer and any pipeline that vectorizes SPD/HPD matrices for standard machine learning estimators). The input T is expected to contain the upper-triangular entries where off-diagonal elements were previously multiplied by sqrt(2) (the symmetric weighting convention used by upper). This function divides those off-diagonal entries by sqrt(2) and fills the lower triangle as the conjugate transpose of the upper triangle to restore symmetry/Hermiticity.` |
| `pyriemann_utils_tangentspace_upper` | `pyriemann.utils.tangentspace.upper` | `pyriemann/utils/tangentspace.py` | `X: numpy.ndarray` | `pyriemann.utils.tangentspace.upper returns the weighted, vectorized upper-triangular part of square symmetric/Hermitian matrices to produce the minimal tangent-space representation used throughout pyRiemann for processing covariance/HPD matrices (for example, covariance matrices estimated from multichannel biosignals such as EEG/MEG/EMG in BCI pipelines). This function extracts the upper triangular entries of each input matrix (including the diagonal), applies a weight of 1.0 to diagonal elements and sqrt(2) to off-diagonal elements, and flattens those weighted entries into a 1-D vector per matrix. The weighting (unity on the diagonal, sqrt(2) on off-diagonals) yields the minimal representation commonly used in tangent-space/vectorization routines so that inner products and norms are preserved when mapping symmetric/Hermitian matrices to Euclidean vectors. The function supports broadcasting over any leading dimensions, so it accepts batches of matrices with shape (..., n, n) and returns a batch of vectors with shape (..., n * (n + 1) / 2). The routine does not validate that the numerical values of X are symmetric/Hermitian; it only requires square matrices and will operate on the provided upper-triangular values. It performs no in-place modification of the input and returns a new ndarray.` |
| `pyriemann_utils_test_is_hankel` | `pyriemann.utils.test.is_hankel` | `pyriemann/utils/test.py` | `X: numpy.ndarray` | `pyriemann.utils.test.is_hankel checks whether a given square numpy.ndarray is a Hankel matrix. A Hankel matrix is a square matrix that is constant along its anti-diagonals (elements with equal i+j indices are equal). In the context of pyRiemann, which processes multichannel time-series and covariance-like matrices for biosignals (EEG/MEG/EMG) and remote sensing, detecting a Hankel structure can be used to validate time-delay embeddings, structured covariance estimates, or to gate algorithms that assume anti-diagonal constancy. This function performs an element-wise exact comparison to verify that property without modifying the input.` |
| `pyriemann_utils_test_is_herm_pos_def` | `pyriemann.utils.test.is_herm_pos_def` | `pyriemann/utils/test.py` | `X: numpy.ndarray, tol: float = 0.0` | `Check if all matrices in X are Hermitian positive-definite (HPD). This utility is used in pyRiemann to validate matrices (for example covariance or cross-spectral matrices computed from multivariate biosignals such as EEG, MEG, EMG or from remote sensing data) before applying algorithms that assume Hermitian (conjugate-symmetric) and positive-definite structure. The function returns True only when every square matrix in X is both Hermitian and positive-definite according to a numerical threshold; it composes the results of is_hermitian(X) and is_pos_def(X, tol=tol).` |
| `pyriemann_utils_test_is_herm_pos_semi_def` | `pyriemann.utils.test.is_herm_pos_semi_def` | `pyriemann/utils/test.py` | `X: numpy.ndarray` | `Check whether every matrix in a collection is Hermitian positive semi-definite (HPSD).` |
| `pyriemann_utils_test_is_hermitian` | `pyriemann.utils.test.is_hermitian` | `pyriemann/utils/test.py` | `X: numpy.ndarray` | `Check whether every square matrix in X is Hermitian. In the pyRiemann library this function is used to validate complex-valued square matrices (for example complex covariance estimates or kernel matrices encountered in biosignal processing, BCI, or remote sensing workflows) before treating them as Hermitian positive-definite (HPD) objects for Riemannian geometry operations. A matrix is considered Hermitian here when its real part is symmetric and its imaginary part is skew-symmetric. The implementation performs this check by testing symmetry of X.real and skew-symmetry of X.imag using the library helpers is_sym and is_skew_sym.` |
| `pyriemann_utils_test_is_pos_def` | `pyriemann.utils.test.is_pos_def` | `pyriemann/utils/test.py` | `X: numpy.ndarray, tol: float = 0.0, fast_mode: bool = False` | `Check whether all matrices contained in X are positive definite (PD). This utility is used within pyRiemann to validate symmetric/Hermitian positive definite (SPD/HPD) matrices such as covariance matrices estimated from multichannel biosignals (EEG/MEG/EMG) or spatial covariance blocks in remote sensing. A return value of True indicates that every matrix in the input satisfies the positive definiteness criterion required by downstream Riemannian-geometry-based algorithms (e.g., covariance-based classification, MDM, TangentSpace). The function accepts a single square matrix of shape (n, n) or a batch of matrices with shape (..., n, n).` |
| `pyriemann_utils_test_is_pos_semi_def` | `pyriemann.utils.test.is_pos_semi_def` | `pyriemann/utils/test.py` | `X: numpy.ndarray` | `pyriemann.utils.test.is_pos_semi_def checks whether every matrix contained in the input array X is positive semi-definite (PSD). This is a lightweight validator used in pyRiemann to verify covariance matrices or other square matrix collections before algorithms that assume non-negative eigenvalues (for example, Riemannian geometry routines that require SPD/PSD inputs).` |
| `pyriemann_utils_test_is_real` | `pyriemann.utils.test.is_real` | `pyriemann/utils/test.py` | `X: numpy.ndarray` | `Check whether every matrix in a collection has no significant imaginary component.` |
| `pyriemann_utils_test_is_real_type` | `pyriemann.utils.test.is_real_type` | `pyriemann/utils/test.py` | `X: numpy.ndarray` | `Check if a collection of matrices is of a real numeric type. This function is used in pyRiemann preprocessing and validation steps where algorithms assume real-valued matrices (for example, covariance estimation and Riemannian operations on symmetric positive definite (SPD) matrices). It inspects the numeric dtype of the input matrix array to determine whether the data are stored as real valued numbers (no imaginary component). This is a lightweight, dtype-level test: it does not check matrix properties such as symmetry, positive-definiteness, or shape validity beyond the array's dtype.` |
| `pyriemann_utils_test_is_skew_sym` | `pyriemann.utils.test.is_skew_sym` | `pyriemann/utils/test.py` | `X: numpy.ndarray` | `Check if all matrices in X are skew-symmetric (X^T = -X) across the last two axes. This utility is part of pyriemann.utils.test and is intended for use in unit tests, validation checks, and preprocessing/diagnostics inside the pyRiemann library. In the pyRiemann context (multivariate biosignal processing and Riemannian geometry of matrices), it helps verify that a candidate array of square matrices represents antisymmetric operators (for example, elements of the Lie algebra of SO(n) or antisymmetric residuals produced during intermediate computations). The check is performed element-wise with a numerical tolerance (see behavior below) and does not modify the input array.` |
| `pyriemann_utils_test_is_square` | `pyriemann.utils.test.is_square` | `pyriemann/utils/test.py` | `X: numpy.ndarray` | `pyriemann.utils.test.is_square checks whether the last two dimensions of a numpy array represent square matrices. This function is typically used in pyRiemann preprocessing and validation code to ensure that inputs that are expected to be batches of square matrices (for example, covariance matrices estimated from multichannel biosignals such as EEG, which are symmetric positive definite and therefore square) have the correct shape before further Riemannian operations. It performs a lightweight shape check only and does not inspect matrix values or properties such as symmetry or positive definiteness.` |
| `pyriemann_utils_test_is_sym` | `pyriemann.utils.test.is_sym` | `pyriemann/utils/test.py` | `X: numpy.ndarray` | `Check if all matrices in X are symmetric. This function is used in pyRiemann to validate that a collection of square matrices (for example covariance matrices estimated from multichannel biosignals such as EEG/MEG used in BCI applications) satisfy the symmetry property required by symmetric positive definite (SPD) or Hermitian positive definite (HPD) matrix processing. It operates on a single numpy.ndarray that may contain a batch of matrices in its leading dimensions and checks symmetry on the last two axes.` |
| `pyriemann_utils_test_is_sym_pos_def` | `pyriemann.utils.test.is_sym_pos_def` | `pyriemann/utils/test.py` | `X: numpy.ndarray, tol: float = 0.0` | `pyriemann.utils.test.is_sym_pos_def checks whether every matrix in a provided array X is symmetric positive-definite (SPD). This is typically used in pyRiemann to validate covariance or Hermitian positive-definite matrices estimated from multichannel biosignals (e.g., EEG, MEG, EMG) before applying Riemannian-geometry-based processing and classification algorithms that require SPD inputs.` |
| `pyriemann_utils_test_is_sym_pos_semi_def` | `pyriemann.utils.test.is_sym_pos_semi_def` | `pyriemann/utils/test.py` | `X: numpy.ndarray` | `Check whether every square matrix in X is symmetric and positive semi-definite (SPSD). This utility is used in pyRiemann to validate matrices that are expected to represent covariance or kernel matrices (for example, covariance matrices estimated from multichannel EEG/MEG/EMG trials in brain‚Äìcomputer interface pipelines). The function returns True only when every matrix in the input is both symmetric and positive semi-definite according to the underlying checks is_sym and is_pos_semi_def; otherwise it returns False. The function does not modify the input array.` |
| `pyriemann_utils_utils_check_function` | `pyriemann.utils.utils.check_function` | `pyriemann/utils/utils.py` | `fun: str, functions: dict` | `Check which function implementation to use given a user input name or a callable. This utility is used across the pyRiemann package to resolve a requested function into a concrete callable implementation used by the API (for example to select implementations for covariance estimation, tangent-space transforms, metric computations or other processing steps in BCI and remote sensing pipelines described in the project README). The function accepts either a string naming one of the available API functions or a callable provided by the user, and returns a callable that can then be invoked by downstream code to process SPD/HPD matrices or multichannel biosignal-derived objects. The resolution does not perform signature compatibility checks on user-provided callables; it only maps names to implementations or verifies that the provided object is callable.` |
| `pyriemann_utils_utils_check_init` | `pyriemann.utils.utils.check_init` | `pyriemann/utils/utils.py` | `init: numpy.ndarray, n: int` | `Check the initial matrix used to initialize algorithms in pyriemann.utils.utils.check_init. This function verifies that the provided initial matrix has the exact square shape (n, n) required by downstream algorithms that operate on n-by-n matrices (for example, covariance matrices and other SPD/HPD matrices used in pyRiemann for biosignal processing and remote sensing). The function also converts the input to a numpy.ndarray using np.asarray but does not perform checks on symmetry or positive-definiteness.` |
| `pyriemann_utils_utils_check_metric` | `pyriemann.utils.utils.check_metric` | `pyriemann/utils/utils.py` | `metric: dict, expected_keys: list = ['mean', 'distance']` | `Check and normalize a metric argument for pyriemann algorithms. This function validates and normalizes the "metric" argument used throughout pyRiemann algorithms that operate on symmetric/Hermitian positive definite (SPD/HPD) covariance matrices (for example in EEG/MEG/BCI pipelines and remote sensing applications described in the project README). The metric argument can be provided as a single metric name string to be applied to all algorithm steps, or as a dictionary mapping specific algorithm steps (for example "mean" and "distance") to metric name strings. A common practical use is to pass a faster metric (e.g., "logeuclid") for the "mean" computation to speed up covariance averaging, while using a more sensitive metric (e.g., "riemann") for the "distance" computation to preserve classification performance in BCI pipelines.` |
| `pyriemann_utils_utils_check_version` | `pyriemann.utils.utils.check_version` | `pyriemann/utils/utils.py` | `library: str, min_version: str, strip: bool = True` | `Check minimum library version required for pyRiemann runtime or optional dependency checks. This function is used in pyRiemann (a package for processing multivariate biosignal data such as EEG/MEG for BCI applications) to verify that an external Python library dependency is present and meets a minimum semantic version requirement before enabling features that rely on that library. It attempts to import the named library, reads its __version__ attribute, optionally strips PEP440 development markers (for backward compatibility with LooseVersion-like behavior), and compares the resulting version string against the supplied minimum. The function returns a boolean indicating whether the dependency is available and sufficiently recent. Behavior and edge cases follow the implementation in pyriemann.utils.utils and are adapted from MNE-Python.` |
| `pyriemann_utils_utils_check_weights` | `pyriemann.utils.utils.check_weights` | `pyriemann/utils/utils.py` | `weights: numpy.ndarray, n_weights: int, check_positivity: bool = False` | `Check weights. Validate, normalize and (optionally) enforce strict positivity of a 1-D weight vector. This utility is used throughout pyRiemann to prepare weighting coefficients that combine objects such as covariance matrices (for example when computing weighted Riemannian means or weighted sums of SPD matrices in BCI and remote sensing pipelines). The function ensures a deterministic, normalized set of weights summing to 1 and raises clear errors for malformed inputs.` |
| `pyriemann_utils_viz_plot_bihist` | `pyriemann.utils.viz.plot_bihist` | `pyriemann/utils/viz.py` | `X: numpy.ndarray, y: numpy.ndarray, n_bins: int = 10, title: str = "Histogram"` | `pyriemann.utils.viz.plot_bihist plots a bi-class histogram of predictions, distances or probabilities produced by binary classifiers or similarity scoring methods used in pyRiemann workflows (for example in BCI or remote sensing pipelines where per-epoch or per-window scores are produced and represented as two-element vectors). This function expects a 2-column array of scores (one column per class) for a set of examples and a matching 1-D array of labels. It rescales each row of X to sum to 1 (interpreting rows as unnormalized scores or probabilities), selects the scores corresponding to each of the two unique labels in y, computes a complementary score for the second class (1 - score), and draws two overlapping histograms with a vertical reference line at 0.5. The histogram bins are computed with a helper that forces the bin edges to include 0.5 so that the decision threshold is aligned with bin boundaries. The function produces a matplotlib figure (side effect) sized to (6, 5), configures axis labels and title, draws a legend titled "Classes" in the upper-left, and returns the figure object for further manipulation or saving.` |
| `pyriemann_utils_viz_plot_biscatter` | `pyriemann.utils.viz.plot_biscatter` | `pyriemann/utils/viz.py` | `X: numpy.ndarray, y: numpy.ndarray` | `Plot scatter of bi-class predictions. This function visualizes two-dimensional predictions, distances, or probabilities for a binary classification problem as a scatter plot. It is intended for use in pyRiemann workflows where classifiers or estimators produce two values per sample (for example, scores derived from covariance-matrix-based BCI pipelines such as MDM or tangent-space classifiers). The plot helps inspect separation between the two classes by grouping points according to the labels provided in y, drawing a diagonal reference line, and enforcing equal axis limits so that distances from the diagonal are comparable on both axes.` |
| `pyriemann_utils_viz_plot_cospectra` | `pyriemann.utils.viz.plot_cospectra` | `pyriemann/utils/viz.py` | `X: numpy.ndarray, freqs: numpy.ndarray, ylabels: list = None, title: str = "Cospectra"` | `Plot cospectral matrices. This function visualizes a sequence of cospectral matrices (frequency-resolved cross-spectral/covariance estimates) as a grid of heatmap subplots. In the pyRiemann workflow for biosignals (for example EEG/MEG processing in BCI applications), cospectral matrices represent multichannel frequency-domain covariance structure estimated per frequency; this function helps inspect those matrices across frequencies to diagnose spectral structure, channel interactions, or preprocessing issues prior to downstream Riemannian processing or classification.` |
| `pyriemann_utils_viz_plot_embedding` | `pyriemann.utils.viz.plot_embedding` | `pyriemann/utils/viz.py` | `X: numpy.ndarray, y: numpy.ndarray = None, embd_type: str = "Spectral", metric: str = "riemann", title: str = "Embedding of SPD matrices", normalize: bool = True, max_iter: int = 50` | `Plot embedding of SPD matrices using manifold embedding algorithms and display the result with matplotlib. This function is used in the pyRiemann library to visualize low-dimensional embeddings of symmetric positive definite (SPD) matrices (for example covariance matrices estimated from multichannel biosignals such as EEG, MEG or EMG, or from spatial windows in hyperspectral/remote sensing applications). It supports three embedding algorithms implemented in the codebase: SpectralEmbedding, LocallyLinearEmbedding and TSNE. The function (1) fits the selected embedding estimator to the provided SPD matrices X, (2) transforms X to the low-dimensional embedding, and (3) creates and returns a matplotlib Figure containing a scatter plot of the embedding with per-class markers and a legend. The visualization is intended to help inspect class separability and structure of SPD matrix datasets used in brain-computer interface (BCI) and related pipelines described in the project README.` |
| `pyriemann_utils_viz_plot_waveforms` | `pyriemann.utils.viz.plot_waveforms` | `pyriemann/utils/viz.py` | `X: numpy.ndarray, display: str, times: numpy.ndarray = None, color: str = "gray", alpha: float = 0.5, linewidth: float = 1.5, color_mean: str = "k", color_std: str = "gray", n_bins: int = 50, cmap: str = None` | `Plot repetitions of a multichannel waveform for inspection and visualization in biosignal/BCI workflows. This function is used to visualize repeated multichannel time-series (for example EEG/MEG/EMG epochs used in brain-computer interface research as described in the package README). It creates a matplotlib figure with one subplot per channel and supports four display modes: plotting every repetition, plotting the mean waveform, plotting the mean with a shaded standard-deviation band, or plotting a 2D histogram of all repetitions. The figure it returns can be embedded in analysis reports, used for manual quality control of epoch preprocessing, or for illustrative figures in publications.` |

## ‚öñÔ∏è License

Original Code License: BSD-3-Clause

Wrapper Code & Documentation: Apache-2.0

*This file was automatically generated on February 26, 2026.*
