# chai_lab

[üîô Back to Main Repo](../../../README.md) | [üîó Original Repo](https://github.com/chaidiscovery/chai-lab)

![Tool Count](https://img.shields.io/badge/Agent_Tools-12-blue?style=flat-square)
![Category](https://img.shields.io/badge/Category-Biology-green?style=flat-square)
![Status](https://img.shields.io/badge/Import_Test-Passed-success?style=flat-square)

## üìñ Overview

`chai_lab` provides GPU-accelerated command-line and Python APIs for running the Chai-1 multimodal foundation model to predict 3D molecular structures of complexes involving proteins, small molecules, DNA/RNA, and modifications, optionally using MSAs/templates for improved accuracy.

> **Note**: This documentation lists the **agent-ready wrapper functions** generated for this package. These functions have been strictly typed, docstring-enhanced, and tested for import stability within a standardized Apptainer environment.

## üõ†Ô∏è Available Agent Tools

Below is the list of **12** functions optimized for LLM tool-use.

| **Tool Name (Wrapper)**   | **Source**          | **File Path**     | **Arguments (Type)**        | **Description**                |
| ------------------------- | ------------------- | ----------------- | --------------------------- | ------------------------------ |
| `chai_lab_data_collate_utils_pad_size` | `chai_lab.data.collate.utils.pad_size` | `chai_lab/data/collate/utils.py` | `max_in_batch: int, allowed_sizes: list[int]` | `chai_lab.data.collate.utils.pad_size returns the chosen padding length for a batch by selecting the smallest allowed size that is greater than or equal to the largest item in the batch. In the Chai-1 codebase this helper is used by collate utilities to decide the tensor length to pad sequences/embeddings to when constructing batches for model inference or training, which helps control GPU memory layout and ensures batch tensors conform to sizes supported by downstream kernels and model code. This function is pure and has no side effects. It expects allowed_sizes to enumerate the candidate padding lengths that are acceptable in the collate pipeline (for example, powers-of-two or predefined bucket sizes used to limit memory fragmentation). The last element of allowed_sizes is treated as the maximum allowed padding size. The function performs a strict capacity check and will raise an error if the requested maximum in the batch exceeds that maximum allowed padding.` |
| `chai_lab_data_features_feature_utils_get_entry_for_key` | `chai_lab.data.features.feature_utils.get_entry_for_key` | `jaxtyping/_decorator.py` | `data: dict, key: str` | `chai_lab.data.features.feature_utils.get_entry_for_key returns a nested entry from a mapping by interpreting a slash-separated key path and walking the mapping one level at a time. This utility is used in the Chai-1 feature-processing pipeline to extract nested features (for example embeddings, MSA or template sub-objects) from dictionaries produced or consumed by functions such as run_folding_on_context and AllAtomFeatureContext construction.` |
| `chai_lab_data_io_cif_utils_get_chain_letter` | `chai_lab.data.io.cif_utils.get_chain_letter` | `chai_lab/data/io/cif_utils.py` | `asym_id: int` | `Get the single-character chain letter corresponding to a one-indexed asym_id. This function maps a one-indexed asym_id (as used when parsing mmCIF/structure files or when interpreting template hit tables in the Chai-1 template-loading pipeline described in the README) to the canonical chain letter used by the codebase. In the Chai-1 project this mapping is used when loading template structures and parsing chains from CIF files (for example, when reading hits from an m8 file and then selecting a chain within the downloaded CIF), so callers can convert numeric asym unit identifiers into human-readable chain identifiers for downstream file naming, indexing, and matching chains to sequence records.` |
| `chai_lab_data_parsing_input_validation_constituents_of_modified_fasta` | `chai_lab.data.parsing.input_validation.constituents_of_modified_fasta` | `chai_lab/data/parsing/input_validation.py` | `x: str` | `chai_lab.data.parsing.input_validation.constituents_of_modified_fasta parses and validates a single-line modified FASTA-style sequence string used as input to Chai-1 folding workflows, returning the sequence constituents (single-letter residues and bracketed multi-character modifications) or None if the input is invalid. This function is used in the Chai-1 codepath that accepts FASTA inputs containing modified residues (for example, RNA/DNA/protein sequences with modifications expressed in parentheses) as described in the repository README. It is intended to detect and extract the atomic constituents that the folding pipeline will interpret as residues or modification blocks, and to reject strings that do not conform to the accepted modified-FASTA format (for example, SMILES strings for ligands should not be passed to this parser).` |
| `chai_lab_data_parsing_input_validation_identify_potential_entity_types` | `chai_lab.data.parsing.input_validation.identify_potential_entity_types` | `chai_lab/data/parsing/input_validation.py` | `sequence: str` | `Identify which high-level molecular entity types a single input string could represent for Chai-1 input parsing and validation. This function inspects a provided FASTA-like sequence or a SMILES-like ligand string and returns a conservative list of possible entity types that the string could represent. It is used by Chai-1 input parsing and validation code to choose how an input should be interpreted before constructing embedding/MSA/template contexts or before attempting folding. The function applies two syntactic checks: (1) it calls constituents_of_modified_fasta(...) to parse modified FASTA tokens and examine one-letter residue constituents; (2) it checks whether the sequence only contains a restricted set of ASCII symbols commonly used in SMILES and manual glycan notations. The function is intentionally permissive: it may return multiple EntityType values when the input is ambiguous (for example, short sequences that could be DNA, RNA, or protein). It does not perform full biochemical or SMILES validation, does not query external services, and does not perform any I/O or mutate program state.` |
| `chai_lab_data_parsing_msas_a3m_tokenize_sequences_to_arrays` | `chai_lab.data.parsing.msas.a3m.tokenize_sequences_to_arrays` | `chai_lab/data/parsing/msas/a3m.py` | `seqs_str: list[str]` | `Tokenize a list of aligned sequences in a3m format into two NumPy arrays that are ready for downstream MSA embedding and folding in the Chai-1 pipeline. This function is used by the Chai-1 codepath that accepts multiple sequence alignments (MSAs) in a3m-like format (see README section "How can MSAs be provided to Chai-1?"). It converts a list of aligned sequence strings into compact uint8 arrays: one containing token identifiers for each alignment column per sequence (used as the primary encoded MSA input to the model) and one containing per-sequence, per-column deletion information (used by MSA-processing helpers). The function derives the alignment column count from the first sequence and relies on the tokenization mapping returned by the internal _get_tokenization_mapping() helper and the parsing implemented in _parse_seqs_to_ndarrays().` |
| `chai_lab_data_parsing_msas_aligned_pqt_expected_basename` | `chai_lab.data.parsing.msas.aligned_pqt.expected_basename` | `chai_lab/data/parsing/msas/aligned_pqt.py` | `query_sequence: str` | `chai_lab.data.parsing.msas.aligned_pqt.expected_basename returns the expected filename (basename) for an aligned.pqt MSA file corresponding to a provided query sequence. This function is used by the Chai-1 MSA handling code to compute the canonical filename under which an MSA (aligned.pqt, a parquet-style table that can include metadata like source database and pairing keys) should be stored or looked up for a given sequence.` |
| `chai_lab_data_parsing_structure_sequence_fasta_one_letter_sequence` | `chai_lab.data.parsing.structure.sequence.fasta_one_letter_sequence` | `chai_lab/data/parsing/structure/sequence.py` | `residue_codes: list[str]` | `chai_lab.data.parsing.structure.sequence.fasta_one_letter_sequence: Convert a list of residue identifiers into a concatenated one-letter FASTA sequence suitable for Chai-1 inputs and downstream folding. Converts each string in residue_codes by looking up the corresponding tabulated residue via gemmi.find_tabulated_residue(res) and calling its fasta_code() method, then concatenates the results in the same order as the input list. This utility is used to produce the one-letter sequence lines that are commonly required by the Chai-1 folding pipeline (for example, to create FASTA files consumed by the CLI command `chai-lab fold` or by the programmatic inference entrypoints such as chai_lab.chai1.run_inference). The function performs no I/O, does not mutate its inputs, and is deterministic for a given gemmi residue table.` |
| `chai_lab_data_parsing_structure_sequence_protein_one_letter_sequence` | `chai_lab.data.parsing.structure.sequence.protein_one_letter_sequence` | `chai_lab/data/parsing/structure/sequence.py` | `residue_codes: list[str]` | `chai_lab.data.parsing.structure.sequence.protein_one_letter_sequence converts a list of protein residue names into a contiguous one-letter amino-acid sequence string used by Chai-1 for sequence inputs such as FASTA lines, MSA entries, template chain sequences, and embedding contexts. This function provides a stable, explicit mapping of residue names to single-character amino-acid codes (similar in effect to gemmi.fasta_code()), and it intentionally encodes non-standard or unknown residue names as the placeholder "X" so downstream folding, MSA, and template-processing code receive a well-formed sequence.` |
| `chai_lab_data_parsing_structure_sequence_protein_one_letter_sequence_with_mods` | `chai_lab.data.parsing.structure.sequence.protein_one_letter_sequence_with_mods` | `chai_lab/data/parsing/structure/sequence.py` | `residue_codes: list[str]` | `Convert a list of protein residue codes into a single one-letter amino-acid sequence string, emitting non-standard or modified residues in bracketed form so the sequence preserves modification identity for downstream processing in Chai-1. This function is used by Chai-1 input parsing and folding utilities to produce a compact, human- and machine-readable linear sequence from per-residue annotations (for example, sequences parsed from FASTA files or PDB residue lists) that may contain chemically modified residues. Non-standard residues are preserved as bracketed tokens so the model input retains modification information required for accurate folding of modified proteins and complexes. The implementation delegates token mapping to the internal helper _get_protein_only_residue_token with mods_in_brackets=True, producing a deterministic, side-effect-free transformation.` |
| `chai_lab_utils_paths_chai1_component` | `chai_lab.utils.paths.chai1_component` | `chai_lab/utils/paths.py` | `comp_key: str` | `chai_lab.utils.paths.chai1_component retrieves and returns the local filesystem path to a Chai-1 exported model component, downloading the component from the official component store if it is not already present.` |
| `chai_lab_utils_tensor_utils_set_seed` | `chai_lab.utils.tensor_utils.set_seed` | `chai_lab/utils/tensor_utils.py` | `seed_sequence: list[int]` | `Seeds numpy, torch, and the Python stdlib random module using a reproducible, hierarchical SeedSequence strategy so that Chai-1 workloads (for example folding runs, MSA sampling, and any stochastic model components described in the project README) have well-defined, independent pseudo-random number generator (PRNG) streams. This function is heavily inspired by Lightning's pl_worker_init_function and is intended to be called during process or worker initialization to avoid correlated RNG streams across libraries.` |

## ‚öñÔ∏è License

Original Code License: Apache-2.0

Wrapper Code & Documentation: Apache-2.0

*This file was automatically generated on February 26, 2026.*
