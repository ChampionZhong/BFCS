# Bio

[üîô Back to Main Repo](../../../README.md) | [üîó Original Repo](https://github.com/biopython/biopython)

![Tool Count](https://img.shields.io/badge/Agent_Tools-153-blue?style=flat-square)
![Category](https://img.shields.io/badge/Category-Biology-green?style=flat-square)
![Status](https://img.shields.io/badge/Import_Test-Passed-success?style=flat-square)

## üìñ Overview

Bio (Biopython) is an open-source collection of Python tools for computational molecular biology, providing utilities to read/write and analyze biological sequence and structure data and interface with common bioinformatics resources.

> **Note**: This documentation lists the **agent-ready wrapper functions** generated for this package. These functions have been strictly typed, docstring-enhanced, and tested for import stability within a standardized Apptainer environment.

## üõ†Ô∏è Available Agent Tools

Below is the list of **153** functions optimized for LLM tool-use.

| **Tool Name (Wrapper)**   | **Source**          | **File Path**     | **Arguments (Type)**        | **Description**                |
| ------------------------- | ------------------- | ----------------- | --------------------------- | ------------------------------ |
| `Bio_Align_substitution_matrices_load` | `Bio.Align.substitution_matrices.load` | `Bio/Align/substitution_matrices/__init__.py` | `name: str = None` | `Load and return a precalculated substitution matrix used for sequence alignment scoring, or list available matrix files. This function is part of the Bio.Align.substitution_matrices module in Biopython and is used in computational molecular biology workflows to obtain substitution matrices (precomputed scoring matrices) for pairwise or multiple sequence alignment algorithms. When called with no argument, it discovers and returns the available matrix filenames in the package data directory so a user or program can choose which matrix to load. When called with a filename, it reads and returns the matrix data parsed by the module's read function so the matrix can be supplied to alignment routines that expect a substitution matrix.` |
| `Bio_AlignIO_PhylipIO_sanitize_name` | `Bio.AlignIO.PhylipIO.sanitize_name` | `Bio/AlignIO/PhylipIO.py` | `name: str, width: int = None` | `Bio.AlignIO.PhylipIO.sanitize_name: Sanitize a sequence identifier string for safe output in PHYLIP-style alignment files used by Biopython's AlignIO/PhylipIO code. This function prepares a Python string intended to be used as a sequence identifier when writing alignment files in the PHYLIP family of formats. It applies a fixed, deterministic sequence of transformations to ensure the identifier does not contain characters banned or problematic for PHYLIP writers and optionally truncates the identifier to a specified maximum width. This routine is used by Biopython's PHYLIP output code to improve interoperability of produced files with downstream tools that expect simple identifiers.` |
| `Bio_Cluster_clustercentroids` | `Bio.Cluster.clustercentroids` | `Bio/Cluster/__init__.py` | `data: numpy.ndarray, mask: numpy.ndarray = None, clusterid: numpy.ndarray = None, method: str = "a", transpose: bool = False` | `Calculate and return the centroid of each cluster. This function computes cluster centroids from a numeric data matrix and a mapping of items to cluster indices. It is intended for use in clustering workflows common in computational molecular biology and bioinformatics (for example summarising clusters of gene expression profiles, feature vectors from sequence analysis, or other high-dimensional experimental measurements). The centroid for a cluster is computed per-dimension either as the arithmetic mean or the median over all items assigned to that cluster, ignoring values marked as missing by the mask. The implementation delegates the numerical work to a compiled extension (_cluster.clustercentroids) for performance; inputs are validated and prepared (see behavior and failure modes below).` |
| `Bio_Cluster_clusterdistance` | `Bio.Cluster.clusterdistance` | `Bio/Cluster/__init__.py` | `data: numpy.ndarray, mask: numpy.ndarray = None, weight: numpy.ndarray = None, index1: list = None, index2: list = None, method: str = "a", dist: str = "e", transpose: bool = False` | `Calculate and return the distance between two clusters within a data matrix used for clustering tasks in computational molecular biology (for example, pairwise distances used in hierarchical clustering of gene expression or other experimental datasets). This function validates inputs, supports handling of missing data via a mask, optional per-item weights, multiple distance metrics (Euclidean, city block, several correlation-based measures), and several ways to combine pairwise distances into a cluster-to-cluster distance (means, medians, single/complete linkage, average). The final numeric distance is computed by delegating to the underlying compiled clustering routine _cluster.clusterdistance after input checks.` |
| `Bio_Cluster_distancematrix` | `Bio.Cluster.distancematrix` | `Bio/Cluster/__init__.py` | `data: numpy.ndarray, mask: numpy.ndarray = None, weight: numpy.ndarray = None, transpose: bool = False, dist: str = "e"` | `Compute and return a triangular distance matrix from a 2-D NumPy array for use in clustering and other computational-molecular-biology analyses.` |
| `Bio_Cluster_kcluster` | `Bio.Cluster.kcluster` | `Bio/Cluster/__init__.py` | `data: numpy.ndarray, nclusters: int = 2, mask: numpy.ndarray = None, weight: numpy.ndarray = None, transpose: bool = False, npass: int = 1, method: str = "a", dist: str = "e", initialid: numpy.ndarray = None` | `Perform k-means clustering on a numeric matrix, returning cluster assignments, the within-cluster sum of distances for the best solution found, and how many times that best solution was observed. This implementation is used in the Biopython project for clustering rows or columns of biological data matrices (e.g., gene expression data: genes as rows, samples as columns), and is suitable for computational molecular biology workflows that require repeated k-means runs with different initializations or a single deterministic run starting from a provided initial clustering.` |
| `Bio_Cluster_kmedoids` | `Bio.Cluster.kmedoids` | `Bio/Cluster/__init__.py` | `distance: numpy.ndarray, nclusters: int = 2, npass: int = 1, initialid: list = None` | `Perform k-medoids clustering on a distance matrix. This function performs k-medoids clustering (partitioning around medoids) on a set of items given a distance matrix and returns the best clustering found, the within-cluster sum of distances (objective) for that clustering, and how many times that optimal solution was discovered across repeated restarts. In the context of Biopython and computational molecular biology, this is typically used to cluster biological items (for example, sequences, profiles, or other pairwise comparisons) when a precomputed pairwise distance matrix is available. The routine accepts three different representations of a symmetric distance matrix (full 2D array, condensed 1D array, or a list of lower-triangular rows) and uses only the lower-triangular part when a full 2D NumPy array is provided. The implementation validates the distance input, prepares an initial clustering (either provided or generated randomly), and delegates the core computation to the underlying clustering routine. If an explicit initial clustering is supplied via initialid, the algorithm runs once deterministically using that initialization; otherwise it performs npass independent random restarts and returns the best solution found.` |
| `Bio_Cluster_pca` | `Bio.Cluster.pca` | `Bio/Cluster/__init__.py` | `data: numpy.ndarray` | `Bio.Cluster.pca performs principal component analysis (PCA) on a two-dimensional numeric data matrix.` |
| `Bio_Cluster_somcluster` | `Bio.Cluster.somcluster` | `Bio/Cluster/__init__.py` | `data: numpy.ndarray, mask: numpy.ndarray = None, weight: numpy.ndarray = None, transpose: bool = False, nxgrid: int = 2, nygrid: int = 1, inittau: float = 0.02, niter: int = 1, dist: str = "e"` | `Calculate a Self-Organizing Map (SOM) on a rectangular grid and return the cluster assignments and cluster centroids.` |
| `Bio_Cluster_treecluster` | `Bio.Cluster.treecluster` | `Bio/Cluster/__init__.py` | `data: numpy.ndarray, mask: numpy.ndarray = None, weight: numpy.ndarray = None, transpose: bool = False, method: str = "m", dist: str = "e", distancematrix: numpy.ndarray = None` | `Perform hierarchical (agglomerative) clustering and return a Tree object that describes the resulting dendrogram. This function implements pairwise single, complete (maximum), centroid, and average linkage hierarchical clustering and is provided by Biopython for clustering numerical biological data (for example gene expression matrices or other feature matrices used in computational molecular biology). The function can compute distances from raw data or accept a precomputed distance matrix; it validates inputs and raises errors for invalid argument combinations.` |
| `Bio_Data_CodonTable_list_ambiguous_codons` | `Bio.Data.CodonTable.list_ambiguous_codons` | `Bio/Data/CodonTable.py` | `codons: list, ambiguous_nucleotide_values: dict` | `Bio.Data.CodonTable.list_ambiguous_codons: Extend a list of codon strings by adding unambiguous and ambiguous codon codes that represent only the provided codons, used for example when constructing codon tables in Biopython (e.g., to extend a list of stop codons with ambiguity codes like 'TAR' or 'URA'). This function is used in the Biopython codon table utilities to compute ambiguous codon symbols that are safe to add to an existing set of codons (for example, stop codons). It examines the nucleotides observed at each of the three codon positions in the provided codons and identifies ambiguous nucleotide letters (from ambiguous_nucleotide_values) whose concrete nucleotide meanings are fully represented at that position across the input codons. It then forms candidate ambiguous codons by combining such letters for the three positions and retains only those candidates whose full expansion (all concrete codons implied by the ambiguous letters) are present in the input codons. The function returns a new list containing the original codons (in their original order) followed by any added ambiguous codons (in a deterministic order produced by the algorithm). The function does not modify the input codons list or the ambiguous_nucleotide_values mapping.` |
| `Bio_Data_CodonTable_list_possible_proteins` | `Bio.Data.CodonTable.list_possible_proteins` | `Bio/Data/CodonTable.py` | `codon: str, forward_table: dict, ambiguous_nucleotide_values: dict` | `Bio.Data.CodonTable.list_possible_proteins returns the set of amino acid residues that a possibly ambiguous three-nucleotide codon can encode, or raises an exception if the codon can encode stop codons (termination) in addition to proteins, or if it is a definitive stop codon. This function is used in the Biopython project for translating nucleotide triplets (codons) into amino acids when working with DNA/RNA sequences that may contain IUPAC ambiguous nucleotide codes; it helps downstream code decide how to handle ambiguous translation outcomes in computational molecular biology workflows (for example, variant interpretation, consensus sequence handling, or translating sequencing reads with ambiguous bases).` |
| `Bio_Data_CodonTable_make_back_table` | `Bio.Data.CodonTable.make_back_table` | `Bio/Data/CodonTable.py` | `table: dict, default_stop_codon: str` | `Back a back-table (naive single-codon mapping) for a codon-to-amino-acid table. This function constructs a "back table" that maps each amino acid (the values from a forward codon table) to a single representative codon (one of the keys from the forward table). It is intended for simple, deterministic back-translation or for producing an example nucleotide codon for each amino acid when using Bio.Data.CodonTable codon tables in Biopython (computational molecular biology and bioinformatics workflows). The function is intentionally naive: when an amino acid is encoded by multiple codons in the input table, only one codon is returned per amino acid. The selection is deterministic and based on the sorted order of the codon keys as iterated by Python: the codon that appears last in the ascending sorted order of the codon strings is chosen. The function also ensures a mapping exists for the stop symbol by assigning the provided default_stop_codon to the None key in the returned mapping.` |
| `Bio_Data_CodonTable_register_ncbi_table` | `Bio.Data.CodonTable.register_ncbi_table` | `Bio/Data/CodonTable.py` | `name: str, alt_name: str, id: int, table: dict, start_codons: list, stop_codons: list` | `Bio.Data.CodonTable.register_ncbi_table registers a single NCBI-style codon table definition with the CodonTable module by converting the provided raw table data into multiple internal codon table objects used throughout Biopython for DNA/RNA translation and ambiguous-base handling. This function is intended for internal (PRIVATE) use when populating the module-level codon table registries used by sequence translation and related utilities in computational molecular biology workflows.` |
| `Bio_Entrez_efetch` | `Bio.Entrez.efetch` | `Bio/Entrez/__init__.py` | `db: str, **keywords` | `Fetch records from the NCBI Entrez EFetch utility and return a file-like handle to the results. This function is used within the Bio.Entrez module of Biopython to retrieve records from NCBI Entrez databases (for example "nucleotide", "protein", "pubmed") in the format requested by the caller. It constructs an HTTP request to the EFetch endpoint (https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi) and returns a handle (an open, file-like object) from which the caller can read the response. Typical use in molecular biology and bioinformatics workflows is to download sequence records, GenBank entries, PubMed abstracts, or other Entrez-stored data for downstream parsing or analysis by Biopython modules. See the NCBI EFetch documentation for parameter meanings and database-specific behaviour: http://www.ncbi.nlm.nih.gov/books/NBK25499/#chapter4.EFetch` |
| `Bio_Entrez_epost` | `Bio.Entrez.epost` | `Bio/Entrez/__init__.py` | `db: str, **keywds` | `Bio.Entrez.epost posts a file or list of NCBI unique identifiers (UIDs) to the NCBI E-utilities EPost endpoint so they can be stored on the NCBI side (in a WebEnv) for use by subsequent Entrez queries (for example, efetch, esummary or elink). This function is part of the Bio.Entrez module in Biopython and is used to programmatically submit identifier lists when building multi-step Entrez workflows in computational molecular biology and bioinformatics. It constructs an HTTP POST request to the EPost CGI endpoint used by NCBI and returns a handle to the HTTP response for downstream parsing.` |
| `Bio_Entrez_esearch` | `Bio.Entrez.esearch` | `Bio/Entrez/__init__.py` | `db: str, term: str, **keywds` | `Run an NCBI Entrez ESearch query and return a handle to the XML results. This function issues a request to the NCBI E-utilities ESearch endpoint to locate primary identifiers and term translations for records in a specified Entrez database. The results are intended for downstream use with other Entrez utilities (for example EFetch, ELink and ESummary) or for parsing with Bio.Entrez.read. The function builds an HTTP(S) request to the ESearch CGI (https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi), encoding the provided db and term together with any additional keyword parameters supplied via keywds into the query. The returned object is a handle to the raw XML response; callers should parse the XML (for example with Bio.Entrez.read) and close the handle when finished to release network resources.` |
| `Bio_ExPASy_get_prodoc_entry` | `Bio.ExPASy.get_prodoc_entry` | `Bio/ExPASy/__init__.py` | `id: str, cgi: str = "https://prosite.expasy.org/cgi-bin/prosite/get-prodoc-entry"` | `Get a text handle to a PRODOC entry at the ExPASy PROSITE web service in HTML format. This function is used in computational molecular biology and bioinformatics workflows (see the Biopython project README) to retrieve the PRODOC documentation page for a given PROSITE entry identifier from the ExPASy web server. The returned handle provides the raw HTML text of the PRODOC entry, which can be read and stored or parsed to extract human-readable documentation about sequence motifs, patterns, and associated annotations curated in the PROSITE/PRODOC resource.` |
| `Bio_ExPASy_get_prosite_entry` | `Bio.ExPASy.get_prosite_entry` | `Bio/ExPASy/__init__.py` | `id: str, cgi: str = "https://prosite.expasy.org/cgi-bin/prosite/get-prosite-entry"` | `Get a text handle to a PROSITE entry on the ExPASy PROSITE service, returned in HTML format. This function is part of Biopython's ExPASy utilities for computational molecular biology and is used to fetch PROSITE database entries (protein families, domains, and functional site annotations) over the web. It performs an HTTP GET request by constructing the URL f"{cgi}?{id}" (concatenating the provided CGI endpoint, a question mark, and the PROSITE entry identifier) and returns a text-mode file-like handle for the HTTP response body. The returned handle supports reading the HTML content (for example, via handle.read()) and can be used as a context manager in a with statement. Typical use is to request a PROSITE accession such as "PS00001" to retrieve the human- and machine-readable HTML documentation for that PROSITE pattern or profile, which can then be inspected, archived, or parsed for downstream sequence analysis or annotation tasks.` |
| `Bio_ExPASy_get_prosite_raw` | `Bio.ExPASy.get_prosite_raw` | `Bio/ExPASy/__init__.py` | `id: str, cgi: str = None` | `Get a text handle to a raw PROSITE or PRODOC record at the ExPASy web service. This function is used in Biopython to retrieve the plain-text PROSITE/PRODOC entry for a given PROSITE accession (for example "PS00001") from the ExPASy host (https://prosite.expasy.org/). The returned handle is a readable text file-like object that can be parsed by Biopython parsers such as Bio.ExPASy.Prosite.read to produce a Prosite record object used for motif, pattern, and protein family annotations in computational molecular biology workflows. The function performs an HTTP GET for the URL https://prosite.expasy.org/{id}.txt using the package-internal opener. Because the handle represents a network resource, prefer using it as a context manager (with statement) so it is closed automatically when no longer needed.` |
| `Bio_ExPASy_get_sprot_raw` | `Bio.ExPASy.get_sprot_raw` | `Bio/ExPASy/__init__.py` | `id: str` | `Get a text handle to a raw SwissProt (UniProt) entry from ExPASy/UniProt. This function constructs the UniProt text URL for the given identifier and opens it using the module's internal _open helper. For an identifier XXX the function fetches the resource at http://www.uniprot.org/uniprot/XXX.txt (as per ExPASy/UniProt location conventions) and returns a readable text-mode handle to the raw SwissProt entry. In practical bioinformatics workflows within Biopython, the returned handle is typically passed to Bio.SwissProt.read or other parsers to obtain a parsed SwissProt record containing protein sequence, feature and annotation data for downstream analysis.` |
| `Bio_ExPASy_ScanProsite_scan` | `Bio.ExPASy.ScanProsite.scan` | `Bio/ExPASy/ScanProsite.py` | `seq: str = "", mirror: str = "https://prosite.expasy.org", output: str = "xml", **keywords` | `Bio.ExPASy.ScanProsite.scan executes a ScanProsite search against the ExPASy ScanProsite web service to locate PROSITE patterns or profiles in a protein sequence or UniProtKB accession. This function is used in computational molecular biology workflows (as described in the Biopython README and module source) to programmatically query the remote ScanProsite service, obtain the raw search results over HTTP, and then parse those results (for example, using Bio.ExPASy.ScanProsite.read when XML output is requested).` |
| `Bio_Geo_Record_out_block` | `Bio.Geo.Record.out_block` | `Bio/Geo/Record.py` | `text: str, prefix: str = ""` | `Bio.Geo.Record.out_block formats a long text string into fixed-width blocks of up to 80 characters per block (slicing the input text every 80 characters) and returns the assembled lines with an optional prefix prepended to each line. This function is used in the Biopython codebase (for example in record formatting within Bio.Geo.Record) to produce human-readable and file-format-friendly multiline fields when writing out record annotations or other long text fields in computational molecular biology workflows. Behavior: The input text is split by simple character slices of length 80 (text[0:80], text[80:160], ...). Each slice is emitted as a separate line with a trailing newline character. After all blocks are emitted an additional newline is appended. If text is empty the function returns a single newline. Note that the slicing is performed only on the text content; the prefix is prepended to each output line after slicing and therefore can increase the printed line length beyond 80 characters. The function does not perform word-aware wrapping and may split words across block boundaries. This routine does not perform any I/O operations; it builds and returns a string suitable for inclusion in file output or display.` |
| `Bio_KEGG_REST_kegg_conv` | `Bio.KEGG.REST.kegg_conv` | `Bio/KEGG/REST.py` | `target_db: str, source_db: str, option: str = None` | `KEGG conv - convert KEGG identifiers to/from outside identifiers using the KEGG REST API. Performs a conversion request against the KEGG REST "conv" endpoint (https://rest.kegg.jp/conv/<target_db>/<source_db>[/<option>]) to map identifiers between KEGG databases (for example organism gene IDs, compound/drug/glycan IDs) and outside databases (for example NCBI GI, NCBI GeneID, UniProt, PubChem, ChEBI). This function is intended for use in computational molecular biology workflows (annotation, cross-referencing, data integration) that require translating identifiers between KEGG and external resources. The function constructs and issues the REST query via the internal helper _q and returns that helper's response. It validates the requested conversion pair and the optional output serialization format before issuing the request.` |
| `Bio_KEGG_REST_kegg_find` | `Bio.KEGG.REST.kegg_find` | `Bio/KEGG/REST.py` | `database: str, query: str, option: str = None` | `KEGG find - Data search. Finds KEGG entries whose keywords or other query data match the provided query string(s) by issuing a call to the KEGG REST API. This function is part of Biopython's KEGG.REST client and is used in computational molecular biology workflows to locate KEGG database entries (for example, compounds, drugs, pathways, enzymes, organisms) that match textual keywords, chemical formulae, or mass values.` |
| `Bio_KEGG_REST_kegg_get` | `Bio.KEGG.REST.kegg_get` | `Bio/KEGG/REST.py` | `dbentries: list, option: str = None` | `Bio.KEGG.REST.kegg_get ‚Äî Retrieve KEGG database entries via the KEGG REST "get" endpoint and return a handle to the response. This function is used in the KEGG REST client portion of Biopython to request textual or binary data for one or more KEGG entries (for example genes, pathways, compounds, glycans, reactions, enzymes, or organism-specific entries) and to obtain specific views of those entries (for example amino-acid sequences, nucleotide sequences, molecular files, KCF, pathway images, KGML, or JSON when supported).` |
| `Bio_KEGG_REST_kegg_info` | `Bio.KEGG.REST.kegg_info` | `Bio/KEGG/REST.py` | `database: str` | `KEGG info - Retrieve current statistics for a KEGG database or organism. This function issues a synchronous REST request to the KEGG REST API endpoint (https://rest.kegg.jp/info/<database>) to obtain human-readable statistics and summary information for a KEGG database or an organism entry. In the context of Biopython (a toolkit for computational molecular biology and bioinformatics), kegg_info is used to programmatically discover the current size, versioning, and basic counts (for example number of entries) for resources hosted by KEGG before performing downstream retrieval or parsing operations. Typical uses include checking the number of pathway, gene, compound, or organism entries, or obtaining a list of supported organism codes via kegg_info('organism').` |
| `Bio_KEGG_REST_kegg_link` | `Bio.KEGG.REST.kegg_link` | `Bio/KEGG/REST.py` | `target_db: str, source_db: str, option: str = None` | `Bio.KEGG.REST.kegg_link queries the KEGG REST API to find related entries between two KEGG databases by using database cross-references. This is used within Biopython to programmatically map entries (for example, mapping genes to pathways or compounds to reactions) using the KEGG REST endpoint /link/<target_db>/<source_db>[/<option>].` |
| `Bio_KEGG_REST_kegg_list` | `Bio.KEGG.REST.kegg_list` | `Bio/KEGG/REST.py` | `database: str, org: str = None` | `KEGG list - Retrieve an entry list from a KEGG database or a database subset restricted to an organism. This function is part of the Bio.KEGG.REST module in Biopython and is used to query the KEGG REST API (see https://rest.kegg.jp/list/<database> and https://rest.kegg.jp/list/<database>/<org>) to obtain plain-text lists of database entries. In the computational molecular biology domain, this is useful for programmatically obtaining lists of pathways, modules, compounds, enzymes, organisms, and other KEGG resources for downstream processing (for example, mapping identifiers, filtering by organism, or constructing local indexes). Behavior depends on the `database` and `org` arguments as detailed below.` |
| `Bio_NMR_NOEtools_predictNOE` | `Bio.NMR.NOEtools.predictNOE` | `Bio/NMR/NOEtools.py` | `peaklist: list, originNuc: str, detectedNuc: str, originResNum: int, toResNum: int` | `Predict the i->j NOE (nuclear Overhauser effect) peak position by generating a single .xpk-format crosspeak entry derived from diagonal (self) peaks in a given peaklist. This function is used in NMR peaklist processing workflows (as in Biopython's NMR utilities) to predict a crosspeak that would arise from magnetization transfer originating on one nucleus of an originating residue and being detected on a nucleus of a target residue, based on existing diagonal/self peaks for those nuclei.` |
| `Bio_NMR_xpktools_data_table` | `Bio.NMR.xpktools.data_table` | `Bio/NMR/xpktools.py` | `fn_list: list, datalabel: str, keyatom: str` | `Bio.NMR.xpktools.data_table generates a residue-indexed data table (as a list of text lines) by aggregating a specified data element from multiple .xpk files. This function is part of the Biopython NMR utilities and is used to compare or combine values (for example peak attributes) across several XPK-format outputs, producing one tab-separated row per residue number between the global minimum and maximum residues found in the input files.` |
| `Bio_Nexus_Nexus_combine` | `Bio.Nexus.Nexus.combine` | `Bio/Nexus/Nexus.py` | `matrices: list` | `Combine multiple Nexus-format character matrices into a single Nexus instance. This function is used in phylogenetics and comparative sequence analysis (as provided by Biopython) to merge several Nexus matrices, each representing an aligned character matrix for a set of taxa (for example, gene alignments, morphological characters, or partitions of a supermatrix), into one combined Nexus matrix that preserves taxon names, character partitions, character sets, and taxon sets while aligning and concatenating sequences across shared taxa. The first matrix in the provided list is deep-copied and used as the base; subsequent matrices are appended to its sequences with careful handling of missing and gap symbols, and per-dataset character set and taxon set names are prefixed with the originating dataset name to avoid collisions. This routine is intended for use with Bio.Nexus Nexus instances that expose attributes such as datatype, charsets, charpartitions, taxsets, charlabels, statelabels, interleave, translate, matrix, taxlabels, nchar, ntax, gap, and missing.` |
| `Bio_Nexus_Nexus_get_start_end` | `Bio.Nexus.Nexus.get_start_end` | `Bio/Nexus/Nexus.py` | `sequence: str, skiplist: tuple = ('-', '?')` | `Return the zero-based start and end indices of the first and last characters in a sequence that are not members of a skiplist. This function is used in Biopython's NEXUS/alignment parsing (Bio.Nexus.Nexus) to locate the ungapped region of an aligned molecular sequence (for example, to trim leading and trailing gap ('-') or unknown ('?') symbols before downstream processing such as consensus building, distance calculations, or writing trimmed alignments).` |
| `Bio_Nexus_Nexus_safename` | `Bio.Nexus.Nexus.safename` | `Bio/Nexus/Nexus.py` | `name: str, mrbayes: bool = False` | `Bio.Nexus.Nexus.safename: Return a taxon identifier formatted to meet the NEXUS file conventions used in phylogenetics and compatible with the MrBayes program when requested. This function is used when writing taxon labels into NEXUS-format files (commonly produced or consumed in computational molecular biology and phylogenetic workflows handled by Biopython). It produces a safe string representation of the provided taxon name according to the NEXUS standard: by default quoting names that contain punctuation or whitespace and escaping single quotes, or by producing a MrBayes-compatible unquoted identifier when mrbayes=True.` |
| `Bio_PDB_DSSP_dssp_dict_from_pdb_file` | `Bio.PDB.DSSP.dssp_dict_from_pdb_file` | `Bio/PDB/DSSP.py` | `in_file: str, DSSP: str = "dssp", dssp_version: str = "3.9.9"` | `Bio.PDB.DSSP.dssp_dict_from_pdb_file: Create a DSSP dictionary from a PDB file by invoking an external DSSP executable and parsing its output into a Python mapping of residues to DSSP annotations. This function is used in structural bioinformatics workflows (see the Biopython project) to obtain per-residue secondary structure assignments and solvent accessibility values from a PDB-format coordinate file by calling the DSSP program and converting its output into a convenient Python data structure.` |
| `Bio_PDB_DSSP_make_dssp_dict` | `Bio.PDB.DSSP.make_dssp_dict` | `Bio/PDB/DSSP.py` | `filename: str` | `Make a DSSP dictionary mapping residue identifiers to DSSP properties. Read a DSSP-format output file produced by the DSSP program (a tool commonly used in structural bioinformatics to assign secondary structure and solvent accessibility to residues in PDB structures) and return a Python dictionary that maps residue identifiers to the primary DSSP annotations. This function is part of the Bio.PDB.DSSP utilities in Biopython and is used by downstream code or users who need to attach DSSP-derived annotations (amino acid identity, secondary structure assignment, and solvent accessibility) to residues parsed from PDB files.` |
| `Bio_PDB_DSSP_ss_to_index` | `Bio.PDB.DSSP.ss_to_index` | `Bio/PDB/DSSP.py` | `ss: str` | `Bio.PDB.DSSP.ss_to_index converts a single-letter DSSP secondary structure symbol into a small integer index used by Bio.PDB.DSSP and other Biopython code that needs numeric labels for protein secondary structure. In the context of Biopython (tools for computational molecular biology and bioinformatics), this mapping is used to convert DSSP output symbols into compact integer codes for array indexing, statistical summaries, or machine learning feature labels.` |
| `Bio_PDB_DSSP_version` | `Bio.PDB.DSSP.version` | `Bio/PDB/DSSP.py` | `version_string: str` | `Bio.PDB.DSSP.version parses a dot-separated semantic version string and returns its numeric components as a tuple of integers for lexicographic comparison. This function is used in the Bio.PDB.DSSP context (part of Biopython's PDB/DSSP handling) to convert human-readable version identifiers (for example, a DSSP program or file format version) into a machine-friendly representation that can be compared using Python's built-in tuple comparison semantics. It performs a straightforward split on the ASCII dot character (".") and converts each resulting segment to an int, preserving the original ordering and number of components: for example, "3.0.1" becomes (3, 0, 1). There are no side effects and no external dependencies; the function does not normalize component count (it neither pads nor truncates the returned tuple).` |
| `Bio_PDB_NACCESS_process_asa_data` | `Bio.PDB.NACCESS.process_asa_data` | `Bio/PDB/NACCESS.py` | `rsa_data: list` | `Process lines from an NACCESS .asa file and return per-atom solvent accessible surface area (ASA) values mapped to atom identifiers. This function is used in the Bio.PDB.NACCESS module of Biopython to parse the atomic-level solvent accessible surface area output produced by the NACCESS program. In computational molecular biology and structural bioinformatics, these atomic ASA values are used to quantify solvent exposure of individual atoms (for example, when analysing surface accessibility, protein‚Äìligand docking, or calculating residue solvent exposure by aggregation). The function expects rsa_data to be the sequence of text lines comprising a single .asa output file (commonly obtained by calling file.readlines() on an .asa file) and extracts fixed-column fields from each line according to the NACCESS .asa format as implemented in the source code.` |
| `Bio_PDB_NACCESS_process_rsa_data` | `Bio.PDB.NACCESS.process_rsa_data` | `Bio/PDB/NACCESS.py` | `rsa_data: list` | `Process residue-level SASA (solvent accessible surface area) data produced by the NACCESS .rsa output and return a structured mapping of residue identifiers to numeric accessibility metrics. This function is used in the Bio.PDB.NACCESS pipeline within Biopython to interpret the per-residue results produced by the external NACCESS program. It expects rsa_data to be the lines (strings) of a .rsa file already read into a Python list. The function scans those lines, processes only the records that start with the literal prefix "RES" (the standard NACCESS residue record), extracts fixed-column fields (residue name, chain identifier, residue sequence number, insertion code and multiple absolute/relative SASA values), converts the numeric fields to floats/integers and returns a dictionary keyed by (chain_id, res_id). The res_id value follows the PDB-style residue id tuple used in Biopython: (" ", resseq, icode) where the first element is the hetero-flag placeholder used here as a single space character.` |
| `Bio_PDB_PICIO_pdb_date` | `Bio.PDB.PICIO.pdb_date` | `Bio/PDB/PICIO.py` | `datestr: str` | `Bio.PDB.PICIO.pdb_date: Convert a date string from the ISO-like format yyyy-mm-dd to the PDB file convention dd-MMM-yy (three-letter uppercase month, two-digit year). This function is used in the PDB input/output utilities of the Bio.PDB.PICIO module within Biopython to format dates for PDB header fields and other PDB-formatted outputs when generating or writing structure files in computational molecular biology and bioinformatics workflows. The function accepts a single string and, if it matches the pattern of four-digit year, two-digit month, and two-digit day separated by hyphens, returns a reformatted date string where the day is preserved, the month is converted to the PDB three-letter uppercase code (JAN, FEB, ..., DEC), and the year is truncated to its last two digits. If the input is empty or does not match the expected pattern, the original string is returned unchanged. The function has no side effects and does not modify external state.` |
| `Bio_PDB_PSEA_psea` | `Bio.PDB.PSEA.psea` | `Bio/PDB/PSEA.py` | `pname: str` | `Bio.PDB.PSEA.psea parses the output file produced by the PSEA secondary-structure assignment step and returns the parsed secondary-structure string for the input protein identifier.` |
| `Bio_PDB_PSEA_psea2HEC` | `Bio.PDB.PSEA.psea2HEC` | `Bio/PDB/PSEA.py` | `pseq: str` | `Translate a PSEA secondary structure string into HEC codes. This function is part of the Bio.PDB.PSEA utilities in Biopython and is used to convert the one-letter codes produced by the PSEA secondary structure assignment into the HEC convention commonly used in protein structure annotation and downstream PDB processing. The PSEA input uses lowercase codes: 'a' for alpha-helix, 'b' for beta-strand, and 'c' for coil/other. This function maps those to uppercase HEC codes: 'H' for helix, 'E' for strand, and 'C' for coil. The output is suitable for storing or visualizing secondary structure annotations alongside residue-based data (one output character per input character).` |
| `Bio_PDB_PSEA_run_psea` | `Bio.PDB.PSEA.run_psea` | `Bio/PDB/PSEA.py` | `fname: str, verbose: bool = False` | `Run PSEA on a structure file and return the generated ".sea" output filename. This function is part of the Bio.PDB.PSEA integration in Biopython and is used to invoke the external P-SEA command-line program from Python to process a structure file (for example a PDB file) and produce the P-SEA tool output. It constructs and runs the external command ["psea", fname] using subprocess.run with captured text output, and then verifies that P-SEA produced an output file in the current working directory. This function assumes the Biopython workflow where an external P-SEA binary is available on the system PATH and is used to post-process or analyze protein structure files as part of PDB-related analyses.` |
| `Bio_PDB_Polypeptide_index_to_one` | `Bio.PDB.Polypeptide.index_to_one` | `Bio/PDB/Polypeptide.py` | `index: int` | `Index to corresponding one-letter amino acid name used by Bio.PDB.Polypeptide. Convert an integer index into the corresponding one-letter amino acid code as used by the Bio.PDB.Polypeptide utilities in Biopython. This function is intended for translating numeric indices (for example, positions in an internal numeric mapping of the 20 standard amino acids) into the single-character amino acid codes commonly used in sequence representation and structural analyses. The implementation performs a direct dictionary lookup against the module-level mapping dindex_to_1. Typical usage is when building or comparing polypeptide sequences extracted from PDB structures where a compact one-letter code is required (for example, assembling a sequence string from residue indices for sequence alignment or annotation). The original doctest examples demonstrate the mapping: index_to_one(0) returns 'A' and index_to_one(19) returns 'Y'.` |
| `Bio_PDB_Polypeptide_index_to_three` | `Bio.PDB.Polypeptide.index_to_three` | `Bio/PDB/Polypeptide.py` | `i: int` | `Bio.PDB.Polypeptide.index_to_three maps an integer index to the corresponding three-letter amino acid residue name used in PDB-style representations and by the Bio.PDB.Polypeptide utilities for sequence and structure handling. This function is used in the Biopython PDB module to convert numeric residue indices (for example, indices in the range 0‚Äì19 for the 20 standard amino acids) into the conventional three-letter residue codes (e.g., 0 -> 'ALA', 19 -> 'TYR') that appear in PDB files and are required by downstream PDB/structure-processing routines.` |
| `Bio_PDB_Polypeptide_one_to_index` | `Bio.PDB.Polypeptide.one_to_index` | `Bio/PDB/Polypeptide.py` | `s: str` | `One-letter amino acid code to integer index used by Bio.PDB.Polypeptide. Converts a single-character amino acid one-letter code into the integer index used by the Bio.PDB.Polypeptide module. This function is used in Biopython (a toolkit for computational molecular biology) to map residue one-letter codes to numeric indices so residues can be looked up or used to index arrays, tables or feature vectors that store per-residue properties in structural bioinformatics code. The mapping is provided by the module-level dictionary d1_to_index; examples from the original implementation include one_to_index('A') == 0 and one_to_index('Y') == 19.` |
| `Bio_PDB_Polypeptide_three_to_index` | `Bio.PDB.Polypeptide.three_to_index` | `Bio/PDB/Polypeptide.py` | `s: str` | `Convert a three-letter amino acid residue name to its integer index used by Bio.PDB.Polypeptide. This function is part of the Bio.PDB.Polypeptide utilities in Biopython, a toolkit for computational molecular biology. It maps a PDB-style three-letter amino acid code (as used in PDB files and in Biopython's Polypeptide handling) to the corresponding integer index from the module's internal mapping (d3_to_index). This integer index is used in downstream polypeptide processing tasks such as array indexing, residue ordering, sequence conversion, and compatibility with other algorithms in Bio.PDB that rely on a canonical ordering of the standard amino acids. For example, three_to_index('ALA') returns 0 and three_to_index('TYR') returns 19 in the standard mapping used here.` |
| `Bio_PDB_ResidueDepth_min_dist` | `Bio.PDB.ResidueDepth.min_dist` | `Bio/PDB/ResidueDepth.py` | `coord: numpy.ndarray, surface: numpy.ndarray` | `Return the minimum Euclidean distance between a single 3D coordinate and a set of surface points.` |
| `Bio_PDB_Selection_get_unique_parents` | `Bio.PDB.Selection.get_unique_parents` | `Bio/PDB/Selection.py` | `entity_list: list` | `Translate a list of entities to a list of their unique parent objects. This function is intended for use in the Bio.PDB selection and traversal workflows in Biopython, where one often has a set of lower-level PDB entities (for example Atom or Residue objects) and needs the corresponding parent-level entities (for example Residue or Chain objects) without duplicates. The function iterates over the provided list, calls each element's get_parent() method to obtain its parent, and returns a list containing each distinct parent exactly once.` |
| `Bio_PDB_Selection_uniqueify` | `Bio.PDB.Selection.uniqueify` | `Bio/PDB/Selection.py` | `items: list` | `Bio.PDB.Selection.uniqueify returns a list containing the unique elements from the provided list. This function is used in the Bio.PDB selection and processing code within Biopython (a toolkit for computational molecular biology) to remove duplicate entries when assembling or filtering PDB-related collections (for example, lists of atom identifiers, residue objects, or other selection results). The deduplication is performed via Python's set, so the operation is fast for hashable items but does not preserve the original input order.` |
| `Bio_PDB_alphafold_db_get_predictions` | `Bio.PDB.alphafold_db.get_predictions` | `Bio/PDB/alphafold_db.py` | `qualifier: str` | `Get all AlphaFold predictions for a UniProt accession. This function is part of Bio.PDB.alphafold_db and is used by Biopython users and tools to fetch AlphaFold prediction records for a given UniProt accession (for example, "P00520") from the AlphaFold public API. It performs an HTTPS request to the AlphaFold endpoint for the supplied qualifier, decodes the JSON response, and yields each prediction record as a Python dictionary. This enables downstream code in computational molecular biology and structural bioinformatics workflows to iterate over prediction records for integration with PDB parsing, annotation, or analysis.` |
| `Bio_PDB_internal_coords_set_accuracy_95` | `Bio.PDB.internal_coords.set_accuracy_95` | `Bio/PDB/internal_coords.py` | `num: float` | `Reduce floating point accuracy to "9.5" (format xxxx.xxxxx) by rounding to five decimal places and returning a float. This helper is used by the IC_Residue class in Bio.PDB.internal_coords when writing PIC and SCAD files. In that domain, limiting numeric precision to five digits after the decimal reduces file size, improves human readability of coordinate files, and ensures consistent numeric formatting required by downstream tools that consume PIC/SCAD output. The implementation formats the input using Python string formatting with a fixed field width and five decimal places, then converts the formatted string back to float (float(f"{num:9.5f}")). This yields a numeric value rounded to five decimal places; the specified field width (9) ensures consistent formatting when producing text files, although any leading spaces are removed by the float conversion. A previously used alternative, round(num, 5), was commented out in the source because it was measured to be slower in this code path.` |
| `Bio_PDB_qcprot_qcp` | `Bio.PDB.qcprot.qcp` | `Bio/PDB/qcprot.py` | `coords1: numpy.ndarray, coords2: numpy.ndarray, natoms: int` | `Bio.PDB.qcprot.qcp implements the Quaternion Characteristic Polynomial (QCP) algorithm in Python to compute the optimal rigid-body rotation and root-mean-square deviation (RMSD) that aligns two sets of 3D coordinates. This function is used in structural bioinformatics (as provided by Biopython) to superpose molecular structures (for example, protein atomic coordinates) and to obtain the rotation matrix and quaternion that maps the mobile coordinate set onto the reference coordinate set. The implementation follows the C implementation and Theobald et al.'s formulation (root-finding of a quartic via Newton‚ÄìRaphson) and preserves variable naming to aid comparison with the original code.` |
| `Bio_PDB_vectors_calc_angle` | `Bio.PDB.vectors.calc_angle` | `Bio/PDB/vectors.py` | `v1: list, v2: list, v3: list` | `Calculate the angle at the middle point (v2) formed by three connected point vectors. This function is used in the Bio.PDB.vectors module of Biopython to compute the geometric angle defined by three points commonly encountered in structural biology (for example, the internal angle at an atom in a protein backbone or side chain defined by three atom coordinates). The routine translates the coordinate system so that v2 is treated as the vertex, forms two arm vectors (v1 - v2 and v3 - v2), and returns the angle between those two arms using the Vector.angle method.` |
| `Bio_PDB_vectors_calc_dihedral` | `Bio.PDB.vectors.calc_dihedral` | `Bio/PDB/vectors.py` | `v1: numpy.ndarray, v2: numpy.ndarray, v3: numpy.ndarray, v4: numpy.ndarray` | `Calculate the dihedral (torsion) angle defined by four connected points. This function is used in the Bio.PDB vectors utilities to compute the torsion (dihedral) angle between four connected points (for example four atom coordinates that define a backbone or side-chain torsion in a molecular structure). The routine computes bond vectors from the input points, forms two plane normals via cross products, computes the unsigned angle between those normals, and then determines the sign of the dihedral from the relative orientation of the inter-connecting vector. This is commonly used in computational molecular biology to compute protein backbone phi/psi/omega angles or other torsion angles for conformational analysis.` |
| `Bio_PDB_vectors_coord_space` | `Bio.PDB.vectors.coord_space` | `Bio/PDB/vectors.py` | `a0: numpy.ndarray, a1: numpy.ndarray, a2: numpy.ndarray, rev: bool = False` | `Bio.PDB.vectors.coord_space generates a 4x4 homogeneous transformation matrix that maps 3D Cartesian coordinates into a new right-handed coordinate space defined by three input points. This is used in the Bio.PDB module to align atomic coordinates or define a local coordinate frame for residues, atoms, or structural motifs: the resulting coordinate space places a1 at the origin, a2 on the positive Z axis, and a0 in the XZ plane.` |
| `Bio_PDB_vectors_get_spherical_coordinates` | `Bio.PDB.vectors.get_spherical_coordinates` | `Bio/PDB/vectors.py` | `xyz: numpy.ndarray` | `Bio.PDB.vectors.get_spherical_coordinates computes spherical coordinates (r, azimuth, polar_angle) for a 3D point given as a NumPy column vector. In the Biopython PDB/vector context this function is used to convert Cartesian atomic coordinates (X, Y, Z) from a structure (e.g. a single atom coordinate extracted from a PDB model) into radial and angular components for downstream analysis of distances, orientations, and angular distributions.` |
| `Bio_PDB_vectors_homog_rot_mtx` | `Bio.PDB.vectors.homog_rot_mtx` | `Bio/PDB/vectors.py` | `angle_rads: float, axis: str` | `Bio.PDB.vectors.homog_rot_mtx generates a 4x4 homogeneous rotation matrix for a single principal axis (x, y or z) used when transforming 3D coordinates in the Bio.PDB molecular-structure workflow. This function constructs a homogeneous transformation matrix suitable for rotating 3D coordinates of atoms or coordinate frames in computational molecular biology applications (for example, when manipulating PDB atom coordinates or building transformation chains). The returned matrix is a NumPy array whose upper-left 3x3 block is the rotation matrix for a single principal axis and whose last row and column make it a 4x4 homogeneous transform (so it can be used with 4-component coordinate vectors [x, y, z, 1]). The rotation follows the standard right-handed convention (positive angles produce counterclockwise rotation in the XY plane when looking from +Z toward the origin). The numeric type of the returned array is numpy.float64.` |
| `Bio_PDB_vectors_homog_scale_mtx` | `Bio.PDB.vectors.homog_scale_mtx` | `Bio/PDB/vectors.py` | `scale: float` | `Bio.PDB.vectors.homog_scale_mtx: Generate a 4x4 homogeneous scaling matrix suitable for 3D coordinate transformations used in the Bio.PDB vector utilities. This function constructs a homogeneous transformation matrix that applies an isotropic scale to 3D coordinates. The returned matrix is intended to be used with 4-component homogeneous coordinate vectors of the form [x, y, z, 1] (common in geometric transforms used in structural biology, molecular modelling, visualization, and coordinate manipulation in Bio.PDB). The matrix scales the X, Y and Z components by the provided scalar while leaving the homogeneous coordinate unchanged, so it can be composed with other 4x4 homogeneous transform matrices (for example rotations, translations, or other scalings) to build compound transformations. The function is pure (no side effects) and deterministic: given the same input it always returns the same NumPy array. If scale is not a finite numeric value (for example NaN or infinity), the resulting matrix will contain the corresponding IEEE floating-point values. There is no special input validation beyond NumPy's array construction.` |
| `Bio_PDB_vectors_homog_trans_mtx` | `Bio.PDB.vectors.homog_trans_mtx` | `Bio/PDB/vectors.py` | `x: float, y: float, z: float` | `Generate a 4x4 homogeneous translation matrix suitable for 3D coordinate transformations used in computational molecular biology workflows (for example, translating atom coordinates in PDB structures handled by Bio.PDB). The matrix is built for the standard homogeneous-coordinate column-vector convention: when a 4√ó1 column vector [X, Y, Z, 1]^T is left-multiplied by the returned matrix, the result is [X + x, Y + y, Z + z, 1]^T.` |
| `Bio_PDB_vectors_m2rotaxis` | `Bio.PDB.vectors.m2rotaxis` | `Bio/PDB/vectors.py` | `m: numpy.ndarray` | `Bio.PDB.vectors.m2rotaxis converts a 3x3 rotation matrix into the equivalent rotation angle and rotation axis (angle-axis representation). This function is used in Bio.PDB and other structural biology code within Biopython to interpret or decompose rigid-body rotations (for example, when analysing or applying coordinate transforms between protein models or PDB coordinate frames). The returned angle is in radians and lies in the closed interval [0, pi]; the returned axis is a unit Vector instance that defines the direction of the rotation and thus the sense of rotation for angles > 0.` |
| `Bio_PDB_vectors_multi_coord_space` | `Bio.PDB.vectors.multi_coord_space` | `Bio/PDB/vectors.py` | `a3: numpy.ndarray, dLen: int, rev: bool = False` | `Bio.PDB.vectors.multi_coord_space generates 4x4 homogeneous transformation matrices that map sets of three Cartesian points (atoms) into a local hedron coordinate space used in PDB geometric computations. This function is used in Biopython's PDB/vector routines to construct a local coordinate system from three atoms (a triad) so that downstream code can compute internal coordinates, align fragments, or transform points into a canonical hedron frame. The new coordinate space produced by the forward transform has the following conventions: the second atom (index 1) is placed at the origin, the third atom (index 2) lies on the positive Z axis, and the first atom (index 0) is constrained to the XZ plane. The implementation builds a translation to move atom 1 to the origin, then applies rotations about Z and Y to align atom 2 with +Z, and finally rotates about Z to move atom 0 into the XZ plane. If rev is True, the function also constructs the reverse transforms that map coordinates from the hedron space back to the original coordinate system.` |
| `Bio_PDB_vectors_multi_rot_Y` | `Bio.PDB.vectors.multi_rot_Y` | `Bio/PDB/vectors.py` | `angle_rads: numpy.ndarray` | `Create multiple 4x4 homogeneous rotation matrices for rotations about the Y axis. This function is part of the Bio.PDB.vectors utilities in Biopython and is used to generate a batch of homogeneous transformation matrices that rotate 3D coordinates around the Y axis by given angles. Each returned matrix is a 4x4 affine rotation matrix (no translation) in homogeneous coordinates, suitable for applying to 3D points or coordinate frames in molecular structure manipulations (for example, rotating atom coordinates in a PDB model). The function allocates and returns a new NumPy array and does not modify its input.` |
| `Bio_PDB_vectors_multi_rot_Z` | `Bio.PDB.vectors.multi_rot_Z` | `Bio/PDB/vectors.py` | `angle_rads: numpy.ndarray` | `Create a stack of 4x4 homogeneous rotation matrices for rotations about the Z axis. This function is used in the Bio.PDB.vectors context (part of Biopython) to build homogeneous transformation matrices that rotate 3D coordinates around the Z axis by specified angles in radians. In computational molecular biology workflows (for example, rotating atom coordinates in a PDB structure, aligning fragments, or composing rigid-body transforms), these matrices can be applied to homogeneous column vectors [x, y, z, 1] to rotate the x-y components while preserving the z coordinate and translation component.` |
| `Bio_PDB_vectors_refmat` | `Bio.PDB.vectors.refmat` | `Bio/PDB/vectors.py` | `p: numpy.ndarray, q: numpy.ndarray` | `Return a left-multiplying 3x3 reflection matrix that mirrors vector p onto vector q. This function is part of Bio.PDB.vectors and is used in structural and geometric operations common in computational molecular biology (for example, reflecting atomic coordinate direction vectors when building symmetric structures or performing geometric transformations on protein backbone/sidechain vectors). The routine computes a Householder-style reflection matrix that, when left-multiplied with the column representation of p, produces a vector that lies in the direction of q (within numerical tolerance). The implementation normalizes the input vectors, handles the near-equality case by returning the identity matrix, and constructs the reflection as I - 2 b b^T where b is the normalized difference between p and q.` |
| `Bio_PDB_vectors_rotmat` | `Bio.PDB.vectors.rotmat` | `Bio/PDB/vectors.py` | `p: numpy.ndarray, q: numpy.ndarray` | `Return a left-multiplying 3x3 rotation matrix that rotates the vector p onto the vector q. This function is part of the Bio.PDB.vectors utilities in Biopython and is used in computational molecular biology workflows that manipulate 3D coordinates (for example, rotating atom coordinates or direction vectors when aligning or transforming PDB structures). The routine computes a rotation matrix suitable for left-multiplication by a 3D coordinate/vector object (the same convention used by Vector.left_multiply in Bio.PDB.vectors). The result is a pure numeric transformation (no side effects) computed from the input vectors using internal helper routines (refmat) and NumPy matrix operations.` |
| `Bio_PDB_vectors_set_X_homog_rot_mtx` | `Bio.PDB.vectors.set_X_homog_rot_mtx` | `Bio/PDB/vectors.py` | `angle_rads: float, mtx: numpy.ndarray` | `Set the rotation components of an existing homogeneous rotation matrix to represent a rotation about the X axis by the specified angle in radians. This function is used in the Bio.PDB vectors utilities to update the rotation submatrix used when transforming 3D coordinates of molecular structures (for example, atom coordinates in protein models) without reallocating a new matrix.` |
| `Bio_PDB_vectors_set_Y_homog_rot_mtx` | `Bio.PDB.vectors.set_Y_homog_rot_mtx` | `Bio/PDB/vectors.py` | `angle_rads: float, mtx: numpy.ndarray` | `Set the elements of an existing homogeneous rotation matrix to represent a rotation about the Y axis by the specified angle (in radians). This function is used in the Bio.PDB.vectors module of Biopython to update the rotation block of a transform matrix so it can be applied to 3D coordinate data (for example, atomic coordinates or intermediate frames) without allocating a new array.` |
| `Bio_PDB_vectors_set_Z_homog_rot_mtx` | `Bio.PDB.vectors.set_Z_homog_rot_mtx` | `Bio/PDB/vectors.py` | `angle_rads: float, mtx: numpy.ndarray` | `Update an existing rotation matrix's Z-axis rotation terms in-place. This function computes the cosine and sine of a rotation angle provided in radians and stores those values into the appropriate entries of an existing NumPy array representing a homogeneous-style rotation matrix. In the Bio.PDB/vectors context (used for coordinate transforms and rigid-body rotations in computational molecular biology, e.g. rotating atom coordinates or coordinate frames when manipulating PDB structures), callers typically maintain mutable transformation matrices and call this function to set or change the rotation about the Z axis without reallocating a new matrix.` |
| `Bio_PDB_vectors_set_homog_trans_mtx` | `Bio.PDB.vectors.set_homog_trans_mtx` | `Bio/PDB/vectors.py` | `x: float, y: float, z: float, mtx: numpy.ndarray` | `Set the translation components of an existing homogeneous transformation matrix in-place. This function is used in the Bio.PDB.vectors module of Biopython when constructing or modifying 4x4 homogeneous transformation matrices that represent rigid-body transforms for 3D molecular coordinates (for example when translating atom or residue coordinates in a protein structure). It overwrites the matrix elements that encode translation along the X, Y and Z axes without allocating a new array, so callers must be aware the provided matrix is mutated.` |
| `Bio_Phylo_Consensus_adam_consensus` | `Bio.Phylo.Consensus.adam_consensus` | `Bio/Phylo/Consensus.py` | `trees: list` | `Bio.Phylo.Consensus.adam_consensus: Compute the Adam consensus tree from multiple phylogenetic trees. This function is part of the Bio.Phylo.Consensus module in Biopython and implements the construction of an Adam consensus tree by combining the root clades of multiple input trees. In the context of computational molecular biology and phylogenetics (see the Biopython README and Bio.Phylo module), this is used to summarise a collection of inferred tree topologies (for example bootstrap replicates or results from different inference runs) into a single representative rooted tree. The function collects the .root attribute from each provided tree, passes the collection to the internal helper _part to compute the consensus root clade, and returns a new rooted BaseTree.Tree built from that result.` |
| `Bio_Phylo_Consensus_bootstrap` | `Bio.Phylo.Consensus.bootstrap` | `Bio/Phylo/Consensus.py` | `msa: list, times: int` | `Generate bootstrap replicates from a multiple sequence alignment (OBSOLETE). This function implements the standard phylogenetic bootstrap resampling procedure used to assess support for inferred tree clades by creating pseudo-replicate alignments: each replicate is produced by sampling alignment columns (sites) with replacement to the same alignment length, and can be passed to tree-building routines to compute support values. The implementation yields replicates lazily (as a generator) and does not modify the input alignment. This function is marked OBSOLETE in the source; it may be superseded by newer, maintained utilities in Bio.Phylo or other Biopython modules.` |
| `Bio_Phylo_Consensus_bootstrap_trees` | `Bio.Phylo.Consensus.bootstrap_trees` | `Bio/Phylo/Consensus.py` | `alignment: numpy.ndarray, times: int, tree_constructor: str` | `Generate bootstrap replicate phylogenetic trees from a multiple sequence alignment for use in assessing clade support in phylogenetic analyses. This function implements the standard non-parametric bootstrap for sequence alignments: it produces "times" replicate alignments by sampling alignment columns (sites) with replacement and then builds a tree for each replicate using the provided tree_constructor. It supports Biopython alignment objects (Alignment or MultipleSeqAlignment) and NumPy 2-D arrays (shape: sequences x sites), matching how the source code handles both object types. The function yields each replicate tree in turn rather than returning a collection, allowing streaming of results for downstream consensus or support-value calculations commonly used in Bio.Phylo workflows.` |
| `Bio_Phylo_Consensus_majority_consensus` | `Bio.Phylo.Consensus.majority_consensus` | `Bio/Phylo/Consensus.py` | `trees: list, cutoff: float = 0` | `Search majority-rule consensus tree from multiple phylogenetic trees. This function implements an extended majority-rule consensus algorithm used in phylogenetic analysis (Bio.Phylo module of Biopython) to combine multiple input trees into a single consensus topology. It accepts a collection of input trees that must share the same set and order of terminal taxa and produces a rooted Bio.Phylo.BaseTree.Tree whose internal clades represent groups of taxa that meet the specified majority cutoff. The method is "extended" because the cutoff may be any value between 0 and 1 (inclusive), not only the classical 0.5 threshold. For each consensus clade included, the returned clade.confidence attribute is set to the percentage (0.0‚Äì100.0) of input trees containing that clade, and clade.branch_length is set to the average branch length computed across only those input trees that contained the clade.` |
| `Bio_Phylo_Consensus_strict_consensus` | `Bio.Phylo.Consensus.strict_consensus` | `Bio/Phylo/Consensus.py` | `trees: list` | `Bio.Phylo.Consensus.strict_consensus searches for the strict consensus tree from multiple phylogenetic trees and returns a new Bio.Phylo.BaseTree.Tree that represents clades present in every input tree. In the context of the Biopython Bio.Phylo module (used in computational molecular biology for representing and analyzing phylogenetic trees), this function is used to summarise agreement across a set of inferred trees by including only those clades (groups of terminal taxa) that appear in all provided trees.` |
| `Bio_Phylo_NeXMLIO_cdao_to_obo` | `Bio.Phylo.NeXMLIO.cdao_to_obo` | `Bio/Phylo/NeXMLIO.py` | `s: str` | `Converts a CDAO-prefixed CURIE/URI into an OBO-prefixed CURIE used in NeXML/CDAO parsing. This function is used by the CDAO parser in Bio.Phylo.NeXMLIO (the optional CDAO/RDF parsing code referenced in the Biopython README) to translate a short CDAO-prefixed identifier into the corresponding OBO-prefixed identifier expected in downstream ontology-annotated NeXML data structures. It expects a string beginning with the literal prefix "cdao:" and uses the module-level mapping cdao_elements to look up the local CDAO term name (the substring after "cdao:") and produce an OBO-prefixed CURIE of the form "obo:<mapped_value>". The result is intended for use where OBO-prefixed URIs/CURIEs are required by other code that consumes ontology terms (for example, when normalizing RDF/ontology annotations while parsing NeXML files).` |
| `Bio_Phylo_NeXMLIO_matches` | `Bio.Phylo.NeXMLIO.matches` | `Bio/Phylo/NeXMLIO.py` | `s: str` | `Check for matches in both CDAO and OBO namespaces for a NeXML metadata identifier. This function is used in Bio.Phylo.NeXMLIO when processing NeXML metadata and ontology terms attached to phylogenetic trees. Its role is to detect identifiers that use the CDAO namespace prefix and, when present, produce a pair containing the original CDAO identifier and its mapped OBO equivalent (via the module-level cdao_to_obo lookup). This aids interoperability between CDAO-prefixed terms commonly found in NeXML files and OBO ontology identifiers used elsewhere in the Bio.Phylo codebase and downstream analyses.` |
| `Bio_Phylo_NeXMLIO_qUri` | `Bio.Phylo.NeXMLIO.qUri` | `Bio/Phylo/NeXMLIO.py` | `s: str` | `Bio.Phylo.NeXMLIO.qUri converts a prefixed (CURIE-like) URI into its full, absolute URI (IRI) using the module's namespace mapping, for use when reading or writing NeXML phylogenetic metadata where XML-style namespace expansion is required. This function is a thin wrapper around resolve_uri(s, namespaces=NAMESPACES, xml_style=True) defined in the same module: it looks up the prefix in the module-level NAMESPACES mapping and expands the input into an XML-style full URI suitable for inclusion in NeXML files and other XML-based phylogenetic exchange formats. It performs no I/O and has no side effects beyond calling resolve_uri.` |
| `Bio_Phylo_PAML__parse_baseml_parse_basics` | `Bio.Phylo.PAML._parse_baseml.parse_basics` | `Bio/Phylo/PAML/_parse_baseml.py` | `lines: list, results: dict` | `Parse the basics that should be present in most baseml results files. This function scans an iterable of text lines produced by PAML's baseml program and extracts a small set of commonly required summary values used in downstream phylogenetic analyses. It is intended to be used as a helper in the Bio.Phylo.PAML parsing pipeline described in the Biopython project README: callers typically supply the lines of a baseml results file and a dictionary to be populated with parsed values. The parsed fields are useful in molecular evolution workflows: the PAML version identifies the software used, lnL (log-likelihood) values and "lnL max" are used for model comparison and inference, "tree length" reports the total branch length of the estimated tree, and "tree" provides the Newick tree string including branch lengths for downstream tree-based analyses. The function also attempts to extract the number of free parameters (np) reported by baseml.` |
| `Bio_Phylo_PAML__parse_baseml_parse_freqs` | `Bio.Phylo.PAML._parse_baseml.parse_freqs` | `Bio/Phylo/PAML/_parse_baseml.py` | `lines: list, parameters: dict` | `Parse and extract basepair and branch frequency parameters from baseml output lines.` |
| `Bio_Phylo_PAML__parse_baseml_parse_kappas` | `Bio.Phylo.PAML._parse_baseml.parse_kappas` | `Bio/Phylo/PAML/_parse_baseml.py` | `lines: list, parameters: dict` | `Parse out the kappa parameters from baseml/PAML output lines.` |
| `Bio_Phylo_PAML__parse_baseml_parse_parameter_list` | `Bio.Phylo.PAML._parse_baseml.parse_parameter_list` | `Bio/Phylo/PAML/_parse_baseml.py` | `lines: list, parameters: dict, num_params: int` | `Parse the parameters list found in baseml-formatted text and extract the unlabeled numeric parameter vector and associated standard errors (SEs), storing them in the provided parameters dictionary for downstream use in PAML baseml workflows.` |
| `Bio_Phylo_PAML__parse_baseml_parse_parameters` | `Bio.Phylo.PAML._parse_baseml.parse_parameters` | `Bio/Phylo/PAML/_parse_baseml.py` | `lines: list, results: dict, num_params: int` | `Parse and collect model parameter values from lines of a baseml/PAML output file and store them into the provided results dictionary for downstream use by the Bio.Phylo.PAML baseml parser.` |
| `Bio_Phylo_PAML__parse_baseml_parse_rates` | `Bio.Phylo.PAML._parse_baseml.parse_rates` | `Bio/Phylo/PAML/_parse_baseml.py` | `lines: list, parameters: dict` | `Bio.Phylo.PAML._parse_baseml.parse_rates parses rate-related lines from baseml/PAML output and extracts numeric rate parameters into a Python dictionary used by the Bio.Phylo.PAML baseml parser. This function is used when reading baseml program output (phylogenetic substitution model results) to collect rate parameters, per-category rates, the 4x4 nucleotide substitution rate matrix Q (for REV-like models), the gamma shape parameter alpha, the rho parameter for auto-discrete-gamma models, and transition probability arrays. The parsed values are returned in the same dictionary object passed in so downstream code in Bio.Phylo.PAML can access model parameters for tasks such as annotating trees, interpreting substitution rates, or performing further calculations.` |
| `Bio_Phylo_PAML__parse_codeml_parse_basics` | `Bio.Phylo.PAML._parse_codeml.parse_basics` | `Bio/Phylo/PAML/_parse_codeml.py` | `lines: list, results: dict` | `Parse basic metadata from lines of a PAML codeml output file. This function inspects an iterable of text lines produced by the PAML codeml program and extracts common, high-level information that appears in most codeml output files. It is intended for use within the Bio.Phylo.PAML codeml output parser in Biopython to gather metadata before more detailed parsing. The function looks for a program version string, the model description, evidence of multi-gene analyses, the codon substitution frequency model, the site-class model name (if present), and the maximum log-likelihood value reported in the file. The implementation uses several compiled regular expressions defined in the same module to match codeml-specific headers (for example, it recognizes both "Codon frequencies:" used in codeml 4.1 and "Codon frequency model:" used in codeml 4.3+), and it relies on a module-level regular expression named line_floats_re to extract floating-point numbers from a line when determining the maximum log-likelihood.` |
| `Bio_Phylo_PAML__parse_codeml_parse_branch_site_a` | `Bio.Phylo.PAML._parse_codeml.parse_branch_site_a` | `Bio/Phylo/PAML/_parse_codeml.py` | `foreground: bool, line_floats: list, site_classes: list` | `Bio.Phylo.PAML._parse_codeml.parse_branch_site_a parses results produced for the PAML branch-site A model and annotates a list of site-class records with branch-specific numeric values. This function is used within the Bio.Phylo.PAML._parse_codeml module to incorporate per-site, per-branch numeric output (for example, posterior probabilities or parameter estimates parsed from codeml output lines) into the site_classes data structure used by downstream Biopython code that represents site class information for phylogenetic selection analyses. This function updates the provided site_classes list in place by ensuring each site class entry has a "branch types" mapping and then storing the corresponding numeric value from line_floats under the key "foreground" if foreground is True, or "background" if foreground is False. If there is nothing to do (site_classes is falsy or line_floats is empty), the function returns immediately without modifying the inputs.` |
| `Bio_Phylo_PAML__parse_codeml_parse_distances` | `Bio.Phylo.PAML._parse_codeml.parse_distances` | `Bio/Phylo/PAML/_parse_codeml.py` | `lines: list, results: dict` | `Parse amino acid sequence distance results from lines of codeml output and store them into the provided results dictionary under the "distances" key. This function is used in the Bio.Phylo.PAML._parse_codeml module to extract pairwise amino-acid distances reported by PAML's codeml program. It recognizes two types of reported distances in the codeml text output: raw ("AA distances") and maximum-likelihood ("ML distances of aa seqs."). The parser expects the distance data to appear as a lower-diagonal matrix: each matrix row begins with a sequence name followed (after 5‚Äì15 spaces) by a sequence of floating point distance values corresponding to previously-seen sequence names in the matrix. The function constructs a symmetric nested dictionary representation of those distances and inserts it into the supplied results dict under the key "distances". This representation is commonly used downstream in phylogenetic analysis workflows within Biopython to compute or visualize pairwise sequence distance matrices.` |
| `Bio_Phylo_PAML__parse_codeml_parse_model` | `Bio.Phylo.PAML._parse_codeml.parse_model` | `Bio/Phylo/PAML/_parse_codeml.py` | `lines: list, results: dict` | `Parse an individual NSsites model's results from a codeml (PAML) output block. This function processes a list of text lines produced by codeml (the PAML package) for a single NSsites model and extracts numerical results and annotations commonly used in evolutionary analyses (for example, maximum log-likelihood for model comparison, estimated tree lengths, branch-wise dN/dS values, site-class proportions and omegas, kappa values, and other model parameters). It is intended to be used within Bio.Phylo.PAML._parse_codeml to convert codeml output into a structured Python dictionary suitable for downstream tasks such as likelihood-ratio tests, summarising model parameters, or exporting results for further computational molecular evolution analyses. The function mutates the supplied results dict in place and also returns it.` |
| `Bio_Phylo_PAML__parse_codeml_parse_nssites` | `Bio.Phylo.PAML._parse_codeml.parse_nssites` | `Bio/Phylo/PAML/_parse_codeml.py` | `lines: list, results: dict, multi_models: bool, multi_genes: bool` | `Determine which NSsites models are present in a codeml output and parse their per-model results into the provided results dictionary. This function is used within Bio.Phylo.PAML._parse_codeml to analyze the text output of PAML's codeml program and extract results for NSsites (site-class) models (for example M0, M1a, M2a, etc.). It locates model sections either as a single reported model for the whole result or as multiple "Model X: ..." blocks, delegates the textual parsing of each model block to the module-level helper parse_model, and then stores the parsed data in the supplied results dict under the "NSsites" key (and, when multi_genes is True, into results["genes"] for per-gene model results). The function returns the (mutated) results dictionary.` |
| `Bio_Phylo_PAML__parse_codeml_parse_pairwise` | `Bio.Phylo.PAML._parse_codeml.parse_pairwise` | `Bio/Phylo/PAML/_parse_codeml.py` | `lines: list, results: dict` | `Parse pairwise comparison blocks from PAML/codeml output lines and update a results dictionary with extracted pairwise metrics. This function is used by Bio.Phylo.PAML._parse_codeml to interpret the text output produced by PAML/yn00 or codeml pairwise runs. It scans the provided sequence of output lines for pair labels (for example, lines matching the pattern "2 (Pan_troglo) ... 1 (Homo_sapie)"), single-value log-likelihood lines (lnL), and six-value distance/selection metric lines (t, S, N, omega, dN, dS). When found, these values are converted to Python float and stored in a nested mapping under the "pairwise" key of the provided results dictionary. This enables downstream Biopython code to programmatically access per-pair metrics produced by PAML for evolutionary and comparative analyses.` |
| `Bio_Phylo_PAML__parse_codeml_parse_siteclass_omegas` | `Bio.Phylo.PAML._parse_codeml.parse_siteclass_omegas` | `Bio/Phylo/PAML/_parse_codeml.py` | `line: str, site_classes: list` | `Parse and assign omega (dN/dS) estimates for PAML codeml site classes from a single formatted line. This function is used by Bio.Phylo.PAML._parse_codeml to extract omega estimates (the dN/dS ratio used in molecular evolution and selection analyses) produced by PAML's codeml for models that report multiple site classes. The function expects a single line of text produced by codeml that contains fixed-width floating point columns (the typical "w:" output). It finds numeric substrings matching the fixed-width format used by codeml output and assigns each found value to the corresponding site class dictionary in the provided site_classes list under the key "omega". This is important for downstream Biopython code that collects per-site-class selection parameter estimates for phylogenetic and molecular evolution analyses.` |
| `Bio_Phylo_PAML__parse_codeml_parse_siteclass_proportions` | `Bio.Phylo.PAML._parse_codeml.parse_siteclass_proportions` | `Bio/Phylo/PAML/_parse_codeml.py` | `line_floats: list` | `Bio.Phylo.PAML._parse_codeml.parse_siteclass_proportions: Find and return the proportion of the alignment assigned to each site class reported by a PAML codeml model. This function is used in the PAML parser within Bio.Phylo to convert a sequence (list) of numeric proportions parsed from a codeml output line into a structured mapping that downstream code (for example, code computing sitewise likelihoods or summarising selection categories) can consume. In phylogenetic analyses with codeml, models may define multiple site classes (e.g. different dN/dS categories); each element of the input corresponds to the fraction of alignment sites assigned to that class. The function performs a direct conversion without validation or transformation of the numeric values.` |
| `Bio_Phylo_PAML__parse_yn00_parse_ng86` | `Bio.Phylo.PAML._parse_yn00.parse_ng86` | `Bio/Phylo/PAML/_parse_yn00.py` | `lines: list, results: dict` | `Parse the Nei & Gojobori (1986) section of yn00 results into Python data structures for downstream phylogenetic analyses. This function is used by the Bio.Phylo.PAML.yn00 parser to read the NG86 (lower-triangular) pairwise comparison block produced by the PAML yn00 program (Nei & Gojobori, 1986 method). The NG86 block lists sequence names (taxa) as row labels and, for each row, a sequence of fields representing pairwise statistics for previously-listed sequences. Each pairwise entry is recorded in the output as three floating-point values: omega (w), dN and dS (often shown in the form "w (dN dS)"). Typical input lines look like: seq_name 0.0000 (0.0000 0.0207) 0.0000 (0.0000 0.0421) This parser is robust to common pathologies of yn00 output: taxon names may be truncated to 30 characters, names may abut numeric fields without separators, and there may be citations or comment lines interleaved with data. The implementation uses regular expressions to detect data rows, extract the taxon name and locate floating-point tokens (including negative values when present) that form triples of (omega, dN, dS).` |
| `Bio_Phylo_PAML__parse_yn00_parse_others` | `Bio.Phylo.PAML._parse_yn00.parse_others` | `Bio/Phylo/PAML/_parse_yn00.py` | `lines: list, results: dict, sequences: dict` | `Parse the "other methods" section of PAML yn00 pairwise output and populate the provided results mapping with per-pair statistics for the LWL85, LWL85m and LPB93 methods. This function reads a sequence of text lines produced by PAML's yn00 program describing pairwise species comparisons. It looks for comparison headers of the form "N (Name1) vs. M (Name2)" to establish the two sequence names for a block of following method result lines. For each method line that contains "dS =" it extracts contiguous "key = value" fields (for example "dS = 0.0227", "dN = 0.0000", "w = 0.0000") using the same regular-expression logic as in the source: r"[dSNwrho]{1,3} =.{7,8}?". Numeric values are converted to Python floats; values that cannot be parsed as floats (for example platform-specific NaN representations like "-1.#IND") are recorded as None. Parsed statistics for a method are stored as a dict mapping statistic name strings (e.g. "dS", "dN", "w", "S", "N", "rho") to float or None. The function is intended for use in computational molecular biology and bioinformatics workflows that integrate Biopython with PAML's yn00 output. The populated results structure enables downstream code that performs comparative analyses of synonymous (dS) and nonsynonymous (dN) rates and related statistics across pairwise species comparisons. The function handles the special case of non-numeric NaN-like fields by mapping them to None so that further numerical processing in Python can explicitly test for missing values.` |
| `Bio_Phylo_PAML__parse_yn00_parse_yn00` | `Bio.Phylo.PAML._parse_yn00.parse_yn00` | `Bio/Phylo/PAML/_parse_yn00.py` | `lines: list, results: dict, sequences: list` | `Parse the Yang & Nielsen (2000) part of PAML yn00 output and insert pairwise statistics into an existing results dictionary. This function is part of Bio.Phylo.PAML._parse_yn00 and is used to parse the section of PAML's yn00 program output that lists pairwise comparisons between sequences (Yang & Nielsen 2000). Each row in that section is expected to start with two sequence indices (1-based) followed by a set of floating point values corresponding to the quantities S, N, t, kappa, omega, dN, dN SE, dS, and dS SE. The function converts the numeric strings to floats, maps the 1-based indices to sequence names provided via the sequences list, constructs a dictionary of the parsed values under the key "YN00" and stores it in the provided results mapping for both orderings of the sequence pair (results[name1][name2] and results[name2][name1]). Typical use is within a PAML output parsing pipeline where an already-initialized results structure must be populated with yn00-derived pairwise evolutionary statistics for downstream analysis (for example, computing dN/dS summaries or annotating trees in Bio.Phylo).` |
| `Bio_Phylo_PAML_baseml_read` | `Bio.Phylo.PAML.baseml.read` | `Bio/Phylo/PAML/baseml.py` | `results_file: str` | `Bio.Phylo.PAML.baseml.read parses a BASEML results file produced by the PAML baseml program and returns a dictionary of parsed results suitable for downstream phylogenetic analysis and programmatic inspection.` |
| `Bio_Phylo_PAML_chi2_cdf_chi2` | `Bio.Phylo.PAML.chi2.cdf_chi2` | `Bio/Phylo/PAML/chi2.py` | `df: int, stat: float` | `Compute the upper-tail cumulative distribution function (p-value) of the chi-square distribution for a given degrees of freedom and observed test statistic. This function is part of Bio.Phylo.PAML.chi2 and is used in phylogenetics and molecular-evolution analyses (for example when processing PAML output) to convert an observed chi-square test statistic into a p-value. Practically, this is most commonly applied to likelihood ratio test (LRT) statistics (often twice the difference in log-likelihoods) to assess whether a more complex model provides a significantly better fit to sequence or tree data than a simpler model. The implementation computes the upper-tail probability using the relation prob = 1 - I_x(alpha), where x = stat / 2 and alpha = df / 2, and I_x is the regularized lower incomplete gamma function (implemented here as _incomplete_gamma).` |
| `Bio_Phylo_PAML_codeml_read` | `Bio.Phylo.PAML.codeml.read` | `Bio/Phylo/PAML/codeml.py` | `results_file: str` | `Bio.Phylo.PAML.codeml.read parses a CODEML results file produced by the PAML codeml program and returns the parsed results as a Python dictionary useful in phylogenetics and molecular evolution analyses. This function opens and reads the given results file (read-only), parses its contents using the module's internal parsing routines, and assembles a dictionary of results covering basic run information, site-model (nonsynonymous/synonymous site) results, pairwise comparisons, and distance estimates. It is intended to be used after running codeml (for example via Codeml.run()) to programmatically extract the results for downstream processing in Biopython's Bio.Phylo workflows or other computational molecular biology pipelines. The function reads the entire file into memory (using readlines()) before parsing, so memory usage grows with file size. It does not modify the filesystem or the input file.` |
| `Bio_Phylo_PAML_yn00_read` | `Bio.Phylo.PAML.yn00.read` | `Bio/Phylo/PAML/yn00.py` | `results_file: str` | `Parse a YN00 results file produced by the PAML yn00 program and return the parsed results as a Python dictionary.` |
| `Bio_Phylo__cdao_owl_resolve_uri` | `Bio.Phylo._cdao_owl.resolve_uri` | `Bio/Phylo/_cdao_owl.py` | `s: str, namespaces: dict = {'cdao': 'http://purl.obolibrary.org/obo/cdao.owl#', 'obo': 'http://purl.obolibrary.org/obo/'}, cdao_to_obo: bool = True, xml_style: bool = False` | `Convert a prefixed URI string to a full URI string for use by the Bio.Phylo CDAO/OWL parser. This function is used by the CDAO/OWL parsing code in Bio.Phylo to translate short, prefixed identifiers encountered in RDF/OWL input (for example during parsing with rdflib) into fully qualified URIs or XML QName style names so downstream Biopython code can match and process ontology terms consistently. Optionally, when a CDAO term name is supplied, it will be translated to the corresponding OBO numeric identifier using the module-level cdao_elements mapping.` |
| `Bio_Phylo__io_convert` | `Bio.Phylo._io.convert` | `Bio/Phylo/_io.py` | `in_file: str, in_format: str, out_file: str, out_format: str, parse_args: dict = None, **kwargs` | `Convert between two phylogenetic tree file formats used in Bio.Phylo.` |
| `Bio_Phylo__io_write` | `Bio.Phylo._io.write` | `Bio/Phylo/_io.py` | `trees: list, file: str, format: str, **kwargs` | `Write a sequence of phylogenetic trees to the given destination using the writer implementation registered for the requested output format.` |
| `Bio_PopGen_GenePop_get_indiv` | `Bio.PopGen.GenePop.get_indiv` | `Bio/PopGen/GenePop/__init__.py` | `line: str` | `Bio.PopGen.GenePop.get_indiv extracts an individual's name and genotype marker data from a single line of a GenePop-format record, returning the parsed individual name, a list of allele tuples per locus and the per-allele code length. This function is used in population genetics workflows (as in the GenePop parsers in Bio.PopGen.GenePop) to convert a text line from a GenePop input file into structured Python objects that downstream routines can analyze (e.g., calculating allele frequencies, genotype counts, or performing population genetic tests).` |
| `Bio_PopGen_GenePop_FileParser_read` | `Bio.PopGen.GenePop.FileParser.read` | `Bio/PopGen/GenePop/FileParser.py` | `fname: str` | `Parse a single GenePop-format file and return a FileRecord representing its contents. This function is part of Biopython's population genetics utilities (Bio.PopGen.GenePop) and is used to read and parse a GenePop file so downstream code can examine populations, loci, samples and genotypes for population-genetic analyses (for example computing allele frequencies or F-statistics). The function creates a FileRecord by invoking FileRecord(fname) and returns that object for programmatic inspection. It performs read-only parsing and does not modify the file on disk.` |
| `Bio_PopGen_GenePop_LargeFileParser_get_indiv` | `Bio.PopGen.GenePop.LargeFileParser.get_indiv` | `Bio/PopGen/GenePop/LargeFileParser.py` | `line: str` | `Bio.PopGen.GenePop.LargeFileParser.get_indiv parses a single line from a Genepop-formatted individual record and returns the individual's name, a list of allele tuples per locus, and the detected allele digit length used to split genotype tokens. This function is used by the GenePop large-file parser in Biopython to interpret one line of individual genotype data found in a Genepop input. The expected input is a single string containing an individual identifier, followed by a comma, then one or more genotype tokens separated by spaces or tabs. Each genotype token encodes one locus by concatenating allele codes (for diploids two allele codes per locus, for haploids a single allele code). The function normalizes whitespace and determines whether allele codes are represented with two digits or three digits before converting them to integers and grouping them into tuples. This parsed output is used downstream by population genetics routines in Biopython to build genotype matrices, calculate allele frequencies, and perform other analyses.` |
| `Bio_SCOP_cmp_sccs` | `Bio.SCOP.cmp_sccs` | `Bio/SCOP/__init__.py` | `sccs1: str, sccs2: str` | `Compare two SCOP concise classification strings (sccs) and return their ordering. This function is part of the Bio.SCOP utilities in Biopython, a toolkit for computational molecular biology. An sccs encodes a protein domain's SCOP concise classification using a class letter followed by numeric components separated by dots (for example, "a.4.5.11"). The leading letter denotes the SCOP class and the subsequent dot-separated fields denote fold, superfamily, family, etc. This function implements a deterministic ordering used when sorting or comparing domain classifications: first by class letter (lexicographic order), then by each numeric component interpreted as an integer, and finally by the number of components (shorter strings are ordered before longer ones when all compared components are equal). Example ordering: a.4.5.1 < a.4.5.11 < b.1.1.1.` |
| `Bio_SCOP_Raf_normalize_letters` | `Bio.SCOP.Raf.normalize_letters` | `Bio/SCOP/Raf.py` | `one_letter_code: str` | `Bio.SCOP.Raf.normalize_letters: Convert RAF one-letter amino acid codes into IUPAC standard codes. This function is part of the Biopython SCOP RAF utilities and is used when parsing or processing SCOP RAF-format residue annotations to ensure amino acid codes conform to the IUPAC one-letter standard expected by downstream Biopython code and common bioinformatics tools. The routine uppercases provided letter codes and maps the RAF-specific unknown/residue placeholder "." to the IUPAC convention "X".` |
| `Bio_SearchIO_ExonerateIO_exonerate_vulgar_parse_vulgar_comp` | `Bio.SearchIO.ExonerateIO.exonerate_vulgar.parse_vulgar_comp` | `Bio/SearchIO/ExonerateIO/exonerate_vulgar.py` | `hsp: dict, vulgar_comp: str` | `Parse the Exonerate "vulgar" component string and populate coordinate block and codon-split information in an HSP dictionary used by Bio.SearchIO.ExonerateIO. This function is used in the Exonerate parser within Biopython (a library of Python tools for computational molecular biology) to interpret the compact "vulgar" representation produced by Exonerate into explicit coordinate ranges and auxiliary annotations on an HSP (high-scoring pair) dictionary. The input hsp dict must contain integer sentinel positions and strand indicators (see Args). The function parses each vulgar component (using the module's _RE_VCOMP regular expression), advances internal sentinels according to component step lengths and strand orientation, identifies contiguous match/codon/gap blocks, records split-codon ranges for frameshifts, and finally writes canonical start/end ranges for both query and hit sequences into the hsp dict for downstream SearchIO consumers.` |
| `Bio_SearchIO__utils_fragcascade` | `Bio.SearchIO._utils.fragcascade` | `Bio/SearchIO/_utils.py` | `attr: str, seq_type: str, doc: str = ""` | `Bio.SearchIO._utils.fragcascade: Return a property descriptor that implements a getter and a cascading setter for attributes on HSPFragment objects used in Biopython SearchIO parsing. This helper constructs a Python property which stores the value on an HSPFragment instance under an internal name derived from the fragment role (hit or query) and the attribute name, and which also propagates (cascades) the same value to the associated sequence object (the fragment's .hit or .query attribute) when that associated sequence is not None. In the context of Biopython's SearchIO module, HSPFragment objects represent aligned subregions (high-scoring pair fragments) extracted from sequence alignment output (for example BLAST/PSI-BLAST results). fragcascade is used to keep attributes (for example sequence strings or coordinate fields) synchronized between an HSPFragment and its parent sequence object so downstream code that inspects either object sees a consistent value.` |
| `Bio_SearchIO__utils_fullcascade` | `Bio.SearchIO._utils.fullcascade` | `Bio/SearchIO/_utils.py` | `attr: str, doc: str = ""` | `Bio.SearchIO._utils.fullcascade returns a Python property that provides a cascading getter and setter for a named attribute on SearchIO container items (for example HSP objects within a Hit or Query container). It is intended for use in Biopython SearchIO code to create container-level attributes that reflect the corresponding attribute on member items: reading the property retrieves the attribute from the first contained item, and writing the property sets that attribute on every contained item.` |
| `Bio_SearchIO__utils_get_processor` | `Bio.SearchIO._utils.get_processor` | `Bio/SearchIO/_utils.py` | `format: str, mapping: dict` | `Return the processor object for a given search result format name by looking it up in a mapping and performing a dynamic import from the Bio.SearchIO subpackage.` |
| `Bio_SearchIO__utils_optionalcascade` | `Bio.SearchIO._utils.optionalcascade` | `Bio/SearchIO/_utils.py` | `cont_attr: str, item_attr: str, doc: str = ""` | `Create and return a property object whose getter reads a named attribute from the first contained item when the container has one or more items, otherwise from a named attribute on the container itself, and whose setter updates (cascades) the named container attribute and the named attribute on every item in the container. This helper is part of Bio.SearchIO._utils and is used by SearchIO container classes (for example to implement the id and description properties of result/hit/container objects used when parsing sequence search outputs such as BLAST). In that domain, containers represent query results or hits and hold zero or more item objects; this function ensures a consistent view of e.g. an identifier or description whether the container is empty or populated, and keeps container and item attributes synchronized when modified.` |
| `Bio_SearchIO__utils_removesuffix` | `Bio.SearchIO._utils.removesuffix` | `Bio/SearchIO/_utils.py` | `string: str, suffix: str` | `Bio.SearchIO._utils.removesuffix: Remove a trailing suffix from a string, providing a small compatibility wrapper for Python 3.8 used in Biopython's SearchIO utilities. This function is used in the Bio.SearchIO._utils module to normalize or clean textual identifiers, filenames, and other string tokens commonly encountered when parsing search results (for example BLAST, HMMER, or other sequence search output). In the Biopython project this helps ensure consistent handling of trailing suffixes across supported Python versions, by delegating to the built-in str.removesuffix on Python versions that provide it and falling back to an equivalent implementation on Python 3.8.` |
| `Bio_Seq_transcribe` | `Bio.Seq.transcribe` | `Bio/Seq.py` | `dna: str` | `Bio.Seq.transcribe transcribes a DNA sequence into an RNA sequence (T -> U), using the convention that the provided sequence represents the coding strand of the DNA double helix. This function is intended for use in computational molecular biology and bioinformatics workflows (for example, preparing RNA sequences for downstream analysis such as translation or RNA structure prediction), as provided by the Biopython project. Transcription is performed by replacing thymine bases ('T' and 't') with uracil ('U' and 'u') without performing any complement or reverse-complement operation. Ambiguous or non-thymine characters (for example 'N') are left unchanged. The function preserves the original object: it does not modify a MutableSeq or string in place but returns a new object containing the transcribed sequence.` |
| `Bio_SeqIO_QualityIO_phred_quality_from_solexa` | `Bio.SeqIO.QualityIO.phred_quality_from_solexa` | `Bio/SeqIO/QualityIO.py` | `solexa_quality: float` | `Convert a Solexa quality score to an equivalent PHRED quality score used by sequencing data parsers. This function is used in Bio.SeqIO.QualityIO within the Biopython project (a toolkit for computational molecular biology) to translate quality scores encoded using the Solexa log-odds scale into the more commonly used PHRED scale. Both Solexa and PHRED scores are log transformations of an estimated probability of error (higher score = lower error probability). The conversion assumes the underlying error probability estimates are equivalent between the two scales. The numeric mapping implemented is: phred_quality = 10 * log(10**(solexa_quality / 10.0) + 1, 10) which first converts the Solexa score back to an error probability equivalent and then expresses that probability on the PHRED scale. The function returns a floating point PHRED value; callers that need integer PHRED scores (for example, to store in certain file formats or downstream tools expecting integer values) should round or cast the returned value as appropriate.` |
| `Bio_SeqIO_QualityIO_solexa_quality_from_phred` | `Bio.SeqIO.QualityIO.solexa_quality_from_phred` | `Bio/SeqIO/QualityIO.py` | `phred_quality: float` | `Bio.SeqIO.QualityIO.solexa_quality_from_phred converts a PHRED-style quality score to the equivalent Solexa-style quality score used by some sequencing file formats and older Illumina encodings. It is part of Biopython's SeqIO/QualityIO utilities for handling per-base sequencing quality values when parsing, converting or writing sequence data.` |
| `Bio_SeqUtils_GC123` | `Bio.SeqUtils.GC123` | `Bio/SeqUtils/__init__.py` | `seq: str` | `Bio.SeqUtils.GC123 calculates G+C content for a nucleotide sequence overall and separately for each codon position (first, second, third) in a coding-sequence reading frame starting at the first base. This function is part of Biopython, a toolkit for computational molecular biology, and is used when assessing sequence composition, codon position bias, or GC-related metrics in coding DNA. This function walks the input sequence in codons (triplets) from the first base, counts occurrences of the unambiguous DNA nucleotides A, T, G, and C (case-insensitive) at each codon position, and computes percentages as 100 * (G + C) / n where n is the count of A/T/G/C observed at that position. An incomplete trailing codon (length < 3) is padded internally so that its remaining positions do not match A/T/G/C and therefore do not contribute to counts. Ambiguous nucleotides (for example 'N' or other non-ATGC characters) are not treated as A/T/G/C: they are effectively ignored and reduce the denominator n for the affected positions. The function performs no input sanitization beyond treating the input as an indexable string and does not modify the input sequence.` |
| `Bio_SeqUtils_GC_skew` | `Bio.SeqUtils.GC_skew` | `Bio/SeqUtils/__init__.py` | `seq: str, window: int = 100` | `Calculate GC skew (G-C)/(G+C) for non-overlapping windows along a DNA sequence. This function computes a simple per-window measure of nucleotide composition asymmetry used in computational molecular biology (for example, profiling local GC bias across chromosomes, contigs, or sequencing reads). For each contiguous, non-overlapping window of the input sequence it counts guanine (G/g) and cytosine (C/c) and returns the ratio (G - C) / (G + C). The implementation is case-insensitive for G and C, ignores ambiguous nucleotides (they are treated as neither G nor C), and explicitly handles windows with no G or C by returning 0.0 for that window to avoid division-by-zero errors.` |
| `Bio_SeqUtils_nt_search` | `Bio.SeqUtils.nt_search` | `Bio/SeqUtils/__init__.py` | `seq: str, subseq: str` | `Search for a DNA subsequence in a DNA sequence string, interpreting IUPAC ambiguous nucleotide codes, and return the regular-expression pattern used followed by the 0-based start positions of each match on the forward strand. This function is part of Biopython's utilities for computational molecular biology and bioinformatics. It is used to locate occurrences of nucleotide subsequences (for example motifs or primer sites) in a larger DNA sequence string while allowing IUPAC ambiguity codes (e.g. N, R, Y) in the query. Ambiguous codes in subseq are expanded using IUPACData.ambiguous_dna_values so that the function builds a Python regular expression pattern (with bracketed character classes like "[ACGT]" for ambiguous positions) and then searches only the forward strand of seq using Python's re.search.` |
| `Bio_SeqUtils_seq1` | `Bio.SeqUtils.seq1` | `Bio/SeqUtils/__init__.py` | `seq: str, custom_map: dict = None, undef_code: str = "X"` | `Convert a protein sequence given with three-letter amino acid codes into a string of one-letter amino acid codes. This function is part of Biopython's Bio.SeqUtils utilities used in computational molecular biology workflows to normalize protein sequences for downstream tasks (for example, sequence comparisons, alignments, or database lookups). It maps contiguous three-character tokens from the input sequence to their one-letter IUPAC amino acid codes using Biopython's IUPACData.protein_letters_3to1_extended mapping. The function is case-insensitive for the three-letter codes, supports the IUPAC ambiguous/reserved one-letter codes (B for Asx, J for Xle, X for Xaa, U for Sel, O for Pyl), and by default maps the termination code "Ter" to "*" (this default can be changed via custom_map). The function performs a simple fixed-width grouping of the input (every three characters), so any trailing characters when the input length is not a multiple of three are ignored.` |
| `Bio_SeqUtils_seq3` | `Bio.SeqUtils.seq3` | `Bio/SeqUtils/__init__.py` | `seq: str, custom_map: dict = None, undef_code: str = "Xaa"` | `Convert a protein sequence from one-letter amino acid codes to concatenated three-letter codes following the IUPAC convention. This function is used in computational molecular biology workflows (as in Biopython) to translate protein sequences represented with single-letter amino acid codes into their three-letter equivalents for tasks such as human-readable output, legacy format conversion, or interfacing with tools that expect three-letter residue codes. The conversion follows the IUPAC extended mapping (including ambiguous and rare codes B -> Asx, J -> Xle, X -> Xaa, U -> Sel, O -> Pyl) and, by default, maps the stop/termination character '*' to 'Ter'. The implementation builds an internal mapping from the IUPAC standard and an optional user-supplied custom_map without mutating the global IUPAC mapping.` |
| `Bio_SeqUtils_six_frame_translations` | `Bio.SeqUtils.six_frame_translations` | `Bio/SeqUtils/__init__.py` | `seq: str, genetic_code: int = 1` | `Return a formatted, human-readable string that shows the six-frame translations of a nucleotide sequence together with nucleotide counts and GC content. This function is part of Bio.SeqUtils in Biopython and is intended for use in computational molecular biology and bioinformatics workflows where a quick, printable overview of all six translation frames (three forward frames and three reverse/complement frames) and basic sequence composition (A, T, G, C counts and GC fraction) is useful. The visual layout and behavior were adapted from xbbtools and are similar to the DNA Strider six-frame translation output: a header with nucleotide counts and a short sequence summary, then blocks of up to 60 nucleotides with corresponding translated amino acids for each frame. The function detects RNA input by checking for the presence of "u" (case-insensitive) in the sequence and uses an RNA-specific reverse-complement routine when appropriate. It delegates codon translation to the translate() implementation used elsewhere in Biopython and computes GC fraction via gc_fraction(..., ambiguous="ignore").` |
| `Bio_SeqUtils_xGC_skew` | `Bio.SeqUtils.xGC_skew` | `Bio/SeqUtils/__init__.py` | `seq: str, window: int = 1000, zoom: int = 100, r: int = 300, px: int = 100, py: int = 100` | `Bio.SeqUtils.xGC_skew calculates and displays both the per-window GC skew and the accumulated GC skew for a nucleotide sequence using a Tkinter graphical canvas. This function is part of Biopython's SeqUtils utilities for computational molecular biology and is intended as an interactive graphical diagnostic: it computes GC content and GC skew over sliding windows (using the helper functions GC_skew and gc_fraction called in the source) and renders a circular plot with radial lines for each window and an accumulated-skew trace useful for visual interpretation (for example, detecting shifts associated with replication origins in bacterial genomes).` |
| `Bio_SeqUtils_CheckSum_crc64` | `Bio.SeqUtils.CheckSum.crc64` | `Bio/SeqUtils/CheckSum.py` | `s: str` | `Return the CRC-64 checksum for a biological sequence as used in Biopython tools for computational molecular biology. This function computes a 64-bit cyclic redundancy check (CRC-64) over the characters of the input sequence and returns a standardized ASCII label suitable for storing in sequence metadata, file headers, database fields, or for lightweight integrity checks in bioinformatics pipelines. The computation is case-sensitive (the ASCII value of each character is used via ord()) and produces a hexadecimal string prefixed with "CRC-". The function is pure (no side effects) and is intended for non-cryptographic checksum purposes such as detecting accidental corruption or quickly comparing sequences; it is not suitable as a cryptographic hash.` |
| `Bio_SeqUtils_CheckSum_gcg` | `Bio.SeqUtils.CheckSum.gcg` | `Bio/SeqUtils/CheckSum.py` | `seq: str` | `Bio.SeqUtils.CheckSum.gcg: Compute the historical GCG checksum for a biological sequence. Computes the GCG checksum (an integer) for a nucleotide or amino-acid sequence string using the same algorithm historically used by the GCG program and implemented in BioPerl (this function is an adaptation used in Biopython). This function is useful in computational molecular biology and bioinformatics workflows that need to reproduce or verify legacy GCG checksums stored in older files or interoperating tools. The algorithm processes the sequence in a single pass, is case-insensitive (all characters are converted to uppercase internally), and is deterministic: the same input string always yields the same integer result. The current function signature expects seq to be a Python str; if you have a Seq object (from Bio.Seq) convert it to str before calling this function. Behavior details: starting with index = 0 and checksum = 0, the function iterates over the characters of seq. For each character, index is incremented by 1 and checksum is increased by index * ord(character_uppercase). When index reaches 57 it is reset to 0 for the next character (so the multiplicative index cycles with period 57). After processing the entire sequence, the function returns checksum % 10000 (an integer in the range 0 to 9999). All characters are converted to uppercase prior to calling ord(), so ASCII letters differing only by case do not change the result. The function performs no I/O and has no side effects; it works in linear time O(n) with respect to the sequence length and uses constant extra memory. Failure modes and edge cases: seq must be a str. Passing a non-str object that does not behave like a string (for example, lacks an upper() method or is not iterable over single-character strings) will raise an AttributeError or TypeError when iterating or calling upper(). An empty string returns 0. Non-ASCII characters are processed with their Unicode code point values via ord(); this will affect the checksum but does not raise an error by itself. The function does not validate biological alphabet characters (A/C/G/T/N, amino-acid letters); any characters present in seq contribute according to their uppercase Unicode code point.` |
| `Bio_SeqUtils_CheckSum_seguid` | `Bio.SeqUtils.CheckSum.seguid` | `Bio/SeqUtils/CheckSum.py` | `seq: str` | `Bio.SeqUtils.CheckSum.seguid returns the SEGUID (a Sequence Globally Unique IDentifier) for a biological sequence. The function computes a reproducible identifier for a nucleotide or amino-acid sequence (or any string/Seq-like object) by normalizing case, computing the SHA-1 digest of the normalized sequence bytes, base64-encoding the digest, and removing base64 padding and newlines to produce the final SEGUID string. This SEGUID is used in Biopython and computational molecular biology workflows to create compact, comparable identifiers for sequence deduplication, database indexing, or cross-referencing sequences in publications or tools (see http://bioinformatics.anl.gov/seguid/ and https://doi.org/10.1002/pmic.200600032).` |
| `Bio_SeqUtils_MeltingTemp_Tm_GC` | `Bio.SeqUtils.MeltingTemp.Tm_GC` | `Bio/SeqUtils/MeltingTemp.py` | `seq: str, check: bool = True, strict: bool = True, valueset: int = 7, userset: tuple = None, Na: float = 50, K: float = 0, Tris: float = 0, Mg: float = 0, dNTPs: float = 0, saltcorr: int = 0, mismatch: bool = True` | `Return the estimated melting temperature (Tm) in degrees Celsius for a DNA/RNA primer or oligonucleotide using empirical formulas based on percent GC content and optional salt corrections. This function implements a family of simple, commonly cited Tm approximations (see Marmur & Doty, Wetmur, Primer3Plus, von Ahsen, and QuikChange variants) and is used in Biopython for quick Tm estimates when designing primers, checking primer properties, or as a component of higher-level primer design pipelines described in the Biopython documentation.` |
| `Bio_SeqUtils_MeltingTemp_Tm_NN` | `Bio.SeqUtils.MeltingTemp.Tm_NN` | `Bio/SeqUtils/MeltingTemp.py` | `seq: str, check: bool = True, strict: bool = True, c_seq: str = None, shift: int = 0, nn_table: dict = None, tmm_table: dict = None, imm_table: dict = None, de_table: dict = None, dnac1: float = 25, dnac2: float = 25, selfcomp: bool = False, Na: float = 50, K: float = 0, Tris: float = 0, Mg: float = 0, dNTPs: float = 0, saltcorr: int = 5` | `Bio.SeqUtils.MeltingTemp.Tm_NN: Calculate the melting temperature (Tm) of a DNA/DNA, RNA/RNA or RNA/DNA duplex using nearest-neighbor (NN) thermodynamic parameters and optional corrections for mismatches, terminal mismatches, dangling ends and salt effects. This function is used in primer and probe design and validation workflows (e.g., PCR primer Tm estimation, oligo/oligo hybridization, RNA/DNA hybridization) by summing enthalpy (ŒîH) and entropy (ŒîS) contributions from initiation terms, nearest-neighbor stacks, internal mismatches, terminal mismatches and dangling ends, converting concentrations to the equilibrium constant k, applying salt corrections, and returning the predicted Tm in degrees Celsius.` |
| `Bio_SeqUtils_MeltingTemp_Tm_Wallace` | `Bio.SeqUtils.MeltingTemp.Tm_Wallace` | `Bio/SeqUtils/MeltingTemp.py` | `seq: str, check: bool = True, strict: bool = True` | `Bio.SeqUtils.MeltingTemp.Tm_Wallace calculates the melting temperature (Tm) of a DNA oligonucleotide using the Wallace rule, a simple rule-of-thumb estimator commonly used in PCR primer design and other basic oligonucleotide annealing estimates.` |
| `Bio_SeqUtils_MeltingTemp_chem_correction` | `Bio.SeqUtils.MeltingTemp.chem_correction` | `Bio/SeqUtils/MeltingTemp.py` | `melting_temp: float, DMSO: float = 0, fmd: float = 0, DMSOfactor: float = 0.75, fmdfactor: float = 0.65, fmdmethod: int = 1, GC: float = None` | `Bio.SeqUtils.MeltingTemp.chem_correction corrects a melting temperature (Tm) estimate for the presence of chemical denaturants DMSO and formamide, producing an adjusted Tm used in oligonucleotide design, PCR primer planning, and nucleic acid hybridization predictions within the Biopython computational molecular biology toolkit. This function applies simple, literature-based linear corrections to a provided melting temperature. These corrections are approximate and intended to give a pragmatic adjustment to Tm values computed elsewhere in Biopython or supplied by the user. The function does not mutate inputs and returns a new float value. The default numeric factors are those coded into the function; alternative reported values from the literature are noted below for user awareness.` |
| `Bio_SeqUtils_MeltingTemp_make_table` | `Bio.SeqUtils.MeltingTemp.make_table` | `Bio/SeqUtils/MeltingTemp.py` | `oldtable: dict = None, values: dict = None` | `Return a dictionary table of thermodynamic parameters used by DNA melting temperature calculations. This function is used within the Bio.SeqUtils.MeltingTemp module to build or customize the lookup table of nearest-neighbor and initiation thermodynamic parameters (commonly enthalpy and entropy pairs) employed by melting temperature routines. If no existing table is provided, a default table is constructed with a set of standard parameter names initialized to (0, 0). A user can supply a pre-existing table and/or a dictionary of new or updated values to modify that table. This is intended for practical use cases such as replacing initiation parameters from one published dataset (for example, Sugimoto '96, stored in DNA_NN2) with values from another dataset (for example, Allawi & SantaLucia '97), as shown in the original example usage.` |
| `Bio_SeqUtils_MeltingTemp_salt_correction` | `Bio.SeqUtils.MeltingTemp.salt_correction` | `Bio/SeqUtils/MeltingTemp.py` | `Na: float = 0, K: float = 0, Tris: float = 0, Mg: float = 0, dNTPs: float = 0, method: int = 1, seq: str = None` | `Calculate a term to correct nucleic acid melting temperature (Tm) or entropy for the ionic environment. This function computes a scalar correction term based on supplied millimolar concentrations of common ions (Na+, K+, Tris, Mg2+) and dNTPs, and on a selected empirical method (1-7) drawn from the literature (Schildkraut & Lifson 1965; Wetmur 1991; SantaLucia 1996/1998; Owczarzy 2004/2008, and von Ahsen 2001 for Na-equivalent). The computed correction is intended to be applied to a previously calculated Tm or to deltaS according to the method semantics described below; the function does not itself compute Tm or deltaS, only the ionic correction term.` |
| `Bio_SeqUtils_lcc_lcc_mult` | `Bio.SeqUtils.lcc.lcc_mult` | `Bio/SeqUtils/lcc.py` | `seq: str, wsize: int` | `Calculate Local Composition Complexity (LCC) values over a sliding window for an unambiguous DNA sequence. This function implements an optimized, incremental computation of the Local Composition Complexity (LCC) over a sequence using a fixed-size sliding window. LCC is a per-window measure of nucleotide composition heterogeneity based on the Shannon entropy of nucleotide frequencies normalized by log(4) (natural logarithm), producing values in the range [0.0, 1.0]. A value of 0.0 indicates a window composed of a single nucleotide (minimum complexity); values near 1.0 indicate maximal composition diversity (approximately equal counts of A, C, G, T). This implementation is used in the Biopython project for genomic sequence analysis to detect low-complexity regions and survey local sequence composition. It is optimized relative to a naive recomputation by updating counts and entropy terms incrementally when the window slides by one base.` |
| `Bio_SeqUtils_lcc_lcc_simp` | `Bio.SeqUtils.lcc.lcc_simp` | `Bio/SeqUtils/lcc.py` | `seq: str` | `Bio.SeqUtils.lcc.lcc_simp calculates the Local Composition Complexity (LCC) for a DNA sequence using a normalized Shannon-entropy style measure (log base 4) as described by Konopka (2005). This function is intended for use in computational molecular biology and bioinformatics workflows (for example, when analyzing nucleotide composition bias or segmenting genomic sequences) and returns a single scalar complexity value representing the overall base composition diversity of the provided sequence.` |
| `Bio_TogoWS_entry` | `Bio.TogoWS.entry` | `Bio/TogoWS/__init__.py` | `db: str, id: list, format: str = None, field: str = None` | `Bio.TogoWS.entry fetches a single or multiple records from the TogoWS "entry" endpoint for molecular biology resources (for example NCBI, KEGG, DDBj, EBI databases). It validates the requested database, optional field extraction and output format against cached metadata (populated on first use), constructs the proper TogoWS URL (quoting and joining identifiers as required), and returns the opened network resource produced by the module's internal _open helper. This function is used within Biopython to retrieve sequence, annotation, and other bioinformatics records programmatically (similar in purpose to NCBI Entrez EFetch, but with optional per-record field extraction supported by TogoWS).` |
| `Bio_TogoWS_search` | `Bio.TogoWS.search` | `Bio/TogoWS/__init__.py` | `db: str, query: str, offset: int = None, limit: int = None, format: str = None` | `Bio.TogoWS.search: Low-level wrapper to perform a text/web search against the TogoWS search API for biological databases. Performs a single search request to the TogoWS service and returns the raw response for the requested database and query. This function is a low-level helper used within Biopython to access remote biological database search services (for example NCBI, EBI, KEGG databases listed by TogoWS). For typical iterative retrieval of many results prefer Bio.TogoWS.search_iter(), and to obtain only the count of matches use Bio.TogoWS.search_count().` |
| `Bio_TogoWS_search_count` | `Bio.TogoWS.search_count` | `Bio/TogoWS/__init__.py` | `db: str, query: str` | `Bio.TogoWS.search_count ‚Äî Request the TogoWS search service and return the integer count of records matching a search. This function calls the TogoWS REST search/count endpoint to determine how many records in a given TogoWS database match the provided query. It is intended for use in bioinformatics workflows where you need to estimate the size of a result set (for example to plan batched downloads using offset and limit with Bio.TogoWS.search()). The function caches the list of known searchable database names in the module-level variable _search_db_names by calling _get_fields(_BASE_URL + "/search") when needed. If the provided db is not in that cached list, the function issues a runtime warning but still attempts the request. The function performs network I/O by constructing a URL of the form _BASE_URL + "/search/{db}/{quote(query)}/count", opening it via _open(), reading the response body, and converting the response to an integer count.` |
| `Bio_TogoWS_search_iter` | `Bio.TogoWS.search_iter` | `Bio/TogoWS/__init__.py` | `db: str, query: str, limit: int = None, batch: int = 100` | `Call TogoWS search and iterate over the resulting identifiers in batches. This generator function is part of Biopython's TogoWS client utilities and is used to perform a search against a remote TogoWS-compatible database (for example "pubmed") and stream the matching record identifiers (strings such as PubMed IDs) without loading all results into memory. It first obtains the total hit count via Bio.TogoWS.search_count(db, query) and then repeatedly calls Bio.TogoWS.search(db, query, offset, batch) to fetch successive batches of identifiers. This is useful in computational molecular biology workflows (e.g., fetching large sets of sequence or literature identifiers) where you want to process results incrementally.` |
| `Bio_UniProt_GOA_record_has` | `Bio.UniProt.GOA.record_has` | `Bio/UniProt/GOA.py` | `inrec: dict, fieldvals: dict` | `Check whether a UniProt GOA record contains any of the specified field values.` |
| `Bio_bgzf_make_virtual_offset` | `Bio.bgzf.make_virtual_offset` | `Bio/bgzf.py` | `block_start_offset: int, within_block_offset: int` | `Bio.bgzf.make_virtual_offset: Compute a BGZF "virtual offset" used by BAM/Tabix indexing by packing a BGZF block file offset and an offset within the decompressed block into a single 64-bit integer. This function implements the BAM indexing scheme representation of a file position as a 64-bit "virtual offset". The virtual offset is formed in C-style bit packing as (block_start_offset << 16) \| within_block_offset, where the high 48 bits encode the file offset of the start of a BGZF block and the low 16 bits encode the byte offset inside the decompressed block. In the Biopython project (a library for computational molecular biology and bioinformatics), this value is used when creating or interpreting BAM (.bam) and Tabix index records to allow random access to alignments or annotations by genomic coordinates.` |
| `Bio_bgzf_open` | `Bio.bgzf.open` | `Bio/bgzf.py` | `filename: str, mode: str = "rb"` | `Open a BGZF-compressed file for reading, writing or appending. This routine is used in computational molecular biology workflows (for example when working with blocked GZIP files such as BAM, BCF, or Tabix-indexed VCF/GFF files) to obtain a Biopython file-like object that performs BGZF-aware I/O.` |
| `Bio_bgzf_split_virtual_offset` | `Bio.bgzf.split_virtual_offset` | `Bio/bgzf.py` | `virtual_offset: int` | `Split a 64-bit BGZF virtual offset into the BGZF block start and the offset within that block. This function is used in Bio.bgzf and related Biopython code that manipulates BGZF-compressed genomic files (for example BAM/BAI workflows). A BGZF virtual offset encodes a file-position that can be used to seek to a particular record: the high-order bits are the byte offset of the start of a BGZF block in the compressed file, and the low-order 16 bits are the offset inside the uncompressed data of that block. This function reverses that packing: it extracts the block start (the compressed-file byte offset where the BGZF block begins) and the within-block offset (the byte offset inside the uncompressed block where the desired data record begins). The result is commonly used when resolving virtual offsets stored in indexes (such as BAI) to actual file seek positions for random access in large genomic files.` |
| `Bio_motifs_create` | `Bio.motifs.create` | `Bio/motifs/__init__.py` | `instances: list, alphabet: str = "ACGT"` | `Create a Motif object from a collection of aligned motif occurrences. This convenience function constructs an Alignment from the provided instances and then constructs and returns a Motif using that alignment and the provided alphabet. In the Biopython project, a Motif object represents a conserved sequence pattern (for example, a transcription factor binding site) derived from multiple aligned occurrences and is used in downstream analyses such as computing position-specific counts, position-specific scoring matrices (PSSMs), consensus sequences, and motif visualization.` |
| `Bio_motifs_write` | `Bio.motifs.write` | `Bio/motifs/__init__.py` | `motifs: list, fmt: str, **kwargs` | `Return a string representation of a collection of sequence motifs in a specified motif file format. This function is part of the Bio.motifs subpackage of Biopython, a toolkit for computational molecular biology. It converts an in-memory list of motif objects (position frequency matrices or similar motif representations used in motif discovery and transcription factor binding site analysis) into the textual file format required by downstream tools or databases. The function supports exporting to ClusterBuster, JASPAR (single or multiple PFM variants), and TRANSFAC-like formats by delegating to the corresponding format-specific writer implementations in Bio.motifs.jaspar, Bio.motifs.transfac, and Bio.motifs.clusterbuster. The fmt argument is treated case-insensitively. No files are written by this function; it returns the formatted content as a string so callers can write it to disk, send it over a network, or further process it in memory.` |
| `Bio_motifs_clusterbuster_write` | `Bio.motifs.clusterbuster.write` | `Bio/motifs/clusterbuster.py` | `motifs: list, precision: int = 0` | `Bio.motifs.clusterbuster.write returns a Cluster Buster position frequency matrix representation for a collection of motif objects, suitable for saving to a file or passing to external motif analysis tools. In the context of Biopython (a library for computational molecular biology), this function serializes Biopython motif objects (each expected to provide a name, counts for A/C/G/T, and optional weight and gap attributes) into the plain-text format understood by the Cluster Buster suite for cis-regulatory motif clustering and scanning.` |
| `Bio_motifs_jaspar_split_jaspar_id` | `Bio.motifs.jaspar.split_jaspar_id` | `Bio/motifs/jaspar/__init__.py` | `id: str` | `Split a JASPAR matrix ID into its base identifier and optional version component. This function is used in the Bio.motifs.jaspar subpackage to parse JASPAR motif matrix identifiers commonly found in JASPAR databases and motif exchange files. A JASPAR ID often encodes a stable matrix identifier (the base ID) and an optional version suffix separated by a single period, for example "MA0047.2". The base ID identifies the motif (useful for looking up the canonical matrix or grouping related motifs) and the version component identifies a release or revision of that matrix (useful for tracking changes across database versions).` |
| `Bio_motifs_jaspar_write` | `Bio.motifs.jaspar.write` | `Bio/motifs/jaspar/__init__.py` | `motifs: list, format: str` | `Bio.motifs.jaspar.write returns a text representation of one or more motif objects in either the "pfm" (position frequency matrix) or "jaspar" motif database format. This function is used in computational molecular biology workflows (as in Biopython) to serialize motif/count matrices for storage, sharing, or submission to motif databases such as JASPAR; the produced string contains ASCII lines with numeric counts formatted to two decimal places and newline termination suitable for writing to a file.` |
| `Bio_motifs_pfm_write` | `Bio.motifs.pfm.write` | `Bio/motifs/pfm.py` | `motifs: list` | `Return a string representing motifs in the Cluster Buster position frequency matrix (PFM) format. This function is part of Biopython's motifs utilities and is used in computational molecular biology workflows to export motif models (position frequency matrices) so they can be consumed by external motif scanning tools such as Cluster-Buster or other tools expecting the four-column A C G T count format. For each motif in the input list, the function writes a header line beginning with ">" followed by the motif's name, then one line per motif position containing four tab-separated numeric counts in the order A, C, G, T. Numeric values are formatted with no decimal places (rounded according to Python's float formatting rules). The implementation concatenates the per-line strings into a single text block and returns it; it does not write to disk or modify the input objects.` |
| `Bio_motifs_transfac_write` | `Bio.motifs.transfac.write` | `Bio/motifs/transfac.py` | `motifs: list` | `Write the representation of one or more motifs in TRANSFAC format. This function is part of the Bio.motifs module in Biopython, used in computational molecular biology to export motif objects (position frequency matrices and associated metadata) into the TRANSFAC flat-file format widely used to represent transcription factor binding sites and their annotation. The function assembles text blocks for each motif following TRANSFAC conventions: two-letter keys (e.g., AC, ID, DT), section separators "XX", per-motif terminators "//", a P0 frequency-matrix section for counts, and an optional top-level version block if the provided motifs container exposes a version attribute. The routine consults Motif.multiple_value_keys to determine when a key maps to multiple output lines, and it writes reference entries (RN, RX, RA, RT, RL) when a motif exposes a references sequence.` |
| `Bio_pairwise2_calc_affine_penalty` | `Bio.pairwise2.calc_affine_penalty` | `Bio/pairwise2.py` | `length: int, open: float, extend: float, penalize_extend_when_opening: bool` | `Calculate the affine gap penalty score for a gap of a given length used in pairwise sequence alignment. This function implements the common affine gap penalty model used by Bio.pairwise2 and other sequence alignment algorithms in computational molecular biology: a gap penalty composed of a gap opening term plus a gap extension term multiplied by the gap length. It is intended to be called when scoring a contiguous gap (run of insertions or deletions) during dynamic programming for pairwise alignments (global, local, or semi-global) as provided by the Biopython pairwise2 machinery.` |
| `Bio_pairwise2_format_alignment` | `Bio.pairwise2.format_alignment` | `Bio/pairwise2.py` | `align1: list, align2: list, score: float, begin: int, end: int, full_sequences: bool = False` | `Format a pairwise alignment (given as two aligned sequences) into a human-readable multi-line string suitable for console display and logging. This function is used in Biopython's pairwise alignment utilities to present an alignment between two sequences (or sequence tokens) in a compact, readable form. It prints a sequence-1 line, a match-line that marks identical matches, mismatches and gaps, and a sequence-2 line, followed by a score line. This is intended for users and developers working with computational molecular biology sequence comparisons, for quick inspection of aligned regions produced by pairwise alignment algorithms.` |
| `Bio_pairwise2_print_matrix` | `Bio.pairwise2.print_matrix` | `Bio/pairwise2.py` | `matrix: list` | `Print a two-dimensional matrix to standard output in a human‚Äëreadable, column‚Äëaligned form for debugging pairwise alignment code in Biopython.` |

## ‚öñÔ∏è License

Original Code License: BSD-3-Clause

Wrapper Code & Documentation: Apache-2.0

*This file was automatically generated on February 26, 2026.*
