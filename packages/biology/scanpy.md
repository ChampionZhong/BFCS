# scanpy

[üîô Back to Main Repo](../../../README.md) | [üîó Original Repo](https://github.com/scverse/scanpy)

![Tool Count](https://img.shields.io/badge/Agent_Tools-21-blue?style=flat-square)
![Category](https://img.shields.io/badge/Category-Biology-green?style=flat-square)
![Status](https://img.shields.io/badge/Import_Test-Passed-success?style=flat-square)

## üìñ Overview

Scanpy is a scalable Python toolkit for analyzing single-cell gene expression data, providing workflows for preprocessing, visualization, clustering, trajectory inference, and differential expression testing.

> **Note**: This documentation lists the **agent-ready wrapper functions** generated for this package. These functions have been strictly typed, docstring-enhanced, and tested for import stability within a standardized Apptainer environment.

## üõ†Ô∏è Available Agent Tools

Below is the list of **21** functions optimized for LLM tool-use.

| **Tool Name (Wrapper)**   | **Source**          | **File Path**     | **Arguments (Type)**        | **Description**                |
| ------------------------- | ------------------- | ----------------- | --------------------------- | ------------------------------ |
| `scanpy__utils_identify_groups` | `scanpy._utils.identify_groups` | `scanpy/_utils/__init__.py` | `ref_labels: numpy.ndarray, pred_labels: numpy.ndarray, return_overlaps: bool = False` | `Identify which predicted label explains which reference label. This function is used in single-cell analysis workflows (Scanpy) to map clustering or prediction labels (pred_labels) back to a set of reference labels (ref_labels) such as known cell types, annotation labels, or previously computed cluster assignments. For each unique reference label, the function computes the counts of cells shared with each predicted label, normalizes these counts both by the predicted-group size and the reference-group size, and selects predicted labels that best "explain" the reference group by maximizing the minimum of these two relative overlaps. This is useful when evaluating how well a predicted clustering or classification matches a biological or annotated reference grouping.` |
| `scanpy__utils_lazy_import` | `scanpy._utils.lazy_import` | `scanpy/_utils/__init__.py` | `full_name: str` | `scanpy._utils.lazy_import imports a module identified by its fully qualified name using importlib utilities and a LazyLoader so that the module's execution is deferred and safely inserted into sys.modules with proper locking. In the Scanpy single-cell analysis toolkit, this utility is used to reduce startup cost and delay importing heavy or optional dependencies (for example dask or visualization libraries) until their attributes are actually accessed by downstream code paths that perform preprocessing, visualization, or large-scale analyses.` |
| `scanpy__utils_moving_average` | `scanpy._utils.moving_average` | `scanpy/_utils/__init__.py` | `a: numpy.ndarray, n: int` | `scanpy._utils.moving_average: Compute the moving average of a one-dimensional NumPy array. This utility computes a simple (unweighted) moving average over a 1-D numeric array using a cumulative-sum algorithm for efficiency. In the Scanpy single-cell analysis context this is typically used to smooth a numeric vector such as a gene expression profile across cells (for example across a neighborhood of cells or along a pseudotime trajectory) to reduce high-frequency noise while preserving coarse trends. The implementation returns values as float and does not modify the input array.` |
| `scanpy_datasets__ebi_expression_atlas_ebi_expression_atlas` | `scanpy.datasets._ebi_expression_atlas.ebi_expression_atlas` | `scanpy/datasets/_ebi_expression_atlas.py` | `accession: str, filter_boring: bool = False` | `scanpy.datasets._ebi_expression_atlas.ebi_expression_atlas: Load a dataset from the EBI Single Cell Expression Atlas and return it as an anndata.AnnData object for downstream single-cell gene expression analysis with Scanpy. This function retrieves a single-cell experiment identified by an EBI accession (for example E-GEOD-98816 or E-MTAB-4888) from the EBI Single Cell Expression Atlas. It first attempts to read a cached H5AD file from the local dataset directory configured in scanpy.settings.datasetdir under a subdirectory named by the accession. If the cached file cannot be read (for example because it does not exist or an OSError occurs), the function downloads the experiment archive using download_experiment, extracts expression data from expression_archive.zip, reads sample/experimental design from experimental_design.tsv, populates the AnnData.obs dataframe with those metadata columns, and writes a compressed H5AD file (gzip) to the same location to cache the assembled dataset for future calls. The returned object is an anndata.AnnData containing the expression matrix (n_obs √ó n_vars) and associated metadata suitable for Scanpy workflows (preprocessing, visualization, clustering, differential expression, etc.). This operation may require an internet connection when the dataset is not already cached locally and will log the download location.` |
| `scanpy_neighbors__connectivity_umap` | `scanpy.neighbors._connectivity.umap` | `scanpy/neighbors/_connectivity.py` | `knn_indices: numpy.typing.NDArray[numpy.int32 \| numpy.int64], knn_dists: numpy.typing.NDArray[numpy.float32 \| numpy.float64], n_obs: int, n_neighbors: int, set_op_mix_ratio: float = 1.0, local_connectivity: float = 1.0` | `scanpy.neighbors._connectivity.umap: Compute a fuzzy simplicial set (sparse connectivity graph) by wrapping umap.fuzzy_simplicial_set for use in Scanpy's neighborhood graph construction for single‚Äëcell gene expression analysis. This function constructs a global fuzzy simplicial set (represented as a sparse graph in CSR format) from precomputed k‚Äënearest neighbor indices and distances. It locally approximates geodesic distances at each observation, builds local fuzzy simplicial sets per observation, and combines them via a fuzzy union. This wrapper is used in Scanpy to produce the connectivity (adjacency) graph that downstream tasks rely on (for example: clustering, UMAP embedding, and graph‚Äëbased visualization) and preserves compatibility with UMAP's implementation while suppressing a common TensorFlow import warning.` |
| `scanpy_plotting__utils_check_projection` | `scanpy.plotting._utils.check_projection` | `scanpy/plotting/_utils.py` | `projection: str` | `Validate a projection argument used by Scanpy plotting utilities. This function is a small input validator used throughout scanpy.plotting._utils and higher-level Scanpy plotting functions to ensure that a requested visualization projection refers to a supported dimensionality for plotting high-dimensional single-cell gene expression embeddings (for example, 2D UMAP, 3D UMAP, PCA or t-SNE visualizations commonly produced in single-cell analysis workflows). It enforces the exact, case-sensitive string values that downstream plotting code expects so that plotting routines can select two- or three-dimensional plotting code paths without further checks.` |
| `scanpy_plotting__utils_fix_kwds` | `scanpy.plotting._utils.fix_kwds` | `scanpy/plotting/_utils.py` | `kwds_dict: dict, **kwargs` | `scanpy.plotting._utils.fix_kwds: Merge and prioritize plotting keyword arguments for Scanpy plotting utilities. Concise utility used by Scanpy's plotting helpers to consolidate two sources of keyword arguments into a single dictionary of parameters for plotting functions in single-cell gene expression analysis workflows. In the Scanpy plotting codebase, callers commonly have a dictionary of plot parameters (for example, defaults or parameters collected earlier in a plotting wrapper) and also accept additional keyword arguments via **kwargs. This function prevents argument duplication errors by merging those two sources and ensuring a predictable precedence: when the same key exists in both, the value coming from kwds_dict (the explicit dictionary of plot parameters typically produced earlier in the plotting call chain) takes precedence and overwrites the value from kwargs (the additional keyword arguments provided by the caller). This behavior is important in the domain of single-cell visualization (e.g., scatter, embedding, or feature plots) where many helper functions assemble parameter dictionaries and then allow callers to override or extend them with keyword arguments. Using fix_kwds ensures that parameters deliberately set earlier in the plotting pipeline are preserved while still allowing additional parameters to be added.` |
| `scanpy_plotting__utils_savefig` | `scanpy.plotting._utils.savefig` | `scanpy/plotting/_utils.py` | `writekey: str, dpi: float = None, ext: str = None` | `Save the current matplotlib figure to a file using Scanpy's figure settings and log the action. This function is used throughout Scanpy plotting utilities to persist figures generated during single-cell gene expression analysis (for example UMAP, PCA, heatmaps, cluster plots) so that results and figures can be included in reports, publications, or downstream reproducible workflows. The filename is constructed from Scanpy's settings: settings.figdir, the provided write key, settings.plot_suffix, and the chosen file extension. The function ensures the target directory exists, may emit a one-time low-resolution warning based on matplotlib rcParams, sets/uses a DPI value for saving, writes the file with matplotlib.pyplot.savefig(..., bbox_inches="tight"), and logs the saved filename at warning level.` |
| `scanpy_plotting__utils_timeseries` | `scanpy.plotting._utils.timeseries` | `scanpy/plotting/_utils.py` | `X: numpy.ndarray, **kwargs` | `scanpy.plotting._utils.timeseries: Create a Matplotlib figure sized for Scanpy timeseries plots and render the provided array X by delegating drawing and layout details to timeseries_subplot. This utility is part of Scanpy's plotting helpers used in the single-cell analysis and visualization workflow (for example, to visualize expression values across an ordered axis such as time, pseudotime, or sample order). The function prepares a figure with Scanpy's preferred default size and subplot margins, then calls timeseries_subplot(X, **kwargs) to perform the actual plotting. It does not return a plotting object; instead it produces side effects on the current Matplotlib state (creates a new figure and draws onto axes).` |
| `scanpy_preprocessing__deprecated_zscore_deprecated` | `scanpy.preprocessing._deprecated.zscore_deprecated` | `scanpy/preprocessing/_deprecated/__init__.py` | `x: numpy.ndarray` | `scanpy.preprocessing._deprecated.zscore_deprecated: Z-score standardize each variable (gene) in a data matrix x. This function implements a column-wise (per-gene) centering by the column mean and scaling by the column standard deviation as used in Scanpy preprocessing workflows and cited in Weinreb2017. This function is deprecated; use scale instead. This function is intended for single-cell gene expression data matrices where rows correspond to cells and columns correspond to genes. It computes column-wise means and standard deviations, tiles them to the shape of x, and returns (x - mean) / (std + 0.0001). The small constant 0.0001 is added to avoid division-by-zero for genes with zero variance.` |
| `scanpy_preprocessing__deprecated_highly_variable_genes_filter_genes_cv_deprecated` | `scanpy.preprocessing._deprecated.highly_variable_genes.filter_genes_cv_deprecated` | `scanpy/preprocessing/_deprecated/highly_variable_genes.py` | `x: numpy.ndarray, e_cutoff: float, cv_filter: float` | `scanpy.preprocessing._deprecated.highly_variable_genes.filter_genes_cv_deprecated filters genes by coefficient of variance and mean for single‚Äëcell gene expression matrices and returns a boolean mask of genes that pass the deprecated CV-based selection.` |
| `scanpy_preprocessing__deprecated_highly_variable_genes_filter_genes_fano_deprecated` | `scanpy.preprocessing._deprecated.highly_variable_genes.filter_genes_fano_deprecated` | `scanpy/preprocessing/_deprecated/highly_variable_genes.py` | `x: numpy.ndarray, e_cutoff: float, v_cutoff: float` | `Filter genes by Fano factor and mean for single-cell gene expression matrices. This deprecated helper is part of Scanpy's preprocessing utilities for selecting highly variable genes in single-cell RNA-seq data. It computes, for each gene (column) in the input expression matrix x, the mean expression across observations (cells) and the Fano factor defined as variance / mean, where the variance is computed with numpy.var (population variance). Genes are selected (if and only if) their mean expression is >= e_cutoff and their Fano factor is >= v_cutoff. This function is provided for compatibility with older Scanpy workflows (module path scanpy.preprocessing._deprecated.highly_variable_genes), and its behavior mirrors the historical Fano-factor-based gene filtering used in exploratory single-cell analysis to retain genes that are both expressed above a minimum level and show overdispersion relative to the mean.` |
| `scanpy_preprocessing__simple_numpy_regress_out` | `scanpy.preprocessing._simple.numpy_regress_out` | `scanpy/preprocessing/_simple.py` | `data: numpy.ndarray, regressor: numpy.ndarray` | `scanpy.preprocessing._simple.numpy_regress_out: Compute and return residuals after regressing out unwanted covariates from a numeric data matrix using NumPy linear algebra. This function implements the normal-equations solution of ordinary least squares to estimate coefficients for the provided regressor (design) matrix and then computes residuals of the input data with those estimated coefficients removed. It is a low-level NumPy implementation used in Scanpy preprocessing to remove unwanted sources of variation in single-cell gene expression analysis (for example, technical covariates such as batch effects, library size, or percent mitochondrial counts). The computation follows coeff = (regressor.T @ regressor)^{-1} @ (regressor.T @ data) and then produces residuals = data - regressor @ coeff. The regressor matrix is treated as a design matrix (observations √ó covariates) and data is treated as an observations √ó features matrix (for single-cell use: observations correspond to cells and features typically correspond to genes).` |
| `scanpy_preprocessing__utils_sparse_mean_var_major_axis` | `scanpy.preprocessing._utils.sparse_mean_var_major_axis` | `scanpy/_compat.py` | `data: numpy.ndarray, indptr: numpy.ndarray, major_len: int, minor_len: int, n_threads: int` | `Compute per-major-axis (per-row) mean and variance for a sparse matrix stored in CSR-like arrays. This function is intended for use in preprocessing of single-cell gene expression matrices (as in Scanpy), where large sparse matrices are common. Given the raw CSR arrays (data and indptr) that represent nonzero entries of a 2-D sparse array, this routine computes for each major-axis entry (rows) the arithmetic mean and the population variance across the minor axis (columns). The implementation is written to be JIT-compiled and parallelized with Numba and numba.prange; n_threads controls that parallelization. The results are suitable for downstream preprocessing steps such as normalization, filtering by mean/variance, or variance-stabilizing transformations in single-cell analysis workflows.` |
| `scanpy_preprocessing__utils_sparse_mean_var_minor_axis` | `scanpy.preprocessing._utils.sparse_mean_var_minor_axis` | `scanpy/_compat.py` | `data: numpy.ndarray, indices: numpy.ndarray, indptr: numpy.ndarray, major_len: int, minor_len: int, n_threads: int` | `Compute per-minor-axis (column) means and variances for a CSR-format sparse matrix. This function is used in Scanpy preprocessing routines to compute per-feature (per-gene) summary statistics across observations (cells) when the expression matrix is stored in CSR (compressed sparse row) format. It iterates over the nonzero entries provided by the CSR arrays and returns the mean and population variance for each minor-axis element (column/gene) across the major axis (rows/cells). The implementation is numba njit-compiled and uses parallel accumulation across n_threads to reduce contention; intermediate per-thread accumulators are combined at the end.` |
| `scanpy_readwrite_convert_bool` | `scanpy.readwrite.convert_bool` | `scanpy/readwrite.py` | `string: str` | `scanpy.readwrite.convert_bool checks whether a given string is the literal boolean "True" or "False" and returns a pair that signals recognition and the corresponding boolean value. This utility is intended for read/write and parsing code in Scanpy (the single-cell gene expression analysis toolkit) where boolean values may be represented as text in configuration files, metadata fields, or I/O parameters; it provides a deterministic, case-sensitive test and a simple encoded result that calling code can use to decide how to interpret or coerce string-valued inputs.` |
| `scanpy_readwrite_convert_string` | `scanpy.readwrite.convert_string` | `scanpy/readwrite.py` | `string: str` | `scanpy.readwrite.convert_string: Convert a textual value into a native Python scalar (int, float, bool, str) or None.` |
| `scanpy_readwrite_is_float` | `scanpy.readwrite.is_float` | `scanpy/readwrite.py` | `string: str` | `scanpy.readwrite.is_float: Check whether a given string can be converted to a Python float. This utility is used by Scanpy read/write code and related parsing utilities to detect whether a textual token represents a floating-point numeric value before attempting numeric conversion. In the context of single-cell gene expression data ingestion (for example when parsing CSV/TSV expression matrices or metadata fields), this function helps decide whether a cell in a text field should be interpreted as a numeric value and avoids unexpected failures when scanning large datasets.` |
| `scanpy_readwrite_is_int` | `scanpy.readwrite.is_int` | `scanpy/readwrite.py` | `string: str` | `scanpy.readwrite.is_int checks whether a text string represents an integer according to Python's built-in int() conversion. This utility is intended for use in Scanpy's read/write and parsing routines when deciding whether a token (for example, a field from a text file, a row/column label, a barcode fragment, a layer index, or other metadata encountered while loading single-cell gene expression data) should be interpreted as an integer. The function performs a single, non-destructive conversion attempt and has no side effects on program state or input objects.` |
| `scanpy_tools__sim_check_nocycles` | `scanpy.tools._sim.check_nocycles` | `scanpy/tools/_sim.py` | `Adj: numpy.ndarray, verbosity: int = 2` | `Check_nocycles verifies that the directed graph encoded by a square adjacency matrix contains no directed cycles.` |
| `scanpy_tools__sim_sample_coupling_matrix` | `scanpy.tools._sim.sample_coupling_matrix` | `scanpy/tools/_sim.py` | `dim: int = 3, connectivity: float = 0.5` | `Sample coupling matrix. Generates a random directed coupling matrix and associated adjacency representations for use in simulation utilities in scanpy.tools._sim. This function is used to produce a small synthetic interaction topology between dim nodes (for example, cell-state groups or modules in single-cell simulation workflows described in the Scanpy project README), ensuring no self-cycles and that the directed graph is acyclic. The sampled matrices can be used by downstream simulation code that requires a numeric coupling matrix, a binary adjacency matrix, and a signed adjacency matrix.` |

## ‚öñÔ∏è License

Original Code License: BSD-3-Clause

Wrapper Code & Documentation: Apache-2.0

*This file was automatically generated on February 26, 2026.*
