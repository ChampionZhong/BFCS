# boltz

[üîô Back to Main Repo](../../../README.md) | [üîó Original Repo](https://github.com/jwohlwend/boltz)

![Tool Count](https://img.shields.io/badge/Agent_Tools-46-blue?style=flat-square)
![Category](https://img.shields.io/badge/Category-Biology-green?style=flat-square)
![Status](https://img.shields.io/badge/Import_Test-Passed-success?style=flat-square)

## üìñ Overview

Boltz is an open-source deep learning package for predicting biomolecular complex structures and interactions‚Äîincluding protein‚Äìligand binding affinities‚Äîto enable fast in silico screening and molecular design.

> **Note**: This documentation lists the **agent-ready wrapper functions** generated for this package. These functions have been strictly typed, docstring-enhanced, and tested for import stability within a standardized Apptainer environment.

## üõ†Ô∏è Available Agent Tools

Below is the list of **46** functions optimized for LLM tool-use.

| **Tool Name (Wrapper)**   | **Source**          | **File Path**     | **Arguments (Type)**        | **Description**                |
| ------------------------- | ------------------- | ----------------- | --------------------------- | ------------------------------ |
| `boltz_data_crop_boltz_pick_chain_token` | `boltz.data.crop.boltz.pick_chain_token` | `boltz/data/crop/boltz.py` | `tokens: numpy.ndarray, chain_id: int, random: numpy.random.mtrand.RandomState` | `Pick a random token belonging to a specified chain from a structured token array used by the Boltz cropping pipeline. This function is used by Boltz preprocessing (cropping) code to select a single token (for example a residue- or atom-level entry) from the set of tokens that represent a biomolecular system. In the Boltz domain (biomolecular interaction and binding-affinity prediction), selecting a representative token from a specific chain is useful for creating localized crops or anchors when preparing inputs for structure and affinity prediction models. The selection is randomized but reproducible when a numpy.random.mtrand.RandomState is provided.` |
| `boltz_data_crop_boltz_pick_interface_token` | `boltz.data.crop.boltz.pick_interface_token` | `boltz/data/crop/boltz.py` | `tokens: numpy.ndarray, interface: numpy.ndarray, random: numpy.random.mtrand.RandomState` | `Pick a single token from the specified intermolecular interface for use as a crop center in Boltz preprocessing and inference. This function is used by Boltz's data-cropping pipeline to choose a representative token located at or near the interface between two chains so that downstream model inputs (structure or affinity prediction) can be focused on the region of interaction. The function expects the tokens array to be a structured numpy.ndarray containing per-token fields used by the cropping logic (the implementation accesses tokens["asym_id"] to group tokens by chain and tokens["center_coords"] to compute inter-token distances). The interface argument is expected to provide chain identifiers for the two sides of the interface (the implementation reads interface["chain_1"] and interface["chain_2"]). Selection is randomized but deterministic if the provided RandomState is seeded. Behavior summary: If tokens exist only on one of the two interface chains, the function selects a random token from the available chain. If no tokens exist on either chain, it selects a random token from the entire tokens array. If tokens exist on both chains, it computes pairwise Euclidean distances between tokens' center_coords and retains tokens on each chain that lie within const.interface_cutoff of at least one token on the opposite chain. If no inter-chain distances fall below const.interface_cutoff, the cutoff is relaxed by +5.0 √Ö to avoid empty candidate sets. A random token is then chosen from the combined set of retained tokens from both chains. The provided RandomState controls the randomness to ensure reproducible sampling when seeded.` |
| `boltz_data_crop_boltz_pick_random_token` | `boltz.data.crop.boltz.pick_random_token` | `boltz/data/crop/boltz.py` | `tokens: numpy.ndarray, random: numpy.random.mtrand.RandomState` | `boltz.data.crop.boltz.pick_random_token picks a single token uniformly at random from a 1D collection of tokens using a supplied NumPy random state. In the Boltz data preprocessing and cropping pipeline (used for preparing biomolecular inputs to the model during training and inference), this function is used to select one token example from an array of candidate tokens in a reproducible way.` |
| `boltz_data_feature_featurizer_dummy_msa` | `boltz.data.feature.featurizer.dummy_msa` | `boltz/data/feature/featurizer.py` | `residues: numpy.ndarray` | `Create a dummy multiple-sequence alignment (MSA) for a single chain used by the Boltz featurizer pipeline.` |
| `boltz_data_feature_featurizerv2_convert_atom_name` | `boltz.data.feature.featurizerv2.convert_atom_name` | `boltz/data/feature/featurizerv2.py` | `name: str` | `Convert an atom name string (as found in PDB or ligand files) into a fixed-length integer encoding used by the Boltz featurizerv2 pipeline. This function is used in the featurization stage of Boltz (a biomolecular interaction modeling system) to convert human-readable atom names (for example "CA", "N", "1HB", or " O " from PDB records) into a numeric representation that can be included in model input features. The encoding is simple and deterministic: the function trims surrounding whitespace, casts the input to str, converts each character c to the integer ord(c) - 32 (so ASCII printable characters are mapped into small non-negative integers and a space character maps to 0), and pads with zero values so that typical atom names (up to 4 characters) produce a 4-element tuple suitable for fixed-size model inputs.` |
| `boltz_data_feature_featurizerv2_dummy_msa` | `boltz.data.feature.featurizerv2.dummy_msa` | `boltz/data/feature/featurizerv2.py` | `residues: numpy.ndarray` | `Create a minimal, placeholder multiple-sequence-alignment (MSA) record for a single chain used by the Boltz featurization pipeline. This function is used when an actual MSA is unavailable or when a fast, deterministic placeholder is required (for example, when skipping MSA server queries during inference). The returned MSA enables downstream featurizers and the Boltz model to proceed without real alignment data by providing a single-sequence MSA with per-position residue types and no deletion events.` |
| `boltz_data_feature_featurizerv2_get_range_bin` | `boltz.data.feature.featurizerv2.get_range_bin` | `boltz/data/feature/featurizerv2.py` | `value: float, range_dict: dict, default: int = 0` | `boltz.data.feature.featurizerv2.get_range_bin maps a numeric value to a discrete integer bin index using a dictionary of numeric ranges. This function is used in the Boltz featurization pipeline to convert continuous scalar features (for example, distances, physicochemical descriptors, or affinity-related scalars such as log10(IC50) used by Boltz affinity predictions) into categorical bin indices that downstream model components expect. This function converts the input value to float, iterates over entries in range_dict (typically mapping tuple(low, high) -> int), and returns the first bin index whose interval contains the value according to the half-open convention low <= value < high. If no interval matches, the supplied default is returned. The function intentionally skips any key equal to the string "other" when testing intervals; that key may be reserved for other processing elsewhere in the featurizer.` |
| `boltz_data_feature_featurizerv2_load_dummy_templates_features` | `boltz.data.feature.featurizerv2.load_dummy_templates_features` | `boltz/data/feature/featurizerv2.py` | `tdim: int, num_tokens: int` | `Load dummy template features used by the v2 featurizer pipeline. This function allocates and returns a dictionary of zero-filled template feature tensors that match the keys and shapes expected by the Boltz v2 model featurizer and downstream networks. It is intended to be used when no real template structure data (for example PDB-derived templates) are available: calling code can pass these dummy tensors so the model receives a complete, well-typed feature set and does not need special-case logic for missing templates. The returned tensors follow the shapes and dtypes constructed in the v2 featurizer: rotation and translation frames, CŒ±/CŒ≤ coordinates, boolean masks, an integer mapping from query tokens to template positions, and visibility flags. Note that the residue-type one-hot encoding uses the module-level constant const.num_tokens as the number of one-hot classes (num_classes) rather than the function argument num_tokens.` |
| `boltz_data_feature_featurizerv2_sample_d` | `boltz.data.feature.featurizerv2.sample_d` | `boltz/data/feature/featurizerv2.py` | `min_d: float, max_d: float, n_samples: int, random: numpy.random._generator.Generator` | `boltz.data.feature.featurizerv2.sample_d: Generate samples from a 1/d probability distribution on the interval [min_d, max_d]. This function is used by featurizerv2 in the Boltz codebase to produce distance-like scalar samples (for example, interatomic or inter-residue distance priors or augmentations) that follow an inverse-distance prior appropriate for scale-invariant sampling in biomolecular interaction and structure modeling tasks used by Boltz (binding affinity and structure prediction).` |
| `boltz_data_feature_symmetry_convert_atom_name` | `boltz.data.feature.symmetry.convert_atom_name` | `boltz/data/feature/symmetry.py` | `name: str` | `boltz.data.feature.symmetry.convert_atom_name converts a biomolecular atom name string into a small, fixed-format numeric tuple used by Boltz feature pipelines for symmetry-aware atom encoding. This function is used when constructing input features for the Boltz models (e.g., encoding PDB/chemical atom names into a deterministic numeric representation that downstream embedding layers or symmetry features consume).` |
| `boltz_data_feature_symmetry_get_symmetries` | `boltz.data.feature.symmetry.get_symmetries` | `boltz/data/feature/symmetry.py` | `path: str` | `boltz.data.feature.symmetry.get_symmetries: Load and return ligand symmetry descriptors from a serialized ligand file used by the Boltz pipeline. This function opens a binary file at the given filesystem path and expects a pickled Python dictionary whose values are molecule objects that contain a "symmetries" property and per-atom "name" properties. It deserializes the top-level file with pickle.load, then for each molecule tries to read a hex-encoded pickled symmetry descriptor from the molecule property "symmetries", unhexlify and unpickle that descriptor, and collect a list of normalized atom names (using convert_atom_name) in the same order as the molecule's atom iteration. The result is a dictionary keyed by the original keys in the input file and valued by a two-tuple (sym, atom_names) where sym is the unpickled symmetry descriptor as stored in the file and atom_names is a list of strings naming the atoms. In the Boltz domain this mapping is used to preserve and apply ligand symmetry information during structure modeling and affinity prediction (for example, to identify equivalent atoms under ligand symmetry when comparing or aligning ligands).` |
| `boltz_data_mol_load_all_molecules` | `boltz.data.mol.load_all_molecules` | `boltz/data/mol.py` | `moldir: str` | `Load all pickled molecule objects from a directory into a name->Mol mapping. This function scans the filesystem directory specified by moldir for files with a ".pkl" extension, opens each file in binary mode, and deserializes its contents using Python's pickle.load. It is used in the Boltz codebase to populate an in-memory dictionary of rdkit.Chem.rdchem.Mol objects (molecular representations) that downstream Boltz inference and training code use for biomolecular interaction modeling and binding affinity prediction (e.g., ligand structure and affinity pipelines described in the project README). The returned mapping keys are the filename stems (filename without extension) and the values are the deserialized Mol objects expected by the Boltz pipelines.` |
| `boltz_data_mol_load_canonicals` | `boltz.data.mol.load_canonicals` | `boltz/data/mol.py` | `moldir: str` | `Load canonicalized molecule objects from a directory for use by Boltz model pipelines. This function reads molecule files from the directory specified by moldir and constructs a dictionary of canonicalized RDKit molecule objects using the Boltz canonical token configuration. It is used by Boltz preprocessing and inference pipelines (for example, preparing ligand representations for binding affinity prediction and structural modeling described in the repository README). Internally this function delegates to load_molecules(moldir, const.canonical_tokens), so the exact canonicalization behavior follows the repository's canonical_tokens settings.` |
| `boltz_data_mol_load_molecules` | `boltz.data.mol.load_molecules` | `boltz/data/mol.py` | `moldir: str, molecules: list[str]` | `Load pickled RDKit molecule objects from a directory for use by Boltz biomolecular modeling. This function reads binary pickle files named "<molecule>.pkl" from a filesystem directory and deserializes them into RDKit molecule objects. In the Boltz pipeline these deserialized objects typically represent CCD/ligand components used when constructing inputs for structure prediction and binding affinity prediction (e.g., affinity_pred_value and affinity_probability_binary described in the project README). The function performs no writing; it opens each file in binary read mode and returns all successfully loaded molecules in memory as a dictionary keyed by the molecule name.` |
| `boltz_data_parse_mmcif_compute_interfaces` | `boltz.data.parse.mmcif.compute_interfaces` | `boltz/data/parse/mmcif.py` | `atom_data: numpy.ndarray, chain_data: numpy.ndarray` | `boltz.data.parse.mmcif.compute_interfaces computes chain-chain interfaces from a gemmi-derived structure and returns unique pairs of chain indices that are within a geometric contact cutoff. This function is used by Boltz to identify which polymer chains in a biomolecular complex are in spatial contact (interfaces) so downstream modules can focus structural and affinity modeling on interacting chain pairs. The implementation maps atoms to chain indices using chain_data, filters to atoms marked present, builds a KDTree over atom coordinates, queries neighbors within const.atom_interface_cutoff, and collects unique, ordered chain index pairs.` |
| `boltz_data_parse_mmcif_get_mol` | `boltz.data.parse.mmcif.get_mol` | `boltz/data/parse/mmcif.py` | `ccd: str, mols: dict, moldir: str` | `boltz.data.parse.mmcif.get_mol: Retrieve and (if needed) load an RDKit molecule for a given Chemical Component Dictionary (CCD) code and cache it in the provided molecule mapping. This function is used when parsing mmCIF files and assembling ligand definitions for Boltz models (biomolecular interaction and affinity prediction). It first attempts to return an already-cached molecule for the CCD code from the provided mapping. If the molecule is absent, it loads the molecule definition from disk using load_molecules(moldir, [ccd]), inserts the loaded molecule into the provided mapping (mutating it), and then returns the loaded RDKit object. This ensures downstream code that constructs features for ligands (used in Boltz structural and affinity predictions) has a consistent RDKit Mol instance for the CCD entry.` |
| `boltz_data_parse_mmcif_with_constraints_compute_interfaces` | `boltz.data.parse.mmcif_with_constraints.compute_interfaces` | `boltz/data/parse/mmcif_with_constraints.py` | `atom_data: numpy.ndarray, chain_data: numpy.ndarray` | `Compute chain-chain interfaces from a gemmi-derived structure for use in Boltz biomolecular interaction modeling. This function identifies which chains in a structure are in contact by examining atom coordinates and a presence mask produced from a gemmi parsing step. It is used in the Boltz preprocessing pipeline to determine chain-chain interfaces that downstream components use for tasks such as complex assembly, structural scoring, and binding affinity prediction described in the Boltz README. The algorithm assigns each atom to a chain using chain_data["atom_num"], filters to atoms marked present in atom_data["is_present"], builds a KDTree over present atom coordinates (atom_data["coords"]), and flags chain pairs that have any pair of atoms within const.atom_interface_cutoff. The returned interfaces are unique, ordered integer pairs and are suitable for downstream modules that expect an array of chain index pairs.` |
| `boltz_data_parse_mmcif_with_constraints_get_mol` | `boltz.data.parse.mmcif_with_constraints.get_mol` | `boltz/data/parse/mmcif_with_constraints.py` | `ccd: str, mols: dict, moldir: str` | `Get or load an RDKit Mol for a given CCD code, using an in-memory cache or loading from a local molecule directory. This function is used by the mmCIF-with-constraints parser in the Boltz codebase to resolve small-molecule components referenced by CCD (Chemical Component Dictionary) codes into RDKit Mol objects. These Mol objects are the molecule representations used downstream by Boltz for structural modeling and binding-affinity prediction (featurization, geometry handling, and chemistry-aware operations). If the requested CCD code is already present in the provided molecule cache/resource, the cached Mol is returned immediately; otherwise the function loads the molecule definition from files found under moldir, inserts the loaded Mol into the provided cache/resource, and returns it.` |
| `boltz_data_parse_schema_convert_atom_name` | `boltz.data.parse.schema.convert_atom_name` | `boltz/data/parse/schema.py` | `name: str` | `boltz.data.parse.schema.convert_atom_name converts an atom name string into a fixed-length integer encoding used by Boltz parsing and featurization pipelines for biomolecular structures. This canonicalization is used when parsing input YAMLs or PDB-style records to produce a compact, comparable representation of atom names for downstream model inputs, table keys, or embedding lookups in Boltz's biomolecular interaction prediction workflows.` |
| `boltz_data_parse_schema_get_global_alignment_score` | `boltz.data.parse.schema.get_global_alignment_score` | `boltz/data/parse/schema.py` | `query: str, template: str` | `Compute the global pairwise alignment score between a query sequence and a template sequence. This function boltz.data.parse.schema.get_global_alignment_score is used in the Boltz data parsing and template-matching pipeline to quantify overall sequence similarity between two biomolecular sequences (typically protein amino-acid sequences). It constructs a Biopython PairwiseAligner with scoring="blastp" and sets aligner.mode = "global", then returns the score of the top (first) alignment. In the Boltz context this score is useful for template selection, input validation, or any downstream logic that requires a single scalar measure of how well a query sequence matches a template sequence when aligned end-to-end.` |
| `boltz_data_parse_schema_get_local_alignments` | `boltz.data.parse.schema.get_local_alignments` | `boltz/data/parse/schema.py` | `query: str, template: str` | `boltz.data.parse.schema.get_local_alignments: Align a query sequence to a template and return one or more local alignment mappings as Alignment objects. This function is used in the Boltz preprocessing and inference pipeline to map residues between an input sequence (query) and a template sequence for downstream structural modeling and binding-affinity prediction tasks in biomolecular interaction prediction.` |
| `boltz_data_parse_schema_get_mol` | `boltz.data.parse.schema.get_mol` | `boltz/data/parse/schema.py` | `ccd: str, mols: dict, moldir: str` | `Get mol for a chemical component (CCD) code. Look up and return an RDKit molecule corresponding to a chemical component identifier (CCD code). This utility is used by the Boltz pipeline to obtain a ligand or small-molecule representation needed for downstream biomolecular interaction modeling and binding affinity prediction. It first checks an in-memory mapping of already-loaded molecules (mols) and, if absent, invokes load_molecules to load the requested CCD entry from persistent storage (moldir) and returns the loaded molecule for use in structural modeling and affinity calculations.` |
| `boltz_data_parse_schema_standardize` | `boltz.data.parse.schema.standardize` | `boltz/data/parse/schema.py` | `smiles: str` | `boltz.data.parse.schema.standardize standardizes a small-molecule SMILES string for use in the Boltz data and inference pipelines (for example, affinity prediction and structure modeling). It parses the input with RDKit (deferring RDKit sanitization), applies an exclusion check, chooses the largest connected fragment, runs a ChEMBL-style molecule standardization pipeline, and returns a canonicalized SMILES suitable for downstream Boltz preprocessing and prediction.` |
| `boltz_data_tokenize_boltz2_compute_frame` | `boltz.data.tokenize.boltz2.compute_frame` | `boltz/data/tokenize/boltz2.py` | `n: numpy.ndarray, ca: numpy.ndarray, c: numpy.ndarray` | `Compute a right-handed orthonormal local frame for a single amino-acid residue from backbone atom coordinates.` |
| `boltz_data_tokenize_boltz2_get_unk_token` | `boltz.data.tokenize.boltz2.get_unk_token` | `boltz/data/tokenize/boltz2.py` | `chain: numpy.ndarray` | `Get the unk token id for a residue in a single molecular chain. This function selects the appropriate "unknown" residue token id used by the Boltz-2 tokenizer based on the chain's molecular type and returns the integer token id that the model uses to represent an unknown or placeholder residue. It is used during tokenization and preprocessing of input biomolecules for Boltz-2 inference and training (structure and affinity prediction), so that non-standard or missing residues are consistently encoded according to whether the chain is DNA, RNA, or a protein. The selection logic follows the repository constants: if chain["mol_type"] equals const.chain_type_ids["DNA"] the DNA unk token is chosen; if it equals const.chain_type_ids["RNA"] the RNA unk token is chosen; otherwise the protein unk token is chosen.` |
| `boltz_model_layers_relative_compute_relative_distribution_perfect_correlation` | `boltz.model.layers.relative.compute_relative_distribution_perfect_correlation` | `boltz/model/layers/relative.py` | `binned_distribution_1: torch.Tensor, binned_distribution_2: torch.Tensor` | `boltz.model.layers.relative.compute_relative_distribution_perfect_correlation: Compute the distribution of the difference (relative bin index) between two discretized (binned) quantities under the assumption that the two quantities are perfectly correlated. In the Boltz model this routine is used by relative-feature layers to convert two aligned binned representations (for example, discretized distance or score histograms produced per residue or atom) into a single binned distribution over relative offsets; the output can be used downstream for modeling pairwise geometric relationships or relative likelihoods in affinity prediction.` |
| `boltz_model_loss_confidence_confidence_loss` | `boltz.model.loss.confidence.confidence_loss` | `boltz/model/loss/confidence.py` | `model_out: dict, feats: dict, true_coords: torch.Tensor, true_coords_resolved_mask: torch.Tensor, multiplicity: int = 1, alpha_pae: float = 0.0` | `Compute confidence loss for boltz.model.loss.confidence.confidence_loss. This function aggregates multiple confidence-related loss terms used in the Boltz family of biomolecular interaction models (Boltz-1 / Boltz-2) to supervise the model's confidence heads during training. In the Boltz context these heads predict per-atom or per-residue uncertainty and resolution signals that guide structure prediction and downstream affinity estimation. The function calls the specialized sub-losses plddt_loss, pde_loss, resolved_loss and optionally pae_loss, combines them into a single scalar training loss, and returns a structured breakdown of the components for logging and weighting. It expects the model output dictionary to contain logits and sampled coordinates produced by the network; the returned losses are torch.Tensor objects that can be backpropagated.` |
| `boltz_model_loss_confidence_pae_loss` | `boltz.model.loss.confidence.pae_loss` | `boltz/model/loss/confidence.py` | `pred_pae: torch.Tensor, pred_atom_coords: torch.Tensor, true_atom_coords: torch.Tensor, true_coords_resolved_mask: torch.Tensor, feats: dict, multiplicity: int = 1, max_dist: float = 32.0` | `Compute the pairwise aligned error (PAE) classification loss used by Boltz models to supervise the model's confidence in predicted atom coordinates for biomolecular interaction and affinity prediction. This function converts predicted and true Cartesian atom coordinates into per-frame token coordinates, computes the Euclidean errors between predicted and true token coordinates, discretizes those errors into bins, and compares the resulting target bin distribution against the model's predicted PAE logits using a masked negative log-likelihood. The loss is averaged over valid token pairs and across the (possibly grouped) batch and is used during training to teach the model to produce calibrated per-pair confidence estimates (PAE) that are important for downstream structural and binding-affinity predictions in Boltz.` |
| `boltz_model_loss_confidence_pde_loss` | `boltz.model.loss.confidence.pde_loss` | `boltz/model/loss/confidence.py` | `pred_pde: torch.Tensor, pred_atom_coords: torch.Tensor, true_atom_coords: torch.Tensor, true_coords_resolved_mask: torch.Tensor, feats: dict, multiplicity: int = 1, max_dist: float = 32.0` | `Compute the pairwise distance error (PDE) loss used by Boltz models for training predicted atomic coordinates against symmetry-corrected ground-truth coordinates. This function converts per-pair absolute distance errors between predicted and true token-level coordinates into discrete bins, computes a negative log-likelihood loss against provided PDE logits, and averages the result across resolved token pairs and the batch. In the Boltz training pipeline (used for biomolecular interaction and binding-affinity modeling described in the README), this loss encourages predicted atom coordinates to reproduce ground-truth inter-token distances after symmetry correction and is particularly relevant when training diffusion-style generative/denoising components (multiplicity corresponds to diffusion batch replication in the code).` |
| `boltz_model_loss_confidence_plddt_loss` | `boltz.model.loss.confidence.plddt_loss` | `boltz/model/loss/confidence.py` | `pred_lddt: torch.Tensor, pred_atom_coords: torch.Tensor, true_atom_coords: torch.Tensor, true_coords_resolved_mask: torch.Tensor, feats: dict, multiplicity: int = 1` | `boltz.model.loss.confidence.plddt_loss computes the pLDDT (per-residue predicted Local Distance Difference Test) classification loss used in Boltz training to supervise the model's confidence head for structure predictions and downstream biomolecular interaction tasks such as affinity-aware modeling. The function converts predicted atom coordinates and model features into token-level distances, computes target lDDT values using a pairwise distance comparison (via lddt_dist), converts those continuous targets into discrete bins, and returns the negative log-likelihood-style loss (cross-entropy on one-hot binned targets) averaged over resolved tokens and the batch. This loss is used during training to teach the model to predict per-token confidence scores that correlate with true structural accuracy, which is critical for Boltz applications in biomolecular interaction prediction and ligand optimization (see project README for context).` |
| `boltz_model_loss_confidence_resolved_loss` | `boltz.model.loss.confidence.resolved_loss` | `boltz/model/loss/confidence.py` | `pred_resolved: torch.Tensor, feats: dict, true_coords_resolved_mask: torch.Tensor, multiplicity: int = 1` | `Compute the resolved-classification loss used by the Boltz confidence head. This function is part of the Boltz biomolecular interaction model loss suite and is used to supervise a binary "resolved vs not-resolved" prediction for tokens (e.g., ligand/protein tokens) during training or diffusion inference. It combines model logits, a symmetry-corrected ground-truth resolved mask, and token-level padding/mapping features to produce a single scalar loss value averaged over the (possibly repeated) diffusion batch.` |
| `boltz_model_loss_diffusion_smooth_lddt_loss` | `boltz.model.loss.diffusion.smooth_lddt_loss` | `boltz/model/loss/diffusion.py` | `pred_coords: torch.Tensor, true_coords: torch.Tensor, is_nucleotide: torch.Tensor, coords_mask: torch.Tensor, nucleic_acid_cutoff: float = 30.0, other_cutoff: float = 15.0, multiplicity: int = 1` | `Compute a smooth lDDT-style loss between predicted and ground-truth atom coordinates for biomolecular structures, with separate distance cutoffs for nucleic acids versus other molecules and optional batch multiplicity handling. This function is used in Boltz diffusion loss computations to quantify local distance agreement (a smooth proxy of lDDT) between predicted and true pairwise atom distances, weighting only atom pairs within type-dependent distance cutoffs and using a smooth set of sigmoid thresholds (0.5, 1.0, 2.0, 4.0 √Ö) to produce a soft correctness score. The final scalar loss returned is 1.0 minus the mean per-sample lDDT score and is suitable for use as a training objective in biomolecular interaction and structure modeling (e.g., protein‚Äìligand, protein‚Äìnucleic acid complexes) as in the Boltz model pipeline.` |
| `boltz_model_loss_diffusion_weighted_rigid_align` | `boltz.model.loss.diffusion.weighted_rigid_align` | `boltz/model/loss/diffusion.py` | `true_coords: torch.Tensor, pred_coords: torch.Tensor, weights: torch.Tensor, mask: torch.Tensor` | `Compute a weighted rigid alignment of predicted atom coordinates to ground-truth atom coordinates for use in Boltz diffusion loss and structural comparison. This function computes a rotation and translation that best aligns the ground-truth point cloud (true_coords) to the predicted point cloud (pred_coords) under per-atom weighting and an atom mask. It is used in the Boltz biomolecular modeling pipeline to remove global rigid-body differences (rotation + translation) before computing coordinate-based losses or RMSD-like metrics during training and inference for protein/ligand structural modeling and affinity prediction. The algorithm computes weighted centroids, centers coordinates, forms a weighted cross-covariance matrix, computes its SVD (performed in float32 internally), corrects the SVD to produce a proper rotation (determinant = 1), applies the rotation and translation, and returns the aligned ground-truth coordinates in the prediction frame. Side effects: the returned tensor is detached from the autograd graph (aligned_coords.detach_()) and the function may print warnings for degenerate/low-rank point clouds. The function does not modify the provided input tensors.` |
| `boltz_model_loss_diffusionv2_smooth_lddt_loss` | `boltz.model.loss.diffusionv2.smooth_lddt_loss` | `boltz/model/loss/diffusionv2.py` | `pred_coords: torch.Tensor, true_coords: torch.Tensor, is_nucleotide: torch.Tensor, coords_mask: torch.Tensor, nucleic_acid_cutoff: float = 30.0, other_cutoff: float = 15.0, multiplicity: int = 1` | `smooth_lddt_loss computes a differentiable/local lDDT-style distance-based loss used during diffusion-based structure modeling in Boltz (diffusionv2). It implements "Algorithm 27" from the codebase and compares predicted and true 3D coordinates of biomolecular atoms/residues by computing per-sample local distance agreement (a smoothed lDDT-like score) over selected inter-particle pairs, then returning 1 minus the mean lDDT (so that perfect agreement yields loss 0). This loss is used in Boltz training and inference to penalize deviations in local pairwise distances between predicted structures and ground-truth structures, with different distance cutoffs applied for nucleic-acid pairs versus other pairs.` |
| `boltz_model_loss_diffusionv2_weighted_rigid_align` | `boltz.model.loss.diffusionv2.weighted_rigid_align` | `boltz/model/loss/diffusionv2.py` | `true_coords: torch.Tensor, pred_coords: torch.Tensor, weights: torch.Tensor, mask: torch.Tensor` | `boltz.model.loss.diffusionv2.weighted_rigid_align computes a weighted rigid-body alignment (rotation and translation) that maps true_coords onto pred_coords by minimizing the weighted squared error between corresponding points. This function is used in the Boltz model loss pipeline (diffusionv2) to align ground-truth atomic coordinates to model-predicted coordinates before computing structural losses (e.g., RMSD or per-atom losses) during training or evaluation of biomolecular interaction and binding-affinity models such as Boltz-1/Boltz-2. The implementation follows the corrected interpretation of Algorithm 28 / equation (2) in the accompanying paper (the paper's Algorithm 28 pseudocode swaps predicted and ground-truth in the printed pseudocode; this function uses the ordering consistent with equation (2)). The algorithm computes weighted centroids, a weighted covariance matrix, performs an SVD (in float32 for numerical stability), enforces a proper rotation (determinant = +1) to resolve reflection ambiguity, and applies the rigid transform to true_coords. The function prints warnings when the alignment is underdetermined or when the covariance is numerically rank-deficient; it casts to float32 internally for SVD and returns a tensor with the same numeric dtype as the input covariance where practical.` |
| `boltz_model_loss_validation_compute_pae_mae` | `boltz.model.loss.validation.compute_pae_mae` | `boltz/model/loss/validation.py` | `pred_atom_coords: torch.Tensor, feats: torch.Tensor, true_atom_coords: torch.Tensor, pred_pae: torch.Tensor, true_coords_resolved_mask: torch.Tensor, multiplicity: int = 1` | `Compute the pae mean absolute error for different interaction modalities in biomolecular complexes. This function is used in the Boltz model evaluation and training/validation pipelines to quantify how well the model's predicted pairwise aligned error (pred_pae) matches the geometric error derived from predicted and ground-truth atom coordinates. It converts atom coordinates into local frames (per the model's frame indices in feats), computes a continuous inter-token distance error in those frames, discretizes that continuous error into the same binning used by the model's pae prediction head, and then computes mean absolute error (MAE) per interaction modality (e.g., dna_protein, ligand_protein, intra_protein, etc.). The modality-specific MAEs are useful for benchmarking structural prediction quality on cross-molecular interfaces and intra-chain structure, which in turn is relevant for downstream tasks in biomolecular interaction prediction and binding affinity modeling described in the repository README (e.g., assessing complex structure quality used for affinity prediction).` |
| `boltz_model_loss_validation_compute_pde_mae` | `boltz.model.loss.validation.compute_pde_mae` | `boltz/model/loss/validation.py` | `pred_atom_coords: torch.Tensor, feats: torch.Tensor, true_atom_coords: torch.Tensor, pred_pde: torch.Tensor, true_coords_resolved_mask: torch.Tensor, multiplicity: int = 1` | `Compute the pde (pairwise distance error) mean absolute error (MAE) across specific biomolecular modality pairs.` |
| `boltz_model_loss_validation_compute_plddt_mae` | `boltz.model.loss.validation.compute_plddt_mae` | `boltz/model/loss/validation.py` | `pred_atom_coords: torch.Tensor, feats: torch.Tensor, true_atom_coords: torch.Tensor, pred_lddt: torch.Tensor, true_coords_resolved_mask: torch.Tensor, multiplicity: int = 1` | `Compute the pLDDT mean absolute error (MAE) per biomolecular modality (protein, ligand/nonpolymer, DNA, RNA).` |
| `boltz_model_loss_validation_factored_lddt_loss` | `boltz.model.loss.validation.factored_lddt_loss` | `boltz/model/loss/validation.py` | `true_atom_coords: torch.Tensor, pred_atom_coords: torch.Tensor, feats: dict, atom_mask: torch.Tensor, multiplicity: int = 1, cardinality_weighted: bool = False` | `Compute the local distance difference test (lddt) aggregated by molecular modality and pair-type masks. This function is used by Boltz training and validation pipelines to evaluate structural accuracy of predicted 3D atom coordinates in a modality-aware manner. It factorizes lddt into biologically relevant interaction classes (for example protein‚Äìligand, DNA‚Äìprotein, intra-protein, etc.) so that downstream loss weighting, monitoring, or metric reporting can distinguish performance on different biomolecular modalities. Internally it derives atom types and chain identifiers from the provided feature dictionary, builds pairwise masks (excluding self-pairs), computes pairwise distances with torch.cdist, applies a modality-dependent distance cutoff, and calls lddt_dist to compute per-modality lddt scores and per-modality pair counts or indicators.` |
| `boltz_model_loss_validation_factored_token_lddt_dist_loss` | `boltz.model.loss.validation.factored_token_lddt_dist_loss` | `boltz/model/loss/validation.py` | `true_d: torch.Tensor, pred_d: torch.Tensor, feats: dict, cardinality_weighted: bool = False` | `Compute per-modality LDDT (local distance difference test) scores by comparing a predicted atom distogram to the ground-truth distogram, factoring the score into biologically relevant token-pair modalities (e.g., DNA‚Äìprotein, RNA‚Äìprotein, ligand‚Äìprotein, intra-chain protein). This function is used in Boltz model validation to report how well the model predicts inter-atomic distance distributions for different molecule-type interactions and to produce modality-level pair counts (or presence flags) used for weighting or aggregation in downstream loss and evaluation pipelines.` |
| `boltz_model_loss_validation_weighted_minimum_rmsd` | `boltz.model.loss.validation.weighted_minimum_rmsd` | `boltz/model/loss/validation.py` | `pred_atom_coords: torch.Tensor, feats: torch.Tensor, multiplicity: int = 1, nucleotide_weight: float = 5.0, ligand_weight: float = 10.0` | `Compute weighted root-mean-square deviation (RMSD) between predicted atom coordinates and ground-truth coordinates after a rigid alignment, with optional per-atom weighting that emphasizes nucleotides and nonpolymeric ligands. This function is used in Boltz model validation and loss evaluation to quantify structural accuracy of biomolecular predictions (for example protein‚Äìligand or protein‚Äìnucleic acid complexes) and to select the best RMSD across multiple diffusion samples (multiplicity). The rigid alignment of ground-truth coordinates to predictions is performed with weighted_rigid_align inside a no-grad block so that the alignment step does not create gradient paths; the RMSD values are computed from the aligned ground truth and the predictions and can be used for evaluation and monitoring during inference or training validation.` |
| `boltz_model_loss_validation_weighted_minimum_rmsd_single` | `boltz.model.loss.validation.weighted_minimum_rmsd_single` | `boltz/model/loss/validation.py` | `pred_atom_coords: torch.Tensor, atom_coords: torch.Tensor, atom_mask: torch.Tensor, atom_to_token: torch.Tensor, mol_type: torch.Tensor, nucleotide_weight: float = 5.0, ligand_weight: float = 10.0` | `Compute a weighted minimum RMSD between predicted and ground-truth atom coordinates after performing a rigid alignment of the ground-truth coordinates to the predictions. This function is used in the Boltz codebase for validation and loss computation of biomolecular structural predictions. It computes per-sample root-mean-square-deviation (RMSD) where atoms are weighted according to their macromolecular role (standard chain, nucleotide, or nonpolymer/ligand). The weighting increases the contribution of nucleotides and ligands using the nucleotide_weight and ligand_weight scalars, which makes the metric more sensitive to errors on those atom classes; this behavior is important in Boltz models that jointly model complex structures and binding affinities, where ligands and nucleic acids often require higher fidelity. The ground-truth coordinates are rigidly aligned to the predictions using weighted_rigid_align (called under torch.no_grad()), then a weighted RMSD is computed using atom_mask to ignore unresolved/missing atoms.` |
| `boltz_model_modules_confidence_utils_compute_aggregated_metric` | `boltz.model.modules.confidence_utils.compute_aggregated_metric` | `boltz/model/modules/confidence_utils.py` | `logits: torch.Tensor, end: float = 1.0` | `Compute an aggregated scalar metric (plddt-like confidence) from histogram logits. This function is used in the Boltz codepath that transforms a discrete histogram prediction (logits over bins) into a single continuous confidence score per element (for example, a per-residue predicted local distance difference test score, pLDDT-like, used in Boltz structural predictions). It converts logits over num_bins into probabilities with a softmax over the last dimension, constructs bin center values evenly spaced from half a bin to the provided maximum value `end`, and returns the probability-weighted sum of those centers. The computation preserves device placement (bounds are created on logits.device) and is differentiable with respect to the input logits, so it can be used in training or inference pipelines that require gradients.` |
| `boltz_model_modules_confidence_utils_compute_ptms` | `boltz.model.modules.confidence_utils.compute_ptms` | `boltz/model/modules/confidence_utils.py` | `logits: torch.Tensor, x_preds: torch.Tensor, feats: dict, multiplicity: int` | `Compute pTM and ipTM confidence scores from pairwise PAE logits and predicted coordinates.` |
| `boltz_model_modules_confidence_utils_tm_function` | `boltz.model.modules.confidence_utils.tm_function` | `boltz/model/modules/confidence_utils.py` | `d: torch.Tensor, Nres: torch.Tensor` | `Compute the rescaling function used for pTM confidence scoring in Boltz. This function implements the rescaling step used by Boltz confidence modules to convert raw distance-like inputs into a bounded rescaling factor for the pTM (predicted TM-score) computation. In the Boltz model family for biomolecular interaction and structure prediction, pTM is used as a confidence metric for predicted protein/complex structures; this function provides the elementwise rescaling 1 / (1 + (d / d0)^2) where d0 is a length-dependent reference distance derived from the number of residues. The implementation follows the formula in the source code: d0 = 1.24 * (torch.clip(Nres, min=19) - 15) ** (1 / 3) - 1.8` |
| `boltz_model_modules_utils_center_random_augmentation` | `boltz.model.modules.utils.center_random_augmentation` | `boltz/model/modules/utils.py` | `atom_coords: torch.Tensor, atom_mask: torch.Tensor, s_trans: float = 1.0, augmentation: bool = True, centering: bool = True, return_second_coords: bool = False, second_coords: torch.Tensor = None` | `center_random_augmentation centers and optionally applies randomized rigid-body augmentations to batched atomic coordinate tensors used by Boltz models for biomolecular interaction prediction. This function implements the preprocessing described as "Algorithm 19" in the codebase: it can subtract a per-sample mean coordinate (centering), apply a shared random rotation to all atoms (via randomly_rotate), and add a per-sample random translation sampled from a normal distribution scaled by s_trans. These transforms are commonly used before feeding coordinates into structure/affinity prediction networks in the Boltz family to remove absolute position dependence and to provide data augmentation that improves generalization.` |

## ‚öñÔ∏è License

Original Code License: MIT

Wrapper Code & Documentation: Apache-2.0

*This file was automatically generated on February 26, 2026.*
