# pybel

[üîô Back to Main Repo](../../../README.md) | [üîó Original Repo](https://github.com/pybel/pybel)

![Tool Count](https://img.shields.io/badge/Agent_Tools-46-blue?style=flat-square)
![Category](https://img.shields.io/badge/Category-Biology-green?style=flat-square)
![Status](https://img.shields.io/badge/Import_Test-Passed-success?style=flat-square)

## üìñ Overview

PyBEL is a pure-Python library for parsing, constructing, and exchanging biological networks encoded in Biological Expression Language (BEL), with import/export support for common graph formats, databases, and network analysis tools.

> **Note**: This documentation lists the **agent-ready wrapper functions** generated for this package. These functions have been strictly typed, docstring-enhanced, and tested for import stability within a standardized Apptainer environment.

## üõ†Ô∏è Available Agent Tools

Below is the list of **46** functions optimized for LLM tool-use.

| **Tool Name (Wrapper)**   | **Source**          | **File Path**     | **Arguments (Type)**        | **Description**                |
| ------------------------- | ------------------- | ----------------- | --------------------------- | ------------------------------ |
| `pybel_canonicalize_postpend_location` | `pybel.canonicalize.postpend_location` | `pybel/canonicalize.py` | `bel_string: str, location_model: dict` | `Append a canonicalized BEL location clause to an existing BEL node string.` |
| `pybel_io_biodati_client_from_biodati` | `pybel.io.biodati_client.from_biodati` | `pybel/io/biodati_client.py` | `network_id: str, username: str = "demo@biodati.com", password: str = "demo", base_url: str = "https://networkstore.demo.biodati.com"` | `pybel.io.biodati_client.from_biodati: Download and return a BELGraph from a BioDati network store given its network identifier. This function connects to a BioDati "network store" web service, authenticates with the provided credentials, requests the network identified by network_id, and returns it as a pybel.struct.graph.BELGraph. In the PyBEL ecosystem, this is used to import networks that were stored or published via BioDati Studio/Network Store so they can be analyzed, summarized, serialized, or exported using PyBEL tooling (for example, graph.summarize(), pybel.dump(...), or exports to CX/GraphDati/NDEx). The function performs network I/O and authentication as a side effect and relies on the BiodatiClient implementation to transform the remote network representation into a BELGraph instance.` |
| `pybel_io_cx_from_cx` | `pybel.io.cx.from_cx` | `pybel/io/cx.py` | `cx: List[Dict]` | `pybel.io.cx.from_cx: Rebuild a BELGraph from CX JSON output produced by PyBEL. Reconstructs a pybel.struct.graph.BELGraph from a CX-format JSON object (the CX export produced by PyBEL/NDEx-compatible pipelines). This function is used in I/O and interchange workflows described in the project README to import a previously exported BEL graph (nodes, edges, annotations, citations, network metadata, namespaces, and annotation lists) back into an in-memory BELGraph data structure for further analysis, validation, modification, or re-export to other formats (for example: NetworkX, Node-Link JSON, GraphDati, INDRA, or NDEx). The function iterates the CX list-of-dictionaries and reconstructs internal aspects (context_legend, annotation_lists, @context entries, networkAttributes, nodes, nodeAttributes, edges, edgeAttributes, and meta entries). It restores node-level constructs (including fusion and variant encodings, products/reactants and members lists), maps CX node name attributes to the BEL node NAME field, parses node data into PyBEL DSL node representations via parse_result_to_dsl, adds nodes to the BELGraph with add_node_from_data, reconstructs edge relations and per-edge qualified data (evidence, citation, source/target modifiers, annotations), converts annotation lists to sets, expands serialized dicts where necessary, and finally adds edges to the graph using add_qualified_edge or add_unqualified_edge.` |
| `pybel_io_cx_from_cx_gz` | `pybel.io.cx.from_cx_gz` | `pybel/io/cx.py` | `path: str` | `pybel.io.cx.from_cx_gz reads a BELGraph from a CX JSON file compressed with gzip and returns the in-memory PyBEL BELGraph representation. This function is part of PyBEL's I/O utilities for interoperability between CX (the Cytoscape/NDEx JSON data model) and PyBEL's BELGraph. It opens the given filesystem path in gzip text mode, decodes the CX JSON content using the standard json loader, and delegates parsing and conversion to pybel.io.cx.from_cx to produce a BELGraph. Practically, use this to import networks exported in CX/NDEx formats into PyBEL for downstream analysis, visualization, or serialization to other formats supported by PyBEL.` |
| `pybel_io_cx_from_cx_jsons` | `pybel.io.cx.from_cx_jsons` | `pybel/io/cx.py` | `graph_json_str: str` | `pybel.io.cx.from_cx_jsons reads a BELGraph from a CX-format JSON string and returns a populated BELGraph suitable for PyBEL workflows.` |
| `pybel_io_gpickle_from_pickle_gz` | `pybel.io.gpickle.from_pickle_gz` | `pybel/io/gpickle.py` | `path: str` | `pybel.io.gpickle.from_pickle_gz reads a BELGraph from a gzipped pickle file and returns the in-memory BELGraph object for downstream biological-network analysis and format interchange.` |
| `pybel_io_graphdati_from_graphdati` | `pybel.io.graphdati.from_graphdati` | `pybel/io/graphdati.py` | `j: dict, use_tqdm: bool = True` | `Convert a GraphDati / BioDati "normal" network JSON dictionary into a compiled PyBEL BELGraph. This function ingests a GraphDati-style JSON object (as produced by BioDati / GraphDati exports in the repository described by the README) and constructs a PyBEL BELGraph by parsing BEL statements embedded in the edges and attaching the per-statement metadata (citations, nanopub ids, annotations) to the resulting graph. It expects the input to follow the "normal" network format produced by BioDati/GraphDati; requesting the BioDati "full" network format is known to crash BioDati and therefore is not supported by this converter. The function populates top-level graph metadata (name, version, authors, description), records the originating BioDati network id on the graph (graph.graph["biodati_network_id"]), and parses each edge label as a BEL statement with the BELParser configured with NAMESPACE_TO_PATTERN. For every metadata entry attached to an edge (each nanopub_data entry) the function clears and reuses parser.control_parser, sets citation fields parsed from the GraphDati CURIE, attaches a default evidence string ("No evidence available from BioDai"), stores the BioDati nanopub id under the annotation key "biodati_nanopub_id", and merges any other parsed annotations before parsing the BEL statement. Because each BEL statement is parsed once per metadata entry, the same BEL statement may be added multiple times with different metadata sets (intentional to preserve nanopub-level provenance).` |
| `pybel_io_graphdati_from_graphdati_gz` | `pybel.io.graphdati.from_graphdati_gz` | `pybel/io/graphdati.py` | `path: str` | `pybel.io.graphdati.from_graphdati_gz reads a GraphDati JSON graph from a gzip-compressed file and converts it into a pybel.struct.graph.BELGraph for use with PyBEL's analysis, export, and visualization tools. This function is used in the PyBEL I/O subsystem to import networks produced or exported in the GraphDati (BioDati) JSON format into PyBEL's native BELGraph representation. It opens the given gzip-compressed file in text mode, decodes the contained JSON document with the standard json loader, and then delegates construction of the BELGraph to the from_graphdati parser, which expects the JSON to follow the GraphDati schema referenced by the GraphDati project.` |
| `pybel_io_graphdati_from_graphdati_jsons` | `pybel.io.graphdati.from_graphdati_jsons` | `pybel/io/graphdati.py` | `s: str` | `pybel.io.graphdati.from_graphdati_jsons: Load a BELGraph from a GraphDati JSON string and convert it into PyBEL's BELGraph data structure used for biological networks.` |
| `pybel_io_hetionet_hetionet_from_hetionet_gz` | `pybel.io.hetionet.hetionet.from_hetionet_gz` | `pybel/io/hetionet/hetionet.py` | `path: str` | `pybel.io.hetionet.hetionet.from_hetionet_gz retrieves a Hetionet-formatted JSON file from disk, decompresses it, parses it into PyBEL's BELGraph data structure, and returns that graph for downstream biological-network analysis and format interchange. In the PyBEL domain, this function is used to import Hetionet (a consolidated biomedical knowledge network) into a BELGraph so it can be validated, summarized, serialized to other formats (NetworkX, CX, GraphML, INDRA, etc.), grounded against controlled vocabularies, and used by analytical tools and pipelines described in the PyBEL README.` |
| `pybel_io_hipathia_from_hipathia_paths` | `pybel.io.hipathia.from_hipathia_paths` | `pybel/io/hipathia.py` | `name: str, att_path: str, sif_path: str` | `Get a BEL graph from HiPathia-formatted files. This function is a convenience loader that reads two HiPathia files from disk and converts them into a PyBEL BELGraph for downstream network analysis and export. In the PyBEL ecosystem, HiPathia files (a .att attribute table and a .sif simple interaction file) are commonly used to represent pathway topology and accompanying node/edge attributes produced by the HiPathia tool for pathway-based analysis. This function uses pandas to parse those files and then delegates construction and validation of the BELGraph to from_hipathia_dfs, allowing users to interoperate HiPathia outputs with PyBEL workflows (for example, to summarize, serialize, or export graphs to other formats supported by PyBEL).` |
| `pybel_io_hipathia_group_delimited_list` | `pybel.io.hipathia.group_delimited_list` | `pybel/io/hipathia.py` | `entries: List[str], sep: str = "/"` | `pybel.io.hipathia.group_delimited_list groups a flat sequence of string entries into ordered sublists by treating a particular string token as a delimiter. This function is used in the HiPathia I/O codepath of PyBEL (pybel.io.hipathia) to convert flat, serialized lists (for example, path components, segment lists, or other exported string sequences) into the grouped list-of-lists structure expected by downstream HiPathia exporters and analytic consumers. The implementation partitions the input by contiguous runs of elements that are not equal to the delimiter token sep using itertools.groupby. Delimiter elements (entries exactly equal to sep) are treated as boundaries and are omitted from the output groups; only the non-delimiter runs are returned, in the original order.` |
| `pybel_io_jgif_from_cbn_jgif` | `pybel.io.jgif.from_cbn_jgif` | `pybel/io/jgif.py` | `graph_jgif_dict: dict` | `pybel.io.jgif.from_cbn_jgif builds a PyBEL BELGraph from a JGIF JSON object produced by the Causal Biological Network (CBN) Database by mapping CBN-specific JGIF fields to the standard JGIF namespace and annotation URLs and then delegating graph construction to pybel.from_jgif. This function is used when integrating networks distributed by the CBN Database into PyBEL workflows described in the project README: it converts the CBN JGIF representation (a JSON graph format used by the Causal Biological Network Database) into a BELGraph suitable for downstream analysis, visualization, export, and interchange with tools that PyBEL supports (for example, NetworkX, Node-Link JSON, CX/NDEx, and others). The implementation first calls map_cbn to translate CBN-specific naming/structure, then inserts the constants GRAPH_NAMESPACE_URL and GRAPH_ANNOTATION_URL with NAMESPACE_URLS and ANNOTATION_URLS into the graph's top-level "graph" object, updates graph["metadata"] with METADATA_AUTHORS, METADATA_LICENSES, and METADATA_CONTACT, and finally calls pybel.from_jgif to produce the BELGraph.` |
| `pybel_io_jgif_from_jgif_gz` | `pybel.io.jgif.from_jgif_gz` | `pybel/io/jgif.py` | `path: str` | `pybel.io.jgif.from_jgif_gz reads a JGIF (JSON Graph) representation of a BEL graph from a gzip-compressed file and reconstructs it as a PyBEL BELGraph. This is a convenience wrapper used in the PyBEL I/O suite to load graphs exported in the JGIF/JSON Graph specification (for example, exports intended for network viewers or interchange) that have been compressed with gzip. The function opens the file in text mode, parses the contained JSON using the standard json library, and delegates to pybel.io.jgif.from_jgif to convert the JSON object into a pybel.struct.graph.BELGraph. The resulting BELGraph is PyBEL's in-memory representation of a Biological Expression Language (BEL) network and contains nodes (biological entities such as Proteins, Complexes, Abundances), edges (BEL relations), namespaces, annotations, citations, and other metadata that downstream PyBEL tools and exports expect.` |
| `pybel_io_jgif_from_jgif_jsons` | `pybel.io.jgif.from_jgif_jsons` | `pybel/io/jgif.py` | `graph_json_str: str` | `pybel.io.jgif.from_jgif_jsons reads a BELGraph from a JGIF-format JSON string. This function is part of PyBEL's I/O utilities for interoperability between BEL graphs and JSON-based network formats. It accepts a string containing a JSON document that conforms to the JGIF (JSON Graph Interchange Format) representation of a BEL graph and returns a pybel.struct.graph.BELGraph, the in-memory PyBEL representation used throughout PyBEL for storing biological networks encoded in the Biological Expression Language (BEL). Internally, the function decodes the JSON string with the standard library json.loads and delegates the construction of the BELGraph to pybel.io.jgif.from_jgif, enabling downstream analysis, serialization to other formats (for example Node-Link JSON, GraphML, CX), visualization in tools like Cytoscape, or further PyBEL processing such as grounding and summarization.` |
| `pybel_io_jgif_map_cbn` | `pybel.io.jgif.map_cbn` | `pybel/io/jgif.py` | `d: dict` | `pybel.io.jgif.map_cbn pre-processes a JGIF (JSON Graph Interchange Format) document produced by the CBN to normalize experimental-context evidence attached to edges so the data can be more reliably consumed by PyBEL I/O pipelines. In the biological-network domain (PyBEL), this function standardizes per-evidence annotation keys (for example mapping "species_common_name" to a canonical "Species" value via a species_map and remapping other keys via annotation_map), strips surrounding whitespace from keys and values, drops empty/placeholder values, and replaces each evidence's EXPERIMENT_CONTEXT mapping with the cleaned, standardized mapping.` |
| `pybel_io_jinja_utils_build_template_environment` | `pybel.io.jinja_utils.build_template_environment` | `pybel/io/jinja_utils.py` | `here: str` | `Build and return a preconfigured jinja2.Environment for use by Flask apps and Jupyter displays in PyBEL. This function constructs a Jinja2 templating environment that is configured to load templates from a "templates" subdirectory located under the provided base directory and to expose a STATIC_PREFIX global that points to a "static" subpath. In the PyBEL codebase this environment is used when rendering BEL graph views in Jupyter and when serving templates from Flask-based applications so that templates and static assets (CSS/JS/images) can be located relative to a module's file system location. The returned Environment is created with autoescape=True and trim_blocks=False and uses a FileSystemLoader rooted at os.path.join(here, "templates").` |
| `pybel_io_jinja_utils_build_template_renderer` | `pybel.io.jinja_utils.build_template_renderer` | `pybel/io/jinja_utils.py` | `path: str` | `Build a render-template function that locates Jinja2 templates relative to a module file and returns a closure for rendering them.` |
| `pybel_io_lines_from_bel_script_gz` | `pybel.io.lines.from_bel_script_gz` | `pybel/io/lines.py` | `path: str, **kwargs` | `pybel.io.lines.from_bel_script_gz parses a gzipped BEL Script file and returns a compiled BELGraph. This function is used in the PyBEL I/O pipeline to read BEL documents that have been compressed with gzip (commonly carrying the .bel.gz extension) and to convert the textual BEL statements into a BELGraph, PyBEL's in-memory representation of a biological network encoded in the Biological Expression Language (BEL). It opens the file at the given filesystem path in text mode (gzip.open(..., "rt")), decodes the text, and delegates parsing and graph construction to pybel.io.lines.from_bel_script, forwarding any keyword arguments. The resulting BELGraph can then be used with PyBEL features (serialization, analysis, grounding, exports to formats like CX/GraphML/Node-Link JSON, and downstream tools described in the README).` |
| `pybel_io_nodelink_from_nodelink_gz` | `pybel.io.nodelink.from_nodelink_gz` | `pybel/io/nodelink.py` | `path: str` | `Read a BEL graph encoded as Node-Link JSON from a gzip-compressed file and convert it to a BELGraph. This function is used in the PyBEL I/O pipeline to load graphs that were exported in the Node-Link JSON representation (a JSON format compatible with NetworkX/JGIF and used by PyBEL for interchange with viewers and other tools) and compressed with gzip. It opens the given filesystem path in text mode, decodes and parses the JSON payload, and delegates to pybel.io.nodelink.from_nodelink to construct and return a pybel.struct.graph.BELGraph. The resulting BELGraph represents a biological network in BEL and can be used with PyBEL functionality such as grounding, summarization, serialization to other formats (GraphML, CX, INDRA JSON), and analysis.` |
| `pybel_io_nodelink_from_nodelink_jsons` | `pybel.io.nodelink.from_nodelink_jsons` | `pybel/io/nodelink.py` | `graph_json_str: str, check_version: bool = True` | `pybel.io.nodelink.from_nodelink_jsons reads a BEL graph encoded as a Node-Link JSON string and returns a compiled BELGraph usable by PyBEL for analysis, summarization, grounding, and format interconversion.` |
| `pybel_io_pykeen_get_triples_from_bel` | `pybel.io.pykeen.get_triples_from_bel` | `pybel/io/pykeen.py` | `path: str` | `Get triples from a BEL Script file and return them as a NumPy array suitable for downstream knowledge-graph workflows (for example, PyKEEN training). This function is a thin wrapper that parses a BEL Script using pybel.from_bel_script and then extracts subject-relation-object triples by delegating to the internal _from_bel helper which calls pybel.io.tsv.api.get_triples. It is intended to convert BEL statements (BEL 1.0 and BEL 2.0+) into a standardized three-column representation (head, relation, tail) for interchange and machine-learning pipelines.` |
| `pybel_io_pykeen_get_triples_from_bel_commons` | `pybel.io.pykeen.get_triples_from_bel_commons` | `pybel/io/pykeen.py` | `network_id: str` | `pybel.io.pykeen.get_triples_from_bel_commons loads a BEL document from BEL Commons and returns its statement triples as a 2-D numpy array suitable for downstream conversion or analysis. This function is a convenience wrapper that converts the given network identifier to a string, invokes the internal BEL Commons loader, and returns the extracted triples in a compact tabular form. In the PyBEL ecosystem (see README), BEL Commons is a web service that hosts BEL networks; this function fetches a BEL document for the specified network and extracts head-relation-tail triples that can be used to compile a BELGraph, export to other formats, or feed downstream tools such as machine-learning pipelines (for example PyKEEN) or graph exporters.` |
| `pybel_io_pykeen_get_triples_from_bel_nodelink` | `pybel.io.pykeen.get_triples_from_bel_nodelink` | `pybel/io/pykeen.py` | `path: str` | `Get triples from a BEL Node-Link JSON file and return them as a NumPy array suitable for downstream consumption (for example, by machine-learning tools such as PyKEEN). This function is a thin wrapper that delegates parsing to the internal BEL loader and to the TSV triple extraction implementation used by PyBEL. It is intended to be used when a BEL graph has been serialized in the Node-Link JSON format and you need a flat list of subject‚Äìpredicate‚Äìobject triples for export, analysis, or input to embedding/training pipelines.` |
| `pybel_io_pykeen_get_triples_from_bel_pickle` | `pybel.io.pykeen.get_triples_from_bel_pickle` | `pybel/io/pykeen.py` | `path: str` | `pybel.io.pykeen.get_triples_from_bel_pickle: Load triples from a BEL pickle file and return them as a NumPy array of (head, relation, tail) rows suitable for downstream consumers such as PyKEEN and other knowledge-graph tooling.` |
| `pybel_io_sbel_from_sbel_gz` | `pybel.io.sbel.from_sbel_gz` | `pybel/io/sbel.py` | `path: str` | `pybel.io.sbel.from_sbel_gz reads a BEL JSONL graph from a gzip-compressed file and returns a pybel.struct.graph.BELGraph. This function opens the file at the given filesystem path using Python's gzip.open in text mode ("rt") and delegates parsing to from_sbel_file(file). The input file is expected to be a gzip-compressed newline-delimited JSON (JSONL) representation of a BEL graph (SBEL/JSONL), where each line encodes a BEL statement or SBEL record. The returned object is a PyBEL BELGraph, the primary in-memory representation of a Biological Expression Language (BEL) network used throughout the PyBEL ecosystem for analysis, serialization, and export to formats and services described in the project README (for example NetworkX/Node-Link JSON, CX/NDEx, GraphML/Cytoscape, INDRA, and others). Behavior and side effects: This function performs I/O by opening and reading the gzip file and will close the file before returning. It relies on from_sbel_file to parse the text stream into a BELGraph; therefore parsing behavior, validation, and any warnings or errors follow from that parser's implementation. The gzip file is opened in text mode using Python's default text encoding and newline handling unless the environment or Python defaults are changed. Memory usage and performance depend on the size of the file and the implementation details of from_sbel_file (e.g., whether it streams or accumulates content). Failure modes and exceptions: The call may raise file-related exceptions (for example FileNotFoundError, OSError) if the path does not exist or is not accessible, gzip.BadGzipFile (or other gzip-related errors) if the file is not a valid gzip archive, and parsing errors propagated from from_sbel_file if the JSONL content is malformed or violates expected SBEL structure. Callers should handle these exceptions as appropriate for their application.` |
| `pybel_manager_cache_manager_not_resource_cachable` | `pybel.manager.cache_manager.not_resource_cachable` | `pybel/manager/cache_manager.py` | `bel_resource: dict` | `Check if a BEL resource entry should not be cached. This function inspects the dictionary metadata for a BEL resource (as returned by get_bel_resource) and determines whether the resource is considered non-cacheable. Within the PyBEL project this is used by the cache manager to decide whether to persist a downloaded or generated resource to the local cache or other storage. The function expects the resource dictionary to contain a "Processing" mapping with an optional "CacheableFlag" string value. The function treats the resource as cacheable only when the "CacheableFlag" exactly equals one of the case-sensitive strings: "yes", "Yes", "True", or "true". Any other value, including a missing "CacheableFlag" or None, is interpreted as non-cacheable.` |
| `pybel_manager_citation_utils_sanitize_date` | `pybel.manager.citation_utils.sanitize_date` | `pybel/manager/citation_utils.py` | `publication_date: str` | `Sanitize a variety of free-form publication date strings into an ISO-8601 date string (YYYY-MM-DD) for use in citation metadata and BEL graph versioning within PyBEL. This function is used by PyBEL's citation utilities (pybel.manager.citation_utils) to convert heterogeneous date representations found in BEL documents, external data sources, or citation records into a consistent ISO-8601 format required for downstream storage, comparison, and display (for example, in graph summaries, exports, and database fields).` |
| `pybel_manager_utils_extract_shared_optional` | `pybel.manager.utils.extract_shared_optional` | `pybel/manager/utils.py` | `bel_resource: dict, definition_header: str = "Namespace"` | `Extract the optional annotations that are shared between BEL namespace documents and BEL annotation resource documents. This function inspects a BEL resource configuration dictionary (for example, a parsed Namespace or AnnotationDefinition document used by PyBEL to describe controlled vocabularies and annotation metadata) and returns a new dictionary containing a canonical set of optional metadata fields that are common to both namespace and annotation resources. It applies a fixed mapping (shared_mapping) from canonical keys used by PyBEL (such as "description", "version", "author", "license", "contact", "citation", etc.) to the locations and element names expected inside a BEL resource document. The function writes values into a fresh result dictionary using update_insert_values and, if the resource contains a Citation.PublishedDate, converts that string into a datetime via parse_datetime and stores it under the key "citation_published". The returned mapping is intended for use by PyBEL components that assemble resource metadata (for example, when loading namespaces or annotations to ground BEL graphs or to include descriptive metadata in BELGraph exports).` |
| `pybel_manager_utils_extract_shared_required` | `pybel.manager.utils.extract_shared_required` | `pybel/manager/utils.py` | `config: dict, definition_header: str = "Namespace"` | `Extract shared required annotation metadata from a BEL resource configuration. This function is used by PyBEL manager utilities when loading or validating BEL namespace and annotation resource documents. Given the parsed configuration dictionary for a BEL resource (for example, a BEL namespace file or an annotation definition file), it extracts the two required metadata fields that are common to both kinds of resource documents: the resource Keyword (the short name used in BEL statements to reference terms from that resource) and the resource creation timestamp. The creation timestamp value is converted by calling parse_datetime on the raw CreatedDateTime value found in the configuration so the caller receives a parsed timestamp object appropriate for downstream metadata comparisons, caching, or versioning logic.` |
| `pybel_struct_filters_node_predicate_builders_data_missing_key_builder` | `pybel.struct.filters.node_predicate_builders.data_missing_key_builder` | `pybel/struct/filters/node_predicate_builders.py` | `key: str` | `pybel.struct.filters.node_predicate_builders.data_missing_key_builder: Build and return a node predicate that tests whether a BELGraph node's data dictionary lacks a given key.` |
| `pybel_struct_operations_node_intersection` | `pybel.struct.operations.node_intersection` | `pybel/struct/operations.py` | `graphs: list` | `Take the node intersection over a collection of BEL graphs and return a new BELGraph that contains only the nodes present in every input graph. This function is part of pybel.struct.operations and is used in the PyBEL ecosystem to compute the common node set across multiple BELGraph instances (biological networks encoded in the Biological Expression Language). The intersection semantics follow the same definition as left_node_intersection_join: the set of nodes present in all provided graphs is computed, each original graph is restricted to that node set (an induced subgraph), and the final result is the union of those induced subgraphs. This is useful in comparative analyses of biological networks where downstream operations should operate only on entities (nodes) shared by all networks.` |
| `pybel_struct_operations_union` | `pybel.struct.operations.union` | `pybel/struct/operations.py` | `graphs: list, use_tqdm: bool = False` | `Take the union of multiple BELGraph objects into a single BELGraph. This function is used within PyBEL to merge separate BEL graphs (BELGraph instances) that represent biological networks encoded in the Biological Expression Language (BEL), for example when combining compiled BEL scripts, network fragments, or outputs from different data sources into a single network for downstream analysis, export, or visualization. The function iterates over the provided collection of graphs, using the first graph as the base (target) and merging subsequent graphs into that base via left_full_join. The merge operation is performed sequentially and is suitable for finite collections of graphs; it is not safe to pass an infinite iterator.` |
| `pybel_struct_pipeline_decorators_get_transformation` | `pybel.struct.pipeline.decorators.get_transformation` | `pybel/struct/pipeline/decorators.py` | `name: str` | `Get a registered pipeline transformation by name. This function looks up and returns a previously registered transformation function from the internal registry used by PyBEL's pipeline decorators. In the context of PyBEL (a framework for parsing and manipulating Biological Expression Language graphs), pipeline transformations are callables that perform a discrete graph-processing step (for example, grounding, validation, or format conversion) and are referenced by name when composing processing pipelines. get_transformation(name) performs a dictionary-style lookup (via mapped.get(name)) into that registry and returns the transformation so the caller can invoke it as part of a pipeline. This function has no side effects on the registry; it only reads from it.` |
| `pybel_testing_generate_generate_random_graph` | `pybel.testing.generate.generate_random_graph` | `pybel/testing/generate.py` | `n_nodes: int, n_edges: int, namespace: str = "NS"` | `Generate a small random BEL subgraph containing protein nodes and sampled "increases" edges for use in tests and examples within the PyBEL ecosystem. The function constructs protein nodes labeled with consecutive integer strings and a given BEL namespace, enumerates all unordered node pairs, samples a requested number of pairs at random, and adds an "increases" relation for each sampled pair with placeholder citation and evidence.` |
| `pybel_testing_utils_get_uri_name` | `pybel.testing.utils.get_uri_name` | `pybel/testing/utils.py` | `url: str` | `pybel.testing.utils.get_uri_name: Extract the file name or resource name from the given URL string for use when saving, caching, or naming downloaded BEL-related resources in PyBEL testing utilities. This function parses the input URL with urllib.parse.urlparse and returns a short, human-usable name describing the remote resource. In practice within PyBEL (for example when calling urllib.request.urlretrieve as shown in the README), this name is used to generate local filenames for downloaded BEL documents, JSON serializations, or other test resources without performing any network I/O.` |
| `pybel_tokens_parse_result_to_dsl` | `pybel.tokens.parse_result_to_dsl` | `pybel/tokens.py` | `tokens: dict` | `Convert a ParseResult (the output of the BEL parser) into a PyBEL DSL BaseEntity. This function is part of the PyBEL parsing pipeline described in the README: after the pyparsing-based BEL grammar produces a ParseResults/dictionary for an entity or post-translational operation (PO), parse_result_to_dsl translates that raw parse representation into the corresponding PyBEL DSL object (BaseEntity). The resulting DSL object is the canonical in-memory representation used by higher-level APIs such as pybel.parse (which can emit JSON for BEL statements), graph construction routines that populate a BELGraph, and export/conversion utilities that interoperate with formats and tools described in the README (NetworkX, CX/NDEx, INDRA, GraphDati, Cytoscape, etc.).` |
| `pybel_utils_ensure_quotes` | `pybel.utils.ensure_quotes` | `pybel/utils.py` | `s: str` | `Ensure that a BEL token or label is wrapped in double quotes when it contains non-alphanumeric characters.` |
| `pybel_utils_expand_dict` | `pybel.utils.expand_dict` | `pybel/utils.py` | `flat_dict: dict, sep: str = "_"` | `pybel.utils.expand_dict expands a flattened dictionary whose keys are composite strings (concatenated nested keys) into a nested dictionary structure by splitting keys on a separator and recursing. In the PyBEL codebase this is useful for rebuilding nested attribute or annotation structures (for example, attributes serialized as concatenated strings in export formats) back into hierarchical Python dicts suitable for BEL graph processing and downstream I/O.` |
| `pybel_utils_get_corresponding_pickle_path` | `pybel.utils.get_corresponding_pickle_path` | `pybel/utils.py` | `path: str` | `pybel.utils.get_corresponding_pickle_path: Compute and return the filesystem path that corresponds to a pickled representation of a BEL file by appending the literal extension ".pickle" to the provided BEL file path. This utility is used in the PyBEL codebase to standardize the filename for a pickled (serialized) form of a BEL document or BELGraph object so calling code can consistently name cache files or serialized outputs. It performs a purely string-based transformation and does not read from or write to the filesystem, perform any validation of the input path, or attempt to detect or replace existing file extensions.` |
| `pybel_utils_hash_dump` | `pybel.utils.hash_dump` | `pybel/utils.py` | `data: dict` | `Hash an arbitrary JSON dictionary by dumping it in sorted order, encoding it in UTF-8, then hashing the bytes with MD5. This function, pybel.utils.hash_dump, produces a deterministic short string fingerprint for a JSON-serializable Python object by performing three steps: (1) serializing the object to a JSON string with keys sorted (json.dumps(..., sort_keys=True)), (2) encoding that JSON string to UTF-8 bytes, and (3) computing the MD5 digest and returning its hexadecimal representation. In the context of PyBEL, this is useful for creating stable identifiers or cache keys for JSON representations produced by the library (for example, Node-Link JSON serializations of BEL graphs used for interchange and export). The returned string is intended to be used as an opaque identifier (e.g., filenames, cache keys, deduplication markers) and not as a cryptographic signature.` |
| `pybel_utils_parse_datetime` | `pybel.utils.parse_datetime` | `pybel/utils.py` | `s: str` | `pybel.utils.parse_datetime parses a date or datetime string used in BEL graph metadata (for example, version or publication timestamps) into a datetime.date value according to the standard PyBEL date/time formats. This helper is used by PyBEL when reading or constructing graph metadata fields such as creation date or published date (for example the from_emmaa example that accepts date='2020-05-29-17-31-58'). It tries the canonical PyBEL formats in a fixed order (CREATION_DATE_FMT, PUBLISHED_DATE_FMT, PUBLISHED_DATE_FMT_2) using datetime.strptime and returns a datetime.date-compatible object when one of the formats matches. It does not perform timezone handling, fuzzy parsing, or infer formats beyond the three supported format strings; if the input does not match any supported format it fails with a ValueError so callers can detect and handle malformed metadata.` |
| `pybel_utils_tokenize_version` | `pybel.utils.tokenize_version` | `pybel/utils.py` | `version_string: str` | `pybel.utils.tokenize_version: Tokenize a version string into a three-integer tuple (major, minor, patch). Converts a textual version identifier commonly used in PyBEL metadata and BEL document exports into a canonical numeric form suitable for numeric comparison, sorting, and inclusion in graph summaries or exported manifests. The function first strips any qualifier starting at the first hyphen (for example "-dev" or "-rc1"), then splits the remaining portion on dots and returns the first three components as integers. This normalization is useful in the PyBEL codebase wherever semantic version-like strings (for example the BELGraph "Version" field shown in the README) must be compared, displayed in summaries, or used in I/O filenames.` |
| `pybel_utils_valid_date` | `pybel.utils.valid_date` | `pybel/utils.py` | `s: str` | `pybel.utils.valid_date: Return whether a string represents a valid ISO 8601 date in the YYYY-MM-DD form. Checks that its argument is a date string that conforms to the ISO 8601 calendar-date pattern "YYYY-MM-DD" and that the year, month, and day constitute a real calendar date (for example, 2020-02-29 is valid while 2019-02-29 is not). This validator is used in PyBEL to validate date-valued metadata commonly found in BEL graphs and workflows (for example published dates or simple version dates used when compiling or serializing BEL documents), ensuring consistency with the PUBLISHED_DATE_FMT applied throughout the codebase. The function delegates to the module-level _validate_date_fmt using the PUBLISHED_DATE_FMT constant, performs no I/O, and has no side effects.` |
| `pybel_utils_valid_date_version` | `pybel.utils.valid_date_version` | `pybel/utils.py` | `s: str` | `pybel.utils.valid_date_version validates whether a string is a valid PyBEL "date version" identifier. This function checks that the provided string conforms to the module's DATE_VERSION_FMT (the date-version format used across PyBEL to label graph versions and timestamps) by delegating to the internal _validator _validate_date_fmt(s, DATE_VERSION_FMT). It is intended for use anywhere PyBEL accepts or produces version/date strings for BEL graphs and I/O (for example, as the date argument to pybel.from_emmaa(...) and the Version field shown by BELGraph.summarize), ensuring consistent formatting for graph metadata, file naming, and interoperability with downstream tools.` |
| `pybel_version_get_version` | `pybel.version.get_version` | `pybel/version.py` | `with_git_hash: bool = False` | `Get the PyBEL package version string via pybel.version.get_version. Returns the package VERSION constant as a human-readable semantic version string and, optionally, appends the current git commit hash to the version string for more specific provenance tracking (for example in logs, CLI output, graph metadata, file exports, or reproducibility records used by PyBEL workflows that parse and serialize BEL graphs).` |

## ‚öñÔ∏è License

Original Code License: MIT

Wrapper Code & Documentation: Apache-2.0

*This file was automatically generated on February 26, 2026.*
