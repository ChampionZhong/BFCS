# pyscf

[üîô Back to Main Repo](../../../README.md) | [üîó Original Repo](https://github.com/pyscf/pyscf)

![Tool Count](https://img.shields.io/badge/Agent_Tools-449-blue?style=flat-square)
![Category](https://img.shields.io/badge/Category-Chemistry-green?style=flat-square)
![Status](https://img.shields.io/badge/Import_Test-Passed-success?style=flat-square)

## üìñ Overview

PySCF is a Python-based computational chemistry framework for performing ab initio electronic structure calculations (e.g., Hartree‚ÄìFock, DFT via external functional libraries, and correlated methods) on molecules and periodic systems.

> **Note**: This documentation lists the **agent-ready wrapper functions** generated for this package. These functions have been strictly typed, docstring-enhanced, and tested for import stability within a standardized Apptainer environment.

## üõ†Ô∏è Available Agent Tools

Below is the list of **449** functions optimized for LLM tool-use.

| **Tool Name (Wrapper)**   | **Source**          | **File Path**     | **Arguments (Type)**        | **Description**                |
| ------------------------- | ------------------- | ----------------- | --------------------------- | ------------------------------ |
| `pyscf_agf2__agf2_build_mats_dfragf2_lowmem` | `pyscf.agf2._agf2.build_mats_dfragf2_lowmem` | `pyscf/agf2/_agf2.py` | `qxi: numpy.ndarray, qja: numpy.ndarray, e_occ: numpy.ndarray, e_vir: numpy.ndarray, os_factor: float = 1.0, ss_factor: float = 1.0` | `build_mats_dfragf2_lowmem builds two molecular-orbital (MO) matrices used by the AGF2 density-fitted (df-AGF2) low-memory driver. This function is a Python wrapper around the compiled routine libagf2.AGF2df_vv_vev_islice_lowmem and prepares inputs, invokes the driver with C-contiguous arrays and MPI slicing, and performs an MPI all-reduce so the returned matrices are the globally assembled results used in subsequent AGF2 self-energy and correlation-energy construction.` |
| `pyscf_agf2__agf2_build_mats_dfragf2_outcore` | `pyscf.agf2._agf2.build_mats_dfragf2_outcore` | `pyscf/agf2/_agf2.py` | `qxi: numpy.ndarray, qja: numpy.ndarray, e_occ: numpy.ndarray, e_vir: numpy.ndarray, os_factor: float = 1.0, ss_factor: float = 1.0` | `build_mats_dfragf2_outcore(qxi, qja, e_occ, e_vir, os_factor=1.0, ss_factor=1.0) Constructs the VV and VEV intermediate matrices used by the AGF2 density-fitted fragment GF2 out-of-core kernel. This Python implementation corresponds to the Fortran routine AGF2df_vv_vev_islice and is intended for use inside PySCF's agf2._agf2 module to accumulate energy-weighted and unweighted two-index intermediates from density-fitted three-index tensors while slicing over occupied orbitals (out-of-core style). The routine performs local BLAS operations (via lib.dot), iterates over occupied orbital slices to limit peak memory use, applies opposite-spin and same-spin scalar weighting factors, and finally synchronizes and reduces the results across MPI ranks using mpi_helper.barrier and mpi_helper.allreduce_safe_inplace.` |
| `pyscf_agf2__agf2_cholesky_build` | `pyscf.agf2._agf2.cholesky_build` | `pyscf/agf2/_agf2.py` | `vv: numpy.ndarray, vev: numpy.ndarray, eps: float = 1e-16` | `Constructs truncated auxiliary tensors (auxiliaries) from the metric-like matrices vv and vev used in the AGF2 self-energy construction. This function is part of the AGF2 implementation in PySCF and is used by build_se_part to produce a compact representation of the auxiliary basis that parameterizes the frequency-dependent self-energy for occupied or virtual spaces. In practice, vv is expected to be a Hermitian, positive-definite or positive-semidefinite metric (for example when gf_occ.naux < gf_occ.nphys or gf_vir.naux < gf_vir.nphys the matrix can be positive-semidefinite). The function performs a Cholesky decomposition of vv to obtain a factor b, falls back to an eigenvalue regularization when vv is not strictly positive-definite, and then diagonalizes a transformed vev to produce eigenvalues and transformed eigenvectors that define the truncated auxiliaries. This numerical procedure stabilizes the auxiliary representation used in correlated Green's function (Self-Energy) computations within the PySCF AGF2 module.` |
| `pyscf_agf2__agf2_get_blksize` | `pyscf.agf2._agf2.get_blksize` | `pyscf/agf2/_agf2.py` | `max_memory_total: float, *sizes` | `Gets a block size (integer) such that the total memory required by the blocks does not exceed the available memory. This utility is used in AGF2 routines within the PySCF project to pick a number of elements per block when forming or processing large arrays/tensors so that the sum over block contributions (sum(sizes) * blksize or max over tuple-sums when tuples are supplied) fits within the remaining memory budget. This function reads the current memory usage via lib.current_memory()[0] and subtracts it from the provided max_memory_total (interpreted as megabytes). It then converts the available memory and element-size estimate into bits (using 8e6 bits per MB and 64 bits per element) and returns the integer quotient mem_avail / (sum_of_sizes * 64 bits) as the block size. The routine supports either a list of integer sizes provided as separate varargs or one or more tuples of integer sizes (in which case the maximum tuple-sum is used).` |
| `pyscf_agf2__agf2_build_mats_ragf2_incore` | `pyscf.agf2._agf2.build_mats_ragf2_incore` | `pyscf/agf2/_agf2.py` | `qeri: numpy.ndarray, e_occ: numpy.ndarray, e_vir: numpy.ndarray, os_factor: float = 1.0, ss_factor: float = 1.0` | `build_mats_ragf2_incore builds two frequency-independent matrices (vv and vev) used by the restricted AGF2 (rAGF2) implementation by wrapping the compiled driver libagf2.AG F2ee_vv_vev_islice. This function is part of the PySCF agf2 module (Python-based Simulations of Chemistry Framework) and is used in electronic-structure workflows to convert a four-index two-electron integral tensor and orbital energy arrays into condensed matrices that enter the AGF2 self-energy construction and subsequent algebraic Green's function procedures.` |
| `pyscf_agf2__agf2_build_mats_uagf2_incore` | `pyscf.agf2._agf2.build_mats_uagf2_incore` | `pyscf/agf2/_agf2.py` | `qeri: tuple, e_occ: tuple, e_vir: tuple, os_factor: float = 1.0, ss_factor: float = 1.0` | `Builds two unrestricted AGF2 intermediate matrices (vv and vev) in-core by calling the compiled C driver AGF2uee_vv_vev_islice from libagf2 and reducing partial results across MPI ranks.` |
| `pyscf_agf2__agf2_build_mats_dfuagf2_lowmem` | `pyscf.agf2._agf2.build_mats_dfuagf2_lowmem` | `pyscf/agf2/_agf2.py` | `qxi: tuple, qja: tuple, e_occ: tuple, e_vir: tuple, os_factor: float = 1.0, ss_factor: float = 1.0` | `Build low-memory DF-U-AGF2 intermediate matrices vv and vev by calling the C driver AGF2udf_vv_vev_islice_lowmem, producing two real square matrices used by the density-fitted unrestricted AGF2 (DF-U-AGF2) algorithm in PySCF. This wrapper prepares Python-side inputs (spin-resolved auxiliary tensors and orbital energies), partitions the work across MPI ranks by slicing occupied-index blocks, calls the libagf2 C routine via ctypes, and then performs MPI reductions to produce the global vv and vev matrices. In the PySCF/AGF2 domain these matrices are energy-weighted auxiliary contractions used as intermediate building blocks for constructing the frequency-independent parts of the AGF2 self-energy in a low-memory workflow.` |
| `pyscf_agf2__agf2_build_mats_dfuagf2_incore` | `pyscf.agf2._agf2.build_mats_dfuagf2_incore` | `pyscf/agf2/_agf2.py` | `qxi: tuple, qja: tuple, e_occ: tuple, e_vir: tuple, os_factor: float = 1.0, ss_factor: float = 1.0` | `Builds the in-core vv and vev intermediate matrices for the density-fitted, unrestricted AGF2 implementation by calling the compiled driver AGF2udf_vv_vev_islice. This wrapper is used in PySCF's agf2 module to assemble two intermediate nmo-by-nmo matrices (vv and vev) that are required by the density-fitted unrestricted AGF2 (df-uAGF2) correlation/self-energy routines. The function partitions work over MPI ranks using mpi_helper, invokes the C driver with contiguous arrays, and then reduces partial results from all ranks into the final full matrices.` |
| `pyscf_agf2__agf2_build_mats_dfragf2_incore` | `pyscf.agf2._agf2.build_mats_dfragf2_incore` | `pyscf/agf2/_agf2.py` | `qxi: numpy.ndarray, qja: numpy.ndarray, e_occ: numpy.ndarray, e_vir: numpy.ndarray, os_factor: float = 1.0, ss_factor: float = 1.0` | `build_mats_dfragf2_incore(qxi, qja, e_occ, e_vir, os_factor=1.0, ss_factor=1.0) Build nmo-by-nmo intermediate matrices for the density-fitted fragment AGF2 procedure using the in-core C driver AGF2df_vv_vev_islice and MPI slicing over occupied orbitals. This function is a thin Python wrapper around the compiled libagf2 routine AGF2df_vv_vev_islice. It prepares inputs, determines array sizes (number of auxiliary functions, occupied and virtual orbitals, and molecular orbitals), slices the occupied-orbital index range for the current MPI rank, calls the C driver with C-contiguous buffers via ctypes, then performs an MPI all-reduce to sum the per-rank contributions. The outputs vv and vev are the two nmo-by-nmo intermediate matrices produced by the C routine; these matrices are used inside the AGF2 (second-order Green's function) implementation in PySCF for assembling correlation/self-energy contributions in the density-fitted fragment variant (dfragf2).` |
| `pyscf_agf2__agf2_build_mats_dfuagf2_outcore` | `pyscf.agf2._agf2.build_mats_dfuagf2_outcore` | `pyscf/agf2/_agf2.py` | `qxi: tuple, qja: tuple, e_occ: tuple, e_vir: tuple, os_factor: float = 1.0, ss_factor: float = 1.0` | `Builds the vv and vev matrices for the density-fitted, unrestricted AGF2 (DF-UAGF2) out-of-core slice implementation used in PySCF's AGF2 module. This Python implementation corresponds to the lower-level routine AGF2udf_vv_vev_islice and is used to accumulate two related matrices required by the AGF2 self-energy construction: vv, a spin-weighted coupling matrix accumulated from auxiliary integral slices, and vev, the same coupling matrix weighted by excitation energy denominators. The function is designed to operate on flattened / sliced density-fitting auxiliary arrays (qxi, qja) so that large datasets can be processed "outcore" (slice-by-slice) and then globally reduced across MPI ranks. It performs local contractions with BLAS (lib.dot), applies same-spin and opposite-spin prefactors, and synchronizes the final results using mpi_helper.barrier() and mpi_helper.allreduce_safe_inplace().` |
| `pyscf_agf2__agf2_build_mats_uagf2_outcore` | `pyscf.agf2._agf2.build_mats_uagf2_outcore` | `pyscf/agf2/_agf2.py` | `qeri: list, e_occ: list, e_vir: list, os_factor: float = 1.0, ss_factor: float = 1.0` | `Build vv and vev matrices for unrestricted AGF2 (uAGF2) using out-of-core, slice-by-slice two-electron integral factors. This function is the Python reimplementation of the routine named AGF2uee_vv_vev_islice used in the PySCF AGF2 machinery. It is intended for use in unrestricted (spin-separated) AGF2 calculations within the PySCF framework and supports out-of-core evaluation by iterating over slices of the factorized two-electron integrals (qeri). The computed matrices vv and vev represent accumulated bilinear forms of integral-factor slices and energy denominator-weighted slices respectively; in practice these objects are used inside AGF2 self-energy construction and related post-Hartree‚ÄìFock routines where contributions from same-spin and opposite-spin channels are combined.` |
| `pyscf_agf2_chkfile_load` | `pyscf.agf2.chkfile.load` | `pyscf/agf2/chkfile.py` | `chkfile: str, key: str` | `pyscf.agf2.chkfile.load: Load array(s) stored under a given key from a PySCF checkpoint file and distribute the loaded object to all MPI ranks. This function is used by AGF2 and other PySCF workflows to read persistent intermediate data (arrays, scalars, or Python objects) from a checkpoint file created by PySCF I/O utilities and to ensure every MPI process receives the same object without every rank performing file I/O. It delegates the actual file read to pyscf.lib.chkfile (via chkutil.load) on MPI rank 0 only, then synchronizes and broadcasts the result to all ranks using mpi_helper.barrier and mpi_helper.bcast_dict. Consult pyscf.lib.chkfile for the precise storage format and semantics of stored keys.` |
| `pyscf_agf2__agf2_build_mats_ragf2_outcore` | `pyscf.agf2._agf2.build_mats_ragf2_outcore` | `pyscf/agf2/_agf2.py` | `qeri: numpy.ndarray, e_occ: numpy.ndarray, e_vir: numpy.ndarray, os_factor: float = 1.0, ss_factor: float = 1.0` | `Build two intermediate two-index matrices used by the restricted AGF2 (RAGF2) out-of-core implementation: vv and vev. This function is the Python implementation of the AGF2ee_vv_vev_islice routine and is intended to be used within PySCF's AGF2 workflow to accumulate contributions from a 4-dimensional slice of electron-repulsion integrals (ERIs) together with occupied and virtual orbital energies. The resulting matrices are used downstream in RAGF2 self-energy and energy evaluations as compact two-index intermediates that collect spin-weighted ERI contractions and their energy-weighted counterparts.` |
| `pyscf_agf2_chempot_binsearch_chempot` | `pyscf.agf2.chempot.binsearch_chempot` | `pyscf/agf2/chempot.py` | `fock: tuple, nphys: int, nelec: int, occupancy: int = 2` | `Finds a chemical potential that best matches a target number of physical electrons by inspecting the eigenvalues and eigenvectors of a Fock matrix and enforcing the Aufbau principle. This routine is used in the AGF2 chemical-potential determination within PySCF: given a Fock matrix describing either a physical fragment or an extended (physical + auxiliary) system, it identifies the highest-occupied and lowest-unoccupied molecular orbitals (HOMO/LUMO) with respect to the physical subspace and returns the midpoint eigenvalue as the chemical potential. If the caller supplies a pre-diagonalised Fock (eigenvalues and eigenvectors), the function uses them directly; otherwise it diagonalises the supplied Fock matrix with numpy.linalg.eigh. The function computes the occupation contributed by each molecular orbital to the first nphys rows (the physical degrees of freedom) via the projection n = occupancy * v[:nphys,i].conj().T @ v[:nphys,i] and accumulates this until the accumulated physical electron count brackets the requested nelec. The returned error is the signed difference between the requested nelec and the chosen accumulated electron count (positive means the chosen state has fewer electrons than requested).` |
| `pyscf_agf2_chkfile_load_mol` | `pyscf.agf2.chkfile.load_mol` | `pyscf/agf2/chkfile.py` | `chkfile: str` | `pyscf.agf2.chkfile.load_mol loads a PySCF molecular object from a checkpoint file and reconstructs the same pyscf.gto.Mole on all MPI ranks for distributed PySCF workflows. This function reads a checkpoint file produced by PySCF's chkfile utilities and returns a gto.Mole that contains the molecular geometry, basis, and other molecule metadata required for subsequent quantum-chemistry computations (for example, SCF, correlated methods, or AGF2 runs). To minimize filesystem activity in MPI-parallel runs, only MPI rank 0 performs the file I/O using chkutil.load_mol and serializes the molecule with mol.dumps(); the serialized data are then synchronized to all ranks via mpi_helper.barrier() and mpi_helper.bcast_dict(), and each rank reconstructs an identical molecule locally with gto.loads().` |
| `pyscf_agf2_chkfile_load_agf2` | `pyscf.agf2.chkfile.load_agf2` | `pyscf/agf2/chkfile.py` | `chkfile: str` | `Load the AGF2 data stored under the "agf2" checkpoint group in a PySCF checkpoint file and reconstruct Python objects used by AGF2 code paths.` |
| `pyscf_agf2_mpi_helper_prange` | `pyscf.agf2.mpi_helper.prange` | `pyscf/agf2/mpi_helper.py` | `start: int, stop: int, step: int` | `pyscf.agf2.mpi_helper.prange: Produce the sub-range(s) of an integer index interval that the current MPI rank should process. This function is used inside the AGF2 (auxiliary Green‚Äôs function, second-order) parallel workflow in PySCF to distribute a global loop range across MPI ranks by delegating to lib.prange for the local per-rank iteration. It returns the sequence of (start, stop) index pairs that a single MPI rank should iterate over when executing distributed work (for example, partitioning index ranges for blocks of an integral or frequency loop). This function either delegates directly to lib.prange when there is one MPI process, or partitions the total interval length (stop - start) into size roughly-even pieces and yields the piece assigned to the current rank. When SIZE > 1 and the module-level flag SCALE_PRANGE_STEP is true, the function reduces the requested step granularity by integer-dividing step by size (step //= size) before calling lib.prange on the per-rank subinterval. The subinterval boundaries are computed with integer division using the local lambda split = lambda x: x * (stop - start) // size; the per-rank start and stop values are then passed to lib.prange to produce the final sequence of (p0, p1) pairs for that rank. The function relies on the mpi_helper module globals size (number of MPI ranks), rank (this process rank), SCALE_PRANGE_STEP, and the lib.prange implementation; these must be available in the executing environment.` |
| `pyscf_ao2mo_incore_general` | `pyscf.ao2mo.incore.general` | `pyscf/ao2mo/incore.py` | `eri_ao: numpy.ndarray, mo_coeffs: list, verbose: int = 0, compact: bool = True, **kwargs` | `pyscf.ao2mo.incore.general transforms two-electron integrals expressed in the atomic-orbital (AO) basis into molecular-orbital (MO) integrals for four (possibly different) sets of orbitals. This function is used in PySCF to produce the MO representation of electron repulsion integrals (ERIs) required by post-Hartree‚ÄìFock methods and other electronic-structure routines that operate in an MO basis. The implementation accepts either a fully expanded 4-index AO tensor (nao**4 elements) or AO integrals stored with permutation symmetry (4-fold or 8-fold) and will choose a dense einsum contraction for fully expanded input or a symmetry-aware transformation routine for packed input. When the four orbital sets contain identical columns or repeated pairs, setting compact=True returns MO integrals in a packed (permutation-symmetric) 2D representation, reducing memory and computational costs; when compact=False the function returns the "plain" uncompressed MO integrals without exploiting permutation symmetry.` |
| `pyscf_ao2mo_incore_full` | `pyscf.ao2mo.incore.full` | `pyscf/ao2mo/incore.py` | `eri_ao: numpy.ndarray, mo_coeff: numpy.ndarray, verbose: int = 0, compact: bool = True, **kwargs` | `pyscf.ao2mo.incore.full transforms atomic-orbital (AO) electron repulsion integrals (ERI) into molecular-orbital (MO) representation using the same set of molecular orbitals for all four indices. This function is part of the PySCF ao2mo.incore module and is used in quantum chemistry post-Hartree‚ÄìFock workflows (for example MP2, CC, and other correlated methods) that require MO-basis two-electron integrals.` |
| `pyscf_ao2mo_incore_half_e1` | `pyscf.ao2mo.incore.half_e1` | `pyscf/ao2mo/incore.py` | `eri_ao: numpy.ndarray, mo_coeffs: list, compact: bool = True` | `pyscf.ao2mo.incore.half_e1: Perform a half transformation of atomic-orbital (AO) two-electron integrals (ij\|kl) to the molecular-orbital (MO) basis by transforming the pair of AO indices corresponding to i and j, producing an array of MO integrals used in post-Hartree‚ÄìFock methods (e.g., MP2, CC) within the PySCF electronic structure framework. This function implements the first (half) step of an AO->MO integral transformation: it contracts two sets of MO coefficient matrices with the AO two-electron integrals to transform the AO indices i and j to the MO basis while leaving the k,l AO pair untransformed. It accepts AO integrals provided with either 4-fold (s4) or 8-fold (s8) permutation symmetry and produces a 2D array whose first dimension indexes the combined i-j MO pairs and whose second dimension indexes the AO pair basis (the remaining AO pair indices). The routine is implemented with performance-critical C backends and is intended for double-precision real integrals in typical quantum chemistry workflows within PySCF.` |
| `pyscf_cc_bccd_get_mo_ovlp` | `pyscf.cc.bccd.get_mo_ovlp` | `pyscf/cc/bccd.py` | `mo1: numpy.ndarray, mo2: numpy.ndarray, ovlp: numpy.ndarray` | `Get MO overlap matrix C_1.conj().T ovlp C_2 used in BCCD and other correlated-method routines in PySCF.` |
| `pyscf_cc_ccsd_get_t1_diagnostic` | `pyscf.cc.ccsd.get_t1_diagnostic` | `pyscf/cc/ccsd.py` | `t1: numpy.ndarray` | `Returns the t1 amplitude norm normalized by the number of correlated electrons, commonly called the T1 diagnostic in coupled-cluster singles and doubles (CCSD) calculations. In the PySCF quantum-chemistry framework this function is used to quantify the overall magnitude of single-excitation amplitudes produced by a CCSD calculation and to provide a compact, dimensionless measure that helps assess the degree to which a system departs from a single-reference description.` |
| `pyscf_cc_ccsd_get_d1_diagnostic` | `pyscf.cc.ccsd.get_d1_diagnostic` | `pyscf/cc/ccsd.py` | `t1: numpy.ndarray` | `Compute the D1 diagnostic for CCSD single-excitation amplitudes as defined in Janssen et al., Chem. Phys. Lett. 290 (1998) 423. This diagnostic extracts a single non-negative scalar that quantifies the magnitude of single-excitation amplitudes and is used within the PySCF coupled-cluster (CCSD) context to assess the importance of single excitations and, indirectly, the potential multireference character of a wavefunction.` |
| `pyscf_ao2mo_semi_incore_general` | `pyscf.ao2mo.semi_incore.general` | `pyscf/ao2mo/semi_incore.py` | `eri: numpy.ndarray, mo_coeffs: list, erifile: str, dataname: str = "eri_mo", ioblk_size: float = 128, compact: bool = True, verbose: int = 3` | `pyscf.ao2mo.semi_incore.general: Transform spherical atomic-orbital (AO) electron repulsion integrals (ERIs) to molecular-orbital (MO) ERIs on disk for four arbitrary sets of orbitals used in PySCF quantum-chemistry workflows. This routine performs a two-step "half-transform" (mu,nu -> ij and lambda,sigma -> kl) and writes the final ij\|kl MO integrals to an HDF5 dataset, enabling out-of-core handling of large integral tensors that would not fit in RAM. This function is used in PySCF to convert an input AO ERI representation (either 4-fold or 8-fold symmetry as produced by PySCF integral routines) into MO-basis ERIs for four potentially distinct sets of molecular orbital coefficient matrices. The produced dataset is intended for downstream correlated-electron methods (MP2, CC, multireference methods) that consume ij\|kl integrals. The implementation minimizes peak memory usage by chunking and by writing an intermediate "half-transformed" array to a temporary HDF5 swap file and then completing the transformation to the final HDF5 dataset.` |
| `pyscf_cc_bccd_get_umat_from_t1` | `pyscf.cc.bccd.get_umat_from_t1` | `pyscf/cc/bccd.py` | `t1: numpy.ndarray` | `pyscf.cc.bccd.get_umat_from_t1: Construct a unitary orbital rotation matrix (or matrices) from CC singles amplitudes t1. This function is used in the bccd (Brueckner coupled-cluster doubles) workflow of the PySCF electronic structure package to convert t1 singles-amplitude information into a unitary rotation matrix U that can be applied to molecular-orbital coefficients. For restricted-reference (RHF) input, a single square unitary matrix of size nmo x nmo is returned. For unrestricted-reference (UHF) input (multiple spin components), a stack of unitary matrices is returned, one per spin. The routine assembles an anti-Hermitian generator A from the t1 amplitudes with the block structure A = [ 0 -t1 t1^H 0 ] and then computes U = expm(A) (matrix exponential) to obtain a unitary rotation. This implements the standard mapping from singles amplitudes to an orbital rotation operator used when performing orbital rotations or orbital optimization driven by singles in coupled-cluster contexts.` |
| `pyscf_cc_addons_spatial2spin` | `pyscf.cc.addons.spatial2spin` | `pyscf/cc/addons.py` | `tx: tuple, orbspin: numpy.ndarray = None` | `pyscf.cc.addons.spatial2spin converts coupled-cluster T1/T2 amplitude tensors from a spatial-orbital (spin-summed or spatial-indexed) representation into the spin-orbital representation used by PySCF's coupled-cluster routines. This function is used in PySCF to map restricted/ spatial-formatted amplitudes (RCCSD-style single-array T1 or T2, or separated alpha/beta blocks) into full spin-orbital amplitude arrays suitable for spin-orbital CC code paths and for interoperation between restricted and unrestricted amplitude formats.` |
| `pyscf_cc_addons_spin2spatial` | `pyscf.cc.addons.spin2spatial` | `pyscf/cc/addons.py` | `tx: numpy.ndarray, orbspin: numpy.ndarray` | `Convert T1/T2 amplitudes from spin-orbital basis to spatial-orbital spin-separated basis used in PySCF coupled-cluster (CC) workflows. This function is used in the PySCF CC addons to transform CC single (T1) and double (T2) excitation amplitude tensors that are expressed in a spin-orbital indexing (interleaved alpha/beta spin-orbitals) into spatial-orbital amplitude tensors separated by spin (alpha and beta). This conversion is required when downstream CC code or post-processing routines expect amplitudes grouped by spatial orbitals and spin blocks (alpha-alpha, alpha-beta, beta-beta) rather than a single spin-orbital tensor. The implementation assumes the convention used elsewhere in PySCF: the first nocc entries of the spin-orbital index correspond to occupied spin-orbitals and the remaining entries correspond to virtual spin-orbitals; orbspin labels each spin-orbital as 0 (alpha) or 1 (beta).` |
| `pyscf_cc_ccsd_get_d2_diagnostic` | `pyscf.cc.ccsd.get_d2_diagnostic` | `pyscf/cc/ccsd.py` | `t2: numpy.ndarray` | `Compute the D2 diagnostic for CCSD T2 amplitudes. This function implements the D2 diagnostic defined in Nielsen et al., Chem. Phys. Lett. 310 (1999) 568. It is intended for use in the PySCF coupled-cluster (ccsd) workflow to quantify the magnitude of double-excitation amplitudes (T2) coming from a restricted closed-shell CCSD calculation. The diagnostic is computed as the maximum of two norms derived from the largest eigenvalues of Hermitian matrices formed by contracting the supplied T2 tensor with itself over occupied or virtual index pairs. Larger values of the D2 diagnostic indicate stronger double-excitation character and can signal increasing nondynamic (multireference) correlation where single-reference CCSD may become unreliable. Note: this diagnostic is currently only defined in the literature and in this implementation for restricted closed-shell systems; it should not be used for unrestricted or general open-shell T2 tensors.` |
| `pyscf_cc_bccd_transform_l1_to_bo` | `pyscf.cc.bccd.transform_l1_to_bo` | `pyscf/cc/bccd.py` | `t1: numpy.ndarray, umat: numpy.ndarray` | `pyscf.cc.bccd.transform_l1_to_bo transforms single-excitation amplitudes (t1) into the Brueckner orbital (BO) basis used in Brueckner coupled-cluster doubles (BCCD) procedures. This function is used in the BCCD orbital-rotation and amplitude-transformation steps to express t1 amplitudes in the rotated (Brueckner) molecular-orbital basis defined by the orbital rotation matrix umat, which is required when checking or enforcing the Brueckner condition (vanishing singles) or when converting amplitudes between orbital representations.` |
| `pyscf_cc_eom_uccsd_vector_to_amplitudes_ip` | `pyscf.cc.eom_uccsd.vector_to_amplitudes_ip` | `pyscf/cc/eom_uccsd.py` | `vector: numpy.ndarray, nmo: tuple, nocc: tuple` | `Convert a flat optimization vector into spin-orbital ionization-potential (IP) EOM-UCCSD singles and doubles amplitude tensors used by PySCF. This function is used in the EOM-UCCSD (equation-of-motion coupled-cluster with single and double excitations) IP module to reconstruct the per-spin singles (r1) and doubles (r2) amplitude arrays from a one-dimensional parameter vector that typically appears in iterative solvers and linear-response routines. The reconstruction follows the layout implemented in the source: packed lower-triangular storage for same-spin double excitations and full storage for mixed-spin doubles; same-spin doubles are expanded to antisymmetric 2-index tensors.` |
| `pyscf_cc_eom_uccsd_spatial2spin_ea` | `pyscf.cc.eom_uccsd.spatial2spin_ea` | `pyscf/cc/eom_uccsd.py` | `rx: list, orbspin: numpy.ndarray = None` | `pyscf.cc.eom_uccsd.spatial2spin_ea converts electron-attached (EOMEA) excitation amplitudes expressed in spatial-orbital blocks into a spin-orbital representation required by spin-orbital EOM-UCCSD operations in the PySCF quantum chemistry framework. This function is used in the EOM-UCCSD module to take spatial-only R1 or R2 amplitude components (separate alpha/beta blocks) and assemble them into a single spin-orbital array where spin labels are encoded by an orbspin mask (0 for alpha, 1 for beta). The conversion preserves the input numeric dtype and arranges virtual and occupied indices according to the provided or implicit orbital-spin ordering so downstream spin-orbital Hamiltonian routines can consume the amplitudes.` |
| `pyscf_cc_eom_uccsd_spin2spatial_eomsf` | `pyscf.cc.eom_uccsd.spin2spatial_eomsf` | `pyscf/cc/eom_uccsd.py` | `rx: numpy.ndarray, orbspin: numpy.ndarray` | `Convert EOMEE spin-orbital R1/R2 amplitudes into spin-flip EOMEE spatial-orbital R1/R2 blocks. This function is used in the EOM-UCCSD code path of the PySCF quantum chemistry package to transform excitation (R1) or double-excitation (R2) amplitudes that are expressed in a spin-orbital basis into spatial-orbital blocks arranged for spin-flip EOM calculations. The conversion groups amplitude elements according to the spin (alpha/beta) of the occupied and virtual orbitals defined by orbspin, returning only the spin-flip relevant blocks. It is a pure transformation with no side effects on inputs.` |
| `pyscf_cc_eom_uccsd_spatial2spin_eomsf` | `pyscf.cc.eom_uccsd.spatial2spin_eomsf` | `pyscf/cc/eom_uccsd.py` | `rx: list, orbspin: numpy.ndarray = None` | `Convert spin-flip EOM-EE spatial-orbital excitation amplitudes (R1/R2) to spin-orbital excitation amplitudes used in spin-orbital EOM-SF code paths.` |
| `pyscf_cc_eom_uccsd_spin2spatial_ea` | `pyscf.cc.eom_uccsd.spin2spatial_ea` | `pyscf/cc/eom_uccsd.py` | `rx: numpy.ndarray, orbspin: numpy.ndarray` | `Convert EOMEA spin-orbital amplitudes (R1 or R2) into spatial-orbital blocks for UCCSD EOM-EA procedures. This function is used in the PySCF coupled-cluster EOM electron-affinity (EOMEA) workflow to separate spin-orbital amplitude arrays into spatial-orbital components grouped by spin (alpha/beta). In EOM-EA calculations built on unrestricted CCSD (UCCSD), excitation/attachment amplitude vectors are often stored in spin-orbital form (one entry per spin-orbital). Many post-processing routines and tensor contractions operate on spatial-orbital blocks (alpha/beta subblocks). This routine accepts either a 1-D R1 spin-orbital vector or a 2-D R2 spin-orbital amplitude array and returns the corresponding spatial-orbital blocks used downstream in EOMEA amplitude manipulation, screening, or contraction.` |
| `pyscf_cc_eom_uccsd_spin2spatial_ip` | `pyscf.cc.eom_uccsd.spin2spatial_ip` | `pyscf/cc/eom_uccsd.py` | `rx: numpy.ndarray, orbspin: numpy.ndarray` | `Convert EOM-IP spin-orbital R1/R2 amplitudes to spatial-orbital R1/R2 blocks used in EOM-UCCSD. This function is used within the pyscf.cc.eom_uccsd module of the PySCF quantum chemistry framework to translate amplitude tensors expressed in a spin-orbital basis (where alpha/beta spin are interleaved) into spatial-orbital blocks separated by spin (alpha/beta). The conversion is required when working with unrestricted coupled-cluster EOM for ionization potentials (EOM-IP) where intermediate code or algorithms expect spatial-orbital block structures: for a 1-D input it extracts spatial occupied single-hole (R1) amplitudes for alpha and beta spins; for a higher-dimensional input it reshapes and partitions two-hole/one-particle (R2) spin-orbital amplitudes into the four spin blocks (alpha-alpha, beta-alpha, alpha-beta, beta-beta) for occupied-occupied -> virtual mapping. The function does not modify its inputs and returns newly allocated numpy arrays.` |
| `pyscf_cc_eom_uccsd_spatial2spin_ip` | `pyscf.cc.eom_uccsd.spatial2spin_ip` | `pyscf/cc/eom_uccsd.py` | `rx: tuple, orbspin: numpy.ndarray = None` | `pyscf.cc.eom_uccsd.spatial2spin_ip: Convert EOM-IP spatial-orbital R1/R2 amplitude blocks to a unified spin-orbital representation used in UCCSD EOM-IP calculations in the PySCF quantum-chemistry framework. This function is used when downstream linear-algebra routines (solvers, matrix-vector products, and response routines) require amplitudes arranged in a spin-orbital basis rather than separate alpha/beta spatial blocks.` |
| `pyscf_cc_eom_uccsd_amplitudes_to_vector_ip` | `pyscf.cc.eom_uccsd.amplitudes_to_vector_ip` | `pyscf/cc/eom_uccsd.py` | `r1: tuple, r2: tuple` | `Convert unrestricted spin-orbital EOM-UCCSD ionization amplitudes into a single packed 1-D vector suitable for iterative solvers (for example Davidson) used in PySCF's equation-of-motion ionization-potential (IP) UCCSD routines. This function is used to take the separate alpha/beta singles and the four spin-block double-amplitude tensors produced in IP-EOM-UCCSD calculations and produce a contiguous 1-D representation expected by linear-algebra and diagonalization routines in the pyscf.cc.eom_uccsd module.` |
| `pyscf_cc_momgfccsd_build_block_tridiagonal` | `pyscf.cc.momgfccsd.build_block_tridiagonal` | `pyscf/cc/momgfccsd.py` | `a: list, b: list, c: list = None` | `Construct a block tridiagonal matrix from supplied on-diagonal and off-diagonal block lists. This function assembles a full 2D block matrix H whose only non-zero blocks are the diagonal blocks a[i], the subdiagonal blocks b[i] placed at block position (i+1, i), and the superdiagonal blocks c[i] placed at block position (i, i+1). If c is not provided, it is created as the conjugate transpose of b (c[i] = b[i].T.conj()), which is the common choice when assembling a Hermitian block tridiagonal matrix as used in moment-constrained Green's function coupled-cluster (MOMGF-CCSD) routines and block-Lanczos style algorithms in PySCF. The assembled matrix is returned as a NumPy ndarray created via numpy.block. The function does not modify its inputs.` |
| `pyscf_cc_gccsd_amplitudes_from_rccsd` | `pyscf.cc.gccsd.amplitudes_from_rccsd` | `pyscf/cc/gccsd.py` | `t1: numpy.ndarray, t2: numpy.ndarray, orbspin: int = None` | `pyscf.cc.gccsd.amplitudes_from_rccsd converts restricted (spatial-orbital) coupled-cluster singles and doubles (RCCSD) amplitudes into spin-orbital amplitudes suitable for generalized/ spin-orbital CCSD routines in PySCF (for example, to provide input amplitudes to pyscf.cc.gccsd routines). This function is a thin wrapper that calls spatial2spin on each amplitude array and returns the corresponding spin-orbital T1 and T2 arrays used by downstream spin-orbital correlated-wavefunction code.` |
| `pyscf_cc_momgfccsd_mat_isqrt` | `pyscf.cc.momgfccsd.mat_isqrt` | `pyscf/cc/momgfccsd.py` | `m: numpy.ndarray, tol: float = 1e-16, hermi: bool = False` | `pyscf.cc.momgfccsd.mat_isqrt returns the inverse square root of a square matrix using an eigendecomposition. This routine is used in the PySCF correlated-electron (coupled-cluster) code paths (pyscf.cc.*), for example to form inverse-square-root metric or overlap operators that arise in MOMGF/CCSD transformations and orthonormalizations. The implementation chooses an algorithm depending on whether the input is known or assumed Hermitian: for Hermitian matrices it uses a real symmetric eigendecomposition (np.linalg.eigh) and forms v diag(w**-1/2) v^H; for general (possibly non-Hermitian) matrices it uses a full eigendecomposition (np.linalg.eig) and forms v diag(w**-1/2) v^{-1}.` |
| `pyscf_cc_momgfccsd_mat_sqrt` | `pyscf.cc.momgfccsd.mat_sqrt` | `pyscf/cc/momgfccsd.py` | `m: numpy.ndarray, hermi: bool = False` | `Compute the matrix square root used by pyscf.cc.momgfccsd routines in PySCF's electronic-structure calculations, returning a matrix X such that X @ X approximates the input matrix m within numerical limits and algorithmic caveats described below. This function is typically used in coupled-cluster / moment-Green's-function (momgfccsd) workflows in PySCF where square roots of Hermitian or general matrices (e.g., metric, density-like, or similarity-transformed matrices) are required for further linear-algebra manipulations.` |
| `pyscf_ci_cisd_t1strs` | `pyscf.ci.cisd.t1strs` | `pyscf/ci/cisd.py` | `norb: int, nelec: int` | `pyscf.ci.cisd.t1strs: Compute the FCI string addresses and fermionic sign factors needed for CIS single-excitation amplitudes and for converting CI coefficients between the physics vacuum and the Hartree‚ÄìFock (HF) vacuum.` |
| `pyscf_ci_cisd_tn_addrs_signs` | `pyscf.ci.cisd.tn_addrs_signs` | `pyscf/ci/cisd.py` | `norb: int, nelec: int, n_excite: int` | `Compute addresses and sign factors for CIS n-excitation amplitudes relative to a Hartree‚ÄìFock (HF) reference. This function is used in the PySCF correlated-electron code path that constructs Configuration Interaction Singles/Doubles (CIS/CISD) style excitation amplitudes expressed as Full CI (FCI) string addresses. For a given number of orbitals (norb), electrons (nelec) and an excitation level (n_excite), it enumerates all determinants reachable by exciting n_excite electrons from the occupied (hole) orbital subspace to the virtual (particle) subspace of the HF reference, returns the integer FCI addresses for those determinants, and computes the sign (+1 or -1) required to convert coefficients defined with the "physics" vacuum ordering into the HF vacuum ordering used by downstream PySCF routines. The implementation uses cistring.gen_strings4orblist to generate hole and particle bit-strings and cistring.strs2addr to convert combined bit-strings into FCI addresses.` |
| `pyscf_ci_cisd_from_fcivec` | `pyscf.ci.cisd.from_fcivec` | `pyscf/ci/cisd.py` | `ci0: numpy.ndarray, norb: int, nelec: int, frozen: int = None` | `Extract CISD amplitudes from a full configuration interaction (FCI) vector. This function converts a PySCF FCI representation (ci0) into the compact set of CISD amplitudes used by PySCF CISD routines. It reads the reference (scalar) coefficient, the single-excitation block, and the double-excitation block from the FCI matrix form and assembles them into the CISD vector ordering produced by amplitudes_to_cisdvec. This conversion is used in workflows where one wants to initialize or compare CISD calculations from a full-CI result in the PySCF quantum chemistry framework (see PySCF README and CI modules).` |
| `pyscf_ci_cisd_overlap` | `pyscf.ci.cisd.overlap` | `pyscf/ci/cisd.py` | `cibra: numpy.ndarray, ciket: numpy.ndarray, nmo: int, nocc: int, s: numpy.ndarray = None` | `pyscf.ci.cisd.overlap computes the scalar overlap ‚ü®Œ®_bra \| Œ®_ket‚ü© between two CISD (Configuration Interaction with Single and Double excitations) wavefunctions represented as CISD vectors. In the PySCF quantum-chemistry framework this routine is used to evaluate the inner product of two CISD wavefunctions either in an orthonormal one-particle basis (fast path) or in a non-orthogonal one-particle basis by explicitly building many-body transformation matrices from determinants of orbital-overlap minors. The returned overlap is a single floating-point number used, for example, in state-overlap assessments, non-orthogonal CI analyses, and post-processing of CISD calculations.` |
| `pyscf_ci_gcisd_to_ucisdvec` | `pyscf.ci.gcisd.to_ucisdvec` | `pyscf/ci/gcisd.py` | `civec: numpy.ndarray, nmo: int, nocc: int, orbspin: list` | `Convert a GCISD coefficient vector to a UCISD coefficient vector. This function is part of the PySCF quantum chemistry library and is used to transform a CI (configuration interaction) wavefunction represented in a generalized CI single-and-double (GCISD) spin-orbital basis into the unrestricted CISD (UCISD) spatial-orbital representation used by the ucisd module. The conversion proceeds by decomposing the input GCISD coefficient vector into reference, single, and double excitation amplitudes (c0, c1, c2) using cisdvec_to_amplitudes, mapping spin-orbital amplitudes to spatial-orbital amplitudes with spin2spatial according to orbspin, and recombining the spatial amplitudes into a UCISD coefficient vector via ucisd.amplitudes_to_cisdvec. The routine checks the norm of the resulting UCISD vector to detect spin-flip excitations: if the UCISD norm is extremely small, the function raises RuntimeError; if the norm is significantly reduced (< 0.99) a warning is emitted and spin-flip components are ignored in the returned UCISD vector.` |
| `pyscf_ci_cisd_to_fcivec` | `pyscf.ci.cisd.to_fcivec` | `pyscf/ci/cisd.py` | `cisdvec: numpy.ndarray, norb: int, nelec: int, frozen: list = None` | `Convert CISD amplitudes (c0, c1, c2) into an FCI coefficient matrix suitable for FCI-based routines. This function is used in PySCF's configuration interaction utilities to map a restricted CISD wavefunction (a closed-shell CISD amplitude vector) into an FCI representation on a determinant/string basis. The input cisdvec is interpreted as the packed CISD coefficient vector that encodes the reference coefficient (c0), single excitations (c1) and double excitations (c2) for a closed-shell system. The output is a dense square numpy.ndarray whose rows and columns index alpha- and beta-string occupations (FCI basis). If frozen orbitals are provided, the function expands the active-space CISD amplitudes to the full orbital space, applying the required parity (phase) corrections so the resulting FCI coefficients correspond to the full norb orbital ordering used elsewhere in PySCF.` |
| `pyscf_data_nucprop_g_factor_to_gyromagnetic_ratio` | `pyscf.data.nucprop.g_factor_to_gyromagnetic_ratio` | `pyscf/data/nucprop.py` | `g: float` | `pyscf.data.nucprop.g_factor_to_gyromagnetic_ratio converts a nuclear g-factor to the gyromagnetic ratio expressed as a Larmor precession frequency per unit magnetic field (Hz per Tesla). This utility is used in the PySCF properties and NMR-related code paths to translate a dimensionless nuclear g-factor into a physically meaningful frequency-per-field quantity for spectroscopy and magnetic-response calculations.` |
| `pyscf_ci_gcisd_from_rcisdvec` | `pyscf.ci.gcisd.from_rcisdvec` | `pyscf/ci/gcisd.py` | `civec: numpy.ndarray, nocc: int, orbspin: numpy.ndarray` | `Convert a (spin-separated) CISD coefficient vector (RCISD or UCISD) into a GCISD coefficient vector suitable for PySCF generalized-CISD routines. This function is used within the PySCF quantum-chemistry framework to translate CISD coefficient vectors that are expressed in restricted (spatial) or unrestricted (separate alpha/beta) formats into a generalized (spin-orbital) CISD coefficient vector. The conversion is useful when downstream GCISD code in pyscf.ci.gcisd expects a single spin-orbital-ordered vector produced by amplitudes_to_cisdvec(c0, c1, c2). Internally the function detects whether the input vector corresponds to an RCISD (spin-restricted CISD) or a UCISD (spin-unrestricted CISD) representation, extracts amplitudes via cisd.cisdvec_to_amplitudes or ucisd.cisdvec_to_amplitudes, maps spatial amplitudes to spin-orbital amplitudes using the orbspin index map (spatial2spin), and reassembles the GCISD-format vector with amplitudes_to_cisdvec.` |
| `pyscf_ci_ucisd_overlap` | `pyscf.ci.ucisd.overlap` | `pyscf/ci/ucisd.py` | `cibra: numpy.ndarray, ciket: numpy.ndarray, nmo: tuple, nocc: tuple, s: list = None` | `pyscf.ci.ucisd.overlap Compute the overlap (inner product) between two CISD (Configuration Interaction with Singles and Doubles) wavefunction vectors. This function is part of the PySCF quantum-chemistry package and is used to evaluate overlaps between CISD many-electron states either in an orthonormal one-particle basis (fast path) or in a non-orthogonal one-particle basis (general path that transforms determinants by computing minors of the one-particle overlap matrices). In the PySCF domain this overlap is used when comparing states, building transition properties, or projecting wavefunctions defined in different molecular-orbital bases.` |
| `pyscf_dft_libxc_is_gga` | `pyscf.dft.libxc.is_gga` | `pyscf/dft/libxc.py` | `xc_code: str` | `pyscf.dft.libxc.is_gga: Determine whether a given exchange-correlation functional identifier corresponds to a Generalized Gradient Approximation (GGA) functional. This function is used in the PySCF density-functional subsystem to classify Libxc/XCFun-style exchange-correlation functionals by their type. In practical DFT workflows within PySCF, knowing that a functional is a GGA signals that the functional depends on the electron density and its gradient (‚àáœÅ) but not higher-order derivatives; this information is used to choose integration grids, to enable gradient-dependent terms in numerical evaluation, and to select appropriate functional evaluation code paths. The implementation delegates the classification to the helper function xc_type(xc_code) and performs an exact string comparison against the category name 'GGA' as returned by xc_type. The comparison is therefore sensitive to the exact output of xc_type and to its case and spelling.` |
| `pyscf_dft_gen_grid_original_becke` | `pyscf.dft.gen_grid.original_becke` | `pyscf/dft/gen_grid.py` | `g: numpy.ndarray` | `pyscf.dft.gen_grid.original_becke computes the original Becke smoothing transformation used in atomic partitioning of numerical integration grids for density functional theory. The implementation follows Becke, J. Chem. Phys. 88, 2547 (1988), DOI:10.1063/1.454033, and corresponds to applying the cubic smoothing polynomial g <- 0.5*(3 - g**2)*g three times to the input switching variable array. This routine is the reference Python-level formulation; performance-sensitive code in PySCF uses an optimized C implementation (VXCgen_grid).` |
| `pyscf_dft_gen_grid_treutler_prune` | `pyscf.dft.gen_grid.treutler_prune` | `pyscf/dft/gen_grid.py` | `nuc: int, rads: numpy.ndarray, n_ang: int, radii: numpy.ndarray = None` | `Treutler-Ahlrichs pruning rule to assign angular-quadrature sizes to radial grid points for a given nucleus. This function implements the Treutler‚ÄìAhlrichs pruning heuristic used in PySCF's grid generation for density-functional calculations (see PySCF README and gen_grid usage). Given the radial grid coordinates along a radial axis for one nucleus, it partitions the radial points into three contiguous groups (first third, middle third, remaining third) and assigns a Lebedev angular-grid size to each radial point: the inner group is assigned 14 angular points (corresponding to Lebedev order l=5), the middle group 50 angular points (l=11), and the outer group is assigned the provided n_ang value (maximum angular resolution). The returned integer array is intended to be consumed by higher-level grid construction routines to determine how many angular quadrature points are used at each radial shell for this nucleus.` |
| `pyscf_dft_gen_grid_stratmann` | `pyscf.dft.gen_grid.stratmann` | `pyscf/dft/gen_grid.py` | `g: numpy.ndarray` | `pyscf.dft.gen_grid.stratmann computes the Stratmann‚ÄìScuseria‚ÄìFrisch switching function (CPL, 257, 213 (1996); DOI:10.1016/0009-2614(96)00600-8) used in PySCF density-functional-theory (DFT) grid construction and atomic partitioning. The implementation follows Eq. 14 of the reference with the internal parameter a = 0.64 and evaluates a degree-7 odd polynomial inside the interval [-a, a], while clamping values to ¬±1 outside that interval. In the context of pyscf.dft.gen_grid, this function provides the elementwise scalar mapping used to produce smooth, compact switch values that appear in weighted numerical integration over molecular DFT grids.` |
| `pyscf_dft_libxc_is_meta_gga` | `pyscf.dft.libxc.is_meta_gga` | `pyscf/dft/libxc.py` | `xc_code: str` | `Returns whether the given exchange-correlation functional identifier corresponds to a meta-generalized-gradient-approximation (meta-GGA) functional. This function is used in the PySCF DFT integration with external functional libraries (for example Libxc, which PySCF delegates functional evaluation to). In PySCF workflows this predicate informs higher-level code whether special treatment for meta-GGA functionals is required (for example, supplying the kinetic energy density tau or handling orbital-dependent terms), because meta-GGAs are labeled with the type string 'MGGA' by the internal xc_type lookup.` |
| `pyscf_dft_libxc_parse_xc_name` | `pyscf.dft.libxc.parse_xc_name` | `pyscf/dft/libxc.py` | `xc_name: str = "LDA,VWN"` | `Convert the XC (exchange‚Äìcorrelation) functional name to the libxc library internal IDs for the primary exchange and correlation components used by PySCF density-functional calculations.` |
| `pyscf_dft_libxc_define_xc_` | `pyscf.dft.libxc.define_xc_` | `pyscf/dft/libxc.py` | `ni: int, description: str, xctype: str = "LDA", hyb: float = 0, rsh: list = (0, 0, 0)` | `Define XC functional for a PySCF NumInt instance and attach evaluation and metadata helpers used by the PySCF DFT machinery. This function is used in the PySCF density-functional workflow to configure how exchange‚Äìcorrelation (XC) energy, potential, and higher derivatives are computed for a given numerical integrator (NumInt). It accepts either a descriptive string that names/combines LibXC/XCFun-style functionals or a user-supplied callable implementing the same eval_xc interface. The function sets ni.eval_xc to a callable that evaluates the requested XC model, and also sets helper callables ni.hybrid_coeff, ni.rsh_coeff, and ni._xc_type that return the hybrid mixing coefficient, range-separated hybrid (RSH) coefficients, and nominal XC family ('LDA'/'GGA'/'MGGA'), respectively. It also provides ni.eval_xc1, a wrapper that adapts the lower-level eval_xc output into the shape and ordering expected by the rest of PySCF (handling spin, derivative order, and special-case reordering for MGGA fxc arrays).` |
| `pyscf_dft_libxc_unregister_custom_functional_` | `pyscf.dft.libxc.unregister_custom_functional_` | `pyscf/dft/libxc.py` | `xc_code: str` | `pyscf.dft.libxc.unregister_custom_functional_ unregisters a previously registered custom exchange-correlation (XC) functional from the module-level registries used by PySCF's DFT interface to external functional evaluators such as Libxc. This function is the counterpart to register_custom_functional_, and it removes the functional identified by its string name from both the spin-restricted and spin-unrestricted custom-functional registries so that subsequent DFT evaluations in PySCF will no longer use the custom implementation for that name.` |
| `pyscf_dft_libxc_nlc_coeff` | `pyscf.dft.libxc.nlc_coeff` | `pyscf/dft/libxc.py` | `xc_code: str` | `pyscf.dft.libxc.nlc_coeff returns the non-local correlation (NLC) coefficients associated with a density-functional approximation (DFA) identified by the given functional code. This accessor is used in PySCF DFT workflows that rely on external functional libraries (for example Libxc or XCFun) to obtain parameters required by non-local correlation (dispersion-like) components of certain functionals.` |
| `pyscf_dft_libxc_hybrid_coeff` | `pyscf.dft.libxc.hybrid_coeff` | `pyscf/dft/libxc.py` | `xc_code: str, spin: int = 0` | `pyscf.dft.libxc.hybrid_coeff: Return the hybrid-exchange coefficient descriptor for a named exchange‚Äìcorrelation (XC) functional. This helper looks up the internal XC descriptor for the functional identified by xc_code (via the module-private helper _get_xc) and returns its hybrid_coeff attribute. In the PySCF DFT workflow this value is used to determine how much exact (Hartree‚ÄìFock) exchange is mixed into the density functional; the value is provided by the underlying XC library (for example Libxc or XCFun) and may be a simple scalar or a more complex descriptor for range-separated or multi-component hybrids. The function performs no modification of global state and simply forwards the hybrid coefficient information from the XC descriptor to the caller.` |
| `pyscf_dft_libxc_define_xc` | `pyscf.dft.libxc.define_xc` | `pyscf/dft/libxc.py` | `ni: int, description: str, xctype: str = "LDA", hyb: float = 0, rsh: list = (0, 0, 0)` | `pyscf.dft.libxc.define_xc: Create and register an exchange‚Äìcorrelation (XC) functional descriptor for use by PySCF's DFT routines and the external XC evaluation libraries (Libxc or XCFun). This wrapper forwards parameters to the internal helper define_xc_ after making a shallow copy of the provided ni argument to avoid unintended modification by downstream code. In the PySCF workflow this function is used to specify which exchange and correlation functional (and any hybrid or range-separation parameters) should be used when delegating energy and potential evaluations to external libraries; the returned descriptor is consumed by DFT drivers, numerical integrators, and wrappers that call Libxc/XCFun.` |
| `pyscf_dft_libxc_eval_xc` | `pyscf.dft.libxc.eval_xc` | `pyscf/dft/libxc.py` | `xc_code: str, rho: numpy.ndarray, spin: int = 0, relativity: int = 0, deriv: int = 1, omega: float = None, verbose: int = None` | `pyscf.dft.libxc.eval_xc evaluates exchange‚Äìcorrelation (XC) energy, potentials, and higher-order functional derivatives by calling the external libxc library. This function is used inside PySCF density-functional calculations to obtain the local XC energy density (exc), the first functional derivatives that form the XC potential (vxc), the second derivatives used for response kernels (fxc), and optional third derivatives (kxc). It accepts a libxc-style functional description string (xc_code) and a grid-wise density array (rho) and returns libxc outputs mapped into PySCF conventions for restricted (spin=0) and unrestricted (spin>0) DFT.` |
| `pyscf_dft_libxc_parse_xc` | `pyscf.dft.libxc.parse_xc` | `pyscf/dft/libxc.py` | `description: str` | `pyscf.dft.libxc.parse_xc parses and decodes an XC (exchange‚Äìcorrelation) functional description string used by PySCF to interface with external functional libraries such as LibXC. The function translates a compact, human-editable description (for example ".8*LDA+.2*B86,VWN" or "B3LYP") into a machine-readable representation used by PySCF to assemble exchange and correlation contributions, to determine exact-exchange (HF) fractions, and to configure range-separated hybrids (RSH/SR_HF/LR_HF). This parser is used in density functional calculations within PySCF to map user-specified functional formulas to libxc numeric identifiers and fractional coefficients and to extract hybrid parameters required by the SCF and DFT routines.` |
| `pyscf_dft_libxc_xc_reference` | `pyscf.dft.libxc.xc_reference` | `pyscf/dft/libxc.py` | `xc_code: str` | `pyscf.dft.libxc.xc_reference returns the bibliographic reference(s) associated with a Libxc exchange-correlation (XC) functional identifier. In the PySCF DFT workflow, PySCF delegates evaluation of density functionals to external libraries such as Libxc; this function provides the canonical citation information for the exact XC functional requested, which is required for properly crediting the source of the functional in publications and reports (see README section on citing Libxc).` |
| `pyscf_dft_radi_mura_knowles` | `pyscf.dft.radi.mura_knowles` | `pyscf/dft/radi.py` | `n: int, charge: int = None, *args, **kwargs` | `pyscf.dft.radi.mura_knowles: Generate Mura‚ÄìKnowles (JCP 1996, DOI:10.1063/1.471749) log3 quadrature radial grid points and their index-derivatives for use in PySCF density-functional-theory (DFT) atom-centered radial integration. This function is used in the DFT radial grid construction pipeline to produce a one-dimensional radial mesh r and the corresponding derivative values dr that are used to form radial integration weights for numerical quadrature on atomic centers.` |
| `pyscf_dft_radi_treutler` | `pyscf.dft.radi.treutler` | `pyscf/dft/radi.py` | `n: int, chg: int, *args, **kwargs` | `pyscf.dft.radi.treutler: utilities for Treutler‚ÄìAhlrichs radial grids used in PySCF density functional integration. This function constructs the Treutler‚ÄìAhlrichs (M4) mapping of a 1D radial quadrature grid and its corresponding radial increments. The radial grid produced here is the radial component used in atomic quadrature rules for numerical integration of exchange‚Äìcorrelation contributions in density functional calculations performed with PySCF. The implementation follows the mapping described in Treutler and Ahlrichs, J. Chem. Phys. 102, 346 (1995) and returns arrays ordered with increasing radius suitable for combination with angular weights to form full atomic quadrature weights.` |
| `pyscf_dft_radi_gauss_chebyshev` | `pyscf.dft.radi.gauss_chebyshev` | `pyscf/dft/radi.py` | `n: int, *args, **kwargs` | `Gauss-Chebyshev radial grid generator used in PySCF density-functional calculations. Implements the Gauss‚ÄìChebyshev radial mapping described in J. Chem. Phys. 108, 3226 (1998) (DOI: 10.1063/1.475719) to produce a one-dimensional sequence of radial coordinates and their associated differential weights. This function is used by PySCF's DFT integration routines to build atomic radial grids (unitless, logarithmically scaled in the implementation) for numerical integration of radial parts of atomic orbitals and density-related quantities.` |
| `pyscf_dft_radi_becke` | `pyscf.dft.radi.becke` | `pyscf/dft/radi.py` | `n: int, charge: int, *args, **kwargs` | `pyscf.dft.radi.becke: Generate radial quadrature points and weights using Becke (J. Chem. Phys. 1988) Gauss‚ÄìChebyshev quadrature of the second kind for atomic radial integration. This function constructs a one-dimensional radial grid (points r and weights w) intended for use in PySCF's DFT radial integration routines. It implements the node/weight construction described by Becke (JCP 88, 2547 (1988); DOI:10.1063/1.454033) by (1) forming Gauss‚ÄìChebyshev nodes t and base weights on the interval [-1, 1] for the second kind, (2) adjusting those weights to remove the intrinsic sqrt(1 - t^2) weighting of the Chebyshev rule, and (3) applying the change of variables r = (1 + t)/(1 - t) * rm to map the domain to (0, +inf) where rm is chosen from BRAGG_RADII according to the supplied charge. The produced arrays r and w are suitable for numerical integration of radial parts of molecular/atomic functions (for example, the radial factor of basis functions or electron density) when assembling DFT integration grids in PySCF.` |
| `pyscf_dft_radi_delley` | `pyscf.dft.radi.delley` | `pyscf/dft/radi.py` | `n: int, *args, **kwargs` | `pyscf.dft.radi.delley ‚Äî Generate B. Delley radial grid points and their discrete derivatives for use in density-functional-theory (DFT) radial integration within the PySCF framework. Generates an array of n radial coordinates and a corresponding array of discrete derivatives using the log2 mapping described by B. Delley (J. Chem. Phys. 104, 9848 (1996); DOI:10.1063/1.471749). The implementation follows the "log2 algorithm" variant: it maps a uniform index variable into a monotonically increasing radial coordinate that spans from small radii up to a fixed outer radius (r_outer = 12.0 in the source code). This routine is intended to provide the radial nodes and a local spacing factor used by PySCF DFT radial quadratures (atomic radial grids) when assembling numerical integration weights in electronic-structure calculations.` |
| `pyscf_dft_xc_utils_format_xc_code` | `pyscf.dft.xc.utils.format_xc_code` | `pyscf/dft/xc/utils.py` | `description: str` | `pyscf.dft.xc.utils.format_xc_code formats and normalizes a user-supplied density-functional exchange‚Äìcorrelation (XC) description string for use inside PySCF. In the PySCF DFT workflow (which delegates functional evaluation to external libraries such as Libxc or XCFun), this function is used to produce a compact, upper-cased, whitespace-free representation of an XC description and to translate range-separated-hybrid (RSH) parameter notation from the common RSH(omega, alpha, beta) form into the internal RSH(alpha; beta; omega) form expected by downstream PySCF parsers and code. This function performs the following concrete operations observed in the source code: 1. Removes all ASCII space characters and newline characters from description, then converts the entire string to upper case. This normalization makes functional names and tokens consistent with PySCF‚Äôs downstream parsing and with conventions used when citing or delegating to external XC libraries. 2. If the token 'RSH' is absent after normalization, returns the normalized string unchanged. 3. If one or more 'RSH' fragments are present, splits the string on the substring 'RSH' and for each fragment of the form RSH(omega,alpha,beta) rewrites it as RSH(alpha;beta;omega) by moving the first numeric parameter (omega) to the final position and replacing commas between the three parameters with semicolons in the internal notation. Non-RSH parts of the description are preserved in their normalized form and rejoined with the literal substring 'RSH'.` |
| `pyscf_dft_xc_deriv_count_combinations` | `pyscf.dft.xc_deriv.count_combinations` | `pyscf/dft/xc_deriv.py` | `nvar: int, order: int` | `pyscf.dft.xc_deriv.count_combinations counts combinatorial multiplicities used when enumerating derivative components for exchange‚Äìcorrelation (XC) functionals in density-functional-theory (DFT) code paths. In the PySCF DFT/xc_deriv context this function provides the integer number of distinct multisets (combinations with replacement) that arise when selecting "order" items from "nvar" independent variables; this count is used to size and index arrays that store unique derivative terms of XC quantities (for example when building higher-order functional derivatives or allocating storage for symmetrized derivative tensors). The original source-level hint for the intent was the expression sum(len(combinations_with_replacement(range(nvar), o) for o in range(order)), and the implementation returns the closed-form combinatorial value via lib.comb(nvar+order, order).` |
| `pyscf_dft_sap_sap_effective_charge` | `pyscf.dft.sap.sap_effective_charge` | `pyscf/dft/sap.py` | `Z: int, r: numpy.ndarray` | `pyscf.dft.sap.sap_effective_charge computes the effective (screened) nuclear charge Z(r) used in the Superposition of Atomic Potentials (SAP) initial guess for self-consistent field (SCF) electronic-structure calculations. The implementation returns exchange-only LDA based effective charges for neutral, spherically symmetric atoms derived from precomputed numerical data (sap_Zeff) and is intended to provide the screened charge as a function of radial distance for constructing SAP potentials as described in the cited references. This function is used in the PySCF SAP module to provide a radial profile of the screened nuclear charge for each atomic number Z when building initial potentials for SCF procedures. The underlying data (sap_Zeff) contain numerically precomputed effective-charge profiles obtained from fully numerical finite-element atomic calculations and spherically symmetric unrestricted Hartree‚ÄìFock references; the function interpolates those profiles to the requested radii.` |
| `pyscf_dft_xc_deriv_ud2ts` | `pyscf.dft.xc_deriv.ud2ts` | `pyscf/dft/xc_deriv.py` | `v_ud: numpy.ndarray` | `pyscf.dft.xc_deriv.ud2ts converts exchange‚Äìcorrelation (XC) derivative arrays from the spin-up/spin-down ("u","d" or "a","b") representation to the total-density/spin-density ("rho","s") representation used in PySCF's DFT grid-based integrals and response calculations. This conversion is commonly needed when evaluating XC potentials and kernels coming from spin-resolved functional evaluations (external XC libraries) and when downstream routines expect total- and spin-density derivative components. The routine delegates the low-level memory transformation to the compiled helper libdft.VXCud2ts for performance. This function accepts a NumPy array containing XC derivatives in a spin-channel representation and returns a NumPy array of the same shape and dtype containing the corresponding derivatives in the total-density / spin-density representation. The conversion implemented corresponds to the linear map vrho = (va + vb)/2 and vs = (va - vb)/2 applied to the spin channels, applied across the array layout used by PySCF's grid-based XC derivative machinery.` |
| `pyscf_dft_xc_deriv_ts2ud` | `pyscf.dft.xc_deriv.ts2ud` | `pyscf/dft/xc_deriv.py` | `v_ts: numpy.ndarray` | `Convert exchange‚Äìcorrelation (XC) derivative tensors from the total-density / spin-density ("ts") representation to the spin-up / spin-down ("u/d") representation used in spin-polarized density-functional calculations. This function is used within PySCF's DFT machinery to transform arrays of XC derivatives computed or accumulated in the combined total/spin channel basis into the separate spin-up and spin-down channel basis expected by other parts of the code (for example, when assembling spin-dependent potentials or response properties). The conversion is performed by calling the compiled routine libdft.VXCts2ud for efficient, elementwise mapping across grid points and batched derivative tensors.` |
| `pyscf_dft_xc_deriv_transform_xc` | `pyscf.dft.xc_deriv.transform_xc` | `pyscf/dft/xc_deriv.py` | `rho: numpy.ndarray, xc_val: numpy.ndarray, xctype: str, spin: int, order: int` | `pyscf.dft.xc_deriv.transform_xc: General transformation to construct the exchange-correlation (XC) derivative tensor used in PySCF density-functional calculations. This function transforms raw, library-provided XC values (xc_val) and the input density descriptor (rho) into a full tensor of XC derivatives of a specified order. It is used in the DFT/XC evaluation and response code paths in PySCF to build the derivative objects required for computing potentials, kernels, and higher-order response contributions. The transformation dispatches different routines for local (LDA, HF) and generalized-gradient (GGA and beyond) type functionals, accounts for spin convention (spin-restricted vs spin-polarized), and assembles contributions from lower-order sigma (\|‚àáœÅ\|^2) terms into the requested higher-order derivative tensor.` |
| `pyscf_dft_xcfun_nlc_coeff` | `pyscf.dft.xcfun.nlc_coeff` | `pyscf/dft/xcfun.py` | `xc_code: str` | `pyscf.dft.xcfun.nlc_coeff ‚Äî Extract nonlocal correlation (NLC) coefficients from an XCFun-style XC code for use in PySCF density-functional calculations. This function parses an XCFun exchange‚Äìcorrelation specification string (xc_code) using PySCF's parse_xc routine and returns the nonlocal-correlation (NLC) components associated with the VV10-style family of functionals. In the context of PySCF DFT and the XCFun integration (see README), NLC refers to nonlocal correlation terms (for example, VV10 variants) that contribute to the total DFT energy and potentials. The returned coefficients are the names (from the internal VV10_XC mapping) and their corresponding multiplicative scaling factors as extracted from the parsed functional specification. The function upper-cases the xc_code internally, filters parsed functional components for those with numeric ids >= 5000 (the VV10/NLC id range used in the codebase), and preserves the ordering and factors produced by parse_xc.` |
| `pyscf_dft_xc_deriv_transform_vxc` | `pyscf.dft.xc_deriv.transform_vxc` | `pyscf/dft/xc_deriv.py` | `rho: numpy.ndarray, vxc: list, xctype: str, spin: int = 0` | `Transform libxc functional derivatives into the derivative tensor of density-related parameters used by PySCF for grid-based exchange‚Äìcorrelation (XC) potential assembly. This function takes the raw derivative arrays returned by a libxc-like evaluator (vxc) and arranges / contracts them with the local density parameter array (rho) to produce the XC derivative tensor vp. The output vp is the derivative of the XC energy density with respect to the local parameters stored in rho (density, gradient components, and kinetic-energy density tau), in the ordering and shapes expected by downstream PySCF DFT code that assembles potentials on integration grids.` |
| `pyscf_dft_xcfun_define_xc` | `pyscf.dft.xcfun.define_xc` | `pyscf/dft/xcfun.py` | `ni: int, description: str, xctype: str = "LDA", hyb: float = 0, rsh: tuple = (0, 0, 0)` | `Define an exchange‚Äìcorrelation (XC) functional in the XCFun wrapper used by PySCF's DFT modules. This is a thin wrapper that delegates to the compiled function define_xc_. The call performed is define_xc_(ni.copy(), description, xctype, hyb, rsh). The function constructs or registers an XC functional description in the XCFun backend so that PySCF can evaluate XC energies, potentials, and response properties during density-functional calculations. The implementation makes a defensive shallow copy of the provided ni value (via ni.copy()) before forwarding it to the underlying binding to avoid mutating caller-owned data structures.` |
| `pyscf_dft_xc_deriv_transform_lxc` | `pyscf.dft.xc_deriv.transform_lxc` | `pyscf/dft/xc_deriv.py` | `rho: numpy.ndarray, fxc: numpy.ndarray, kxc: numpy.ndarray, lxc: numpy.ndarray, xctype: str, spin: int = 0` | `pyscf.dft.xc_deriv.transform_lxc transforms libxc/xcfun vxc functional output into the derivative tensor with respect to the local parameter vector rho used by PySCF DFT code. The function maps the functional derivative arrays produced by libxc (fxc, kxc, lxc) onto the internal ordering of density-related parameters rho = [density, nabla_x, nabla_y, nabla_z, tau], producing a tensor used by PySCF to assemble exchange‚Äìcorrelation kernels and response quantities.` |
| `pyscf_dft_xcfun_rsh_coeff` | `pyscf.dft.xcfun.rsh_coeff` | `pyscf/dft/xcfun.py` | `xc_code: str` | `pyscf.dft.xcfun.rsh_coeff: Extract range-separated-hybrid (RSH) parameters from an exchange‚Äìcorrelation functional code.` |
| `pyscf_dft_xc_deriv_transform_kxc` | `pyscf.dft.xc_deriv.transform_kxc` | `pyscf/dft/xc_deriv.py` | `rho: numpy.ndarray, fxc: list, kxc: list, xctype: str, spin: int = 0` | `Transform libxc/XCFun kernel derivatives into the derivative tensor of the rho parameters used by PySCF density-functional integration routines. This function is used inside the PySCF DFT pipeline to convert the raw functional derivative arrays produced by external density-functional libraries (e.g. LibXC or XCFun) into the structured derivative tensor indexed by the local variables that PySCF stores per integration grid point. The rho parameter vector referenced throughout this function corresponds to the per-grid-point quantities in the order: density_a, (nabla_x)_a, (nabla_y)_a, (nabla_z)_a, tau_a for spin channel a (and similarly for spin channel b when spin=1). The output tensor produced by transform_kxc is the kernel of second/third/... order derivatives organized consistently with the rho parameter ordering; this tensor is consumed by PySCF routines that assemble weighted integrals of functional derivatives across grids to form potentials, response contributions, and higher-order terms in DFT calculations.` |
| `pyscf_dft_xcfun_eval_xc1` | `pyscf.dft.xcfun.eval_xc1` | `pyscf/dft/xcfun.py` | `xc_code: str, rho: numpy.ndarray, spin: int = 0, deriv: int = 1, omega: float = None` | `pyscf.dft.xcfun.eval_xc1 evaluates an exchange-correlation (XC) functional and its derivatives by calling the XCFun backend via PySCF's xcfun wrapper. This function is used in PySCF density-functional calculations to obtain the XC energy density and higher-order derivatives on a set of real-space integration grid points; the output ordering of derivative components follows the XCFun convention used by the underlying C library. The implementation accepts local, semi-local, and hybrid functionals (types 'HF', 'LDA', 'GGA', 'MGGA') and supports up to MAX_DERIV_ORDER derivatives as asserted at runtime.` |
| `pyscf_fci_addons_civec_spinless_repr` | `pyscf.fci.addons.civec_spinless_repr` | `pyscf/fci/addons.py` | `ci0_r: list, norb: int, nelec_r: list` | `pyscf.fci.addons.civec_spinless_repr converts a set of CAS-CI vectors from a spin-pure representation into a spinless representation so they can be linearly combined across different spin projections M. In the context of PySCF's FCI add-ons, this is used to map a problem with norb spatial orbitals and separate alpha/beta electron counts (neleca, nelecb) into an equivalent spinless problem with 2 * norb orbitals and (neleca+nelecb, 0) electron partitioning. The function preserves the input array datatype, makes copies of the converted vectors, and returns a stacked ndarray containing the spinless CAS-CI vectors for subsequent CAS-CI manipulations or post-processing that require a common spinless basis.` |
| `pyscf_fci_addons_cre_b` | `pyscf.fci.addons.cre_b` | `pyscf/fci/addons.py` | `ci0: numpy.ndarray, norb: int, neleca_nelecb: tuple, ap_id: int` | `pyscf.fci.addons.cre_b constructs an (N+1)-electron configuration-interaction (CI) wavefunction by applying a beta-spin electron creation operator to an input N-electron CI wavefunction. This routine is part of the PySCF FCI addons used to manipulate CI coefficient arrays expressed in the occupation-string basis (rows index alpha strings, columns index beta strings). It maps each input beta string to the newly created beta string indices using cistring.gen_cre_str_index and applies the fermionic sign factors; an additional sign flip is applied when the number of alpha electrons is odd to account for operator interchange between alpha and beta spins.` |
| `pyscf_fci_addons_cre_a` | `pyscf.fci.addons.cre_a` | `pyscf/fci/addons.py` | `ci0: numpy.ndarray, norb: int, neleca_nelecb: tuple, ap_id: int` | `Construct (N+1)-electron CI wavefunction by applying an alpha-electron creation operator to an N-electron CI wavefunction in PySCF's FCI addon. This function is used in the pyscf.fci.addons module to build the second-quantized state \|N+1> = a^+_p \|N>, where an alpha electron is created in orbital ap_id. It is intended for Full Configuration Interaction (FCI) workflows in PySCF where one needs to add an alpha electron to an existing configuration interaction (CI) coefficient array (for example, when constructing states with one extra alpha electron or building excitation/de-excitation operators). The input CI is organized with rows indexing alpha occupation bit-strings and columns indexing beta occupation bit-strings; the output has the same column dimension (beta strings) but a larger number of rows corresponding to one more alpha electron.` |
| `pyscf_dft_xc_deriv_transform_fxc` | `pyscf.dft.xc_deriv.transform_fxc` | `pyscf/dft/xc_deriv.py` | `rho: numpy.ndarray, vxc: list, fxc: list, xctype: str, spin: int = 0` | `Transform libxc / XCFun exchange-correlation functional derivatives into the derivative tensor of the local density parameters carried in rho. In density-functional theory (DFT) implementations inside PySCF, external libraries (for example Libxc or XCFun) provide functional derivatives of the exchange-correlation energy with respect to scalar and gradient-dependent variables. This function rearranges and combines those derivatives into a tensor that matches the parameter ordering used by PySCF grid-based DFT routines: each parameter vector is ordered as [density, (nabla_x), (nabla_y), (nabla_z), tau] and, for spin-polarized cases, there are separate blocks for the two spin channels (commonly denoted "a" and "b"). The output tensor produced by this routine contains the second derivatives of the exchange-correlation energy with respect to those parameters at each grid point, suitable for forming response kernels and assembling matrix elements in PySCF DFT response and property calculations.` |
| `pyscf_fci_addons_des_b` | `pyscf.fci.addons.des_b` | `pyscf/fci/addons.py` | `ci0: numpy.ndarray, norb: int, neleca_nelecb: tuple, ap_id: int` | `pyscf.fci.addons.des_b Construct an (N-1)-electron configuration interaction (CI) wavefunction by applying a beta-spin electron annihilation operator to an N-electron CI wavefunction. This function is used in the PySCF FCI addons to obtain the CI vector that results from removing one beta electron from a specified spatial orbital; it is commonly used when building reduced-density matrices, computing transition amplitudes that involve electron removal, or when constructing intermediate states in FCI-based post-processing.` |
| `pyscf_fci_addons_des_a` | `pyscf.fci.addons.des_a` | `pyscf/fci/addons.py` | `ci0: numpy.ndarray, norb: int, neleca_nelecb: tuple, ap_id: int` | `Construct (N-1)-electron wavefunction by removing an alpha electron from the N-electron wavefunction in the PySCF FCI addon. This function implements the second-quantized annihilation operator a_p acting on the alpha-spin part of a full-configuration-interaction (FCI) CI vector, returning a new CI array that represents the state \|N-1> = a_p \|N>. It is used in PySCF for tasks that require explicit electron removal on the alpha spin manifold (for example, forming Dyson orbitals, computing ionization amplitudes, or intermediate steps in spin-adapted FCI manipulations).` |
| `pyscf_fci_addons_initguess_triplet` | `pyscf.fci.addons.initguess_triplet` | `pyscf/fci/addons.py` | `norb: int, nelec: tuple, binstring: str` | `pyscf.fci.addons.initguess_triplet: Generate a normalized triplet initial guess CI vector/matrix for the PySCF FCI solver. Constructs a simple, normalized initial configuration interaction (CI) guess intended to represent a spin triplet (M_S = 0) combination for use as a starting vector in Full Configuration Interaction (FCI) diagonalization or iterative solvers within the PySCF quantum chemistry framework. The routine uses the number of spatial orbitals, the alpha/beta electron counts, and a binary occupation string that selects a particular Slater determinant (address) in one spin sector. Internally it uses cistring.num_strings to determine the number of alpha and beta string basis functions and cistring.str2addr to map the provided binary occupation pattern to the integer address of that determinant. The returned CI array has only two nonzero entries, +sqrt(1/2) and -sqrt(1/2), producing a normalized antisymmetric combination between the two determinants needed to form the triplet M_S = 0 state. This initial guess is useful in practical FCI workflows to bias the solver toward a triplet state and to accelerate convergence when a triplet solution is expected.` |
| `pyscf_fci_addons_transform_ci` | `pyscf.fci.addons.transform_ci` | `pyscf/fci/addons.py` | `ci: numpy.ndarray, nelec: tuple, u: list` | `Transform CI coefficients from an old one-particle orbital basis to a new one-particle orbital basis according to a given orbital rotation. In PySCF's full configuration interaction (FCI) workflow, the CI eigenproblem can be solved either by transforming the Hamiltonian integrals into a rotated orbital basis or by transforming the CI coefficient vector obtained in the old basis. This function implements the latter: given CI coefficients CI_old computed for a Hamiltonian expressed in the old basis, transform_ci returns CI_new that represents the same many-electron wavefunction in the rotated (new) one-particle basis defined by the orbital rotation matrix/matrices u. The transformation is performed by evaluating determinants of appropriate submatrices (minors) of u for all occupied-orbital patterns (alpha and beta strings), which is the standard Slater-determinant transformation rule under orbital rotations used in quantum chemistry FCI calculations.` |
| `pyscf_fci_addons_large_ci` | `pyscf.fci.addons.large_ci` | `pyscf/fci/addons.py` | `ci: numpy.ndarray, norb: int, nelec: tuple, tol: float = 0.1, return_strs: bool = True` | `pyscf.fci.addons.large_ci searches a Full Configuration Interaction (FCI) coefficient array for large-amplitude configuration state contributions and returns the corresponding determinant identifiers in either binary-string form or as occupied-orbital lists. In the PySCF quantum chemistry context (see README), this helper is used after an FCI calculation to locate and inspect the most important Slater determinants (alpha and beta occupation strings) that contribute to a correlated wavefunction. The function reshapes a flattened CI vector into the rectangular array of alpha- and beta-string combinations, thresholds by absolute amplitude, and returns matched (coefficient, alpha-id, beta-id) tuples for downstream analysis, debugging, or human inspection.` |
| `pyscf_fci_addons_guess_wfnsym` | `pyscf.fci.addons.guess_wfnsym` | `pyscf/fci/addons.py` | `ci: numpy.ndarray, norb: int, nelec: list, orbsym: list` | `pyscf.fci.addons.guess_wfnsym: Guess the wavefunction symmetry (irreducible representation ID) for a CI wavefunction from its CI coefficient vector(s). This utility is part of PySCF's full configuration interaction (FCI) addons and is used to infer the total spatial symmetry label of a CI wavefunction by combining the orbital symmetry labels (orbsym) of occupied orbitals in the occupied alpha/beta occupation strings. In the PySCF quantum-chemistry framework this inferred irrep ID is used for symmetry labeling, symmetry-based checks, and for choosing symmetry-adapted post-processing or reporting.` |
| `pyscf_fci_addons_symm_initguess` | `pyscf.fci.addons.symm_initguess` | `pyscf/fci/addons.py` | `norb: int, nelec: list, orbsym: list, wfnsym: int = 0, irrep_nelec: dict = None` | `pyscf.fci.addons.symm_initguess generates a configuration-interaction (CI) initial guess vector/matrix that is constrained to a specified point-group irreducible representation (irrep) and intended for use as an initial wavefunction in PySCF full configuration interaction (FCI) workflows. The function was designed to assemble a CI coefficients 2D array consistent with orbital symmetry labels so downstream FCI solvers start from a symmetry-adapted guess that reduces symmetry mixing during iterative diagonalization. NOTE: this implementation is deprecated and calling it will raise a DeprecationWarning instead of returning a CI guess.` |
| `pyscf_fci_cistring_addr2str` | `pyscf.fci.cistring.addr2str` | `pyscf/fci/cistring.py` | `norb: int, nelec: int, addr: int` | `Convert a configuration-interaction (CI) determinant address to its occupation string. This function is used in the pyscf.fci.cistring module of the PySCF quantum chemistry framework to map an integer "address" (ordinal index) that identifies a CI determinant into its corresponding occupation string. In the context of CI calculations, determinants are represented as fixed-length bitstrings of length norb with exactly nelec occupied orbitals; this function returns that bitstring representation where each character is '1' for an occupied orbital and '0' for an unoccupied orbital. The function chooses an internal implementation depending on the total number of distinct strings (num_strings(norb, nelec)): for moderately sized spaces it calls the vectorized addrs2str implementation, while for very large spaces it calls a specialized _addr2str implementation. The function performs no I/O and has no side effects on program state; it only returns the string representation for the given address.` |
| `pyscf_fci_addons_symmetrize_wfn` | `pyscf.fci.addons.symmetrize_wfn` | `pyscf/fci/addons.py` | `ci: numpy.ndarray, norb: int, nelec: list, orbsym: list, wfnsym: int = 0` | `Symmetrize the full configuration interaction (FCI) CI wavefunction by zeroing out determinant coefficients whose overall spatial symmetry does not match the requested target irreducible representation (irrep). This function is part of the pyscf.fci.addons utilities and is used in FCI calculations to enforce spatial symmetry on the many-electron wavefunction. It constructs alpha and beta occupation strings for the given number of orbitals and electrons, computes the symmetry of each determinant from the per-orbital irreps (orbsym), and returns a new CI coefficient array where coefficients of determinants that do not transform as the specified wfnsym are set to zero. The routine calls internal helpers (_unpack_nelec to interpret nelec, cistring.make_strings to enumerate determinants, and _symmetrize_wfn to perform the masking), and is typically used to reduce the CI space and to target states of a particular spatial symmetry in post-Hartree‚ÄìFock calculations.` |
| `pyscf_fci_cistring_addrs2str` | `pyscf.fci.cistring.addrs2str` | `pyscf/fci/cistring.py` | `norb: int, nelec: int, addrs: numpy.ndarray` | `Convert a list of CI determinant addresses to occupation "strings" used by PySCF's FCI routines.` |
| `pyscf_fci_addons_transform_ci_for_orbital_rotation` | `pyscf.fci.addons.transform_ci_for_orbital_rotation` | `pyscf/fci/addons.py` | `ci: numpy.ndarray, norb: int, nelec: tuple, u: numpy.ndarray` | `pyscf.fci.addons.transform_ci_for_orbital_rotation: Transform CI coefficients (dimension conserved) to the representation in a rotated one-particle basis used in FCI (full configuration interaction) calculations. Transforms a CI (configuration interaction) coefficient vector or tensor that was obtained for a CI Hamiltonian defined in an original one-particle orbital basis into the equivalent CI coefficients in a new one-particle basis obtained by applying an orbital rotation. In electronic-structure workflows implemented in PySCF, the same CI problem can be solved either by rotating the one- and two-electron integrals (transforming the Hamiltonian) or by transforming the CI coefficients; this function performs the latter. This is useful in contexts such as orbital optimization, post-SCF correlation analyses, or when comparing CI solutions across different orbital bases without rebuilding and diagonalizing the Hamiltonian.` |
| `pyscf_fci_cistring_gen_cre_str_index` | `pyscf.fci.cistring.gen_cre_str_index` | `pyscf/fci/cistring.py` | `orb_list: list, nelec: int` | `Generate mapping index from N-electron occupation strings to N+1-electron occupation strings produced by a single creation operator. This function is used in the FCI (full configuration interaction) string handling in PySCF to accelerate construction of matrix elements: for every N-electron Slater determinant (represented by a bitstring produced from orb_list and nelec) it records, for each possible creation into an unoccupied orbital, the orbital index used for creation, an unused placeholder value preserved for compatibility with upstream C routines, the integer index (address) of the resulting N+1-electron string in the ordering used by the FCI code, and the fermionic parity (sign) arising from antisymmetry when inserting the electron.` |
| `pyscf_fci_addons_overlap` | `pyscf.fci.addons.overlap` | `pyscf/fci/addons.py` | `bra: numpy.ndarray, ket: numpy.ndarray, norb: int, nelec: tuple, s: list = None` | `pyscf.fci.addons.overlap Compute the overlap (inner product) between two FCI (full configuration interaction) CI wavefunction coefficient arrays used in PySCF. This routine is used in FCI-related post-processing and analysis within the PySCF framework to evaluate <bra\|ket> where bra and ket are CI coefficient tensors defined for a given number of orbitals and electron occupation. When the one-particle basis used to represent the CI wavefunctions is non-orthogonal, an optional overlap/rotation matrix or list of matrices can be provided to transform the bra coefficients into the ket orbital basis before taking the inner product.` |
| `pyscf_fci_cistring_gen_des_str_index` | `pyscf.fci.cistring.gen_des_str_index` | `pyscf/fci/cistring.py` | `orb_list: list, nelec: int` | `Generate an index mapping that relates each N-electron occupation string (bitstring) defined by orb_list to the N-1-electron occupation strings produced by applying a fermionic annihilation operator to that N-electron string. This function is used in the PySCF full configuration interaction (FCI) cistring utilities to accelerate application of annihilation operators when assembling matrix elements, computing determinants, or performing excitation/de-excitation operations in FCI routines. The function builds the list of N-electron strings by calling make_strings(orb_list, nelec) and then calls the compiled helper libfci.FCIdes_str_index to fill a dense index table. The returned index table lets FCI code look up, for any N-electron string and any choice of an occupied orbital to annihilate, the address of the resulting (N-1)-electron string together with the fermionic sign (parity) resulting from the annihilation.` |
| `pyscf_fci_cistring_gen_occslst` | `pyscf.fci.cistring.gen_occslst` | `pyscf/fci/cistring.py` | `orb_list: tuple, nelec: int` | `pyscf.fci.cistring.gen_occslst ‚Äî Generate occupied-orbital index lists for every occupation string used in FCI string representations.` |
| `pyscf_fci_cistring_gen_linkstr_index` | `pyscf.fci.cistring.gen_linkstr_index` | `pyscf/fci/cistring.py` | `orb_list: list, nocc: int, strs: numpy.ndarray = None, tril: bool = False` | `pyscf.fci.cistring.gen_linkstr_index generates a lookup table (link index) that describes how occupation-number strings (Slater determinant bit-strings used in Full Configuration Interaction (FCI) within PySCF) are transformed by a single fermionic annihilation-creation operator pair. This lookup table is used by FCI routines to efficiently form Hamiltonian and excitation matrix elements by mapping an initial string and an excitation (annihilate an occupied orbital, create in a target orbital) to the index of the resulting string and the accompanying fermionic phase factor.` |
| `pyscf_fci_cistring_reform_linkstr_index` | `pyscf.fci.cistring.reform_linkstr_index` | `pyscf/fci/cistring.py` | `link_index: numpy.ndarray` | `pyscf.fci.cistring.reform_linkstr_index compresses the (a, i) pair index stored in a link-string index array into a single lower-triangular integer index. The compression produces indices that are consistent with the 4-fold permutation symmetry commonly exploited for two-electron integrals in FCI (full configuration interaction) routines, allowing downstream code to identify equivalent excitation pairs and reduce redundant integral lookups or storage.` |
| `pyscf_fci_cistring_gen_linkstr_index_trilidx` | `pyscf.fci.cistring.gen_linkstr_index_trilidx` | `pyscf/fci/cistring.py` | `orb_list: list, nocc: int, strs: list = None` | `Generate link-string index for two-body single-excitation operators with enforced lower-triangular ordering (p > q) used in PySCF FCI string handling. This function is part of the pyscf.fci.cistring utilities that build data structures for mapping excitation operators onto determinant bit-string representations in full configuration interaction (FCI) algorithms. In the domain of quantum chemistry and PySCF, gen_linkstr_index_trilidx produces the link-string index entries for operators of the form p^+ q acting on many-electron basis states, with the explicit convention that the creation orbital index p is strictly greater than the annihilation orbital index q (the "lower-triangular" or trilidx convention). The produced index has the structure [pq, *, str1, sign] for each linked excitation as returned by the underlying gen_linkstr_index call with the trilidx flag enabled. This function simply invokes gen_linkstr_index with trilidx=True and therefore yields exactly the same result as reform_linkstr_index(gen_linkstr_index(...)) when that reform operation enforces the trilidx ordering.` |
| `pyscf_fci_cistring_gen_linkstr_index_o1` | `pyscf.fci.cistring.gen_linkstr_index_o1` | `pyscf/fci/cistring.py` | `orb_list: list, nelec: int, strs: list = None, tril: bool = False` | `gen_linkstr_index_o1 generates a lookup table that encodes how Slater determinants (occupation strings) in the PySCF FCI cistring representation are related by a single one-electron operator a_p^\dagger a_q (a creation at orbital p and annihilation at orbital q). This table is used in full configuration interaction (FCI) routines inside PySCF to quickly enumerate nonzero connections between determinants produced by single excitations or diagonal (p==q) one-electron terms when assembling Hamiltonian or other one-body operator matrix elements.` |
| `pyscf_fci_cistring_gen_strings4orblist` | `pyscf.fci.cistring.gen_strings4orblist` | `pyscf/fci/cistring.py` | `orb_list: list, nelec: int` | `pyscf.fci.cistring.gen_strings4orblist: Generate occupation bitstrings for a specified list of orbitals used by the FCI routines in PySCF. This function enumerates all distinct occupation bitstrings with a fixed number of electrons (nelec) distributed over the orbitals listed in orb_list. It is used in the pyscf.fci module to represent Slater determinants / occupation patterns compactly as integer bitmasks when constructing and manipulating Full Configuration Interaction (FCI) wavefunctions and Hamiltonians. Each returned integer is a 64-bit signed integer (numpy.int64) whose binary representation encodes orbital occupancy: a bit value of 1 indicates the corresponding orbital is occupied, and 0 indicates it is unoccupied. The lowest (right-most) bit corresponds to the lowest orbital index in orb_list, so the integer value can be interpreted directly as a binary occupation string consistent with the examples and conventions in the FCI code paths.` |
| `pyscf_fci_cistring_strs2addr` | `pyscf.fci.cistring.strs2addr` | `pyscf/fci/cistring.py` | `norb: int, nelec: int, strings: list` | `Convert a list of occupation bitstrings to CI determinant addresses used by the PySCF FCI routines. This function maps each occupation string (an integer encoding an electron occupation pattern using bit positions) to its corresponding integer address in the CI (configuration interaction) determinant ordering implemented by pyscf.fci.cistring and the underlying C helper libfci. It is intended for use when assembling or indexing FCI vectors and matrices: given raw bitstring representations of determinants, strs2addr returns the zero-based index into the CI space used throughout PySCF FCI code.` |
| `pyscf_fci_cistring_sub_addrs` | `pyscf.fci.cistring.sub_addrs` | `pyscf/fci/cistring.py` | `norb: int, nelec: int, orbital_indices: list, sub_nelec: int = 0` | `The addresses (integer indices) of the FCI determinants that match occupancy conditions on a set of orbital indices. This function is part of pyscf.fci.cistring and is used in Full Configuration Interaction (FCI) workflows within the PySCF electronic-structure framework to map bitstring determinants to their linear addresses in the canonical (norb, nelec) determinant ordering produced by strs2addr and make_strings. When sub_nelec == 0 the function constructs determinant bit-strings by calling make_strings(orbital_indices, nelec) and returns their addresses in the (norb, nelec) space via strs2addr. When sub_nelec != 0 the function enumerates all (norb, nelec) determinants, counts how many of the specified orbital_indices are occupied in each determinant, selects determinants with exactly sub_nelec of those orbitals occupied, and returns the addresses of that selected subset via strs2addr. The returned addresses can be used as indices into arrays or vectors that are ordered according to the cistring (bitstring) canonical ordering used across PySCF FCI utilities.` |
| `pyscf_fci_cistring_tn_strs` | `pyscf.fci.cistring.tn_strs` | `pyscf/fci/cistring.py` | `norb: int, nelec: int, n: int` | `Generate integer-encoded Slater determinant strings that enumerate n-electron excitation patterns (Tn amplitudes) used by the Full Configuration Interaction (FCI) routines in pyscf.fci.cistring. This function constructs all determinants obtained by exciting exactly n electrons from the Hartree‚ÄìFock (HF) reference (first nelec orbitals occupied) into the virtual space (orbitals nelec..norb-1). The result is used to index Tn amplitude tensors in post-Hartree‚ÄìFock methods where excitations are represented as bitstrings encoded in Python integers (consistent with cistring.make_strings).` |
| `pyscf_fci_direct_ep_make_rdm1e` | `pyscf.fci.direct_ep.make_rdm1e` | `pyscf/fci/direct_ep.py` | `fcivec: numpy.ndarray, nsite: int, nelec: tuple` | `Compute the one-electron reduced density matrix dm_pq = <c_p^‚Ä† c_q> for a full configuration interaction (FCI) wavefunction represented in the occupation-string basis. This function is part of the PySCF FCI routines (pyscf.fci.direct_ep) and is used in electronic-structure workflows to obtain the 1-particle reduced density matrix (1-RDM) from an FCI vector. The resulting 1-RDM is commonly used to evaluate one-electron expectation values, construct natural orbitals, and as input to correlated property computations in quantum chemistry.` |
| `pyscf_fci_direct_ep_make_rdm12e` | `pyscf.fci.direct_ep.make_rdm12e` | `pyscf/fci/direct_ep.py` | `fcivec: numpy.ndarray, nsite: int, nelec: tuple` | `pyscf.fci.direct_ep.make_rdm12e computes the one-electron and two-electron reduced density matrices (RDMs) from a full configuration interaction (FCI) coefficient vector in the direct_ep/site-based representation used in PySCF. This function is used in FCI workflows to obtain spatial (site/orbital) RDMs required for expectation values, energy contributions, and property evaluation. The returned RDMs are built by summing over spin-up and spin-down occupation-string sectors and are reordered so the 2-particle RDM follows the chemist convention.` |
| `pyscf_fci_direct_ep_make_rdm1p` | `pyscf.fci.direct_ep.make_rdm1p` | `pyscf/fci/direct_ep.py` | `fcivec: numpy.ndarray, nsite: int, nelec: int, nphonon: int` | `pyscf.fci.direct_ep.make_rdm1p computes the one-phonon reduced density matrix for an electron-phonon full configuration interaction (FCI) wavefunction. The function is used in the PySCF direct electron-phonon FCI module to obtain the matrix of expectation values dm[p,q] = <psi\| b_p^+ b_q \|psi>, where b_p^+ is the phonon creation operator on site p. This 1-phonon density matrix is commonly required to evaluate phonon observables, site-resolved phonon populations, and off-diagonal phonon coherences in electron-phonon model calculations performed with PySCF.` |
| `pyscf_fci_direct_nosym_contract_2e` | `pyscf.fci.direct_nosym.contract_2e` | `pyscf/fci/direct_nosym.py` | `eri: numpy.ndarray, fcivec: numpy.ndarray, norb: int, nelec: tuple, link_index: tuple = None` | `pyscf.fci.direct_nosym.contract_2e contracts the two-electron part of the electronic Hamiltonian with a full configuration interaction (FCI) vector to produce the action of the 2-electron Hamiltonian on that FCI vector (H_2e \|CI>). This routine is used in the PySCF FCI solver (direct_nosym) to build the contribution of electron-electron interactions to the FCI matrix-vector product needed in iterative eigensolvers and energy evaluations. The input eri is NOT the plain two-electron operator matrix (pq\|rs). Instead eri must be provided in the modified form used by this routine: eri_{pq,rs} = (pq\|rs) - (1/Nelec) sum_q (pq\|qs), and, to restore symmetry between the index pairs (pq) and (rs), eri_{pq,rs} = (pq\|rs) - (0.5/Nelec) [ sum_q (pq\|qs) + sum_p (pq\|rp) ]. With this definition, the function computes the contracted result of the 2-electron Hamiltonian defined in the source code documentation: h2e = eri_{pq,rs} p^+ q r^+ s = (pq\|rs) p^+ r^+ s q - (pq\|rs) delta_{qr} p^+ s. See also direct_nosym.absorb_h1e for how one-electron terms may be combined with eri for full Hamiltonian contractions.` |
| `pyscf_fci_direct_spin0_make_hdiag` | `pyscf.fci.direct_spin0.make_hdiag` | `pyscf/fci/direct_spin0.py` | `h1e: numpy.ndarray, eri: numpy.ndarray, norb: int, nelec: tuple, compress: bool = False` | `Construct a symmetrized, flattened Hamiltonian matrix for spin-0 full configuration interaction (FCI) calculations from one- and two-electron integrals. This function is part of PySCF's FCI direct solver utilities for spin-singlet (s = 0) problems. It builds the Hamiltonian matrix elements appropriate for a spin-0 FCI Hilbert space by delegating the initial construction to the spin-1 variant (direct_spin1.make_hdiag), then reshaping the result to a square matrix and explicitly symmetrizing it to reduce numerical round-off error. The final result is returned as a 1-D NumPy array containing the ravelled (symmetric) square matrix. In practice this routine is used by iterative FCI solvers (for example Davidson-style eigensolvers) inside PySCF to obtain the Hamiltonian matrix or its diagonal/block representation for preconditioning, matrix-vector products, and energy evaluations in quantum chemistry simulations.` |
| `pyscf_fci_direct_nosym_energy` | `pyscf.fci.direct_nosym.energy` | `pyscf/fci/direct_nosym.py` | `h1e: numpy.ndarray, eri: numpy.ndarray, fcivec: numpy.ndarray, norb: int, nelec: tuple, link_index: dict = None` | `pyscf.fci.direct_nosym.energy: Compute the Full Configuration Interaction (FCI) electronic energy for a given molecular Hamiltonian and FCI coefficient vector using PySCF internal routines. This routine folds the one-electron integrals into an effective two-electron Hamiltonian with absorb_h1e, applies the two-electron Hamiltonian to the FCI vector with contract_2e, and returns the expectation value <CI\|H\|CI>, which is the electronic energy for the supplied FCI wavefunction in the PySCF FCI framework.` |
| `pyscf_fci_direct_spin0_contract_2e` | `pyscf.fci.direct_spin0.contract_2e` | `pyscf/fci/direct_spin0.py` | `eri: numpy.ndarray, fcivec: numpy.ndarray, norb: int, nelec: tuple, link_index: numpy.ndarray = None` | `Contract two-electron integrals with a spin-0 (singlet) FCI vector. This function computes the action of the two-electron part of the electronic Hamiltonian on a full configuration interaction (FCI) vector specialized for spin-adapted S=0 (spin-0) calculations used by the PySCF FCI solver. It calls ao2mo.restore(4, ...) to restore 4-fold symmetry of the supplied two-electron integrals, symmetrizes and scales them to match the internal convention, and then delegates the core contraction to a compiled routine (libfci.FCIcontract_2e_spin0). The result is returned as a direct_spin1.FCIvector view with the same shape as the input fcivec. This routine is used inside PySCF to evaluate the two-electron Hamiltonian contribution for variational FCI energy/gradient evaluations and iterative FCI solvers that require repeated matrix-vector products.` |
| `pyscf_fci_direct_nosym_absorb_h1e` | `pyscf.fci.direct_nosym.absorb_h1e` | `pyscf/fci/direct_nosym.py` | `h1e: numpy.ndarray, eri: numpy.ndarray, norb: int, nelec: int, fac: float = 1` | `pyscf.fci.direct_nosym.absorb_h1e: Modify a two-electron Hamiltonian tensor to include the contribution from a one-electron Hamiltonian for use in full configuration interaction (FCI) routines (direct, no spatial symmetry). This function is used in the FCI direct_nosym workflow to fold a mean-field-like one-electron term into an effective two-electron integral tensor so downstream FCI code can treat the modified two-electron tensor as containing both 1e and 2e contributions.` |
| `pyscf_fci_direct_spin0_trans_rdm1` | `pyscf.fci.direct_spin0.trans_rdm1` | `pyscf/fci/direct_spin0.py` | `cibra: numpy.ndarray, ciket: numpy.ndarray, norb: int, nelec: tuple, link_index: list = None` | `pyscf.fci.direct_spin0.trans_rdm1 computes the spin-summed one-particle transition reduced density matrix (1-RDM) in the spatial (orbital) basis for a full configuration interaction (FCI) bra and ket state within the PySCF FCI direct_spin0 code path. This function is used in FCI post-processing to obtain transition 1-RDMs for evaluating one-electron expectation values and transition properties by summing the separate alpha and beta spin components returned by the spin-resolved routine trans_rdm1s.` |
| `pyscf_fci_direct_spin0_make_rdm1s` | `pyscf.fci.direct_spin0.make_rdm1s` | `pyscf/fci/direct_spin0.py` | `fcivec: numpy.ndarray, norb: int, nelec: int, link_index: list = None` | `Create one-particle reduced density matrices (RDM1) for alpha and beta spins from a full configuration interaction (FCI) vector in the spin-0 (singlet) direct FCI implementation. This function is used in PySCF's FCI module to obtain the one-particle density matrices needed to compute expectation values (for example, one-electron energies and spin-independent one-particle properties) from an FCI wavefunction. In the spin-0/direct_spin0 context, the alpha and beta one-particle RDMs are identical; this routine builds the RDM for one spin and returns it twice to represent both spin channels.` |
| `pyscf_fci_direct_spin0_make_rdm1` | `pyscf.fci.direct_spin0.make_rdm1` | `pyscf/fci/direct_spin0.py` | `fcivec: numpy.ndarray, norb: int, nelec: tuple, link_index: list = None` | `Concise summary: Computes the spatial one-particle reduced density matrix (RDM1) for a spin-restricted (total spin S=0) full configuration interaction (FCI) wavefunction vector and returns the result multiplied by 2 to combine alpha and beta spin contributions into spatial orbital occupancies. This function is used in the PySCF FCI direct_spin0 module to produce the one-particle density needed for post-processing tasks such as energy evaluation, property calculations, and orbital analysis in quantum chemistry simulations.` |
| `pyscf_fci_direct_spin1_absorb_h1e` | `pyscf.fci.direct_spin1.absorb_h1e` | `pyscf/fci/direct_spin1.py` | `h1e: numpy.ndarray, eri: numpy.ndarray, norb: int, nelec: int, fac: float = 1` | `pyscf.fci.direct_spin1.absorb_h1e modifies a two-electron integral tensor to absorb the contribution of a one-electron Hamiltonian for use in full configuration interaction (FCI) routines in the direct_spin1 (spin-adapted) code path of PySCF. This routine is used in electronic-structure calculations to combine one-electron (kinetic + nuclear attraction or Fock-like) terms into an effective two-electron Hamiltonian representation so that subsequent FCI matrix assembly can operate on a single 4-index tensor.` |
| `pyscf_fci_direct_spin1_energy` | `pyscf.fci.direct_spin1.energy` | `pyscf/fci/direct_spin1.py` | `h1e: numpy.ndarray, eri: numpy.ndarray, fcivec: numpy.ndarray, norb: int, nelec: tuple, link_index: list = None` | `Compute the FCI electronic energy (expectation value) for a given Hamiltonian and FCI vector in the direct_spin1 FCI implementation. This function is used in the PySCF quantum chemistry framework to evaluate the scalar electronic energy E = <C\|H\|C> for a Full Configuration Interaction (FCI) wavefunction C represented by fcivec. It first folds the one-electron integrals into the two-electron integrals via absorb_h1e (hence working with the effective two-electron Hamiltonian used by the direct_spin1 routines), then forms the Hamiltonian action on the FCI vector with contract_2e, and finally computes the dot product of the input vector with that action to produce the energy. This routine is applicable to non-relativistic electronic structure problems expressed in an orthonormal molecular orbital basis and follows the FCI conventions used by the pyscf.fci.direct_spin1 module.` |
| `pyscf_fci_direct_spin0_trans_rdm1s` | `pyscf.fci.direct_spin0.trans_rdm1s` | `pyscf/fci/direct_spin0.py` | `cibra: numpy.ndarray, ciket: numpy.ndarray, norb: int, nelec: int, link_index: list = None` | `pyscf.fci.direct_spin0.trans_rdm1s Compute the spin-resolved transition one-particle reduced density matrices (RDM1) for spin-restricted full configuration interaction (FCI) wavefunctions. This routine is used in PySCF FCI modules to obtain the alpha and beta spin parts of the transition one-particle RDM between two CI states (bra and ket). The returned matrices are suitable for evaluating one-body transition properties (for example transition dipoles or spin-resolved expectation values) in quantum chemistry calculations performed with PySCF.` |
| `pyscf_fci_direct_spin0_trans_rdm12` | `pyscf.fci.direct_spin0.trans_rdm12` | `pyscf/fci/direct_spin0.py` | `cibra: numpy.ndarray, ciket: numpy.ndarray, norb: int, nelec: tuple, link_index: list = None, reorder: bool = True` | `Compute spin-adapted (spin-0) transition one- and two-particle reduced density matrices (1-RDM and 2-RDM) between two full configuration interaction (FCI) many-electron states. This function is part of the pyscf.fci.direct_spin0 module of the PySCF quantum chemistry package. It constructs transition density matrices needed to evaluate expectation values and transition properties (for example transition dipole moments or two-body operator matrix elements) between a "bra" CI state and a "ket" CI state represented in the FCI determinant/configuration basis. The implementation delegates to the generic rdm.make_rdm12 kernel and then optionally reorders the returned matrices with rdm.reorder_rdm to match the internal index ordering conventions used elsewhere in PySCF.` |
| `pyscf_fci_direct_spin1_make_hdiag` | `pyscf.fci.direct_spin1.make_hdiag` | `pyscf/fci/direct_spin1.py` | `h1e: numpy.ndarray, eri: numpy.ndarray, norb: int, nelec: tuple, compress: bool = False` | `Diagonal Hamiltonian for Davidson preconditioner in the direct spin-1 (UHF) FCI routine. This function constructs the diagonal elements of the full configuration interaction (FCI) Hamiltonian for use as the diagonal preconditioner in a Davidson-type iterative eigensolver. It is intended for electronic structure calculations in the PySCF framework and specifically for the UHF (unrestricted Hartree‚ÄìFock) direct-spin1 FCI implementation. The diagonal elements returned correspond to diagonal matrix elements <I\|H\|I> for all Slater determinant pairs formed from the generated alpha and beta occupation lists. The returned array is therefore used to accelerate convergence of iterative diagonalization by providing the H_ii values for preconditioning and shift operations.` |
| `pyscf_fci_direct_spin1_get_init_guess` | `pyscf.fci.direct_spin1.get_init_guess` | `pyscf/fci/direct_spin1.py` | `norb: int, nelec: tuple, nroots: int, hdiag: numpy.ndarray` | `Return an initial guess composed of single Slater determinants for use as starting vectors in full configuration interaction (FCI) diagonalization routines in the pyscf.fci.direct_spin1 implementation. This function constructs simple, physically motivated initial CI vectors by selecting determinants based on the provided diagonal Hamiltonian elements and the specified number of alpha and beta electrons; the guesses are suitable for use by iterative eigensolvers (for example Davidson or Lanczos) within the PySCF FCI solver.` |
| `pyscf_fci_direct_spin1_make_rdm1` | `pyscf.fci.direct_spin1.make_rdm1` | `pyscf/fci/direct_spin1.py` | `fcivec: numpy.ndarray, norb: int, nelec: tuple, link_index: tuple = None` | `Spin-traced one-particle density matrix for a Full Configuration Interaction (FCI) wavefunction. Computes the spin-traced one-particle reduced density matrix dm1[p,q] = <q_alpha^dagger p_alpha> + <q_beta^dagger p_beta> using the FCI state vector provided. This function is part of PySCF's FCI direct_spin1 routines and is used in electronic structure calculations to extract one-particle observables (for example, to form the expectation value of a one-electron Hamiltonian). The implementation obtains the spin-resolved matrices by calling make_rdm1s(fcivec, norb, nelec, link_index) and returns their elementwise sum. The convention for indices and operator ordering follows McWeeny, Eq. (5.4.20). The resulting matrix can be contracted with a one-particle Hamiltonian h1 as E = einsum('pq,qp', h1, rdm1) to obtain the one-body contribution to the energy.` |
| `pyscf_fci_direct_spin1_make_rdm12` | `pyscf.fci.direct_spin1.make_rdm12` | `pyscf/fci/direct_spin1.py` | `fcivec: numpy.ndarray, norb: int, nelec: tuple, link_index: list = None, reorder: bool = True` | `Spin-traced one- and two-particle reduced density matrix builder for FCI spin-1 functions. This function computes the spin-traced one-particle density matrix (1pdm) and two-particle density matrix (2pdm) for a full configuration interaction (FCI) wavefunction represented by fcivec in the spin-adapted (spin-1) formulation used in pyscf.fci.direct_spin1. The returned 1pdm and 2pdm are suitable for evaluating expectation values and energies in electronic structure calculations. In particular, the energy contribution from one- and two-electron operators can be formed as E = einsum('pq,qp', h1, 1pdm) + 1/2 * einsum('pqrs,pqrs', eri, 2pdm), where h1[p,q] = <p\|h\|q> and eri[p,q,r,s] = (pq\|rs). The mathematical definitions implemented are 1pdm[p,q] = < q_alpha^dagger p_alpha > + < q_beta^dagger p_beta >; 2pdm[p,q,r,s] = < p_alpha^dagger r_alpha^dagger s_alpha q_alpha > + < p_beta^dagger r_alpha^dagger s_alpha q_beta > + < p_alpha^dagger r_beta^dagger s_beta q_alpha > + < p_beta^dagger r_beta^dagger s_beta q_beta >, i.e. the spin trace over alpha/beta spin blocks.` |
| `pyscf_fci_direct_spin1_make_rdm123` | `pyscf.fci.direct_spin1.make_rdm123` | `pyscf/fci/direct_spin1.py` | `fcivec: numpy.ndarray, norb: int, nelec: tuple, link_index: list = None, reorder: bool = True` | `Compute spin-traced 1-, 2-, and 3-particle reduced density matrices (RDMs) from a full configuration interaction (FCI) state vector in the direct_spin1 FCI implementation of PySCF. This function is used in electronic-structure workflows (PySCF) to extract reduced density matrices needed for computing expectation values of one-, two-, and three-body operators, analysis of correlation, and as inputs to downstream post‚ÄëFCI routines.` |
| `pyscf_fci_direct_spin1_trans_rdm1` | `pyscf.fci.direct_spin1.trans_rdm1` | `pyscf/fci/direct_spin1.py` | `cibra: numpy.ndarray, ciket: numpy.ndarray, norb: int, nelec: tuple, link_index: list = None` | `pyscf.fci.direct_spin1.trans_rdm1 computes the spin-traced transition one-particle reduced density matrix (1-RDM) for a transition between two FCI (full configuration interaction) states. The function is part of the FCI utilities in the PySCF quantum chemistry framework and returns the matrix elements used to evaluate one-electron transition properties by summing the alpha and beta spin contributions computed by the helper trans_rdm1s function.` |
| `pyscf_fci_direct_spin1_make_rdm1s` | `pyscf.fci.direct_spin1.make_rdm1s` | `pyscf/fci/direct_spin1.py` | `fcivec: numpy.ndarray, norb: int, nelec: tuple, link_index: tuple = None` | `Spin-separated one-particle reduced density matrices for a Full Configuration Interaction (FCI) wavefunction. This function is used in the PySCF FCI direct spin-1 implementation to compute the spin-resolved one-particle reduced density matrices (RDM-1) for the alpha and beta spin sectors from a given FCI vector. The returned matrices correspond to the expectation values <q^dagger p> for creation/annihilation operators in the second-quantized representation and follow the convention used in McWeeny (see original implementation comment and Eq (5.4.20) in McWeeney). These spin-separated RDMs are commonly used in quantum chemistry workflows implemented in PySCF to evaluate one-body operator expectation values (for example, the one-electron energy via E = einsum('pq,qp', h1, rdm1)), to build spin-dependent density matrices for property evaluation, or as intermediates in post-FCI analyses.` |
| `pyscf_fci_direct_spin1_make_rdm1234` | `pyscf.fci.direct_spin1.make_rdm1234` | `pyscf/fci/direct_spin1.py` | `fcivec: numpy.ndarray, norb: int, nelec: tuple, link_index: list = None, reorder: bool = True` | `Spin-traced 1-, 2-, 3- and 4-particle reduced density matrices (RDMs) for a full configuration interaction (FCI) wavefunction in the direct_spin1 FCI representation. This function is used in the PySCF FCI spin-adapted direct_spin1 module to compute spin-traced k-particle RDMs (k = 1,2,3,4) from an FCI coefficient vector. The produced RDMs are spin-summed (spin-traced) and are suitable for use in downstream tasks in electronic-structure workflows (for example, evaluating expectation values, forming reduced-density-based observables, or contracting with electron repulsion integrals). Internally this function calls rdm.make_dm1234 with the 'FCI4pdm_kern_sf' kernel and, optionally, rdm.reorder_dm1234 to adapt the index ordering to the conventions used elsewhere in PySCF.` |
| `pyscf_fci_direct_spin1_make_rdm12s` | `pyscf.fci.direct_spin1.make_rdm12s` | `pyscf/fci/direct_spin1.py` | `fcivec: numpy.ndarray, norb: int, nelec: tuple, link_index: list = None, reorder: bool = True` | `Spin-separated one- and two-particle reduced density matrices (RDMs) for a Full Configuration Interaction (FCI) wavefunction represented by a CI vector in the pyscf.fci.direct_spin1 implementation. This function is used in the FCI module of the PySCF framework (a Python-based Simulations of Chemistry Framework) to compute spin-resolved reduced density matrices from an FCI coefficient vector. The outputs are suitable for computing expectation values such as the electronic energy in the conventional chemistry notation: E = einsum('pq,qp', h1, 1pdm) + 1/2 * einsum('pqrs,pqrs', eri, 2pdm) where h1[p,q] = <p\|h\|q>, eri[p,q,r,s] = (pq\|rs), 1pdm[p,q] = <q^dagger p>, and 2pdm[p,q,r,s] = <p^dagger r^dagger s q>. In practical usage within PySCF this function calls lower-level kernels rdm.make_rdm12_spin1 and (optionally) rdm.reorder_rdm to produce RDMs in the standard orbital ordering used by the library.` |
| `pyscf_fci_direct_spin1_cyl_sym_sym_allowed_indices` | `pyscf.fci.direct_spin1_cyl_sym.sym_allowed_indices` | `pyscf/fci/direct_spin1_cyl_sym.py` | `nelec: tuple, orbsym: numpy.ndarray, wfnsym: int` | `Indices of symmetry-allowed determinant pairs for each irreducible representation (irrep) in the cylindrical (linearmole) symmetry treatment used by PySCF's FCI direct spin-1 implementation. This function is used in the pyscf.fci.direct_spin1_cyl_sym module to precompute, for a given electron occupation (nelec), orbital symmetry assignment (orbsym), and target many-body wavefunction symmetry (wfnsym), the list of linearized indices of alpha/beta determinant pairs that satisfy the conservation of angular-momentum-like quantum numbers and parity required by the target wfnsym. The returned lists are intended for use when assembling FCI Hamiltonian blocks or selecting symmetry-allowed basis states; each returned array contains integer indices into the flattened product space of alpha- and beta-determinant indices, with the linearization rule index = alpha_index * nb + beta_index where nb is the number of beta strings.` |
| `pyscf_fci_direct_spin1_pspace` | `pyscf.fci.direct_spin1.pspace` | `pyscf/fci/direct_spin1.py` | `h1e: numpy.ndarray, eri: numpy.ndarray, norb: int, nelec: tuple, hdiag: numpy.ndarray = None, np: int = 400` | `pyscf.fci.direct_spin1.pspace constructs a reduced-size "pspace" configuration-interaction Hamiltonian matrix used to improve the Davidson preconditioner in full configuration interaction (FCI) calculations for singlet/triplet spin-adapted direct_spin1 algorithms. The function selects a subset of many-electron determinants (by diagonal energies) and builds the corresponding small Hamiltonian block (h0) that approximates the action of the full Hamiltonian in that subspace; this small matrix is intended to be used as a preconditioning/operator model inside iterative eigensolvers (Davidson-like) in the PySCF FCI driver.` |
| `pyscf_fci_fci_slow_reorder_rdm` | `pyscf.fci.fci_slow.reorder_rdm` | `pyscf/fci/fci_slow.py` | `rdm1: numpy.ndarray, rdm2: numpy.ndarray, inplace: bool = True` | `pyscf.fci.fci_slow.reorder_rdm reorders a two-particle reduced density matrix (2-RDM) prepared as a product of one-particle excitation operators into the true two-electron reduced density matrix representation used in energy evaluation in FCI calculations. This function is used in the PySCF FCI (full configuration interaction) module to convert a 2-RDM initially stored as rdm2(pq,rs) = <E^p_q E^r_s> (the expectation value of a product of one-particle excitation operators) into the reordered 2-RDM rdm2(pq,rs) = <e^{pr}_{qs}>. The reordered 2-RDM remains in Mulliken ordering (indices arranged as [e1,e1,e2,e2]) but becomes the true two-electron density matrix that, when contracted with two-electron integrals (int2e), yields the two-electron contribution to the electronic energy. The routine derives the number of molecular orbitals nmo from rdm1.shape[0] and performs an index-level correction by subtracting the one-particle density matrix from diagonal index blocks of rdm2.` |
| `pyscf_fci_fci_dhf_slow_absorb_h1e` | `pyscf.fci.fci_dhf_slow.absorb_h1e` | `pyscf/fci/fci_dhf_slow.py` | `h1e: numpy.ndarray, eri: numpy.ndarray, norb: int, nelec: int, fac: float = 1` | `pyscf.fci.fci_dhf_slow.absorb_h1e modifies a two-electron Hamiltonian tensor so that it includes the contribution from a one-electron Hamiltonian, producing a 4-index two-electron Hamiltonian with the one-electron effects absorbed for use in Full Configuration Interaction (FCI) routines in PySCF.` |
| `pyscf_fci_direct_spin1_trans_rdm12` | `pyscf.fci.direct_spin1.trans_rdm12` | `pyscf/fci/direct_spin1.py` | `cibra: numpy.ndarray, ciket: numpy.ndarray, norb: int, nelec: tuple, link_index: list = None, reorder: bool = True` | `pyscf.fci.direct_spin1.trans_rdm12 computes spin-traced transition 1- and 2-particle reduced density matrices (RDMs) between two FCI many-electron states. This function is used in the PySCF quantum chemistry framework to obtain transition RDMs needed for property evaluation, response calculations, and matrix element contractions between a "bra" CI vector and a "ket" CI vector in full configuration interaction (FCI) calculations carried out in the direct_spin1 module. The returned 1-particle RDM dm1 and 2-particle RDM dm2 are spin-traced (alpha+beta summed) and follow the common quantum-chemistry conventions: 1pdm[p,q] = < q^dagger p > 2pdm[p,q,r,s] = < p^dagger r^dagger s q >. The implementation delegates the core work to rdm.make_rdm12_spin1 using the kernel 'FCItdm12kern_sf' and optionally reorders the output with rdm.reorder_rdm.` |
| `pyscf_fci_direct_spin1_symm_sym_allowed_indices` | `pyscf.fci.direct_spin1_symm.sym_allowed_indices` | `pyscf/fci/direct_spin1_symm.py` | `nelec: tuple, orbsym: numpy.ndarray, wfnsym: int` | `Indices of symmetry-allowed determinants for each irreducible representation (irrep) used by the FCI direct_spin1_symm routines. This function enumerates alpha- and beta-spin Slater determinant bitstrings for the given orbital and electron occupation, groups them by the orbital symmetry labels, and returns for each irrep the flattened indices in the product space of alpha√óbeta determinants that produce the requested total wavefunction symmetry wfnsym. This is used to construct or select symmetry-adapted FCI determinant spaces in PySCF (direct_spin1_symm), where restricting the determinant list by symmetry reduces the CI Hamiltonian dimension and enforces the target spatial symmetry of the computed wavefunction.` |
| `pyscf_fci_fci_dhf_slow_get_init_guess` | `pyscf.fci.fci_dhf_slow.get_init_guess` | `pyscf/fci/fci_dhf_slow.py` | `norb: int, nelec: int, nroots: int, hdiag: numpy.ndarray` | `Initializes a set of CI (configuration interaction) guess vectors composed of single Slater determinants for use in the PySCF FCI solver (module pyscf.fci.fci_dhf_slow). The function constructs a list of one-hot CI vectors (each vector has unit amplitude on a single determinant) chosen from the determinants with the smallest diagonal Hamiltonian elements, and applies a tiny deterministic perturbation to the first vector to break exact degeneracies and improve the stability of iterative eigensolvers (e.g., Davidson). This routine is used as the starting guess for FCI diagonalization in quantum chemistry calculations performed with the PySCF framework.` |
| `pyscf_fci_fci_slow_absorb_h1e` | `pyscf.fci.fci_slow.absorb_h1e` | `pyscf/fci/fci_slow.py` | `h1e: numpy.ndarray, eri: numpy.ndarray, norb: int, nelec: int, fac: float = 1` | `pyscf.fci.fci_slow.absorb_h1e modifies a two-electron integral tensor to absorb the contribution of a one-electron Hamiltonian, producing an effective two-electron Hamiltonian used by Full Configuration Interaction (FCI) routines in PySCF. This operation is used in the pyscf.fci.fci_slow code path to combine one- and two-electron terms so downstream FCI code can work with a single 4-index operator while preserving the correct mean-field one-electron contribution. This function expects a one-electron Hamiltonian matrix and a two-electron integral array compatible with ao2mo.restore(1, eri, norb). It restores the full 4-index two-electron tensor from eri, computes an orbital-space mean-field contribution from the two-electron tensor, forms a one-electron correction f1e = h1e - 0.5 * trace_contraction(h2e), scales that correction by 1/nelec (with a tiny floor to avoid division by zero), and adds the scaled correction to the two-electron tensor on the appropriate index pairs. The returned tensor has the same floating dtype as h1e and shape (norb, norb, norb, norb). The original inputs are not modified because eri is copied before restoration; the function uses ao2mo.restore(1, eri.copy(), norb) internally.` |
| `pyscf_fci_rdm_make_dm123` | `pyscf.fci.rdm.make_dm123` | `pyscf/fci/rdm.py` | `fname: str, cibra: numpy.ndarray, ciket: numpy.ndarray, norb: int, nelec: tuple` | `pyscf.fci.rdm.make_dm123 computes spin-traced one-, two-, and three-particle reduced density matrices (1-RDM, 2-RDM, 3-RDM) from full configuration interaction (FCI) CI coefficient vectors. This routine is part of PySCF's FCI utilities and is used in post-processing FCI wavefunctions for property evaluation, embedding, and analysis that require reduced density matrices.` |
| `pyscf_fci_selected_ci_cre_des_linkstr_tril` | `pyscf.fci.selected_ci.cre_des_linkstr_tril` | `pyscf/fci/selected_ci.py` | `strs: list, norb: int, nelec: tuple` | `pyscf.fci.selected_ci.cre_des_linkstr_tril: Build the creation/annihilation link table for generating input strings using a lower-triangular ordering.` |
| `pyscf_fci_rdm_make_dm1234` | `pyscf.fci.rdm.make_dm1234` | `pyscf/fci/rdm.py` | `fname: str, cibra: numpy.ndarray, ciket: numpy.ndarray, norb: int, nelec: tuple` | `Spin-traced 1-, 2-, 3- and 4-particle reduced density matrices (RDMs) computed from Full Configuration Interaction (FCI) bra and ket CI vectors. This routine is part of PySCF's FCI machinery for constructing reduced density matrices used in quantum chemistry workflows (property evaluation, embedding, response, and analysis). It calls a compiled driver in the librdm extension to efficiently form the raw spin-traced RDMs from CI vectors and then completes higher-order tensors to enforce the expected fermionic index relationships. The returned arrays are NumPy ndarrays with shapes determined by the number of spatial orbitals (norb). The function documents the ordering conventions used internally and the relationship to the "normal" density-matrix order obtained after applying the separate reorder_dm123 routine. Behavior and important notes: - The function interprets 2pdm, 3pdm, and 4pdm in the intermediate (spin- traced but not fully permuted) ordering used by the underlying driver: 2pdm[p,q,r,s] = < p^dagger q r^dagger s > 3pdm[p,q,r,s,t,u] = < p^dagger q r^dagger s t^dagger u > 4pdm[p,q,r,s,t,u,v,w] = < p^dagger q r^dagger s t^dagger u v^dagger w > - After calling reorder_dm123 (a separate utility), these tensors are transformed to the "normal" density-matrix ordering commonly used in post-processing: 2pdm[p,r,q,s] = < p^dagger q^dagger s r > 3pdm[p,s,q,t,r,u] = < p^dagger q^dagger r^dagger u t s > 4pdm[p,t,q,u,r,v,s,w] = < p^dagger q^dagger r^dagger s^dagger w v u t > - Internally, the function generates alpha/beta link-index tables (bitstring link tables) from norb and nelec to determine the expected sizes of the CI vectors. The CI vectors cibra and ciket are converted to contiguous C-order NumPy arrays before being passed to the compiled driver. - The compiled driver invoked is librdm.FCIrdm4_drv obtained via getattr(librdm, fname). Therefore fname must match a callable attribute exposed by the librdm extension; otherwise an AttributeError will be raised. - After the compiled driver fills the raw tensors, helper routines _complete_dm3_ and _complete_dm4_ are applied to rdm3 and rdm4, respectively, to populate index permutations required by fermionic antisymmetry and the chosen spin-trace convention. - The function asserts that the flattened sizes of cibra and ciket match the product na*nb where na and nb are the numbers of alpha/beta Slater determinants implied by (norb, nelec). If these assertions fail, an AssertionError is raised.` |
| `pyscf_fci_selected_ci_cre_des_linkstr` | `pyscf.fci.selected_ci.cre_des_linkstr` | `pyscf/fci/selected_ci.py` | `strs: numpy.ndarray, norb: int, nelec: int, tril: bool = False` | `Create a link-index table that encodes creation/destruction operator links for a set of determinant occupation strings used by PySCF's selected configuration interaction (selected CI) routines. This function wraps the compiled libfci.SCIcre_des_linkstr routine to produce the integer-encoded link table that other parts of the pyscf.fci.selected_ci module use to enumerate single-electron annihilations and single excitations between input strings when assembling Hamiltonian matrix elements or generating connected determinants in full configuration interaction style algorithms.` |
| `pyscf_fci_selected_ci_des_des_linkstr_tril` | `pyscf.fci.selected_ci.des_des_linkstr_tril` | `pyscf/fci/selected_ci.py` | `strs: list, norb: int, nelec: tuple` | `pyscf.fci.selected_ci.des_des_linkstr_tril returns a link-table representation for generating input occupation strings used by the selected-configuration-interaction (selected_ci) routines in the Full Configuration Interaction (FCI) part of PySCF, with the lower-triangular ("tril") convention enabled. This function is a thin wrapper that calls des_des_linkstr(strs, norb, nelec, True). In the context of PySCF (a Python-based framework for quantum chemistry), this link table encodes how creation/destruction operators connect intermediate determinants (or occupation strings) to the target set of input strings used by selected-CI algorithms. Setting the internal tril flag to True chooses the lower-triangular ordering/convention for constructing the links, which affects how pairs and index orderings are enumerated for generation of excitation/de-excitation connections in selected-CI tensors and matrix elements.` |
| `pyscf_fci_selected_ci_gen_des_linkstr` | `pyscf.fci.selected_ci.gen_des_linkstr` | `pyscf/fci/selected_ci.py` | `strs: numpy.ndarray, norb: int, nelec: int` | `pyscf.fci.selected_ci.gen_des_linkstr generates a link table (link_index) that maps input determinant strings to the intermediate occupation patterns used by PySCF's selected configuration interaction (selected-CI) Full Configuration Interaction (FCI) routines. This link table is constructed by calling the underlying C helper functions in libfci (SCIdes_uniq_strs and SCIdes_linkstr) via ctypes and is intended for use by other selected-CI routines in PySCF to assemble Hamiltonian and excitation connections efficiently.` |
| `pyscf_fci_selected_ci_des_des_linkstr` | `pyscf.fci.selected_ci.des_des_linkstr` | `pyscf/fci/selected_ci.py` | `strs: numpy.ndarray, norb: int, nelec: int, tril: bool = False` | `pyscf.fci.selected_ci.des_des_linkstr: Build the link table that maps double-excitation connections between a set of determinant-like "strings" (intermediates) used by the selected configuration interaction (selected CI) routines in PySCF's FCI module. This function prepares an index array that encodes how input determinant strings (strs) couple via two-electron excitations to intermediate strings used to assemble Hamiltonian or amplitude contributions in selected CI workflows. It is implemented by calling low-level libfci C routines (SCIdes_uniq_strs and SCIdes_des_linkstr) through ctypes and is intended for use inside PySCF FCI/selected-CI code paths that require precomputed excitation link structures for efficiency.` |
| `pyscf_fci_selected_ci_gen_cre_linkstr` | `pyscf.fci.selected_ci.gen_cre_linkstr` | `pyscf/fci/selected_ci.py` | `strs: numpy.ndarray, norb: int, nelec: int` | `Generate a creation-operator link table for selected configuration interaction (selected CI) routines. This function computes the link table that maps creation-operator actions to the input configuration "strings" (strs) used by the selected CI implementation in pyscf.fci.selected_ci. It prepares intermediate orbital indices from the provided input strings by calling compiled libfci C routines (SCIcre_uniq_strs and SCIcre_linkstr), deduplicating and sorting the intermediate list, and then filling a link-index array that subsequent selected CI code uses to apply creation operators efficiently. The function casts the input strs to numpy.int64, allocates and returns a numpy.int32 array with shape (ninter, nelec+1, 4) that contains the link information produced by libfci.SCIcre_linkstr. If no virtual orbitals exist (nelec == norb), there are no creation operations to record and the function returns None.` |
| `pyscf_fci_fci_slow_contract_2e` | `pyscf.fci.fci_slow.contract_2e` | `pyscf/fci/fci_slow.py` | `eri: numpy.ndarray, fcivec: numpy.ndarray, norb: int, nelec: int, link_index: tuple = None` | `pyscf.fci.fci_slow.contract_2e computes the action of the two-electron excitation operator E_{pq}E_{rs} on a full configuration interaction (FCI) CI vector. This routine is part of the slow, reference FCI implementation in PySCF and is used when assembling or applying the two-electron part of the electronic Hamiltonian to a CI vector for small systems or for correctness/debugging. This function accepts molecular-orbital two-electron integrals and a CI vector in PySCF's string-based FCI representation, contracts the integrals with single excitations generated from the string link tables for alpha and beta spin sectors, and returns a new CI vector equal to E_{pq}E_{rs}\|CI>. The implementation reshapes the CI vector into a matrix of alpha- and beta-string amplitudes, uses precomputed link indices to map creation/annihilation operations between Slater determinants, performs an einsum over the four-index integral tensor, and accumulates contributions back into a flattened CI vector.` |
| `pyscf_fci_selected_ci_spin_square` | `pyscf.fci.selected_ci.spin_square` | `pyscf/fci/selected_ci.py` | `civec_strs: numpy.ndarray, norb: int, nelec: tuple` | `Compute the expectation value of the total spin-squared operator S^2 and the corresponding spin multiplicity for a restricted Hartree‚ÄìFock FCI (RHF-FCI) configuration-interaction (CI) wavefunction obtained from a spin-degenerate Hamiltonian in the pyscf.fci.selected_ci module. This function is intended for use in post-Hartree‚ÄìFock FCI analyses within PySCF to determine the total spin quantum number S and the multiplicity (2S+1) from an RHF-FCI CI coefficient vector produced by selected CI routines. The implementation calls the internal helper contract_ss to form S^2 acting on the CI vector and then computes the expectation value and derived quantities.` |
| `pyscf_fci_selected_ci_make_rdm2` | `pyscf.fci.selected_ci.make_rdm2` | `pyscf/fci/selected_ci.py` | `civec_strs: list, norb: int, nelec: tuple, link_index: list = None, **kwargs` | `Spin-traced two-particle density matrix for selected-configuration-interaction (selected CI) wavefunctions in PySCF. This function constructs the spin-traced two-particle reduced density matrix (2pdm) used in FCI/selected-CI post-processing and property evaluation. The returned 2pdm implements the spin-summed definition 2pdm[p,q,r,s] = <p_alpha^‚Ä† r_alpha^‚Ä† s_alpha q_alpha> + <p_beta^‚Ä† r_alpha^‚Ä† s_alpha q_beta> + <p_alpha^‚Ä† r_beta^‚Ä† s_beta q_alpha> + <p_beta^‚Ä† r_beta^‚Ä† s_beta q_beta>, by calling the lower-level helper make_rdm2s to obtain spin-resolved blocks (dm2aa, dm2ab, dm2bb) and then summing them: dm2aa += dm2bb dm2aa += dm2ab dm2aa += dm2ab.transpose(2,3,0,1) The result is the spin-traced 4-index 2pdm in the molecular orbital basis, suitable for computing two-body expectation values (for example, electron repulsion energy contributions) in the selected CI context within the PySCF framework.` |
| `pyscf_fci_selected_ci_make_rdm1` | `pyscf.fci.selected_ci.make_rdm1` | `pyscf/fci/selected_ci.py` | `civec_strs: list, norb: int, nelec: tuple, link_index: list = None` | `Spin-traced 1-particle density matrix for selected-CI wavefunctions. Computes the spin-traced one-particle reduced density matrix (RDM1) defined as dm1[p,q] = <q_alpha^\dagger p_alpha> + <q_beta^\dagger p_beta>. The convention follows McWeeny (see Eq. (5.4.20) in McWeeney's book) used in the selected configuration interaction (selected CI) implementation within PySCF. The returned matrix is the elementwise sum of the alpha and beta one-particle density matrices produced by make_rdm1s; internally this function calls make_rdm1s(civec_strs, norb, nelec, link_index) and returns rdm1a + rdm1b. In quantum-chemical practice this spin-traced RDM1 is used to evaluate expectation values of one-electron operators by simple contraction, e.g. E_one_electron = einsum('pq,qp', h1, rdm1). The diagonal elements give orbital occupations and the trace of the returned matrix equals the total number of electrons (nelec[0] + nelec[1]) within numerical tolerance.` |
| `pyscf_fci_selected_ci_trans_rdm1` | `pyscf.fci.selected_ci.trans_rdm1` | `pyscf/fci/selected_ci.py` | `cibra_strs: list, ciket_strs: list, norb: int, nelec: tuple, link_index: list = None` | `pyscf.fci.selected_ci.trans_rdm1 computes the spin-traced transition one-particle density matrix for a transition between two selected-CI states. This function is part of the selected configuration interaction (selected_ci) FCI utilities in PySCF and is used to obtain the spin-summed transition 1-particle density matrix needed for computing transition properties (for example transition dipoles or spin-summed expectation values) between two CI states represented by lists of configuration strings. Internally it calls trans_rdm1s to obtain separate alpha and beta 1-particle transition density matrices and returns their elementwise sum. The returned matrix satisfies 1pdm[p,q] = < q_alpha^dagger p_alpha > + < q_beta^dagger p_beta >, i.e. the sum of alpha and beta transition one-particle density matrix elements.` |
| `pyscf_fci_spin_op_contract_ss` | `pyscf.fci.spin_op.contract_ss` | `pyscf/fci/spin_op.py` | `fcivec: numpy.ndarray, norb: int, nelec: tuple` | `pyscf.fci.spin_op.contract_ss contracts the total-spin-squared operator S^2 with a Full Configuration Interaction (FCI) CI wavefunction, returning the resulting CI vector S^2 \|CI>. This routine is used in quantum-chemistry FCI calculations within the PySCF framework to evaluate the action of the S^2 operator on a CI expansion (for example to compute expected S^2 values or to form matrix-vector products involving S^2 in spin-analysis and spin-adaptation workflows).` |
| `pyscf_fci_spin_op_spin_square0` | `pyscf.fci.spin_op.spin_square0` | `pyscf/fci/spin_op.py` | `fcivec: numpy.ndarray, norb: int, nelec: int` | `Compute the S^2 expectation value and spin multiplicity for a restricted-Hartree‚ÄìFock full configuration interaction (RHF-FCI) CI wavefunction vector.` |
| `pyscf_fci_selected_ci_slow_contract_2e` | `pyscf.fci.selected_ci_slow.contract_2e` | `pyscf/fci/selected_ci_slow.py` | `eri: numpy.ndarray, civec_strs: tuple, norb: int, nelec: int, link_index: tuple = None` | `pyscf.fci.selected_ci_slow.contract_2e: Compute the action of two-particle excitation operators contracted with the electronic two-electron integrals on a CI state within the selected-configuration-interaction (selected CI / FCI) machinery of PySCF. This function implements the tensor contraction that yields the new CI coefficient vector for the operator combination E_{pq} E_{rs} V_{pqrs} applied to a CI wavefunction \|CI>, where E_{pq} are spin-orbital excitation operators and V_{pqrs} are the two-electron integrals restored by ao2mo.restore. It is used in the selected_ci_slow code path to produce the matrix-vector product required in FCI-like procedures (energy evaluation, Davidson iterations, or Hamiltonian builds) using alpha/beta string representations and link-index tables to enumerate single and double excitations efficiently.` |
| `pyscf_grad_mspdft_get_diabfns` | `pyscf.grad.mspdft.get_diabfns` | `pyscf/grad/mspdft.py` | `obj: str` | `Interpret the name of a multistate pair-density functional theory (MS-PDFT) objective and return two callable functions that implement the objective's derivative components used by the MS-PDFT gradient machinery in PySCF. This function is used by PySCF gradient modules that assemble derivatives for MS-PDFT methods. Rather than computing derivatives immediately, it maps a textual MS-PDFT method identifier to the concrete implementations of (1) the orbital-rotation and CI-transfer portion of the Hessian-vector product for intermediate-state rotations and (2) the gradient with respect to nuclear geometry perturbations. The mapping is currently implemented by dynamically importing implementations from pyscf.grad.cmspdft when the requested method is supported.` |
| `pyscf_fci_spin_op_spin_square_general` | `pyscf.fci.spin_op.spin_square_general` | `pyscf/fci/spin_op.py` | `dm1a: numpy.ndarray, dm1b: numpy.ndarray, dm2aa: numpy.ndarray, dm2ab: numpy.ndarray, dm2bb: numpy.ndarray, mo_coeff: tuple, ovlp: numpy.ndarray = 1` | `General spin square operator for UHF-FCI wavefunctions. Computes the expectation value of the total spin-squared operator S^2 and the corresponding spin multiplicity (2S+1) for an unrestricted Hartree‚ÄìFock full configuration interaction (UHF-FCI) wavefunction using one- and two-particle reduced density matrices in a molecular-orbital (MO) representation. This implementation projects AO-space overlaps into the MO basis when a nontrivial AO overlap matrix is provided and implements the standard decomposition of S^2 into S_z*S_z and S_+*S_- + S_-*S_+ contributions: <CI\|S_+ S_-\|CI>, <CI\|S_- S_+\|CI>, and <CI\|S_z S_z\|CI>, contracting the provided one-particle (dm1a, dm1b) and two-particle (dm2aa, dm2ab, dm2bb) density matrices with the projected overlap matrices. The function follows the conventional PySCF FCI/FCIDUMP indexing and uses the ordering and transpositions shown in the source code to form the alpha-beta cross terms (dm2abba, dm2baab). It returns the scalar expectation value of S^2 and the corresponding multiplicity derived from S = sqrt(<S^2> + 1/4) - 1/2, which is useful to assess spin contamination and to identify the physical spin state of a computed UHF-FCI wavefunction.` |
| `pyscf_grad_rhf_make_rdm1e` | `pyscf.grad.rhf.make_rdm1e` | `pyscf/grad/rhf.py` | `mo_energy: numpy.ndarray, mo_coeff: numpy.ndarray, mo_occ: numpy.ndarray` | `pyscf.grad.rhf.make_rdm1e constructs the energy-weighted one-particle (one-electron) density matrix used in restricted Hartree‚ÄìFock (RHF) gradient calculations. The matrix is assembled in the atomic-orbital (AO) basis by summing contributions from molecular orbitals (MOs) that are treated as occupied (mo_occ > 0), where each occupied MO contribution is weighted by the product of its orbital energy and occupation. In PySCF this energy-weighted density appears when forming response terms and energy derivatives with respect to nuclear coordinates.` |
| `pyscf_grad_uhf_make_rdm1e` | `pyscf.grad.uhf.make_rdm1e` | `pyscf/grad/uhf.py` | `mo_energy: tuple, mo_coeff: tuple, mo_occ: tuple` | `Construct the unrestricted (UHF) energy-weighted one-particle density matrices for alpha and beta spin channels.` |
| `pyscf_gto_basis_parse_ecp` | `pyscf.gto.basis.parse_ecp` | `pyscf/gto/basis/__init__.py` | `string: str, symb: str = None` | `pyscf.gto.basis.parse_ecp parses an effective core potential (ECP) specification given as text and returns the parsed ECP data in the format expected by PySCF gto basis utilities. This function is part of the PySCF (Python-based Simulations of Chemistry Framework) gto basis handling and is used when users supply ECP definitions (for example, in NWChem-style text) that must be converted into PySCF's internal representation for attaching ECPs to atomic basis sets in electronic-structure calculations. The implementation delegates the parsing work to parse_nwchem_ecp.parse, so behavior, accepted textual conventions, and the detailed structure of the returned data follow that parser's rules. No file I/O is performed by this wrapper: the input is taken entirely from the provided string. In typical usage within PySCF, the returned value is passed directly to gto basis setup routines so that the specified ECP can be applied to the corresponding atom(s) in molecular calculations.` |
| `pyscf_gto_basis_load_pseudo` | `pyscf.gto.basis.load_pseudo` | `pyscf/gto/basis/__init__.py` | `filename_or_basisname: str, symb: str` | `Parses and loads a pseudopotential (PP) entry for use by the pyscf.gto module. This function accepts either a filesystem path to a CP2K-format pseudopotential file or a short basis/pseudopotential name that may be resolved via the internal PP_ALIAS mapping and the packaged GTH pseudopotential directory. The parsed pseudopotential data is the representation produced by the CP2K-format parser used internally by PySCF and is suitable for supplying pseudopotential information to PySCF GTO-based calculations (for example, DFT calculations that use GTH pseudopotentials). Behavior summary and domain significance: In the PySCF (Python-based Simulations of Chemistry Framework) gto submodule, pseudopotentials are used to replace atomic core electrons and reduce computational cost for quantum chemistry calculations. This function centralizes the logic for locating, loading, and parsing pseudopotential definitions. It first normalizes the element symbol, then either loads an external file if filename_or_basisname is a valid path, resolves known aliases to files installed with PySCF, or asks the CP2K-format parser to parse the provided name. Filesystem reads and alias resolution are performed as side effects.` |
| `pyscf_gto_basis_bse_autoabs` | `pyscf.gto.basis.bse.autoabs` | `pyscf/gto/basis/bse.py` | `name: str, elements: list` | `pyscf.gto.basis.bse.autoabs: Create a Coulomb fitting (auxiliary) basis set from an existing orbital basis specification using the Basis Set Exchange (BSE) helper routines and convert it into the PySCF orbital-basis representation. This function is used within the PySCF (Python-based Simulations of Chemistry Framework) gto/basis workflow to automatically generate auxiliary (Coulomb fitting) basis sets that are commonly employed in density-fitting / resolution-of-identity (RI) approximations to accelerate the evaluation of two-electron Coulomb integrals. The generation follows the prescription discussed in R. Yang, A. P. Rendell, and M. J. Frisch, J. Chem. Phys. 127, 074102 (2007), and is applicable to orbital bases accessible via the Basis Set Exchange API for elements in the covered range (for example H to Kr in the referenced work). Practical significance: the returned auxiliary basis is directly usable by PySCF density-fitting routines to reduce computational cost at the expense of an approximate representation of the Coulomb operator.` |
| `pyscf_gto_basis_bse_autoaux` | `pyscf.gto.basis.bse.autoaux` | `pyscf/gto/basis/bse.py` | `name: str, elements: list` | `pyscf.gto.basis.bse.autoaux generates an auxiliary basis set for the specified orbital basis set using the Auto-Aux algorithm of Stoychev, Auer, and Neese (J. Chem. Theory Comput. 2017). This function is part of the PySCF basis utilities (pyscf.gto.basis.bse) and automates construction of auxiliary (density-fitting / resolution-of-identity) basis functions that are compatible with a given orbital basis set identified by name and restricted to a given set of chemical elements. The generated auxiliary basis is intended for use in density-fitting (RI) and related post-Hartree‚ÄìFock procedures within the PySCF framework and is produced by calling the basis-set-exchange to obtain the orbital basis and then applying the Auto-Aux generation routine.` |
| `pyscf_gto_basis_bse_get_basis` | `pyscf.gto.basis.bse.get_basis` | `pyscf/gto/basis/bse.py` | `name: str, elements: list` | `pyscf.gto.basis.bse.get_basis: Obtain a basis set and return it in the PySCF internal basis format used for quantum chemistry calculations. This function is used in the PySCF electronic-structure framework to retrieve an atomic-orbital basis set identified by a common basis-set name (for example "cc-pVDZ") and to convert the retrieved basis into the internal dictionary format consumed by PySCF routines (for example by pyscf.gto.Mole construction and integrals code). Internally it delegates retrieval to basis_set_exchange.api.get_basis(name, elements) and then converts the raw basis-set data into the PySCF orbital-basis representation via the module's _orbital_basis conversion routine, returning the processed dictionary.` |
| `pyscf_gto_basis_load` | `pyscf.gto.basis.load` | `pyscf/gto/basis/__init__.py` | `filename_or_basisname: str, symb: str, optimize: bool = False` | `Convert a basis-set identifier or file into the PySCF internal basis representation for a single atomic symbol. This function is used throughout PySCF to obtain the basis definition that can be assigned to mol.basis[symb] for electronic structure calculations (for example, assigning a standard STO-3G or user-supplied basis to an atom). It accepts either a case-insensitive basis set name (which may match built-in aliases, GTH aliases, user-provided basis sets, or common Pople names), a filesystem path to a file containing basis definitions, or a compound identifier that encodes a contraction scheme using the "@<scheme>" suffix. The returned value is the basis data for the requested atomic symbol in the internal format expected by PySCF routines that build atomic orbital integrals.` |
| `pyscf_gto_basis_parse_cp2k_parse` | `pyscf.gto.basis.parse_cp2k.parse` | `pyscf/gto/basis/parse_cp2k.py` | `string: str, symb: str = None, optimize: bool = False` | `Parse a CP2K-format basis set text and return the corresponding PySCF internal basis representation suitable for assignment to Mole.basis or Cell.basis. This function is used in the PySCF workflow to convert basis definitions produced or distributed in CP2K format (text blocks that may contain multiple element blocks and comments) into the internal data structure that PySCF quantum-chemistry objects accept.` |
| `pyscf_gto_basis_parse_cp2k_pp_parse` | `pyscf.gto.basis.parse_cp2k_pp.parse` | `pyscf/gto/basis/parse_cp2k_pp.py` | `string: str, symb: str = None` | `pyscf.gto.basis.parse_cp2k_pp.parse parses CP2K-format pseudopotential text and returns the parsed pseudopotential in PySCF's internal basis/pseudopotential representation that can be assigned to Cell.pseudo for electronic-structure calculations. This function is used in the PySCF domain to convert CP2K-style GTH pseudopotential blocks (text that would appear in CP2K input files) into the in-memory format PySCF expects for pseudopotentials during atomistic and periodic calculations.` |
| `pyscf_gto_basis_parse_gaussian_parse` | `pyscf.gto.basis.parse_gaussian.parse` | `pyscf/gto/basis/parse_gaussian.py` | `string: str, optimize: bool = True` | `Parse a basis set specification given as a text in NWChem format and convert it to PySCF's internal basis representation that can be assigned to Mole.basis for quantum-chemistry calculations.` |
| `pyscf_gto_basis_parse_cp2k_pp_load` | `pyscf.gto.basis.parse_cp2k_pp.load` | `pyscf/gto/basis/parse_cp2k_pp.py` | `pseudofile: str, symb: str, suffix: str = None` | `Parse and load the CP2K-format pseudopotential entry for a given element symbol and return it in PySCF's internal pseudopotential representation suitable for assignment to Cell.pseudo. This function is used in the pseudopotential handling pipeline of pyscf.gto.basis.parse_cp2k_pp: it locates the CP2K pseudopotential block for the requested atom symbol in the provided pseudofile, parses that block, and converts it to the internal format that PySCF uses when constructing Hamiltonians and integrals for calculations that use pseudopotentials (for example, periodic or molecular calculations that replace core electrons with an effective potential).` |
| `pyscf_gto_basis_parse_nwchem_load` | `pyscf.gto.basis.parse_nwchem.load` | `pyscf/gto/basis/parse_nwchem.py` | `basisfile: str, symb: str, optimize: bool = True` | `pyscf.gto.basis.parse_nwchem.load loads a single atomic basis definition for the given atomic symbol from an NWChem-format basis file and returns the parsed basis in the internal PySCF format used for building contracted Gaussian basis sets. This function is used by PySCF to read basis set segments from external basis files and convert them to the data structures consumed by integral evaluation and electronic-structure modules.` |
| `pyscf_gto_basis_parse_cp2k_pp_search_seg` | `pyscf.gto.basis.parse_cp2k_pp.search_seg` | `pyscf/gto/basis/parse_cp2k_pp.py` | `pseudofile: str, symb: str, suffix: str = None` | `Locate and return the pseudopotential entry for a given atomic symbol from a CP2K/GTH-format pseudopotential file. This function is part of the CP2K pseudopotential parsing helpers in pyscf.gto.basis.parse_cp2k_pp and is used by higher-level code in PySCF that needs to read and apply Goedecker‚ÄìTeter‚ÄìHutter (GTH) style pseudopotentials shipped in CP2K-format files. It opens the file given by pseudofile, splits the file into pseudopotential blocks using the CP2K marker "#PSEUDOPOTENTIAL", and then delegates the per-block selection to an internal helper (_search_gthpp_block). The returned value is the raw pseudopotential block associated with the requested atom and is intended to be consumed by subsequent parsing routines that build PySCF internal pseudopotential/basis representations.` |
| `pyscf_gto_basis_parse_nwchem_optimize_contraction` | `pyscf.gto.basis.parse_nwchem.optimize_contraction` | `pyscf/gto/basis/parse_nwchem.py` | `basis: list` | `Search the basis segments which have identical primitive exponents and merge their contraction coefficient columns to produce more general-contracted segments suitable for downstream use in PySCF. This function is intended for use while parsing NWChem-style basis specifications (pyscf.gto.basis.parse_nwchem) to reduce redundant segments that share exactly the same exponent arrays. It differs from to_general_contraction in that the output may still contain multiple segments for a given angular-momentum/kappa key; only segments whose exponent arrays are exactly equal are merged.` |
| `pyscf_gto_basis_load_ecp` | `pyscf.gto.basis.load_ecp` | `pyscf/gto/basis/__init__.py` | `filename_or_basisname: str, symb: str` | `pyscf.gto.basis.load_ecp loads an effective core potential (ECP) definition for a specified element from a local file, the bundled PySCF basis directory, a NWChem-formatted basis string/name, or the Basis Set Exchange (BSE). This function is used in PySCF to obtain ECP data (pseudopotentials) required by quantum chemistry calculations to replace explicit core electrons with an effective potential for the element identified by symb. This function accepts either a filesystem path to an ECP file or a basis name/identifier. If filename_or_basisname is a path to an existing file, the file is parsed as a NWChem-format ECP file. If filename_or_basisname is not a file path, the function will canonicalize the name via the repository alias map and bundled basis directory, then try to parse it as a NWChem-format basis specification. If that fails, and if the optional Basis Set Exchange integration is available in the environment, the function will query BSE for the requested basis and extract ECP data for the given element. The returned ECP data can then be supplied to PySCF molecular/basis setup routines to apply a pseudopotential for the specified element during electronic-structure calculations.` |
| `pyscf_gto_basis_parse_nwchem_remove_zero` | `pyscf.gto.basis.parse_nwchem.remove_zero` | `pyscf/gto/basis/parse_nwchem.py` | `basis: list` | `pyscf.gto.basis.parse_nwchem.remove_zero removes basis-function exponents from an NWChem-style basis description when all of their contraction coefficients are exactly zero. This function is used by the PySCF NWChem basis parser to clean parsed basis sets: it reduces memory and avoids creating basis functions that contribute nothing to integrals or molecular orbitals by eliminating exponent rows whose contraction coefficients are all zero.` |
| `pyscf_gto_basis_parse_nwchem_ecp_load` | `pyscf.gto.basis.parse_nwchem_ecp.load` | `pyscf/gto/basis/parse_nwchem_ecp.py` | `basisfile: str, symb: str` | `Load effective core potential (ECP) definition for a specified atomic symbol from an NWChem-format basis/ECP file. This function is a thin convenience wrapper used in the PySCF gto/basis subsystem to obtain the ECP information that PySCF needs to attach pseudopotentials to atoms when building molecular integrals and Hamiltonians. Internally it locates the ECP block for the requested element in the provided file (via the module's _search_ecp helper) and converts that block into PySCF's internal representation (via the module's _parse_ecp helper). The returned value is intended to be consumed by other PySCF gto/basis routines that construct basis set and ECP data for quantum-chemistry calculations.` |
| `pyscf_gto_basis_parse_nwchem_convert_basis_to_nwchem` | `pyscf.gto.basis.parse_nwchem.convert_basis_to_nwchem` | `pyscf/gto/basis/parse_nwchem.py` | `symb: str, basis: list` | `Convert the internal PySCF basis representation into a NWChem-format basis set string suitable for writing into NWChem input files or for interoperability with NWChem-based workflows in quantum chemistry. This function is part of the pyscf.gto.basis.parse_nwchem module and is used to export PySCF's in-memory contracted Gaussian basis description into the plain-text format expected by NWChem, including a summary comment line and per-shell blocks of numerical primitive/contracted data.` |
| `pyscf_gto_basis_parse_nwchem_to_general_contraction` | `pyscf.gto.basis.parse_nwchem.to_general_contraction` | `pyscf/gto/basis/parse_nwchem.py` | `basis: list` | `to_general_contraction(basis) Convert a segmented-contracted basis representation into a general-contracted basis representation. This function is used in the PySCF quantum chemistry framework to convert basis-set sections that are expressed as segmented contractions (separate contraction blocks per primitive exponent) into a single general contraction per angular-momentum (and optional kappa) section. In practice this is useful when reading or manipulating basis sets (for example, NWChem-style segmented basis data or results from gto.uncontract/gto.contract flows) so that all primitives with the same angular momentum are represented by a shared list of unique exponents and a coefficient matrix describing general contraction vectors. The conversion preserves the angular-momentum grouping (and optional relativistic kappa) and combines coefficient blocks by placing them on a block-diagonal matrix before aggregating coefficients associated with identical exponents.` |
| `pyscf_gto_basis_parse_nwchem_parse` | `pyscf.gto.basis.parse_nwchem.parse` | `pyscf/gto/basis/parse_nwchem.py` | `string: str, symb: str = None, optimize: bool = True` | `Parse a basis set specification given in NWChem format and return the corresponding PySCF internal basis representation that can be assigned to Mole.basis. This function is used within the PySCF framework (Python-based Simulations of Chemistry Framework) to convert textual basis-set data (for example copied from NWChem basis libraries or files) into the list/dictionary structure that PySCF molecules expect. The parser ignores comment lines starting with '#', blank lines, and lines beginning with the keywords "BASIS SET" or "END". When a chemical symbol is supplied, the function will search for and extract the basis block for that element; otherwise it parses all provided lines.` |
| `pyscf_gto_basis_parse_nwchem_ecp_convert_ecp_to_nwchem` | `pyscf.gto.basis.parse_nwchem_ecp.convert_ecp_to_nwchem` | `pyscf/gto/basis/parse_nwchem_ecp.py` | `symb: str, ecp: list` | `Convert the internal ECP data structure used by PySCF into a text string formatted for NWChem ECP input blocks. This function is used in the PySCF gto/basis subsystem to export effective core potentials (ECPs) so they can be consumed by NWChem or written into NWChem-compatible input files when sharing pseudopotential data between quantum chemistry packages.` |
| `pyscf_gto_basis_parse_nwchem_ecp_parse` | `pyscf.gto.basis.parse_nwchem_ecp.parse` | `pyscf/gto/basis/parse_nwchem_ecp.py` | `string: str, symb: str = None` | `Parse NWChem-formatted effective core potential (ECP) text and return it in the PySCF internal basis format used for attaching ECPs to atoms (i.e., suitable for assignment to Mole.ecp). This function is used in the PySCF quantum chemistry framework to convert textual ECP blocks produced for NWChem into the data structure that PySCF's electronic structure routines consume when applying effective core potentials to atoms in molecular calculations.` |
| `pyscf_gto_mole_bse_predefined_ecp` | `pyscf.gto.mole.bse_predefined_ecp` | `pyscf/gto/mole.py` | `basis_name: str, elements: list` | `pyscf.gto.mole.bse_predefined_ecp: Find predefined effective core potential (ECP) information for a requested basis set name and a list of atomic species using the BSE (Basis Set Exchange) metadata cached in the module. This function is used by PySCF to determine whether a given basis set (identified by basis_name) has an associated ECP definition in the repository of predefined BSE metadata and, if so, which atoms in the provided elements list require that ECP. The practical significance is to enable automatic selection or validation of ECPs when building molecular basis descriptions for electronic structure calculations.` |
| `pyscf_gto_mole_cart2j_kappa` | `pyscf.gto.mole.cart2j_kappa` | `pyscf/gto/mole.py` | `kappa: int, l: int = None, normalized: str = None` | `pyscf.gto.mole.cart2j_kappa: Construct the Cartesian-to-spinor transformation matrix for a given Dirac kappa. This function produces the complex-valued transformation matrix used in PySCF to map Cartesian Gaussian-type orbital (GTO) basis functions onto spinor spherical components parameterized by the relativistic quantum number kappa. It is used when building spinor integrals and interfacing with the libcint library (moleintor.libcgto.CINTc2s_ket_spinor_sf1) in relativistic electronic-structure calculations.` |
| `pyscf_gto_mole_atom_types` | `pyscf.gto.mole.atom_types` | `pyscf/gto/mole.py` | `atoms: list, basis: dict = None, magmom: numpy.ndarray = None` | `pyscf.gto.mole.atom_types identifies symmetry-inequivalent atom groups in a PySCF molecular atom list and optionally refines those groups by atomic basis equivalence and collinear magnetic moment. It is used in PySCF to determine which atom indices share the same chemical identity and basis representation (important for assigning basis sets, exploiting molecular symmetry, and handling ghost atoms), and to split those groups further when spin polarization (magnetic moment) distinguishes otherwise identical atomic sites.` |
| `pyscf_gto_mole_cart2j_l` | `pyscf.gto.mole.cart2j_l` | `pyscf/gto/mole.py` | `l: int, normalized: str = None` | `pyscf.gto.mole.cart2j_l: Compute the Cartesian-to-spinor transformation matrix for angular momentum l used in PySCF to convert Cartesian Gaussian-type orbitals (GTOs) into a spinor angular-momentum basis block. This transformation is used in PySCF when assembling integrals or converting basis-function coefficient vectors between Cartesian GTO representations and spinor (total-angular-momentum) representations required for relativistic or spinor-enabled electronic-structure operations.` |
| `pyscf_gto_mole_cart2zmat` | `pyscf.gto.mole.cart2zmat` | `pyscf/gto/mole.py` | `coord: numpy.ndarray` | `pyscf.gto.mole.cart2zmat converts a list/array of Cartesian atomic coordinates into a z-matrix style multiline string used by PySCF for simple text representation of molecular geometry.` |
| `pyscf_gto_mole_cart2sph` | `pyscf.gto.mole.cart2sph` | `pyscf/gto/mole.py` | `l: int, c_tensor: numpy.ndarray = None, normalized: str = None` | `Cartesian to real spherical transformation matrix. Converts coefficients or a transformation tensor for Cartesian Gaussian-type orbitals (GTOs) into the corresponding coefficients in the real (tesseral) spherical-harmonic representation used by PySCF and the underlying libcint integrals. This function is used in atomic-orbital basis conversions and integral transformations inside the PySCF quantum-chemistry framework (for example, when translating Cartesian AO representations to real spherical AOs for integral evaluation or post-processing). Behavior and domain significance: - The angular momentum quantum number l selects the shell type (l=0 -> s, l=1 -> p, l=2 -> d, ...). The function computes a matrix that maps Cartesian GTO components (nf = (l+1)*(l+2)//2 Cartesian functions) to real spherical harmonics (nd = 2*l+1). These sizes are used throughout PySCF and libcint when handling basis functions. - For l == 0 or l == 1 the conversion is trivial up to a normalization scaling: if normalized == 'sp' (the libcint convention where s and p functions are already normalized), the input tensor is returned unchanged; otherwise a fixed scalar normalization factor is applied (0.282094791773878143 for s, and 0.488602511902919921 for p). These numeric factors are the standard normalization constants that map unnormalized Cartesian s/p basis functions to the real spherical normalization used in PySCF and libcint. - For 2 <= l <= 15 the function calls the compiled C helper moleintor.libcgto.CINTc2s_ket_sph to form the full Cartesian-to-spherical transformation. The C function writes into a Fortran-ordered output buffer for efficient downstream use in PySCF integrals. - The function asserts l <= 15; angular momenta above 15 are not supported and will raise an AssertionError.` |
| `pyscf_gto_mole_conc_env` | `pyscf.gto.mole.conc_env` | `pyscf/gto/mole.py` | `atm1: numpy.ndarray, bas1: numpy.ndarray, env1: numpy.ndarray, atm2: numpy.ndarray, bas2: numpy.ndarray, env2: numpy.ndarray` | `pyscf.gto.mole.conc_env concatenates the integral environment arrays of two Mole-like objects to build a single combined environment suitable for computing cross-molecule integrals (for example, integrals between basis functions ¬µ on mol1 and ŒΩ on mol2, <¬µ\|ŒΩ>). This helper is used in PySCF to prepare the internal integer/pointer tables (atm, bas) and the floating-point environment vector (env) that the low-level integral engines (for example, gto.moleintor.getints) expect when evaluating integrals that span two separate Mole instances. The function returns new arrays that represent the concatenation of the per-molecule integral descriptors. It adjusts pointer and atom-index columns in the second molecule's atm and bas arrays so that their internal offsets refer correctly into the concatenated env and the combined atom list. The function copies and modifies the atm2 and bas2 inputs internally and does not mutate the original caller arrays.` |
| `pyscf_gto_mole_dyall_nuc_mod` | `pyscf.gto.mole.dyall_nuc_mod` | `pyscf/gto/mole.py` | `nuc_charge: int, nucprop: dict = {}` | `pyscf.gto.mole.dyall_nuc_mod computes the Dyall empirical Gaussian nuclear charge exponent zeta for a given atomic number and optional nuclear properties. This function implements the parametrization of L. Visscher and K. Dyall (At. Data Nucl. Data Tables, 67, 207 (1997)) used in PySCF to define a finite Gaussian nuclear charge distribution rho(r) = nuc_charge * Norm * exp(-zeta * r^2), where zeta controls the spatial width of the nuclear charge distribution. In the PySCF electronic-structure context, this zeta is used when modeling extended (non-point) nuclei for integrals and relativistic corrections, particularly relevant for heavier elements where finite-nucleus effects matter. The function derives zeta from an empirical radius r computed from the nuclear mass via r = (0.836 * mass**(1./3) + 0.570) / 52917.7249 and then zeta = 1.5 / (r**2). The numeric constant 52917.7249 and the coefficients 0.836 and 0.570 follow the Dyall parametrization; the mass value is taken from nucprop['mass'] if provided, otherwise from elements.ISOTOPE_MAIN[nuc_charge], which supplies the default isotope mass used across PySCF. The returned zeta is a floating-point Gaussian exponent appropriate for constructing the normalized Gaussian nuclear charge distribution used by PySCF routines.` |
| `pyscf_gto_mole_expand_etb` | `pyscf.gto.mole.expand_etb` | `pyscf/gto/mole.py` | `l: int, n: int, alpha: float, beta: float` | `pyscf.gto.mole.expand_etb generates a list of Gaussian-type orbital (GTO) exponents in the even-tempered form used to populate Mole.basis entries in PySCF. This function is used in the PySCF quantum-chemistry framework to produce a sequence of radial exponents for primitive GTOs for a given angular momentum shell; those exponents determine the spatial extent and decay of the basis functions used in electronic structure calculations.` |
| `pyscf_gto_mole_etbs` | `pyscf.gto.mole.etbs` | `pyscf/gto/mole.py` | `etbs: list` | `pyscf.gto.mole.etbs: Utilities to generate even-tempered Gaussian atomic basis primitives and format them for assignment to a Mole.basis in PySCF quantum-chemistry calculations. Generates a flattened list of basis primitives from a sequence of even-tempered basis (ETB) specifications. Each ETB specification is interpreted as a geometric progression of Gaussian exponents defined by an initial exponent and a common ratio; the function expands each specification into primitive Gaussian entries and returns them in the format expected by Mole.basis so they can be used directly in electronic-structure calculations (Hartree‚ÄìFock, DFT, correlated methods) implemented within PySCF.` |
| `pyscf_gto_basis_parse` | `pyscf.gto.basis.parse` | `pyscf/gto/basis/__init__.py` | `string: str, symb: str = None, optimize: bool = False` | `pyscf.gto.basis.parse parses textual basis set and pseudopotential (ECP/PP) blocks written in NWChem or CP2K formats and returns a PySCF internal representation suitable for assignment to Mole.basis or Cell.basis. This function is used within the PySCF quantum chemistry framework to convert basis/ECP text (for example, basis set blocks copied from NWChem output files or CP2K basis/pseudopotential specifications) into the Python data structures that PySCF electronic-structure routines expect. The parser recognizes three main dispatch cases based on markers in the input text: if the substring "ECP" appears it is treated as an NWChem-format ECP and routed to the NWChem ECP parser; if the substring "GTH" appears it is treated as a CP2K/Goedecker‚ÄìTeter‚ÄìHutter pseudopotential/basis block and routed to the CP2K parsers (the presence of "PSEUDOPOTENTIAL" within a "GTH" block selects the CP2K pseudopotential parser); otherwise the text is assumed to be an NWChem-format basis set and routed to the NWChem basis parser. Blank lines and literal lines that contain "BASIS SET" or "END" are ignored during parsing. The returned structure is intended to be directly assignable to mol.basis or cell.basis to define atomic basis functions or pseudopotentials in molecular and periodic calculations.` |
| `pyscf_gto_mole_fakemol_for_cgtf_charge` | `pyscf.gto.mole.fakemol_for_cgtf_charge` | `pyscf/gto/mole.py` | `coord: numpy.ndarray, expnt: numpy.ndarray = 1e+16, contr_coeff: numpy.ndarray = 1` | `Constructs a lightweight pyscf.gto.Mole that represents a Gaussian charge distribution centered at a single coordinate for use in CGTF charge-related integral routines. This function is used in the PySCF Gaussian integrals machinery when a localized Gaussian representation of an external point/compact charge is required (for example, in charge fitting or charge-interaction integrals used by CGTF-related code). It builds a minimal Mole object with internal arrays (_atm, _bas, _env) arranged so integrals can be evaluated as if there were an atom with one or a contracted set of s-type Gaussian primitives representing the charge. The returned Mole is marked as built (fakemol._built == True) and is intended only as a transient container for integral evaluation, not as a full chemical system description.` |
| `pyscf_gto_mole_fakemol_for_charges` | `pyscf.gto.mole.fakemol_for_charges` | `pyscf/gto/mole.py` | `coords: numpy.ndarray, expnt: numpy.ndarray = 1e+16` | `Construct a fake pyscf.gto.mole.Mole that encodes point charges located at the given Cartesian coordinates using narrow Gaussian charge distributions. This helper is used within the PySCF (Python-based Simulations of Chemistry Framework) codebase to represent external point charges or localized monopoles as very narrow Gaussian basis functions so that existing integrals/routines that expect a Mole object (with _atm, _bas, _env layout) can be reused for embedding, QM/MM point-charge fields, or any calculation that requires a Mole-like container of charges. The function builds internal ATM and BAS integer arrays and an ENV array that stores coordinates and Gaussian exponent/coeff pairs, and sets the returned Mole._built flag to True so downstream PySCF routines treat it as a ready Mole object.` |
| `pyscf_gto_mole_format_basis` | `pyscf.gto.mole.format_basis` | `pyscf/gto/mole.py` | `basis_tab: dict, sort_basis: bool = True` | `Convert a Mole.basis-like mapping into PySCF's internal basis-set data format used by integral formation and other electronic-structure routines. This function is used inside PySCF to prepare atom-centered basis descriptions provided by the user (for example via Mole.basis) into the canonical internal representation expected by downstream code such as integral builders and basis-manipulation utilities (for example decontract_basis). The function normalizes atom keys, converts each atom's basis specification using PySCF's basis converter pipeline, removes empty entries, and optionally sorts the resulting shell list by angular momentum so that functions which assume grouped angular-momentum blocks operate correctly.` |
| `pyscf_gto_mole_fromstring` | `pyscf.gto.mole.fromstring` | `pyscf/gto/mole.py` | `string: str, format: str = "xyz"` | `pyscf.gto.mole.fromstring converts a molecular geometry string in a supported format into the internal line-based geometry representation used by PySCF utilities and tests.` |
| `pyscf_gto_mole_format_pseudo` | `pyscf.gto.mole.format_pseudo` | `pyscf/gto/mole.py` | `pseudo_tab: dict` | `Convert the input pseudopotential table (pseudo_tab) to the internal data format used by PySCF's GTO module for pseudopotentials. This function is used in the PySCF framework to prepare pseudopotential data so that downstream modules (basis set handling, integral evaluation, and quantum chemistry solvers) can consume a consistent, fully expanded representation. The input pseudo_tab is a mapping for atomic sites to pseudopotential specifications; values in pseudo_tab may be either: - a string identifier naming a pseudopotential (in which case pyscf.pbc.gto.pseudo.load is called to obtain the internal representation for the standardized atomic symbol), or - an already-formatted pseudopotential data structure (in which case the value is used verbatim). The function canonicalizes atom labels using the internal helper _symbol(atom) before using them as keys in the returned mapping. When a string identifier is provided for an atom, _std_symbol_without_ghost is used to compute the standardized symbol passed to pyscf.pbc.gto.pseudo.load. The returned structure matches the internal :attr:`pseudo` layout expected by PySCF's GTO routines.` |
| `pyscf_gto_mole_from_zmatrix` | `pyscf.gto.mole.from_zmatrix` | `pyscf/gto/mole.py` | `atomstr: str` | `Convert a Z-matrix string to Cartesian coordinates and atom symbols suitable for PySCF molecular input.` |
| `pyscf_gto_mole_format_ecp` | `pyscf.gto.mole.format_ecp` | `pyscf/gto/mole.py` | `ecp_tab: dict` | `pyscf.gto.mole.format_ecp converts a user-supplied ECP (effective core potential) specification into the internal ECP data format used by PySCF's molecular integrals and basis handling routines. This function is used when constructing a Mole object or reading atomic basis/ECP input so that downstream code always sees a consistent mapping from element symbol to the ECP definition (including the number of core electrons and radial/ang-momentum projectors).` |
| `pyscf_gto_mole_gaussian_int` | `pyscf.gto.mole.gaussian_int` | `pyscf/gto/mole.py` | `n: int, alpha: float` | `pyscf.gto.mole.gaussian_int computes the definite integral int_0^inf x^n exp(-alpha x^2) dx and returns its closed-form value using the Gamma function. In the PySCF quantum-chemistry context this routine is used to evaluate one-dimensional radial moments that appear when analytically integrating Gaussian-type functions (e.g., normalization factors and radial parts of overlap, kinetic, and two-electron integrals). The function implements the known identity Gamma((n+1)/2) / (2 * alpha^{(n+1)/2}), so callers obtain the analytic contribution of x^n times a Gaussian damping factor without numerical quadrature.` |
| `pyscf_gto_mole_is_au` | `pyscf.gto.mole.is_au` | `pyscf/gto/mole.py` | `unit: str` | `Return whether the given unit string is recognized as atomic units (A.U.) by PySCF. This function is part of pyscf.gto.mole and is used within the PySCF molecular input and geometry handling code to decide whether user-supplied unit strings should be interpreted as atomic units (a.u.). In quantum chemistry and within PySCF, atomic units are a common internal convention for expressing distances, energies, and other physical quantities; correctly detecting that a user requested atomic units affects scaling and interpretation of numerical values passed to the library.` |
| `pyscf_gto_mole_fromfile` | `pyscf.gto.mole.fromfile` | `pyscf/gto/mole.py` | `filename: str, format: str = None` | `pyscf.gto.mole.fromfile reads a molecular geometry from a plain text file and returns the parsed representation suitable for constructing a PySCF molecule (primarily used in test code and simple I/O workflows). This function opens the file at the given path, optionally infers the format from the filename extension when format is None, reads the entire file as text, and delegates parsing to pyscf.gto.mole.fromstring. Supported textual input formats (as recognized by this function and passed to fromstring) include "raw", "xyz", "zmat", and "sdf". The "raw" format is a simple, line-oriented format where each non-empty line contains an atomic symbol followed by three Cartesian coordinates: symbol x y z. The function uses a with-open context to ensure the file is closed after reading.` |
| `pyscf_gto_mole_gto_norm` | `pyscf.gto.mole.gto_norm` | `pyscf/gto/mole.py` | `l: int, expnt: float` | `Normalized factor for a Gaussian-type orbital (GTO) radial function r^l * exp(-alpha * r^2). This function computes the scalar normalization constant N that enforces 1/sqrt(integral_0^inf [g(r)]^2 r^2 dr) for the radial part g(r) = r^l exp(-alpha r^2). It is used throughout the PySCF quantum-chemistry codebase to normalize primitive GTO radial functions when building basis functions for molecular electronic-structure calculations (see the repository README for PySCF context). The returned normalization factor ensures that the associated three-dimensional GTO basis function has unit norm under the usual volume element r^2 dr dOmega.` |
| `pyscf_gto_mole_filatov_nuc_mod` | `pyscf.gto.mole.filatov_nuc_mod` | `pyscf/gto/mole.py` | `nuc_charge: float, nucprop: dict = {}` | `pyscf.gto.mole.filatov_nuc_mod computes the Gaussian exponent parameter zeta for the Filatov nuclear charge distribution model used in PySCF to represent a finite (smeared) nuclear charge density of the form rho(r) = nuc_charge * Norm * exp(-zeta * r^2). This exponent is an empirical fit (Filatov & Cremer) expressed in the implementation below and is used whenever a Gaussian representation of the nuclear charge is required in molecular-integral construction or relativistic/finite-nucleus corrections within the PySCF framework. The routine evaluates an empirical expression for an effective nuclear radius r (using a fit that depends on the scalar nuclear charge and the library constant param.LIGHT_SPEED) and returns zeta = 1 / (r**2). The implementation follows the fits reported in M. Filatov and D. Cremer, Theor. Chem. Acc. 108, 168 (2002) and Chem. Phys. Lett. 351, 259 (2002). The result is a single scalar floating-point Gaussian exponent used to parameterize the radial decay of the Gaussian nuclear charge distribution.` |
| `pyscf_gto_mole_len_spinor` | `pyscf.gto.mole.len_spinor` | `pyscf/gto/mole.py` | `l: int, kappa: int` | `pyscf.gto.mole.len_spinor returns the number of spinor components (spinor basis functions) associated with a given orbital angular momentum quantum number and kappa index. This helper is used in the PySCF molecular integrals and basis construction code to determine how many spinor functions should be allocated or iterated for a particular (l, kappa) channel when building relativistic or spinor-enabled basis sets in the pyscf.gto.mole module.` |
| `pyscf_gto_mole_len_cart` | `pyscf.gto.mole.len_cart` | `pyscf/gto/mole.py` | `l: int` | `pyscf.gto.mole.len_cart computes the number of Cartesian Gaussian-type basis functions associated with a given angular momentum quantum number. This function is part of the PySCF gto.mole utilities and is used when building atomic orbital basis sets, allocating integrals and arrays, and mapping angular momentum labels (s, p, d, f, ...) to the corresponding number of Cartesian components required by Cartesian Gaussian basis representations.` |
| `pyscf_gto_mole_format_atom` | `pyscf.gto.mole.format_atom` | `pyscf/gto/mole.py` | `atoms: list, origin: numpy.ndarray = 0, axes: numpy.ndarray = None, unit: str = "angstrom"` | `pyscf.gto.mole.format_atom converts a user-provided molecular geometry (the same form accepted by Mole.atom in PySCF) into PySCF's internal atomic list format used throughout the library for building Mole objects, performing integrals, and running quantum-chemical simulations. The function normalizes nuclear-charge notations to element symbols, converts coordinates into atomic units (Bohr) according to the specified unit, applies an optional rotation (axes) and translation (origin), and accepts both inline geometry strings and Python lists or tuples as input. This conversion is a necessary preprocessing step in PySCF so downstream modules receive a consistent, unit-correct, and oriented geometry.` |
| `pyscf_gto_mole_loads` | `pyscf.gto.mole.loads` | `pyscf/gto/mole.py` | `molstr: str` | `pyscf.gto.mole.loads deserializes a JSON document string into a pyscf.gto.mole.Mole object used by the PySCF (Python-based Simulations of Chemistry Framework) library. This function is intended to restore a Mole instance previously serialized by the corresponding dumps routine so that geometry, basis, effective core potentials (ECP), and internal low-level arrays can be used directly in quantum chemistry calculations, checkpoint recovery, or interprocess transfer within PySCF workflows.` |
| `pyscf_gto_mole_make_bas_env` | `pyscf.gto.mole.make_bas_env` | `pyscf/gto/mole.py` | `basis_add: list, atom_id: int = 0, ptr: int = 0` | `Convert a PySCF Mole.basis specification into the two arrays expected by the libcint integral engine: the per-shell descriptor array ("bas") and the flattened numerical environment array ("env"). This function is used in the PySCF gto/mole code path to translate a Python-level basis specification (basis_add) into the low-level, contiguous layout required by libcint for efficient computation of one- and two-electron integrals. The function handles contracted Gaussian primitives, optional relativistic kappa values, per-shell angular momentum, exponent/coefficent sorting, and normalization steps that match PySCF conventions (calls gto_norm and, when GLOBAL NORMALIZE_GTO is set, _calls _nomalize_contracted_ao_). It also emits a warning to stderr if a shell has angular momentum > 14 because the integral library may not support it.` |
| `pyscf_gto_mole_unpack` | `pyscf.gto.mole.unpack` | `pyscf/gto/mole.py` | `moldic: dict` | `Unpack a dictionary produced by pyscf.gto.mole.pack to reconstruct a pyscf.gto.mole.Mole object used as input for quantum chemistry calculations. This function creates a new Mole instance and populates its attribute dictionary directly from the provided mapping. It is intended to reverse the transformation performed by pyscf.gto.mole.pack so that a serialized or transferred representation of a molecule (for example, saved to disk, sent between processes, or persisted for later reuse) can be restored as a Mole object ready to be used by PySCF routines (SCF, DFT, post-HF methods). Note that unpack bypasses Mole.__init__ initialization logic and therefore does not perform validation, recomputation of derived attributes, or initialization side effects that the constructor might normally run.` |
| `pyscf_gto_mole_sph2spinor_l` | `pyscf.gto.mole.sph2spinor_l` | `pyscf/gto/mole.py` | `l: int` | `pyscf.gto.mole.sph2spinor_l: Compute the real spherical-to-spinor transformation matrix for a given orbital angular momentum l. This function returns the linear transformation matrix that maps coefficient vectors expressed in the real-valued spherical harmonic basis (orbital angular momentum l) into the spinor spherical-harmonic basis used in two-component/spinor representations within PySCF. It is a thin wrapper that delegates to pyscf.gto.mole.sph2spinor_kappa with kappa fixed to 0 (sph2spinor_kappa(0, l)). In practical quantum-chemistry workflows inside PySCF, this matrix is used when constructing spinor orbitals, transforming integrals, or converting basis-function expansions between real spherical harmonics and the spinor basis required by relativistic or spin-dependent computations.` |
| `pyscf_gto_mole_uncontract` | `pyscf.gto.mole.uncontract` | `pyscf/gto/mole.py` | `_basis: list` | `pyscf.gto.mole.uncontract: Uncontract a PySCF internal-format contracted basis (_basis) into a flat list of primitive Gaussian basis entries suitable for routines that require primitive (uncontracted) functions, such as low-level integral generation, linear-dependency checks, or exporting primitives for analysis. This function implements the behavior used in PySCF to convert contracted basis descriptions (lists of shells with contracted primitives) into a list where each primitive has an explicit exponent and a unit contraction coefficient.` |
| `pyscf_gto_moleintor_ascint3` | `pyscf.gto.moleintor.ascint3` | `pyscf/gto/moleintor.py` | `intor_name: str` | `pyscf.gto.moleintor.ascint3 converts a legacy cint2-style integral routine name into the cint3-style name used by PySCF's molecular integral layer. This function is used in the molecular integrals subsystem of PySCF (Python-based Simulations of Chemistry Framework) to adapt older cint2 naming conventions to the cint3 naming conventions expected by the moleintor code paths that dispatch spinor, spherical, cartesian, or spin-specific integral implementations. In practice, callers supply the textual identifier of an integral routine (for example, a string used to look up a C-accelerated integral kernel) and ascint3 returns a normalized name suitable for selecting the corresponding cint3 kernel. Behavior and transformation rules: - If the input string begins with the prefix 'cint', the leading 'c' is removed (e.g., 'cint2e' -> 'int2e'). This mirrors the transition from cint2-prefixed identifiers to cint3 identifiers within the PySCF integrals naming scheme. - If the resulting name does not already end with one of the recognized suffixes '_sph', '_cart', '_spinor', or '_ssc', the function appends the suffix '_spinor'. This ensures the returned name refers to a spinor-capable cint3 kernel when the original name did not explicitly specify spherical/cartesian/spinor/ssc variants. - No other parts of the name are modified. Side effects: - This function has no side effects on program state; it returns a new string and does not mutate external objects. Failure modes and notes: - The function expects intor_name to be a Python str as used throughout PySCF's integral name handling. If a non-string object is passed, attribute lookup for startswith/endswith will fail (raising an AttributeError), and such misuse should be avoided by callers. - An empty string input will result in '_spinor' being returned per the transformation rules (empty does not start with 'cint' and does not end with any recognized suffix). - The function does not validate that the returned name corresponds to an actually implemented kernel; it only performs syntactic normalization.` |
| `pyscf_gto_mole_sph2spinor_kappa` | `pyscf.gto.mole.sph2spinor_kappa` | `pyscf/gto/mole.py` | `kappa: int, l: int = None` | `pyscf.gto.mole.sph2spinor_kappa returns the real-spherical-to-spinor transformation matrices for a specified relativistic quantum number kappa used in PySCF angular-momentum / spinor basis construction. The function obtains the full transformation matrices from pyscf.symm.sph.sph2spinor(l) and then selects the subset of columns corresponding to the spinor block associated with the requested kappa. This transformation is used in PySCF to convert basis functions expressed in real spherical harmonics into the two-component spinor blocks (commonly needed when building spinor-adapted integrals or working with relativistic/special spin-coupled basis representations).` |
| `pyscf_gw_gw_ac_AC_pade_thiele_diag` | `pyscf.gw.gw_ac.AC_pade_thiele_diag` | `pyscf/gw/gw_ac.py` | `sigma: numpy.ndarray, omega: numpy.ndarray` | `Analytic continuation to the real axis using a Pade approximation constructed by Thiele's reciprocal difference method. This function is intended for use in the GW module of PySCF to transform self-energy data sampled on an imaginary-frequency axis (e.g., Matsubara frequencies) into a compact set of Pade coefficients that can be evaluated on the real-frequency axis for each orbital. The implementation follows Thiele's reciprocal difference algorithm (see J. Low Temp. Phys. 29, 179 (1977)). For each orbital the function selects subsets of input frequency and self-energy points, builds a Pade approximant via the helper routine thiele, and returns the complex Pade coefficients together with the corresponding subset of input frequency points used to construct the approximant.` |
| `pyscf_gto_moleintor_getints_by_shell` | `pyscf.gto.moleintor.getints_by_shell` | `pyscf/gto/moleintor.py` | `intor_name: str, shls: list, atm: numpy.ndarray, bas: numpy.ndarray, env: numpy.ndarray, comp: int = 1` | `For given 2, 3 or 4 atomic-orbital shells, call the underlying libcint/libcgto integral routines to compute one-electron, two-electron, two-center-two-electron or three-center two-electron integrals for the specified shells. This function is an internal PySCF interface that (1) converts the atom/basis/environment arguments into the C-compatible numpy arrays expected by libcint, (2) determines the number of contracted Gaussian-type orbitals (CGTOs) in each shell from the bas array, (3) allocates a Fortran-ordered buffer, and (4) invokes the C integral kernel named by intor_name via libcgto. It is used throughout PySCF where low-level per-shell integrals are needed (for example, building ERI blocks, 3-center Coulomb integrals for density fitting, or 1e operator blocks).` |
| `pyscf_gw_gw_ac_get_rho_response` | `pyscf.gw.gw_ac.get_rho_response` | `pyscf/gw/gw_ac.py` | `omega: float, mo_energy: numpy.ndarray, Lpq: numpy.ndarray` | `Compute the electronic density response (polarizability) in the auxiliary basis at a (typically imaginary) frequency omega for use in GW screening and self-energy calculations. This function is used in the pyscf.gw.gw_ac module to build the density response matrix in an auxiliary basis from molecular orbital energies and auxiliary-projected three-index integrals. The computed response Pi(P,Q) is the matrix representation of the independent-particle density response (sum over occupied->virtual transitions) evaluated at frequency omega. The implementation returns the response including both spin channels; the multiplicative factor of 4 in the code accounts for the two electronic spins and the combined contribution from the occupied->virtual transition amplitude and its complex-conjugate pair in the sum-over-states expression. Typical usage is within GW screening (W) construction and related many-body perturbation theory routines in PySCF.` |
| `pyscf_gw_gw_ac_AC_twopole_diag` | `pyscf.gw.gw_ac.AC_twopole_diag` | `pyscf/gw/gw_ac.py` | `sigma: numpy.ndarray, omega: numpy.ndarray, orbs: numpy.ndarray, nocc: int` | `pyscf.gw.gw_ac.AC_twopole_diag: Analytic continuation of GW self-energy to the real frequency axis using a two-pole fit applied independently to each orbital. Fits a two-pole model to complex self-energy data sigma sampled on a frequency mesh omega for each orbital. The function loops over orbitals (leading dimension of sigma), constructs an orbital-dependent initial guess for the 10 fit parameters, and calls scipy.optimize.least_squares with finite-difference Jacobian, trust-region-reflective method, and tight tolerances to obtain the best-fit parameters for that orbital. This routine is used in the GW analytic-continuation workflow in PySCF to produce a compact, analytic representation of the orbital self-energy on the real axis from sampled data (typically obtained on the imaginary or Matsubara axis). The fitted parameters can be used downstream to evaluate the self-energy at real frequencies, to locate quasiparticle peaks, or to build spectral functions.` |
| `pyscf_gw_gw_cd_get_rho_response` | `pyscf.gw.gw_cd.get_rho_response` | `pyscf/gw/gw_cd.py` | `omega: float, mo_energy: numpy.ndarray, Lpq: numpy.ndarray` | `Compute density response function in the auxiliary basis at (imaginary) frequency omega. This function is used in the GW module (pyscf.gw.gw_cd) to build the density response (screening) matrix in a density-fitting / auxiliary basis representation from molecular orbital energies and three-index Cholesky/auxiliary tensors. The computed response matrix Pi encodes how the electronic density (from both spin channels) responds at frequency omega and is suitable for use in GW screening and polarizability constructions where auxiliary-basis representations are employed.` |
| `pyscf_gw_gw_slow_kernel` | `pyscf.gw.gw_slow.kernel` | `pyscf/gw/gw_slow.py` | `imds: str, orbs: list = None, linearized: bool = False, eta: float = 0.001, tol: float = 1e-09, method: str = "fallback"` | `Calculates GW quasiparticle (corrected) orbital energies for a set of molecular orbitals using GW intermediates provided by an AbstractIMDS object from the PySCF GW module. This function is used in the context of many-body perturbation theory (the GW approximation) implemented in PySCF to find corrected energies that include electron-electron correlation beyond mean-field (SCF) orbital energies. It evaluates the quasiparticle equation for each requested orbital (or orbital block), finds a root of the quasiparticle equation using a numerical root-finder, and returns the resulting corrected energies in an array whose shape corresponds to the orbital index layout in imds.entire_space. Practical significance: these corrected energies are the GW estimates of electronic excitation energies or electron addition/removal energies used in post-SCF analyses and comparisons with experiment.` |
| `pyscf_gw_ugw_ac_AC_pade_thiele_diag` | `pyscf.gw.ugw_ac.AC_pade_thiele_diag` | `pyscf/gw/ugw_ac.py` | `sigma: numpy.ndarray, omega: numpy.ndarray` | `Analytic continuation to the real axis using a Pade approximation constructed with Thiele's reciprocal difference method. This function is intended for use in GW analytic-continuation workflows within PySCF (pyscf.gw.ugw_ac), where sigma and omega contain self-energy (or related Green's function) samples on an imaginary Matsubara-frequency grid. The implementation follows the Thiele reciprocal-difference Pade construction (see J. Low Temp. Phys. 29, 179 (1977)) and returns the complex Pade coefficients for each orbital along with the subset of frequency points actually used to build the approximant.` |
| `pyscf_gw_ugw_ac_AC_twopole_diag` | `pyscf.gw.ugw_ac.AC_twopole_diag` | `pyscf/gw/ugw_ac.py` | `sigma: numpy.ndarray, omega: numpy.ndarray, orbs: numpy.ndarray, nocc: int` | `pyscf.gw.ugw_ac.AC_twopole_diag: Perform analytic continuation of orbital self-energy data onto the real-frequency axis using a two-pole fit, returning the per-orbital optimized two-pole model coefficients used by the GW analytic-continuation routines.` |
| `pyscf_gw_ugw_ac_get_rho_response` | `pyscf.gw.ugw_ac.get_rho_response` | `pyscf/gw/ugw_ac.py` | `omega: float, mo_energy: numpy.ndarray, Lpqa: numpy.ndarray, Lpqb: numpy.ndarray` | `Compute the density response function in the auxiliary (resolution-of-identity) basis at an imaginary frequency iw for unrestricted GW (ugw) AC screening. This function is used in the PySCF GW module (pyscf.gw.ugw_ac) to form the auxiliary-basis representation of the frequency-dependent density response (polarizability) needed when evaluating screened interactions or polarizability on the imaginary frequency axis. The implementation assumes an unrestricted (spin-separated) molecular orbital basis and builds the response by summing contributions from alpha and beta spin single excitations using the provided auxiliary couplings Lpqa and Lpqb.` |
| `pyscf_hessian_thermo_rotation_const` | `pyscf.hessian.thermo.rotation_const` | `pyscf/hessian/thermo.py` | `mass: numpy.ndarray, atom_coords: numpy.ndarray, unit: str = "GHz"` | `Compute rotational constants for a molecular geometry to characterize rotational spectra. This function pyscf.hessian.thermo.rotation_const computes the three principal rotational constants of a molecule from atomic masses and Cartesian coordinates. It is used in molecular spectroscopy and thermochemical analyses (as in PySCF) to convert the principal moments of inertia of the mass-distributed nuclear framework into spectroscopically relevant rotational constants. The routine forms the center-of-mass, constructs the 3√ó3 moment of inertia tensor in atomic units (Bohr for coordinates, atomic mass units for masses), diagonalizes it to obtain principal moments, and converts those moments to the requested unit using PySCF‚Äôs physical constants (pyscf.nist). The returned values correspond to the three principal axes used to characterize rotational spectra.` |
| `pyscf_lib_chkfile_load_mol` | `pyscf.lib.chkfile.load_mol` | `pyscf/lib/chkfile.py` | `chkfile: str` | `pyscf.lib.chkfile.load_mol loads a pyscf.gto.Mole object from a PySCF checkpoint file (chkfile). This function is used to deserialize a Mole previously saved by pyscf.lib.chkfile.save_mol so the molecular specification (atomic coordinates, basis sets, charge, spin, and other metadata) can be reused in subsequent PySCF quantum-chemistry workflows such as SCF, DFT, and post-HF methods.` |
| `pyscf_lib_linalg_helper_cho_solve` | `pyscf.lib.linalg_helper.cho_solve` | `pyscf/lib/linalg_helper.py` | `a: numpy.ndarray, b: numpy.ndarray, strict_sym_pos: bool = True` | `pyscf.lib.linalg_helper.cho_solve solves the linear system a x = b for x, where a is expected to be a Hermitian (conjugate symmetric) positive-definite matrix commonly encountered in quantum chemistry linear algebra (for example overlap, metric, or density-related matrices in PySCF workflows). The implementation delegates to scipy.linalg.solve with assume_a='pos' to enable LAPACK paths optimized for positive-definite matrices, providing both performance and numerical behavior appropriate for PySCF computations.` |
| `pyscf_lib_chkfile_load` | `pyscf.lib.chkfile.load` | `pyscf/lib/chkfile.py` | `chkfile: str, key: str` | `pyscf.lib.chkfile.load: Load arrays or groups from a PySCF HDF5-format checkpoint file.` |
| `pyscf_lib_linalg_helper_make_diag_precond` | `pyscf.lib.linalg_helper.make_diag_precond` | `pyscf/lib/linalg_helper.py` | `diag: numpy.ndarray, level_shift: float = 0.001` | `Generate a diagonal preconditioner function for use in PySCF linear-algebra routines (e.g., iterative eigenvalue or subspace solvers). The returned function applies an elementwise division by a shifted diagonal to regularize the usual Jacobi-style preconditioner (Ax - x*e)/(diag(A) - e), breaking the correlation that can make basis vectors linearly dependent (see issue referenced in source). The implementation uses a fixed small cutoff (1e-8) to avoid exact division by zero after applying the level shift.` |
| `pyscf_lib_chkfile_dump` | `pyscf.lib.chkfile.dump` | `pyscf/lib/chkfile.py` | `chkfile: str, key: str, value: dict` | `Save array(s) or nested Python containers into a checkpoint file (HDF5) used by the PySCF (Python-based Simulations of Chemistry Framework) code base. This function persistently stores numerical arrays, Python sequences (list/tuple), and mapping objects (dict) into an HDF5-formatted checkpoint file so that PySCF computations (for example, CI coefficients, symmetry metadata, density matrices, and other intermediate results) can be reloaded by later steps or by other PySCF modules. The function writes datasets and groups using the h5py/HDF5 storage model via pyscf.lib.H5FileWrap. When given a dict, keys are translated into HDF5 groups and datasets recursively; when given a list or tuple, elements are stored under a generated group named with the suffix "__from_list__" and numeric, zero-padded member names (format '%06d'). If a dataset cannot be written directly because it has an object dtype or cannot be broadcast into a single HDF5 dataset, the implementation falls back to saving each element individually as a group of datasets. Existing entries at the provided key (or its "__from_list__" variant) in the target file are deleted before writing the new content.` |
| `pyscf_lib_diis_restore` | `pyscf.lib.diis.restore` | `pyscf/lib/diis.py` | `filename: str` | `pyscf.lib.diis.restore - Restore or construct a DIIS object from a saved DIIS file. Restore/construct a DIIS object (Direct Inversion in the Iterative Subspace) by reading a DIIS checkpoint file stored on disk. In the PySCF quantum chemistry framework, DIIS objects encapsulate the vectors, error vectors, coefficients, and internal parameters used to accelerate convergence of self-consistent field (SCF) and related iterative procedures. This convenience wrapper delegates the work to DIIS().restore(filename) in the same module and returns the reconstructed DIIS instance for reuse in continuing or analyzing an interrupted or previously saved electronic structure calculation.` |
| `pyscf_lib_linalg_helper_safe_eigh` | `pyscf.lib.linalg_helper.safe_eigh` | `pyscf/lib/linalg_helper.py` | `h: numpy.ndarray, s: numpy.ndarray, lindep: float = 1e-15` | `safe_eigh solves the generalized eigenvalue problem h v = w s v in a numerically stable two-pass procedure tailored for quantum-chemistry linear-algebra tasks (for example, solving Roothaan equations with an overlap metric that may contain near-linear dependencies). The function first diagonalizes the metric s to detect and remove linearly dependent directions below a threshold, then transforms h into the non-redundant subspace and diagonalizes the reduced problem to obtain the generalized eigenpairs. This preserves physical eigenpairs while avoiding numerical instabilities due to small eigenvalues of s.` |
| `pyscf_lib_linalg_helper_eigh_by_blocks` | `pyscf.lib.linalg_helper.eigh_by_blocks` | `pyscf/lib/linalg_helper.py` | `h: numpy.ndarray, s: numpy.ndarray = None, labels: list = None` | `Solve an ordinary or generalized eigenvalue problem by diagonalizing diagonal blocks of a Hermitian (or real symmetric) matrix. This function is used in the PySCF quantum chemistry framework to perform block-wise diagonalization when basis functions are partitioned (for example by symmetry irreducible representations, orbital symmetries, or other grouping labels). When labels are provided, the rows and columns with the same label are grouped into a block and each block is diagonalized independently; when labels is None, the full eigenproblem is delegated to scipy.linalg.eigh.` |
| `pyscf_lib_linalg_helper_pick_real_eigs` | `pyscf.lib.linalg_helper.pick_real_eigs` | `pyscf/lib/linalg_helper.py` | `w: numpy.ndarray, v: numpy.ndarray, nroots: int, envs: dict` | `pyscf.lib.linalg_helper.pick_real_eigs selects eigenvalues whose imaginary parts are small (numerical noise) and converts complex-conjugate eigenpairs to real representations when appropriate. In the PySCF quantum-chemistry workflow, diagonalization routines can produce eigenvalues and eigenvectors with small nonzero imaginary components even when the underlying physical problem has real spectrum (for example, real-symmetric Hamiltonians, overlap matrices, or effective Fock/Kohn‚ÄìSham operators). This function is used by PySCF linear-algebra helpers to pick the eigenvalues that are effectively real (within a numeric tolerance) from arrays produced by general eigensolvers, warn when fewer than the requested number of "real" roots are found, and delegate conversion of complex conjugate pairs to _eigs_cmplx2real so downstream code (e.g., post-processing, state selection in SCF/CI routines) receives real-valued results when possible.` |
| `pyscf_lib_misc_generate_pickle_methods` | `pyscf.lib.misc.generate_pickle_methods` | `pyscf/lib/misc.py` | `excludes: tuple = (), reset_state: bool = False` | `pyscf.lib.misc.generate_pickle_methods generates a pair of functions implementing Python's pickle protocol methods (__getstate__ and __setstate__) that can be attached to user-defined classes. In the PySCF (Python-based Simulations of Chemistry Framework) context these generated methods are used to produce a compact, portable serialized representation of computational objects (for example SCF instances, integrals containers, or task/state objects) by omitting non-serializable or large transient attributes such as open streams and cached internal state. The returned methods are intended to be assigned on a class as "__getstate__, __setstate__ = generate_pickle_methods(...)" so pickle and other serialization tools will use them.` |
| `pyscf_lib_misc_invalid_method` | `pyscf.lib.misc.invalid_method` | `pyscf/lib/misc.py` | `name: str` | `pyscf.lib.misc.invalid_method creates a placeholder callable that indicates a method is invalid or intentionally unimplemented within the PySCF framework. It is used when a class, module, or API wants to de-register or replace an existing method with a sentinel that consistently signals "not implemented" at runtime, aiding clear error reporting and API maintenance.` |
| `pyscf_lib_misc_finger` | `pyscf.lib.misc.finger` | `pyscf/lib/misc.py` | `a: numpy.ndarray` | `pyscf.lib.misc.finger computes a deterministic scalar "fingerprint" for a numpy.ndarray by taking the dot product of the array flattened in row-major order with a fixed cosine-based weight vector. In the PySCF (Python-based Simulations of Chemistry Framework) codebase this routine is used to produce compact numeric signatures of numerical arrays (for example, molecular integrals, orbital coefficient arrays, density matrices, or intermediate tensors) for quick equality checks, lightweight caching keys, logging, or debugging comparisons where a full elementwise comparison would be expensive.` |
| `pyscf_lib_misc_flatten` | `pyscf.lib.misc.flatten` | `pyscf/lib/misc.py` | `lst: list` | `Flatten a sequence of first-level iterables into a single list used by PySCF for assembling collections (e.g., lists of basis-function descriptors, integrals, or other per-component lists) when building larger data structures in the Python-based Simulations of Chemistry Framework.` |
| `pyscf_lib_misc_index_tril_to_pair` | `pyscf.lib.misc.index_tril_to_pair` | `pyscf/lib/misc.py` | `ij: numpy.ndarray` | `pyscf.lib.misc.index_tril_to_pair maps a flattened lower-triangular (tril) linear index used in PySCF to the corresponding pair of row and column indices (i, j). Given a linear index or array of linear indices ij that encodes positions in a packed lower-triangular layout using the convention ij = i * (i + 1) / 2 + j, this function computes the pair indices i and j (zero-based, consistent with NumPy/Python) such that each returned pair satisfies the above relation. In PySCF and quantum chemistry codes, this mapping is commonly used when compactly storing symmetric matrices (for example overlap, density, or two-electron integrals) in a 1D array containing only the lower triangle; index_tril_to_pair recovers the original matrix coordinates used to reconstruct or address elements.` |
| `pyscf_lib_misc_num_threads` | `pyscf.lib.misc.num_threads` | `pyscf/lib/misc.py` | `n: int = None` | `pyscf.lib.misc.num_threads controls and queries the number of OpenMP (OMP) threads used by PySCF and dependent native libraries (for example, NumPy or BLAS backends) in parallel numerical workloads. When called with an integer argument, it requests the runtime to set the process-wide OMP thread count to that value using the PySCF internal numpy_helper C interface. When called without an argument, it returns the currently available OMP thread count as observed through the same internal interface. This function is used in the PySCF codebase and by PySCF users to manage parallelism for CPU-bound linear algebra and other OpenMP-enabled kernels. It is recommended over directly setting the environment variable OMP_NUM_THREADS at runtime because many native libraries read that environment variable when they are imported/initialized; changing os.environ['OMP_NUM_THREADS'] after import does not reliably change the runtime thread count for those libraries. Internally this function delegates to pyscf.lib.numpy_helper._np_helper.set_omp_threads and pyscf.lib.numpy_helper._np_helper.get_omp_threads via ctypes, so the observed behavior depends on that C helper and the availability of OpenMP support in the build.` |
| `pyscf_lib_misc_make_class` | `pyscf.lib.misc.make_class` | `pyscf/lib/misc.py` | `bases: tuple, name: str = None, attrs: dict = None` | `Construct and return a Python class object composed from the given base classes, with optional explicit name and attribute dictionary. This function is used in PySCF to dynamically build composite classes from mixins and base classes (for example when combining functionality from multiple modules, extensions, or plugin mixins in the Python-based Simulations of Chemistry Framework), and to cache and reuse identical class combinations so that the same (name, bases) pair yields the same class object across the process.` |
| `pyscf_lib_misc_prange_split` | `pyscf.lib.misc.prange_split` | `pyscf/lib/misc.py` | `n_total: int, n_sections: int` | `Generate a sequence of index ranges that splits n_total elements into n_sections parts using the same split convention as numpy.array_split. This function is used in PySCF to partition a linear index range (for example, indices of basis functions, matrix rows/columns, or integrals) into contiguous, load-balanced sections for parallel loops or chunked processing. The splitting follows the rule that the first (n_total % n_sections) sections receive one extra element (size floor(n_total/n_sections) + 1) and the remaining sections receive floor(n_total/n_sections) elements. Each returned pair (start, end) represents a half-open interval [start, end) of integer indices that together cover 0..n_total without overlap.` |
| `pyscf_lib_misc_prange` | `pyscf.lib.misc.prange` | `pyscf/lib/misc.py` | `start: int, end: int, step: int` | `pyscf.lib.misc.prange splits an integer index interval into contiguous, non-overlapping fragments of a given maximum length and yields the boundaries for each fragment. In the PySCF (Python-based Simulations of Chemistry Framework) codebase, this helper is used to partition linear index ranges (for example, ranges of atomic orbital or molecular orbital indices, integral blocks, or other loop indices) into smaller chunks for batched processing, memory-limited loops, or parallel work distribution. The function is a generator: for a given integer interval from start up to end, it produces successive tuples (p0, p1) that define half-open subintervals [p0, p1) covering the original range without overlap. Each yielded tuple gives the inclusive start index and the exclusive end index of a fragment; the final fragment may be shorter than step if (end - start) is not an exact multiple of step.` |
| `pyscf_lib_misc_square_mat_in_trilu_indices` | `pyscf.lib.misc.square_mat_in_trilu_indices` | `pyscf/lib/misc.py` | `n: int` | `pyscf.lib.misc.square_mat_in_trilu_indices returns an n x n integer matrix that maps the unique elements of a flattened lower-triangular (tril) vector to positions in a full symmetric square matrix. This function is used in PySCF (the Python-based Simulations of Chemistry Framework) to convert a compact storage of unique symmetric matrix elements (commonly used for symmetric operators, density matrices, and pairwise interaction tensors in quantum chemistry) back into a full symmetric index structure that can be used to reconstruct or address the full matrix. The function constructs the mapping by enumerating the lower-triangular indices in the same order as numpy.tril_indices(n), assigning each unique tril element a consecutive integer index from 0 to n*(n+1)//2 - 1, and mirroring those indices across the diagonal so that the output matrix is symmetric. The result is independent of any external state (no side effects) and uses O(n^2) time and memory to produce an (n, n) integer array.` |
| `pyscf_lib_misc_with_doc` | `pyscf.lib.misc.with_doc` | `pyscf/lib/misc.py` | `doc: str` | `pyscf.lib.misc.with_doc is a small decorator factory used in the PySCF (Python-based Simulations of Chemistry Framework) codebase to attach or replace the documentation string of a function. This utility is used throughout PySCF to provide authoritative docstrings for functions that are generated dynamically, wrapped by higher-order functions, or otherwise lack an inline literal docstring, thereby improving introspection (help(), IPython tooltips) and Sphinx-generated documentation for quantum chemistry routines and utilities.` |
| `pyscf_lib_numpy_helper_broadcast_mul` | `pyscf.lib.numpy_helper.broadcast_mul` | `pyscf/lib/numpy_helper.py` | `a: numpy.ndarray, b: numpy.ndarray, out: numpy.ndarray = None` | `Broadcasted entrywise multiplication specialized for PySCF tensor operations.` |
| `pyscf_lib_numpy_helper_cartesian_prod` | `pyscf.lib.numpy_helper.cartesian_prod` | `pyscf/lib/numpy_helper.py` | `arrays: list, out: numpy.ndarray = None` | `pyscf.lib.numpy_helper.cartesian_prod generates the Cartesian product of multiple one-dimensional input arrays and returns all ordered combinations as a two-dimensional NumPy array. This function is part of PySCF's numpy_helper utilities and is used in the PySCF (Python-based Simulations of Chemistry Framework) codebase to enumerate combinations of 1-D parameter arrays, for example when forming grids or combinatorial parameter lists required in electronic-structure workflows. This function accepts a sequence of 1-D array-like objects, converts them to NumPy arrays, determines a common result dtype using numpy.result_type, allocates or uses the provided output buffer, and arranges the data so that each row of the returned 2-D array is one combination (cartesian product) of the inputs. The number of rows in the result equals the product of the lengths of the input arrays and the number of columns equals the number of input arrays. If an output buffer is provided via the out parameter, the function will use it as the backing storage via numpy.ndarray(..., buffer=out), so the buffer must be compatible in size, dtype, and writable memory layout; otherwise a new array is allocated.` |
| `pyscf_lib_misc_prange_tril` | `pyscf.lib.misc.prange_tril` | `pyscf/lib/misc.py` | `start: int, stop: int, blocksize: int` | `pyscf.lib.misc.prange_tril: Partition a contiguous integer range [start, stop) into subranges suitable for iterating over a lower-triangular (tril) index space so that the cumulative triangular count inside each subrange stays below a specified blocksize. This helper is used in PySCF to split the work of loops that enumerate pairs (i,j) with i<=j (lower triangular ordering) into blocks with bounded computational/memory cost, enabling batching or parallel dispatch of triangular-indexed workloads (for example, blocked generation or contraction of two-electron integrals and related tensor slices).` |
| `pyscf_lib_misc_repo_info` | `pyscf.lib.misc.repo_info` | `pyscf/lib/misc.py` | `repo_path: str` | `pyscf.lib.misc.repo_info obtains repository metadata for a PySCF source tree: it resolves the supplied path to an absolute repository location and, when a Git repository is detected, assembles a one- or two-line Git status string containing original HEAD, branch name, and commit ID. This information is used by PySCF to report the source repository location and commit identifiers for reproducibility, debugging, logging, and citation purposes. The function inspects the filesystem for a .git directory either at the given path or in its parent directory. If a Git repository is found, repo_info calls the internal git_info routine and formats its output into human-readable lines such as "GIT ORIG_HEAD <orig_head>" and "GIT HEAD (branch <branch>) <head>" (or "GIT HEAD <head>" when no branch name is present). If no Git repository is found, only the canonical absolute path is returned. The function does not modify files on disk; it only reads filesystem metadata and delegates to git_info for Git-specific details. The implementation currently does not collect information about external libraries (for example BLAS, libcint, libxc, libxcfun, tblis), as indicated by the in-source TODO.` |
| `pyscf_lib_numpy_helper_cleanse` | `pyscf.lib.numpy_helper.cleanse` | `pyscf/lib/numpy_helper.py` | `a: numpy.ndarray, axis: int = 0, tol: float = 0` | `Cleanse floating-point array values by grouping nearly identical numbers (within a specified tolerance) and setting each group to a single representative value. This reduces spurious differences caused by floating-point round-off so that numpy.round_ and numpy.unique behave as expected in numerical workflows used throughout PySCF (Python-based Simulations of Chemistry Framework), for example when stabilizing arrays of orbital energies, integrals, grid values, or other computed quantities before further comparison or grouping.` |
| `pyscf_lib_numpy_helper_base_repr_int` | `pyscf.lib.numpy_helper.base_repr_int` | `pyscf/lib/numpy_helper.py` | `number: int, base: int, ndigits: int = None` | `pyscf.lib.numpy_helper.base_repr_int converts an integer or an array of integers into a sequence of base-N digits and returns those digits as Python lists for scalars or as a 2-D numpy.ndarray for array inputs. This helper is used in PySCF utilities that need an explicit digit-wise representation of integers (for example, encoding occupation patterns, indexing combinatorial objects, or other bit/base decompositions used in quantum-chemistry bookkeeping).` |
| `pyscf_lib_numpy_helper_direct_sum` | `pyscf.lib.numpy_helper.direct_sum` | `pyscf/lib/numpy_helper.py` | `subscripts: str, *operands` | `Apply an einsum-like direct (outer) summation over multiple operand arrays to produce a combined tensor following a compact subscript notation. This function is a utility in the PySCF (Python-based Simulations of Chemistry Framework) code base used to build composite multi-index tensors from smaller arrays (for example when forming direct-sum or outer-sum combinations of orbital, integral, or index-space tensors). The calling convention mirrors NumPy einsum style with the following extensions implemented in this routine: each operand term may be prefixed by a '+' or '-' sign (default '+'); commas and spaces are treated as separators; an explicit output mapping may be provided after '->'; if no '->' is given the output subscript is the concatenation of the input subscripts. Operands are converted with numpy.asarray and are combined by repeated reshaping and elementwise addition/subtraction followed by a final einsum to reorder axes to the requested output.` |
| `pyscf_lib_numpy_helper_expm` | `pyscf.lib.numpy_helper.expm` | `pyscf/lib/numpy_helper.py` | `a: numpy.ndarray` | `Equivalent to scipy.linalg.expm. Computes the matrix exponential exp(a) for a square numpy.ndarray using a truncated Taylor series with scaling and repeated squaring, as used in PySCF numerical linear-algebra routines (for example, orbital rotations, short-time propagators, and other matrix-exponential needs in quantum-chemistry algorithms).` |
| `pyscf_lib_numpy_helper_condense` | `pyscf.lib.numpy_helper.condense` | `pyscf/lib/numpy_helper.py` | `opname: str, a: numpy.ndarray, loc_x: list, loc_y: list = None` | `Condense a 2D NumPy array into an array of block-wise reductions using a named reduction operator. This function is part of PySCF's numpy_helper utilities and is used to aggregate blocks of a 2-dimensional numerical array (for example, parts of a density matrix or integral arrays) into a smaller 2D array of reduced values (e.g., sums, maxima). The function accepts explicit block boundary indices along rows and columns (loc_x and loc_y) and applies the specified operator to each block, returning a condensed array with one entry per block pair.` |
| `pyscf_lib_numpy_helper_entrywise_mul` | `pyscf.lib.numpy_helper.entrywise_mul` | `pyscf/lib/numpy_helper.py` | `a: numpy.ndarray, b: numpy.ndarray, out: numpy.ndarray = None` | `pyscf.lib.numpy_helper.entrywise_mul performs entrywise (element-wise) multiplication of two 2-D NumPy arrays (matrices). It is a low-level numerical helper used in the PySCF (Python-based Simulations of Chemistry Framework) codebase for elementwise combination of matrix-valued data such as density matrices, intermediate arrays in integral transformations, or other 2-D numerical tensors that arise in quantum-chemistry algorithms. The implementation enforces strict shape, dimensionality and dtype compatibility and dispatches to optimized C routines for double-precision real and double-precision complex data to accelerate performance-critical paths in PySCF.` |
| `pyscf_lib_numpy_helper_ddot` | `pyscf.lib.numpy_helper.ddot` | `pyscf/lib/numpy_helper.py` | `a: numpy.ndarray, b: numpy.ndarray, alpha: float = 1, c: numpy.ndarray = None, beta: float = 0` | `Matrix-matrix multiplication for double-precision (float64) NumPy arrays used throughout PySCF for dense linear-algebra operations in quantum chemistry calculations. This function computes the BLAS-level DGEMM operation and is a thin wrapper around a low-level _dgemm implementation optimized for double precision. It implements the operation C_out = alpha * A @ B + beta * C_in (BLAS DGEMM semantics). The function handles common memory-layout cases for inputs (C-contiguous or Fortran-contiguous) by choosing an appropriate transpose flag and, when necessary, creating C-contiguous copies so that the underlying BLAS call receives data in an expected layout. If c is None, a new array of shape (m, n) is allocated and beta is forced to 0 (so the allocated contents are ignored). This function is intended for use in PySCF modules that require efficient double-precision matrix multiplications (for example, assembling density matrices, Fock matrices, or performing tensor contractions that have been reduced to matrix products).` |
| `pyscf_lib_numpy_helper_inplace_transpose_scale` | `pyscf.lib.numpy_helper.inplace_transpose_scale` | `pyscf/lib/numpy_helper.py` | `a: numpy.ndarray, alpha: float = 1.0` | `In-place parallel scaling and transposition of a square matrix used by PySCF linear-algebra routines to avoid extra memory allocations and accelerate matrix operations common in quantum chemistry computations. This function transposes the input square matrix a in-place and multiplies every element by the scalar factor alpha using a parallel C/OpenMP helper, preserving the original array object and shape while minimizing memory movement.` |
| `pyscf_lib_numpy_helper_hermi_triu` | `pyscf.lib.numpy_helper.hermi_triu` | `pyscf/lib/numpy_helper.py` | `mat: numpy.ndarray, hermi: int = 1, inplace: bool = True` | `pyscf.lib.numpy_helper.hermi_triu produces a Hermitian or anti-Hermitian square matrix by copying the elements from the lower triangular part of a square NumPy array into the upper triangular part, using optimized native helpers from the PySCF C extension. This function is used in PySCF linear-algebra workflows (quantum chemistry matrix construction and symmetrization) to ensure the full matrix satisfies Hermitian or anti-Hermitian symmetry expected by downstream algorithms (e.g., diagonalization, integral transformations).` |
| `pyscf_lib_numpy_helper_inv_base_repr_int` | `pyscf.lib.numpy_helper.inv_base_repr_int` | `pyscf/lib/numpy_helper.py` | `x: numpy.ndarray, base: int` | `pyscf.lib.numpy_helper.inv_base_repr_int: Convert a sequence of base-digits into the integer(s) they represent (inverse of base_repr_int). This function is used in PySCF (the Python-based Simulations of Chemistry Framework) to map a positional-digit representation (for example, combinatorial indices, encoded occupation patterns, or multi-digit identifiers produced by lib.base_repr_int) back to standard integer indices; it accepts a numpy array of digits and a radix and returns the corresponding integer value(s). This function interprets elements of x as integer digits in the given base and computes the positional value by summing digit * base**position. For multi-dimensional inputs the last axis is treated as the digit axis (most-significant digit first along the last axis), and the function returns an array of integers shaped as the input shape with the last axis removed. For one-dimensional sequences it returns a scalar integer. The input is coerced to integer dtype using numpy.asarray(x, dtype=int) and the computation uses Python/numpy integer arithmetic; the function does not modify the caller's original object.` |
| `pyscf_lib_numpy_helper_hermi_sum` | `pyscf.lib.numpy_helper.hermi_sum` | `pyscf/lib/numpy_helper.py` | `a: numpy.ndarray, axes: tuple = None, hermi: int = 1, inplace: bool = False, out: numpy.ndarray = None` | `pyscf.lib.numpy_helper.hermi_sum computes the elementwise Hermitian sum a + a.T.conj() with improved memory efficiency compared to making an explicit transpose copy. In the PySCF quantum-chemistry workflow this is used when forming Hermitian matrices from general (possibly non-Hermitian) blocks or slices (for example when constructing symmetric contributions to Fock or density matrices, or accumulating blockwise results from tensor contractions). The function supports a 2-D square matrix or a stack of square matrices stored as a 3-D array with axes layout (0,2,1) and attempts to use a C-accelerated path for C-contiguous arrays of dtype numpy.double or numpy.complex128; otherwise a Python fallback performs the blockwise computation. The result is written into and returned via the out buffer (which may be the input array if inplace=True), avoiding an additional full-array transpose copy.` |
| `pyscf_lib_numpy_helper_isin_1d` | `pyscf.lib.numpy_helper.isin_1d` | `pyscf/lib/numpy_helper.py` | `v: numpy.ndarray, vs: numpy.ndarray, return_index: bool = False` | `Check whether a 1-D target vector v appears exactly as a row in a collection of vectors vs. This utility is used in the PySCF codebase to test membership of a specific flattened vector (e.g., a molecular orbital coefficient vector, a determinant bitstring represented as an integer vector, or any fixed-length parameter vector used in electronic-structure workflows) within a list/array of candidate vectors. The function performs an elementwise exact comparison (using absolute difference and integer/float equality) after flattening v and reshaping vs to have rows of the same length; it does not perform approximate or tolerance-based comparisons.` |
| `pyscf_lib_numpy_helper_leading_dimension_order` | `pyscf.lib.numpy_helper.leading_dimension_order` | `pyscf/lib/numpy_helper.py` | `a: numpy.ndarray` | `pyscf.lib.numpy_helper.leading_dimension_order determines the leading dimension (stride) and memory order of a 2D NumPy array and reports a C-compatible shape when possible. This helper is used throughout PySCF linear-algebra and integral routines to decide how to pass matrices to BLAS/LAPACK and other low-level kernels that are sensitive to row-major (C) or column-major (Fortran) memory layout.` |
| `pyscf_lib_numpy_helper_locs_to_indices` | `pyscf.lib.numpy_helper.locs_to_indices` | `pyscf/lib/numpy_helper.py` | `locs: numpy.ndarray, segement_list: numpy.ndarray` | `pyscf.lib.numpy_helper.locs_to_indices converts a list/array of segment boundary positions ("locs") and a specification of desired segment IDs ("segement_list") into a flat numpy.int32 array of contiguous integer indices that correspond to the union of those segments. This helper is used throughout the PySCF (Python-based Simulations of Chemistry Framework) codebase to translate segment/block specifications (for example, contiguous groups of atomic orbital or molecular orbital indices, integral blocks, or other contiguous index ranges) into a concrete 1-D index array suitable for array slicing, indexing, and assembly of block-wise data.` |
| `pyscf_lib_numpy_helper_ndarray_pointer_2d` | `pyscf.lib.numpy_helper.ndarray_pointer_2d` | `pyscf/lib/numpy_helper.py` | `array: numpy.ndarray` | `pyscf.lib.numpy_helper.ndarray_pointer_2d returns a 1-D numpy.ndarray of pointer-sized unsigned integers that contain the memory addresses (byte offsets from address zero) of the first element in each row of the supplied 2-D, C-contiguous numpy.ndarray. This helper is intended for low-level interfacing in the PySCF computational-chemistry codebase where C/Fortran routines or ctypes-based APIs require an array of per-row pointers to contiguous row data.` |
| `pyscf_lib_numpy_helper_pack_tril` | `pyscf.lib.numpy_helper.pack_tril` | `pyscf/lib/numpy_helper.py` | `mat: numpy.ndarray, axis: int = -1, out: numpy.ndarray = None` | `pyscf.lib.numpy_helper.pack_tril flattens the lower-triangular elements of one or a batch of square matrices into a contiguous packed representation used in PySCF for compact storage and faster linear-algebra operations common in quantum chemistry (for example, compressing symmetric matrices such as density matrices or two-electron integral slices).` |
| `pyscf_lib_numpy_helper_takebak_2d` | `pyscf.lib.numpy_helper.takebak_2d` | `pyscf/lib/numpy_helper.py` | `out: numpy.ndarray, a: numpy.ndarray, idx: numpy.ndarray, idy: numpy.ndarray, thread_safe: bool = True` | `Reverse of take_2d: accumulate a small 2D block into a larger 2D array in-place. Performs the equivalent operation out[idx[:, None], idy] += a for a 2D block a, modifying out in-place and returning out. In the PySCF codebase this routine is used when assembling contributions computed on index subsets (for example, adding sub-blocks of integrals or density-matrix contributions back into a global 2D array). The function prefers C-optimized code paths for double and complex128 dtypes and falls back to NumPy advanced-index accumulation for other dtypes when thread_safe is True.` |
| `pyscf_lib_numpy_helper_tag_array` | `pyscf.lib.numpy_helper.tag_array` | `pyscf/lib/numpy_helper.py` | `a: numpy.ndarray, **kwargs` | `pyscf.lib.numpy_helper.tag_array attaches arbitrary Python attributes to a NumPy array by returning a NPArrayWithTag view that holds the array data together with a dictionary of attributes. In the PySCF (Python-based Simulations of Chemistry Framework) codebase this function is used to carry metadata alongside numeric arrays (for example, attaching basis, symmetry, molecule, or other calculation metadata to intermediate arrays) so downstream code can access both numerical data and contextual information without separate containers. The function converts the provided input to a NumPy ndarray via numpy.asarray and then creates a NPArrayWithTag view of that ndarray. If the input is already an instance of NPArrayWithTag, its existing attributes are preserved and then updated with the provided keyword attributes. Attribute names and values are stored in the returned object's __dict__ and are intended to be used as metadata attached to the array in computational chemistry workflows handled by PySCF.` |
| `pyscf_lib_numpy_helper_solve_lineq_by_SVD` | `pyscf.lib.numpy_helper.solve_lineq_by_SVD` | `pyscf/lib/numpy_helper.py` | `a: numpy.ndarray, b: numpy.ndarray` | `Solves the linear system a * x = b using a truncated singular value decomposition (SVD). This function is used in PySCF (a Python-based simulations of chemistry framework) to obtain stable solutions for linear systems that arise in quantum-chemistry computations when the coefficient matrix a may be singular or nearly singular. The implementation computes the SVD of a, discards singular values smaller than the module-level constant LINEAR_DEP_THRESHOLD, and forms a solution x from the retained singular vectors and singular values. This produces a regularized least-squares solution (minimizing \|\|a x - b\|\|_2 over the retained subspace) and avoids numerical instability caused by tiny singular values.` |
| `pyscf_lib_numpy_helper_split_reshape` | `pyscf.lib.numpy_helper.split_reshape` | `pyscf/lib/numpy_helper.py` | `a: numpy.ndarray, shapes: tuple` | `Split a 1-D numpy.ndarray into one or more tensors described by a nested tuple of shapes. This function is used in the PySCF (Python-based Simulations of Chemistry Framework) codebase to convert a flattened parameter vector (for example, concatenated orbital coefficients, density matrix blocks, or other flattened model parameters commonly used in electronic structure codes) into structured tensor blocks. The argument shapes describes how to partition and reshape the flat array a into individual tensors or nested groups of tensors. The function never modifies the input array in-place; it constructs new numpy.ndarray objects for the returned tensors (these may be views or copies depending on NumPy's internal behavior).` |
| `pyscf_lib_numpy_helper_omatcopy` | `pyscf.lib.numpy_helper.omatcopy` | `pyscf/lib/numpy_helper.py` | `a: numpy.ndarray, out: numpy.ndarray = None` | `pyscf.lib.numpy_helper.omatcopy copies a 2-D numpy.ndarray (matrix) while preserving its memory order (row-major or column-major). This routine is used in PySCF linear-algebra code paths where maintaining the original array order and leading-dimension semantics is important for correct and efficient interoperability with low-level C/Fortran routines and optimized copy kernels used in quantum-chemistry computations (for example, copying density, overlap, or Hamiltonian matrices before passing them to native libraries).` |
| `pyscf_lib_numpy_helper_transpose_sum` | `pyscf.lib.numpy_helper.transpose_sum` | `pyscf/lib/numpy_helper.py` | `a: numpy.ndarray, inplace: bool = False, out: numpy.ndarray = None` | `Compute the element-wise sum a + a.T (matrix plus its transpose) with improved memory efficiency compared to constructing the transpose and summing separately. This helper is provided in the PySCF library (Python-based Simulations of Chemistry Framework) to build symmetrized matrices commonly needed in quantum-chemistry workflows (e.g., symmetrizing density, overlap, Fock, or integral intermediate matrices) while reducing temporary memory allocations. The implementation forwards the call to hermi_sum(a, inplace=inplace, out=out) to perform the computation.` |
| `pyscf_lib_numpy_helper_transpose` | `pyscf.lib.numpy_helper.transpose` | `pyscf/lib/numpy_helper.py` | `a: numpy.ndarray, axes: tuple = None, inplace: bool = False, out: numpy.ndarray = None` | `Transposing an array with improved memory efficiency for PySCF tensor operations. This function is used throughout the PySCF (Python-based Simulations of Chemistry Framework) codebase to transpose arrays and small tensors encountered in quantum-chemistry workflows (for example, transposing density matrices, orbital coefficient matrices, or 3-index/two-electron integral tensors) while minimizing additional memory allocations and exploiting optimized C kernels for common dtypes and layouts. The implementation chooses different algorithms depending on array dimensionality, memory contiguity, dtype, and the requested axes to offer an in-place path where safe and fast out-of-place paths when needed.` |
| `pyscf_lib_numpy_helper_unpack_row` | `pyscf.lib.numpy_helper.unpack_row` | `pyscf/lib/numpy_helper.py` | `tril: numpy.ndarray, row_id: int` | `pyscf.lib.numpy_helper.unpack_row extracts a single full row from a packed lower-triangular representation of a square matrix. The function is used in PySCF to access one row of symmetric or Hermitian matrices that are stored in compact (packed) form to save memory (for example, packed density matrices or two-electron integral blocks). It is equivalent to calling unpack_tril(tril)[row_id] but avoids allocating the entire unpacked matrix when only one row is needed.` |
| `pyscf_lib_numpy_helper_zdot` | `pyscf.lib.numpy_helper.zdot` | `pyscf/lib/numpy_helper.py` | `a: numpy.ndarray, b: numpy.ndarray, alpha: float = 1, c: numpy.ndarray = None, beta: float = 0` | `pyscf.lib.numpy_helper.zdot: Matrix-matrix multiplication for double-complex (numpy.complex128) arrays using a BLAS zgemm backend. This function is used within the PySCF (Python-based Simulations of Chemistry Framework) code path for high-performance complex linear-algebra operations common in quantum-chemistry workflows (for example, transforming complex orbital coefficient matrices or contracting complex integral blocks). It implements the operation C := alpha * A @ B + beta * C with explicit handling of memory layout to call the BLAS _zgemm routine efficiently.` |
| `pyscf_lib_numpy_helper_einsum` | `pyscf.lib.numpy_helper.einsum` | `pyscf/lib/numpy_helper.py` | `subscripts: str, *tensors, **kwargs` | `Perform an einsum-style tensor contraction optimized for common quantum-chemistry tensor patterns by reshaping operands to matrix multiplies when possible. This function is a drop-in, more efficient variant used throughout PySCF for multi-tensor contractions (for example, contracting molecular orbital and integral tensors in post-Hartree‚ÄìFock methods). It preserves the semantics of an einsum expression while applying an internal contraction path and specialized two-operand contraction routine to reduce work and memory when the expression meets the function's assumptions. This implementation differs from numpy.einsum in two important, documented ways inherited from PySCF usage patterns: it assumes that any repeated index in the subscripts is a summation index (i.e., the pattern 'i,i->i' is not supported) and that every repeated index appears exactly twice (i.e., patterns such as 'ij,ik,il->jkl' are not supported). It also requires the output indices to be explicitly specified in the subscripts string (for example, use 'ij,j->i' rather than the implicit 'ij,j').` |
| `pyscf_lib_numpy_helper_zdotNN` | `pyscf.lib.numpy_helper.zdotNN` | `pyscf/lib/numpy_helper.py` | `aR: numpy.ndarray, aI: numpy.ndarray, bR: numpy.ndarray, bI: numpy.ndarray, alpha: float = 1, cR: numpy.ndarray = None, cI: numpy.ndarray = None, beta: float = 0` | `zdotNN computes the non-conjugated complex matrix product c = alpha * (a * b) + beta * c where a and b are provided as separate real and imaginary parts. This routine is part of PySCF's low-level numpy_helper linear-algebra utilities and is used in quantum-chemistry workflows inside PySCF to assemble complex-valued matrices (for example intermediate products of density matrices, Fock/Kohn‚ÄìSham matrices, or complex integrals) while avoiding explicit complex dtype arithmetic by operating on real and imaginary components.` |
| `pyscf_lib_scipy_helper_pivoted_cholesky` | `pyscf.lib.scipy_helper.pivoted_cholesky` | `pyscf/lib/scipy_helper.py` | `A: numpy.ndarray, tol: float = -1.0, lower: bool = False` | `pyscf.lib.scipy_helper.pivoted_cholesky computes a pivoted Cholesky factorization of a symmetric (Hermitian) positive semidefinite matrix A, returning a triangular factor (lower or upper), the pivot permutation vector, and the numerical rank. This routine is used within the PySCF (Python-based Simulations of Chemistry Framework) codebase to obtain robust low-rank decompositions of matrices that arise in quantum-chemistry workflows (for example, compression of integral or covariance-like matrices), and it wraps a LAPACK-style implementation with full pivoting to handle singular or near-singular cases.` |
| `pyscf_lo_cholesky_cholesky_mos` | `pyscf.lo.cholesky.cholesky_mos` | `pyscf/lo/cholesky.py` | `mo_coeff: numpy.ndarray` | `Calculates localized molecular orbitals (MOs) by performing a pivoted Cholesky factorization of a density-matrix-like quantity constructed from a provided block of MO coefficients. This function is part of PySCF's localized-orbital toolset and is used in computational chemistry workflows (for example, to generate localized orbitals for local correlation methods or integral factorizations). It factors the matrix D = mo_coeff @ mo_coeff.T using a pivoted Cholesky routine, permutes the Cholesky factors back to the original atomic-orbital (AO) ordering, and returns a block of localized MOs spanning the same MO subspace as the input.` |
| `pyscf_lib_numpy_helper_zdotCN` | `pyscf.lib.numpy_helper.zdotCN` | `pyscf/lib/numpy_helper.py` | `aR: numpy.ndarray, aI: numpy.ndarray, bR: numpy.ndarray, bI: numpy.ndarray, alpha: float = 1, cR: numpy.ndarray = None, cI: numpy.ndarray = None, beta: float = 0` | `Compute the complex conjugate dot product c = conj(a) * b from separate real and imaginary parts. This function implements the complex inner product used throughout PySCF where complex arrays are stored as separate real and imaginary numpy.ndarray buffers for performance and BLAS-like accumulation. The operation performed is, in mathematical form, c = alpha * (conj(a) ¬∑ b) + beta * c_initial, with conj(a) the complex conjugate of a, and the dot (¬∑) denoting the sum-over-products (inner product) performed by the internal ddot routine. The result is returned as two numpy.ndarray objects holding the real and imaginary parts of c. This routine is commonly used in quantum chemistry workloads inside PySCF to compute overlaps, contractions of complex-valued vectors/matrices, and other linear-algebra kernels where explicit complex number storage is avoided for efficiency.` |
| `pyscf_lib_numpy_helper_zdotNC` | `pyscf.lib.numpy_helper.zdotNC` | `pyscf/lib/numpy_helper.py` | `aR: numpy.ndarray, aI: numpy.ndarray, bR: numpy.ndarray, bI: numpy.ndarray, alpha: float = 1, cR: numpy.ndarray = None, cI: numpy.ndarray = None, beta: float = 0` | `zdotNC computes the complex-valued product c = alpha * (a * conj(b)) + beta * c where a and b are provided as separate real and imaginary numpy arrays. This function is a low-level helper in PySCF's numpy_helper module used to perform complex linear-algebra operations by working on real and imaginary parts separately. In the PySCF quantum-chemistry context, the inputs a and b typically represent complex-valued matrices or vectors such as molecular-orbital coefficients, density-matrix blocks, or other complex intermediate tensors; this routine computes the product of a with the complex conjugate of b using real arithmetic (via the internal ddot calls) and optionally accumulates the result into provided output buffers. The implementation mirrors BLAS-style scaling and accumulation: the computed product is scaled by alpha and any provided output buffers are scaled by beta and added.` |
| `pyscf_lo_ibo_MakeAtomIbOffsets` | `pyscf.lo.ibo.MakeAtomIbOffsets` | `pyscf/lo/ibo.py` | `Atoms: list` | `pyscf.lo.ibo.MakeAtomIbOffsets: Calculate atom-wise starting offsets for the valence minimal basis (IB) orbitals and return supporting per-element orbital counts and labels used by intrinsic bond orbital (IBO) construction.` |
| `pyscf_lib_numpy_helper_unpack_tril` | `pyscf.lib.numpy_helper.unpack_tril` | `pyscf/lib/numpy_helper.py` | `tril: numpy.ndarray, filltriu: int = 1, axis: int = -1, out: numpy.ndarray = None` | `Reconstruct a full square matrix (or a batch of square matrices) from a packed lower-triangular representation used in PySCF. This function performs the inverse of pack_tril: given an array that holds the lower-triangular elements (packed format), unpack_tril returns a full square array (or array of square arrays) by placing the packed elements into the lower triangle and optionally filling the upper triangle according to filltriu. In PySCF this is commonly used to reconstruct matrices such as density matrices or integral blocks stored in compact lower-triangular form to save memory and I/O cost.` |
| `pyscf_lib_scipy_helper_pivoted_cholesky_python` | `pyscf.lib.scipy_helper.pivoted_cholesky_python` | `pyscf/lib/scipy_helper.py` | `A: numpy.ndarray, tol: float = -1.0, lower: bool = False` | `pyscf.lib.scipy_helper.pivoted_cholesky_python performs a pedestrian (pure-Python) pivoted Cholesky factorization with full column pivoting of a positive semidefinite matrix. It is intended for use within the PySCF quantum-chemistry framework to produce a low-rank Cholesky factor (for example, when decomposing positive semidefinite matrices that appear in density fitting or integral decompositions). This implementation should be used only when a LAPACK-optimized routine is unavailable, as it is significantly slower than optimized library calls. This routine constructs a triangular factor L by greedily selecting pivot indices and updating the residual diagonal D. The algorithm stops when the largest remaining diagonal element falls below the provided tolerance, producing a numerical rank and a permutation vector that records the pivot ordering. The returned factor and permutation can be used to form an approximate reconstruction of A after applying the permutation (see Returns).` |
| `pyscf_lo_ibo_shell_str` | `pyscf.lo.ibo.shell_str` | `pyscf/lo/ibo.py` | `l: int, n_cor: int, n_val: int` | `pyscf.lo.ibo.shell_str constructs a space-separated label string that defines which atomic shells of a given angular momentum l are treated as core (bracketed) and which are treated as valence (unbracketed). This helper is used in the PySCF lo.ibo (localized / intrinsic bond orbital) context to build textual shell specifications for partitioning atomic orbitals into core and valence shells when preparing localization, orbital analysis, or shell-based selections in quantum-chemistry workflows within the PySCF framework. Detailed behavior: The function uses an internal pattern table (cor_shell) that maps angular momentum l to a template string (for example, l=0 -> "[{n}s]", l=1 -> "[{n}px] [{n}py] [{n}pz]", l=2 -> d-shell templates, l=3 -> f-shell templates). Core shell labels are formatted using these templates and remain enclosed in square brackets to mark them as "core" in downstream parsers; valence shell labels are the same templates but with the brackets removed. Principal quantum numbers are assigned sequentially beginning at n = l + 1; the function first emits n_cor core shells (in increasing principal quantum number order) and then n_val valence shells, joining all formatted labels with single spaces. The function does not modify external state and returns the constructed string.` |
| `pyscf_lo_orth_lowdin` | `pyscf.lo.orth.lowdin` | `pyscf/lo/orth.py` | `s: numpy.ndarray` | `Compute the L√∂wdin (symmetric) orthonormalization matrix for a basis with overlap matrix s. This function implements the L√∂wdin (symmetric) orthogonalization commonly used in quantum chemistry and in the PySCF framework to transform a non-orthogonal atomic-orbital (AO) basis into an orthonormal basis. Given the overlap matrix s (S_mu,nu = <mu\|nu>), the function diagonalizes s, discards eigencomponents with eigenvalues at or below a numerical threshold (1e-15) to avoid division by (near) zero, and constructs the matrix c_lowdin = V_diag(1/sqrt(e)) V^H restricted to the retained subspace. The returned matrix c_lowdin can be used as the column matrix of new basis vectors so that the new basis \|i> = sum_mu \|mu> c_lowdin[mu,i] satisfies c_lowdin^H s c_lowdin = I on the retained subspace. In PySCF this is used during basis orthonormalization steps such as constructing orthonormal molecular orbitals from AO coefficients.` |
| `pyscf_lo_nao_set_atom_conf` | `pyscf.lo.nao.set_atom_conf` | `pyscf/lo/nao.py` | `element: str, description: list` | `Change the default atomic core and valence shell configuration for an element in the NAO (numerical atomic orbital) AOSHELL mapping used by PySCF. This function is used by PySCF's localized-orbital / NAO utilities to override the default per-element core and core+valence shell counts stored in the data/elements.py AOSHELL table. It resolves the provided element to a nuclear charge using mole.charge(element) and updates AOSHELL[charge] in-place so subsequent NAO/basis logic uses the new core and valence shell counts. The update is also reported to standard error.` |
| `pyscf_lo_orth_vec_lowdin` | `pyscf.lo.orth.vec_lowdin` | `pyscf/lo/orth.py` | `c: numpy.ndarray, s: numpy.ndarray = 1` | `vec_lowdin(c, s=1) Performs L√∂wdin (symmetric) orthogonalization of the column space of a coefficient matrix c with respect to a metric s and returns the orthonormalized coefficient matrix. This routine is used in the PySCF electronic-structure context (for example in the lo.orth module and orbital localization routines) to transform a set of basis coefficients so that their columns are orthonormal with respect to the overlap/metric matrix S. Concretely, the routine forms the small metric M = c.conj().T @ s @ c, computes the L√∂wdin symmetric orthonormalization matrix X = lowdin(M), and returns c @ X. The implementation uses the conjugate transpose of c to support complex-valued coefficients and the identity scalar default for s for convenience when the metric is the standard Euclidean inner product.` |
| `pyscf_lo_orth_weight_orth` | `pyscf.lo.orth.weight_orth` | `pyscf/lo/orth.py` | `s: numpy.ndarray, weight: numpy.ndarray` | `pyscf.lo.orth.weight_orth: Construct weight-scaled Lowdin-orthonormalization coefficients for a given overlap matrix. This function constructs a new set of basis-coefficient vectors c_{mu,i} that define orthonormal basis functions under the original atomic-orbital overlap matrix s, after applying a multiplicative weight per basis function. It implements the transformation c = w * [ (w s w)^{-1/2} ], where w is the diagonal weighting defined by the 1D array weight, s is the square overlap matrix, and (w s w)^{-1/2} is obtained by the Lowdin symmetric orthonormalization of the weighted overlap matrix s1 = w s w. In PySCF this routine is used in localized orbital and basis-transformation utilities to produce a new basis \|mu> c_{mu i} whose columns are orthonormal with respect to the original quantum-chemical overlap s (i.e., c^T s c = I), enabling downstream procedures that require an orthonormal representation (for example, population analysis, projector construction, or subsequent orthogonal transformations in electronic structure workflows).` |
| `pyscf_mcpdft__dms_dm2_cumulant` | `pyscf.mcpdft._dms.dm2_cumulant` | `pyscf/mcpdft/_dms.py` | `dm2: numpy.ndarray, dm1s: numpy.ndarray` | `pyscf.mcpdft._dms.dm2_cumulant computes the spin‚Äësummed two‚Äëbody cumulant reduced density matrix (cm2) used in PySCF's multiconfiguration pair-density functional theory (MCPDFT) code paths. The cumulant isolates correlated two‚Äëparticle contributions by removing the disconnected (mean‚Äëfield) product of one‚Äëparticle density matrices from the spin‚Äësummed two‚Äëparticle reduced density matrix (2‚ÄëRDM). This routine is used in quantum chemistry workflows implemented in the PySCF framework (see project README) wherever a two‚Äëbody cumulant is required for correlation analysis, on‚Äëtop pair density evaluation, or input to MCPDFT energy expressions.` |
| `pyscf_mcpdft__dms_dm2s_cumulant` | `pyscf.mcpdft._dms.dm2s_cumulant` | `pyscf/mcpdft/_dms.py` | `dm2s: numpy.ndarray, dm1s: numpy.ndarray` | `pyscf.mcpdft._dms.dm2s_cumulant computes the spin-summed two-body cumulant reduced density matrices (cm2s) from spin-separated one- and two-particle reduced density matrices. This routine is used in the mcpdft (multiconfiguration pair-density functional theory) workflow within PySCF to extract the non-separable (cumulant) part of the two-particle RDM required for constructing correlation/energy contributions that go beyond the mean-field separable product of 1-RDMs.` |
| `pyscf_mcpdft__libxc_split_x_c_comma` | `pyscf.mcpdft._libxc.split_x_c_comma` | `pyscf/mcpdft/_libxc.py` | `xc: str` | `Split an xc code string into two separate identifiers: one for exchange and one for correlation, used by the PySCF mcpdft._libxc plumbing that maps user-specified XC identifiers to LibXC exchange/correlation components. The function locates a comma in the input string or in any alias/lookup it resolves, upper-cases the input for alias matching, consults module tables for numeric LibXC codes and aliases (XC_ALIAS, XC_CODES, XC_KEYS, INTCODES_TYPES, INTCODES_HYB), and enforces a recursion limit when expanding aliases. This is used when parsing an xc specification passed to higher-level MCPDFT/DFT routines so that the exchange and correlation parts can be handled separately by LibXC or other backends.` |
| `pyscf_mcpdft_mspdft_get_diabfns` | `pyscf.mcpdft.mspdft.get_diabfns` | `pyscf/mcpdft/mspdft.py` | `obj: str` | `Return a pair of callables (diabatizer, diabatize) appropriate for the requested MS-PDFT method name. The pair implements (1) evaluation of the MS-PDFT objective function and its first and second derivatives (the second-order power series used by Newton-like optimizers) and (2) the transformation/optimization that produces CI vectors in the optimized intermediate-state (diabatic) basis. This helper is used in the MS-PDFT (multistate pair-density functional theory) components of PySCF to select method-specific implementations: for "CMS" the function returns the Coulomb-energy-based diabatizer and a local Newton solver for intermediate-state optimization; for "XMS" the function returns the state-averaged Fock-based diabatizer and its corresponding solver.` |
| `pyscf_mcpdft_otfnal_unregister_otfnal` | `pyscf.mcpdft.otfnal.unregister_otfnal` | `pyscf/mcpdft/otfnal.py` | `xc_code: str` | `Unregister an on-top functional previously registered for MC-PDFT calculations. This function removes a custom on-top functional from PySCF's module-level registry and from the underlying libxc custom functional registry so that the functional will no longer be available to subsequent multiconfiguration pair-density functional theory (MC-PDFT) calculations. In the PySCF MC-PDFT workflow, on-top functionals encode pair-density‚Äìdependent contributions to the total energy; unregistering is used when a previously registered custom functional (for example, added via a corresponding registration API) must be removed to avoid name collisions or to revert to built-in behavior.` |
| `pyscf_mcpdft_otfnal_make_scaled_fnal` | `pyscf.mcpdft.otfnal.make_scaled_fnal` | `pyscf/mcpdft/otfnal.py` | `xc_code: str, hyb_x: float = 0, hyb_c: float = 0, fnal_x: float = None, fnal_c: float = None` | `make a new libxc-style exchange-correlation code string that scales and mixes wavefunction and density-functional components for use in PySCF MCPDFT (on-top functional) workflows. This function constructs an xc_code string that represents a functional of the form Exc = hyb_x * E_x[Psi] + fnal_x * E_x[rho] + hyb_c * E_c[Psi] + fnal_c * E_c[rho], where E_x[Psi]/E_c[Psi] are exchange/correlation energy contributions obtained from a wave function (Psi) and E_x[rho]/E_c[rho] are exchange/correlation density functionals evaluated by libxc (rho). This is used in the PySCF mcpdft.otfnal context to build mixed functionals that combine explicit wavefunction exchange/correlation (e.g., HF exchange or multiconfigurational wave function components) with density-functional contributions provided by libxc. The decomposition of any wavefunction energy E[Psi] into exchange (E_x) and correlation (E_c) parts is arbitrary and must be consistent with how the caller interprets those components.` |
| `pyscf_mcpdft_tfnal_derivs_contract_vot` | `pyscf.mcpdft.tfnal_derivs.contract_vot` | `pyscf/mcpdft/tfnal_derivs.py` | `vot: tuple, rho: numpy.ndarray, Pi: numpy.ndarray` | `Evalute the product of unpacked vot with perturbed density, pair density, and their derivatives on numerical integration grids used by the MC-PDFT tfnal_derivs workflow in PySCF. This function is used in multi-configuration pair-density functional theory (MC-PDFT) derivative code to form the grid-wise scalar contraction between the functional derivative arrays (vot) and the local electron density and on-top pair density (and their spatial/auxiliary derivatives) required by TF-NAL style functional derivative expressions.` |
| `pyscf_mcpdft_otfnal_register_otfnal` | `pyscf.mcpdft.otfnal.register_otfnal` | `pyscf/mcpdft/otfnal.py` | `xc_code: str, preset: dict` | `pyscf.mcpdft.otfnal.register_otfnal registers a new on-top (OT) density functional with the libxc backend so that the functional can be used by PySCF's multiconfigurational pair-density functional theory (MCPDFT) workflows. This function is used when developers or advanced users need to make a custom on-top functional available to PySCF (for example, to test new parameterizations or to expose a composite functional built from an underlying Kohn‚ÄìSham LibXC functional). The function delegates the actual registration to libxc.register_custom_functional_ and records hybrid mixing information in the module-level registry REG_OT_FUNCTIONALS so that subsequent MCPDFT code can query hybrid fractions for exchange and correlation.` |
| `pyscf_mcpdft_otfnal_make_hybrid_fnal` | `pyscf.mcpdft.otfnal.make_hybrid_fnal` | `pyscf/mcpdft/otfnal.py` | `xc_code: str, hyb: float, hyb_type: int = 1` | `make_hybrid_fnal generates a PySCF-style hybrid exchange‚Äìcorrelation (XC) functional specification by combining a base libxc functional code (xc_code) with a small set of "hybridization" parameters (hyb) according to one of several predefined combination rules (hyb_type). This convenience wrapper is used in the mcpdft.otfnal code path of PySCF to produce hybrid functionals suitable for multiconfigurational pair-density functional theory workflows; it produces a functional specification that is ultimately passed to make_scaled_fnal and then consumed by PySCF's DFT machinery (pyscf.dft.libxc) for evaluation of exchange and correlation contributions.` |
| `pyscf_md_set_seed` | `pyscf.md.set_seed` | `pyscf/md/__init__.py` | `seed: int` | `Sets the seed for the random number generator used by the md module in PySCF. This function initializes or replaces the module-level random number generator used by pyscf.md routines by creating a numpy.random.Generator backed by numpy.random.PCG64 initialized with the given integer seed. In the context of the PySCF (Python-based Simulations of Chemistry Framework) md submodule, this seed controls all subsequent pseudo-random behaviour that relies on the module's rng variable, for example random initial velocities, stochastic forces, Monte Carlo sampling, or other randomized procedures that may appear in molecular dynamics or related stochastic workflows within PySCF. Calling this function ensures deterministic, reproducible sequences of pseudo-random numbers for those md module operations when the same seed and the same numpy/PySCF environment are used.` |
| `pyscf_pbc_cc_eom_kccsd_ghf_amplitudes_to_vector_ee` | `pyscf.pbc.cc.eom_kccsd_ghf.amplitudes_to_vector_ee` | `pyscf/pbc/cc/eom_kccsd_ghf.py` | `r1: numpy.ndarray, r2: numpy.ndarray, kshift: numpy.ndarray, kconserv: numpy.ndarray` | `Transform 3- and 7-dimensional excitation-amplitude arrays used in k-point CCSD/EOM-EE (GHF, periodic boundary conditions) into a 1-dimensional vector containing only the unique amplitude elements according to the k-point and orbital-index ordering used by pyscf.pbc.cc.eom_kccsd_ghf. This routine is used in the periodic (pbc) k-point coupled-cluster singles-and-doubles (kCCSD) / equation-of-motion for excited states (EOM-EE) with a generalized Hartree‚ÄìFock (GHF) reference inside the PySCF framework. It packs the single-excitation amplitudes r1 and the independent double-excitation amplitudes r2 into a contiguous 1D numpy array in a deterministic order so downstream linear-algebra routines (diagonalization, iterative solvers, projections) operate on a vector of independent variables rather than full tensors.` |
| `pyscf_pbc_cc_eom_kccsd_ghf_enforce_2p_spin_doublet` | `pyscf.pbc.cc.eom_kccsd_ghf.enforce_2p_spin_doublet` | `pyscf/pbc/cc/eom_kccsd_ghf.py` | `r2: numpy.ndarray, kconserv: numpy.ndarray, kshift: int, orbspin: list, excitation: str` | `Enforces the two-particle (2p) spin-selection rule for EOM-KCCSD generalized-Hartree-Fock amplitudes in periodic boundary condition calculations so that the net spin change of the 2p excitation is limited to +/- 1/2. This function is used in the PySCF pbc.cc.eom_kccsd_ghf module to post-process or project EOM two-particle amplitude tensors (r2) for ionization-potential ('ip') or electron-affinity ('ea') excitation operators, zeroing amplitude components that correspond to forbidden net spin changes and enforcing the required antisymmetry under particle exchange across k-points according to the k-point conservation array.` |
| `pyscf_pbc_cc_eom_kccsd_ghf_spatial2spin_ip_doublet` | `pyscf.pbc.cc.eom_kccsd_ghf.spatial2spin_ip_doublet` | `pyscf/pbc/cc/eom_kccsd_ghf.py` | `r1: tuple, r2: tuple, kconserv: numpy.ndarray, kshift: int, orbspin: numpy.ndarray = None` | `Convert R1/R2 amplitudes expressed in spatial-orbital blocks into R1/R2 amplitudes in the spin-orbital representation for an ionization-potential (IP) doublet calculation in periodic (k-point) systems. This function is used in the PySCF pbc EOM-KCCSD GHF code path to assemble spin-resolved amplitudes required by spin-orbital EOM solvers from spatial-orbital components computed separately for alpha/alpha, beta/alpha, alpha/beta, and beta/beta spin combinations. The routine preserves numerical dtypes, respects k-point momentum conservation via kconserv, and supports a custom per-kpoint orbital-spin ordering via orbspin; when orbspin is None, an alternating alpha/beta ordering is assumed.` |
| `pyscf_pbc_cc_eom_kccsd_ghf_spin2spatial_ea_doublet` | `pyscf.pbc.cc.eom_kccsd_ghf.spin2spatial_ea_doublet` | `pyscf/pbc/cc/eom_kccsd_ghf.py` | `r1: numpy.ndarray, r2: numpy.ndarray, kconserv: numpy.ndarray, kshift: int, orbspin: numpy.ndarray` | `Convert R1/R2 electron-attached (EA) amplitudes from a spin-orbital representation to a spatial-orbital representation separated into spin blocks for alpha/beta components, for use in k-point periodic boundary condition (PBC) EOM-KCCSD with generalized Hartree‚ÄìFock (GHF). This function is used in the pyscf.pbc.cc.eom_kccsd_ghf module to transform spin-orbital EA excitation amplitudes (R1, R2) into spatial-orbital blocks used by downstream routines that expect separate alpha and beta virtual subspaces per k-point and spin. The conversion observes momentum (k-point) conservation via kconserv and selects the amplitudes for a particular k-point shift given by kshift. The resulting arrays preserve the input dtype and are arranged to match the blocked spin structure produced from orbspin (0 for alpha, 1 for beta) described in the PBC orbital indexing used throughout the EOM-KCCSD implementation.` |
| `pyscf_pbc_cc_eom_kccsd_rhf_amplitudes_to_vector_singlet` | `pyscf.pbc.cc.eom_kccsd_rhf.amplitudes_to_vector_singlet` | `pyscf/pbc/cc/eom_kccsd_rhf.py` | `r1: numpy.ndarray, r2: numpy.ndarray, kconserv: numpy.ndarray` | `Transform 3- and 7-dimensional singlet EOM-CC amplitude arrays r1 and r2 for k-point periodic CCSD (EOM-KCCSD) into a 1-dimensional vector containing unique amplitude entries suitable for linear-algebra operations (for example, Davidson diagonalization). This function is used in the PySCF periodic coupled-cluster EOM module (pyscf.pbc.cc.eom_kccsd_rhf) to produce a compact vector of excitation amplitudes for singlet symmetry by flattening r1 and selecting only non-redundant elements of r2 according to a combined index ordering that enforces momentum conservation via the kconserv lookup table. r1 is expected to be the single-excitation amplitude array with shape (nkpts, nocc, nvir) corresponding to indices (k_i, i, a). r2 is expected to be the double-excitation amplitude array with k-point and orbital indices ordered as in the source code; the common convention in this module is r2 with seven axes for (k_i, k_J, k_a, i, J, a, B) before the internal transpose. kconserv is the integer k-point conservation table with shape (nkpts, nkpts, nkpts) that maps (ki, ka, kj) -> kb such that momentum is conserved for the four-index amplitude blocks.` |
| `pyscf_pbc_cc_eom_kccsd_ghf_spin2spatial_ip_doublet` | `pyscf.pbc.cc.eom_kccsd_ghf.spin2spatial_ip_doublet` | `pyscf/pbc/cc/eom_kccsd_ghf.py` | `r1: numpy.ndarray, r2: numpy.ndarray, kconserv: numpy.ndarray, kshift: int, orbspin: numpy.ndarray` | `Convert R1/R2 vectors from a spin-orbital representation into a spatial-orbital (alpha/beta separated) representation for the ionization-potential (IP) doublet case in k-point, generalized Hartree‚ÄìFock (GHF) EOM-CCSD calculations. This utility is used in the PySCF pbc.cc.eom_kccsd_ghf implementation to transform EOM-IP excitation vectors that are expressed in spin-orbital indexing into the spatial (alpha / beta) blocks that downstream routines expect for spin-adapted or block-structured processing. The function preserves the input dtype and produces new arrays whose shapes reflect the per-kpoint counts of occupied/virtual alpha and beta orbitals. It assumes the same number of occupied and virtual orbitals for every k-point and that orbspin encodes spin labels as 0 (alpha) and 1 (beta).` |
| `pyscf_pbc_cc_eom_kccsd_ghf_spatial2spin_ea_doublet` | `pyscf.pbc.cc.eom_kccsd_ghf.spatial2spin_ea_doublet` | `pyscf/pbc/cc/eom_kccsd_ghf.py` | `r1: tuple, r2: tuple, kconserv: numpy.ndarray, kshift: int, orbspin: numpy.ndarray = None` | `Convert R1/R2 amplitude tensors from a spatial-orbital representation to a spin-orbital representation for the electron-attached (EA) doublet manifold in k-point, periodic-boundary-condition coupled-cluster (k-CCSD) calculations using a generalized Hartree‚ÄìFock (GHF) reference. This function is used in the PySCF pbc.cc.eom_kccsd_ghf module to translate spatial-spin-decomposed EA vectors (r1, r2) produced by spin-adapted or spatial-orbital routines into the full spin-orbital format required by downstream EOM-CCSD linear algebra (for example, assembling the spin-orbital right-hand vectors used in Davidson diagonalization or for residual/evaluation routines).` |
| `pyscf_pbc_cc_eom_kccsd_rhf_join_indices` | `pyscf.pbc.cc.eom_kccsd_rhf.join_indices` | `pyscf/pbc/cc/eom_kccsd_rhf.py` | `indices: numpy.ndarray, struct: numpy.ndarray` | `pyscf.pbc.cc.eom_kccsd_rhf.join_indices converts a multi-dimensional integer index vector into a single linear index using the per-dimension radices provided by struct. This routine is used in the PySCF periodic (pbc) coupled-cluster EOM k-CCSD RHF code to map tuples of indices (for example k-point, band, or orbital coordinates across dimensions) into a single array index for compact storage and lookup.` |
| `pyscf_pbc_cc_eom_kccsd_rhf_vector_to_amplitudes_singlet` | `pyscf.pbc.cc.eom_kccsd_rhf.vector_to_amplitudes_singlet` | `pyscf/pbc/cc/eom_kccsd_rhf.py` | `vector: numpy.ndarray, nkpts: int, nmo: int, nocc: int, kconserv: numpy.ndarray` | `Convert a packed 1-D excitation vector used in k-point (periodic) EOM-CCSD (singlet) calculations into orbital- and k-point-resolved singles and doubles amplitude arrays. This function is used in the pyscf.pbc.cc.eom_kccsd_rhf module to unpack a linearized vector of excitation amplitudes (the internal representation used by iterative solvers and linear-algebra routines) into the physical amplitude tensors required by the equations-of-motion coupled-cluster with k-point symmetry (k-CCSD) for restricted Hartree‚ÄìFock reference states. The input vector encoding is expected to follow the packing convention: all singles (r1) entries first, followed by packed doubles (r2) blocks that exploit momentum-conservation and permutation symmetries via the kconserv lookup. The routine preserves the input array dtype and produces new numpy.ndarray objects for r1 and r2; it does not modify the input vector in-place.` |
| `pyscf_pbc_cc_kccsd_t_rhf_check_read_success` | `pyscf.pbc.cc.kccsd_t_rhf.check_read_success` | `pyscf/pbc/cc/kccsd_t_rhf.py` | `filename: str, **kwargs` | `Determine whether a dataset file for the k-point CCSD(T) restricted-HF (kccsd_t_rhf) workflow in the PySCF periodic-boundary-condition (pbc) module can be considered successfully written and therefore safe to read. In the PySCF project, routines that read intermediate or restart datasets (typically stored in HDF5-like files) use this predicate to avoid reading incomplete files produced by concurrent or interrupted write operations. The implementation is currently a stub that always returns False; the intended behavior is to inspect file metadata (for example a 'completed' attribute set by the writer) to decide read readiness.` |
| `pyscf_pbc_cc_kccsd_rhf_vector_to_nested` | `pyscf.pbc.cc.kccsd_rhf.vector_to_nested` | `pyscf/pbc/cc/kccsd_rhf.py` | `vector: numpy.ndarray, struct: list, copy: bool = True, ensure_size_matches: bool = True` | `pyscf.pbc.cc.kccsd_rhf.vector_to_nested reconstructs a nested array structure from a flattened 1-D numpy vector used by the k-point CCSD/RHF routines in PySCF. This function is used to map a single optimization or solver vector (flattened amplitudes and intermediates) back to the original nested collection of numpy arrays (tensors) described by struct so downstream coupled-cluster code can operate on arrays with original shapes and nesting.` |
| `pyscf_pbc_cc_kccsd_t_rhf_zip_kpoints` | `pyscf.pbc.cc.kccsd_t_rhf.zip_kpoints` | `pyscf/pbc/cc/kccsd_t_rhf.py` | `kpt_indices: list` | `pyscf.pbc.cc.kccsd_t_rhf.zip_kpoints converts and tiles k-point indices into integer index combinations suitable for assembling three-particle operator elements in k-point coupled-cluster (k-CCSD(T)) calculations for periodic systems. In the context of PySCF's pbc.cc.kccsd_t_rhf module, this function implements a Cartesian-product-like expansion specialized for the momentum-index bookkeeping required when forming triple-excitation (three-particle) amplitude or integral index combinations across k-points in periodic boundary condition (PBC) calculations. The function ensures all returned indices are integers and returns a flattened, tiled list of index tuples that downstream routines (integral contraction, amplitude updates) can iterate over deterministically.` |
| `pyscf_pbc_cc_kccsd_rhf_nested_to_vector` | `pyscf.pbc.cc.kccsd_rhf.nested_to_vector` | `pyscf/pbc/cc/kccsd_rhf.py` | `data: list, destination: numpy.ndarray = None, offset: int = 0` | `Puts a nested iterable of NumPy arrays into a one-dimensional vector. This function is used in the periodic coupled-cluster (kccsd_rhf) code path of PySCF to pack nested amplitude or intermediate arrays (for example, cluster amplitudes organized by k-points and excitation rank) into a contiguous 1D NumPy array for use in linear-algebra operations or I/O. When called without an explicit destination array, the function inspects the nested structure to compute the total storage required, allocates a 1D NumPy array of the appropriate dtype and size, and returns that array together with a structure descriptor that can be used to restore the flat vector back into the original nested layout.` |
| `pyscf_pbc_cc_kccsd_t_rhf_create_eris_vooo` | `pyscf.pbc.cc.kccsd_t_rhf.create_eris_vooo` | `pyscf/pbc/cc/kccsd_t_rhf.py` | `ooov: numpy.ndarray, nkpts: int, nocc: int, nvir: int, kconserv: numpy.ndarray, out: numpy.ndarray = None` | `Creates vooo from ooov array for k-point periodic CCSD(T) computations in PySCF. This function converts a four-index two-electron integral block given in a physicist-like ordering (ooov) into a chemist-like vooo ordering used by the k-point restricted CCSD(T) implementation (kccsd_t_rhf). The conversion includes complex conjugation and a specific transpose of the orbital indices, and it uses the k-point momentum conservation mapping kconserv to place the transformed block at the correct k-point index kb = kconserv[ki,kj,ka]. This routine is typically used during the construction of intermediate electron-repulsion integrals for triples corrections in periodic quantum chemistry calculations with PySCF (k-point periodic boundary condition workflows).` |
| `pyscf_pbc_cc_kccsd_t_rhf_create_eris_vvop` | `pyscf.pbc.cc.kccsd_t_rhf.create_eris_vvop` | `pyscf/pbc/cc/kccsd_t_rhf.py` | `vovv: numpy.ndarray, oovv: numpy.ndarray, nkpts: int, nocc: int, nvir: int, kconserv: numpy.ndarray, out: numpy.ndarray = None` | `Creates the vvop tensor from input two-electron integral blocks vovv and oovv (physicist notation) for k-point periodic CCSD(T) routines. This function is used in the PySCF periodic, restricted-HF k-point CCSD(T) implementation (pyscf.pbc.cc.kccsd_t_rhf) to assemble a combined tensor needed by downstream amplitude and energy routines that enforce crystal momentum conservation via the kconserv mapping. The routine preserves the dtype of vovv when allocating the output, applies complex conjugation and a specific axes permutation to convert the input block ordering into the output ordering, and writes into the provided output buffer or allocates one if out is None.` |
| `pyscf_pbc_cc_kccsd_t_rhf_transpose_t2` | `pyscf.pbc.cc.kccsd_t_rhf.transpose_t2` | `pyscf/pbc/cc/kccsd_t_rhf.py` | `t2: numpy.ndarray, nkpts: int, nocc: int, nvir: int, kconserv: numpy.ndarray, out: numpy.ndarray = None` | `Creates a transposed copy of two-body cluster amplitudes t2 used by k-point CCSD(T) in periodic boundary condition (PBC) calculations, returning an array with k-point and orbital indices rearranged so the k-point axes are ordered as (ka, kb, kj) and the orbital axes are ordered as (nvir, nvir, nocc, nocc). This function is used in pyscf.pbc.cc.kccsd_t_rhf to convert stored T2 amplitudes into the layout expected by subsequent tensor contractions in k-CCSD(T) post-processing and (T) energy routines. It understands two storage conventions for t2: full storage across all k-point triples and lower-triangular storage that exploits symmetry (ki <= kj) to save memory.` |
| `pyscf_pbc_dft_multigrid__backend_c_gradient_gs` | `pyscf.pbc.dft.multigrid._backend_c.gradient_gs` | `pyscf/pbc/dft/multigrid/_backend_c.py` | `f_gs: numpy.ndarray, Gv: numpy.ndarray` | `pyscf.pbc.dft.multigrid._backend_c.gradient_gs computes the G-space (reciprocal-space) components of the spatial gradient ‚àáf(r) from the Fourier coefficients f(G) and the G-vectors G. This function is used in the plane-wave / periodic-boundary-condition (PBC) multigrid routines within PySCF's periodic DFT code to obtain the Cartesian components of the gradient in G-space for quantities represented by their Fourier transforms (for example, orbitals, density, or potential components in a multigrid/FFT-based solver). The implementation dispatches the computation to a C multithreaded routine (libdft.gradient_gs) for performance and is mathematically equivalent to performing numpy.einsum('np,px->nxp', f_gs, 1j*Gv) but with multithreading and explicit C-contiguous memory layout.` |
| `pyscf_pbc_dft_multigrid__backend_c_get_gga_vrho_gs` | `pyscf.pbc.dft.multigrid._backend_c.get_gga_vrho_gs` | `pyscf/pbc/dft/multigrid/_backend_c.py` | `v: numpy.ndarray, v1: numpy.ndarray, Gv: numpy.ndarray, weight: float, ngrid: int, fac: float = 2.0` | `Compute and update a generalized-gradient-approximation (GGA) density-related potential vector v in reciprocal (G) space used by the PySCF periodic-boundary-condition (PBC) multigrid DFT backend. This function wraps and calls the external C routine libdft.get_gga_vrho_gs to perform the complex arithmetic efficiently in C: it implements the operation v <- v - fac * 1j * einsum('px,xp->p', Gv, v1) followed by v <- v * weight. In the PySCF DFT workflow this routine is used to accumulate the GGA contribution to the potential (v) on a grid in reciprocal space, where Gv contains G-vector components and v1 encodes intermediate response-like quantities. The function ensures arrays are C-contiguous and cast to the dtypes required by the C backend before calling libdft.` |
| `pyscf_pbc_df_rsdf_helper_remove_exp_basis` | `pyscf.pbc.df.rsdf_helper.remove_exp_basis` | `pyscf/pbc/df/rsdf_helper.py` | `basis: list, amin: float = None, amax: float = None` | `Remove Gaussian primitive functions from a PySCF GTO basis whose exponents lie outside the open interval (amin, amax). This function operates on basis specifications used throughout PySCF (for molecular or periodic/ PBC calculations) in the GTO basis format (as stored in mol._basis or cell._basis). Each primitive exponent is a float that controls the radial extent of a Gaussian-type orbital (GTO) primitive; filtering primitives by exponent is useful in practice to remove very diffuse or very tight primitives that can cause numerical instability, near-linear dependence, or excessive computational cost in electronic structure calculations.` |
| `pyscf_pbc_grad_krhf_make_rdm1e` | `pyscf.pbc.grad.krhf.make_rdm1e` | `pyscf/pbc/grad/krhf.py` | `mo_energy: list, mo_coeff: list, mo_occ: list` | `Construct energy-weighted one-particle density matrices for each k-point used in KRHF gradient evaluations in the periodic-boundary-conditions (pbc) module of PySCF. This function is a thin wrapper that dispatches per-k-point inputs to molgrad.make_rdm1e and stacks the results into a NumPy array for use in analytic gradient routines.` |
| `pyscf_pbc_grad_kuhf_make_rdm1e` | `pyscf.pbc.grad.kuhf.make_rdm1e` | `pyscf/pbc/grad/kuhf.py` | `mo_energy: numpy.ndarray, mo_coeff: numpy.ndarray, mo_occ: numpy.ndarray` | `Compute the energy-weighted one-electron reduced density matrix for k-point unrestricted Hartree‚ÄìFock (KUHF) gradient calculations. This function is part of the PySCF periodic-boundary-condition gradient machinery (pyscf.pbc.grad.kuhf). It constructs the energy-weighted one-particle reduced density matrix (1-RDM) for an unrestricted (k-point) calculation by delegating the per-spin construction to the k-point restricted-HF gradient helper pyscf.pbc.grad.krhf.make_rdm1e and stacking the two spin components. The resulting array is used in analytic gradient evaluations to accumulate contributions that depend on orbital energies, coefficients, and occupations for each spin channel.` |
| `pyscf_pbc_gto_cell_fromfile` | `pyscf.pbc.gto.cell.fromfile` | `pyscf/pbc/gto/cell.py` | `filename: str, format: str = None` | `Read a periodic Cell geometry from a file and construct a PySCF PBC Cell object. This function is part of the pyscf.pbc.gto.cell utilities and is used to create a pyscf.pbc.gto.Cell representing the periodic simulation cell (lattice vectors, atomic positions, basis/atom specifications as available in the source file). It is primarily intended for testing and simple file-based workflows where a user or test harness provides a file in a supported format; the returned Cell can then be used in downstream PySCF periodic-boundary-condition (PBC) electronic-structure calculations such as SCF, DFT, or correlated methods.` |
| `pyscf_pbc_gto_cell_loads` | `pyscf.pbc.gto.cell.loads` | `pyscf/pbc/gto/cell.py` | `cellstr: str` | `Deserialize a JSON document string into a pyscf.pbc.gto.cell.Cell instance representing a periodic Gaussian-type-orbital (GTO) cell used in PySCF periodic-boundary calculations.` |
| `pyscf_pbc_gto_cell_unpack` | `pyscf.pbc.gto.cell.unpack` | `pyscf/pbc/gto/cell.py` | `celldic: dict` | `pyscf.pbc.gto.cell.unpack converts a packed Cell attribute dictionary into a new Cell object suitable for use as input to periodic-boundary (PBC) electronic-structure calculations. This function is used in the PySCF periodic (pbc) electronic-structure workflow to reconstruct a pyscf.pbc.gto.cell.Cell instance from a previously packed mapping of attributes (for example, a dictionary produced by serializing or saving cl.__dict__). It instantiates a fresh Cell via Cell(), then updates that instance's attribute dictionary with the entries from celldic so the returned object reflects the packed state and can be used to generate or reproduce input arguments for Cell-based PBC calculations.` |
| `pyscf_pbc_gto_pseudo_pp_Ylm` | `pyscf.pbc.gto.pseudo.pp.Ylm` | `pyscf/pbc/gto/pseudo/pp.py` | `l: int, m: int, theta: float, phi: float` | `Spherical harmonic Y_l^m for use in PySCF PBC pseudopotential and angular-projection routines. This function evaluates the complex-valued spherical harmonic Y_l^m(theta, phi) using SciPy's scipy.special.sph_harm implementation and the same angle ordering/convention as SciPy. In the PySCF periodic-boundary-condition (pbc) gto.pseudo.pp code path, spherical harmonics are used to represent the angular dependence of pseudopotential projectors and to project atomic-like angular components; this function provides the atomic-centred angular factor that appears in those expansions. The implementation calls scipy.special.sph_harm(m, l, phi, theta) so the azimuthal angle phi is passed first to SciPy and the polar (colatitude) angle theta is passed second, matching SciPy's expected argument order.` |
| `pyscf_pbc_gto_pseudo_pp_Ylm_real` | `pyscf.pbc.gto.pseudo.pp.Ylm_real` | `pyscf/pbc/gto/pseudo/pp.py` | `l: int, m: int, theta: float, phi: float` | `Compute the real-valued spherical harmonic Y_lm(theta, phi) from the complex spherical harmonic Ylm used in PySCF's periodic-boundary-condition (pbc) gaussian-type-orbital (gto) pseudopotential code. This function is used when angular components of atomic orbitals, projector functions, or multipole expansions need real spherical harmonics rather than complex-valued harmonics; it converts the complex Ylm(l,\|m\|,theta,phi) returned by the internal Ylm routine into the standard real form by taking appropriate real or imaginary parts and scaling by sqrt(2) for \|m\|>0.` |
| `pyscf_pbc_gto_cell_pgf_rcut` | `pyscf.pbc.gto.cell.pgf_rcut` | `pyscf/pbc/gto/cell.py` | `l: int, alpha: float, coeff: float, precision: float = 1e-08, rcut: float = 0, max_cycle: int = 10, eps: float = 0.001` | `pyscf.pbc.gto.cell.pgf_rcut estimates cutoff radii for primitive Gaussian functions used in real-space integral screening in periodic electronic structure calculations (PySCF PBC module). The routine solves for rcut from the asymptotic relation c * rcut^(l+2) * exp(-alpha * rcut^2) ~ precision, where c = log(coeff/precision), and returns a radius beyond which the primitive Gaussian amplitude falls below the requested precision. This cutoff is used to truncate Gaussian tails for efficient integral evaluation and grid-based operations in periodic simulations.` |
| `pyscf_pbc_gto_cell_fromstring` | `pyscf.pbc.gto.cell.fromstring` | `pyscf/pbc/gto/cell.py` | `string: str, format: str = "poscar"` | `Convert a geometry string in a supported periodic-geometry file format into the internal lattice and atomic-coordinate string pair used by pyscf.pbc.gto.cell. This function is a small parser (marked ‚Äúin testing‚Äù in the original implementation) intended for converting file contents from common periodic-geometry formats into the two-string internal representation returned here and used when constructing PySCF Cell objects for periodic calculations (pyscf.pbc.gto.cell). The recognized formats are case-insensitive and currently include POSCAR/ VASP ("poscar" or "vasp"), extended XYZ with Lattice information ("xyz"), and a simple "raw" layout. The returned pair is (a, atom) where a is a three-line string of cartesian lattice vectors and atom is a newline-separated string of atom lines with element and cartesian coordinates.` |
| `pyscf_pbc_gw_krgw_ac_AC_pade_thiele_diag` | `pyscf.pbc.gw.krgw_ac.AC_pade_thiele_diag` | `pyscf/pbc/gw/krgw_ac.py` | `sigma: numpy.ndarray, omega: numpy.ndarray` | `Analytic continuation to the real frequency axis for per-orbital self-energies using a Pade approximation constructed by Thiele's reciprocal difference method. This function is used in the pbc.gw.krgw_ac workflow of PySCF to convert Matsubara/imaginary-frequency self-energy data (sigma) sampled on a discrete frequency grid (omega) into a set of Pade coefficients that approximate the analytic continuation to real frequencies. The implementation subsamples the input frequency grid with a fixed pattern (indices 1, 7, 13, 19, 25, 31, 37 and then every 4th index from index 41 onward) to build the data points used by the Thiele algorithm implemented in thiele(), and processes each orbital (row) independently to produce complex Pade coefficients.` |
| `pyscf_pbc_gw_krgw_ac_AC_twopole_diag` | `pyscf.pbc.gw.krgw_ac.AC_twopole_diag` | `pyscf/pbc/gw/krgw_ac.py` | `sigma: numpy.ndarray, omega: numpy.ndarray, orbs: numpy.ndarray, nocc: int` | `Analytic continuation to the real-frequency axis using a two-pole model for orbital self-energies in periodic GW calculations. This function is used in the pyscf.pbc.gw.krgw_ac module to fit a compact two-pole analytic model to orbital-resolved self-energy data sampled on the imaginary (Matsubara) frequency axis. The fitted model parameters can be evaluated on the real axis to obtain a continued self-energy for subsequent spectral analysis, quasiparticle energy estimation, or other post-processing steps in periodic-boundary-condition (PBC) GW workflows.` |
| `pyscf_pbc_gw_kugw_ac_AC_twopole_diag` | `pyscf.pbc.gw.kugw_ac.AC_twopole_diag` | `pyscf/pbc/gw/kugw_ac.py` | `sigma: numpy.ndarray, omega: numpy.ndarray, orbs: numpy.ndarray, nocc: int` | `Analytic continuation to the real frequency axis for orbital-dependent self-energy data using a two-pole model fitted independently for each orbital. This routine is used in the periodic-boundary-condition (PBC) GW code path of PySCF (pyscf.pbc.gw) to convert frequency-dependent self-energy samples (sigma) defined on a discrete frequency grid (omega) into a compact set of fit parameters that parametrize an analytic two-pole approximation per orbital. The fitted parameters are intended for downstream evaluation of the real-axis self-energy or spectral functions in GW calculations and match the parameter vector expected by the two_pole_fit residual function used in the module.` |
| `pyscf_pbc_lib_chkfile_load_cell` | `pyscf.pbc.lib.chkfile.load_cell` | `pyscf/pbc/lib/chkfile.py` | `chkfile: str` | `Load a pyscf.pbc.gto.cell.Cell object from a PySCF checkpoint file produced by scf.chkfile.save_cell. This function reads a checkpoint file (HDF5) containing a serialized representation of a periodic unit cell (Cell) used by PySCF's periodic-boundary-condition (PBC) modules. It restores the Cell object so the unit cell geometry, basis, lattice vectors, and other metadata can be reused to continue calculations (for example, restarting SCF) or to post-process results. The function opens the checkpoint file in read-only mode, attempts to deserialize the saved Cell using pyscf.pbc.gto.loads, and falls back to unpacking a legacy dictionary representation followed by a build call to finalize the Cell. The restored Cell is suitable for immediate use with pyscf.pbc.gto and pyscf.pbc.scf routines assuming compatibility between the file contents and the installed PySCF version.` |
| `pyscf_pbc_lib_kpts_map_k_points_fast` | `pyscf.pbc.lib.kpts.map_k_points_fast` | `pyscf/pbc/lib/kpts.py` | `kpts_scaled: numpy.ndarray, ops: numpy.ndarray, tol: float = 1e-06` | `Find symmetry-related k-points in the Brillouin zone for periodic calculations. This function is used in PySCF's periodic-boundary-condition (PBC) workflows to build a mapping between k-points that are related by a set of point-group rotation operators. It is a performance-oriented wrapper (adapted from GPAW) that reshapes the input k-point array and delegates to the generic tuple-mapping routine with ntuple=1. The mapping is used to identify which k-point in the input grid corresponds to the rotated image of another k-point up to a reciprocal-lattice vector, which is essential when exploiting crystal symmetries to reduce k-point sampling and to transform quantities (for example, Hamiltonian or density matrices) under symmetry operations.` |
| `pyscf_pbc_lib_kpts_check_mo_occ_symmetry` | `pyscf.pbc.lib.kpts.check_mo_occ_symmetry` | `pyscf/pbc/lib/kpts.py` | `kpts: int, mo_occ: list, tol: float = 1e-05` | `Check if molecular orbital (MO) occupation numbers provided for all k-points in the full Brillouin zone (BZ) are consistent with the k-point symmetry (stars) defined in the KPoints object, and return the occupations restricted to the irreducible Brillouin zone (IBZ) if the symmetry check passes. This function is used in periodic-boundary-condition (PBC) electronic structure workflows in PySCF to validate that occupations at symmetry-equivalent k-points are identical within a numerical tolerance before downstream processing (for example, band-structure analysis, total-energy evaluation, or post-Hartree‚ÄìFock treatments). If symmetry is broken according to the provided tolerance, a RuntimeError is raised to signal a likely inconsistent solution (common for KUHF with integer occupations); otherwise a list of MO occupations for the IBZ is returned.` |
| `pyscf_pbc_gw_kugw_ac_AC_pade_thiele_diag` | `pyscf.pbc.gw.kugw_ac.AC_pade_thiele_diag` | `pyscf/pbc/gw/kugw_ac.py` | `sigma: numpy.ndarray, omega: numpy.ndarray` | `AC_pade_thiele_diag performs analytic continuation of frequency-dependent quantities (commonly the GW self-energy) from a Matsubara / complex-frequency grid to the real-frequency axis by constructing a Pade approximant using Thiele's reciprocal difference method (J. Low Temp. Phys. 29, 179 (1977)). This function is used in periodic-boundary-condition GW workflows (pyscf.pbc.gw.kugw_ac) to obtain a compact set of Pade coefficients per orbital that can be evaluated on the real axis to produce spectral information (quasiparticle energies, lifetimes, and spectral functions).` |
| `pyscf_pbc_lib_kpts_make_kpts_ibz` | `pyscf.pbc.lib.kpts.make_kpts_ibz` | `pyscf/pbc/lib/kpts.py` | `kpts: int, tol: float = 1e-06` | `Locate k-points in the irreducible Brillouin zone (IBZ) for periodic electronic-structure calculations and annotate the provided k-point mesh object with symmetry-reduced indexing and related data used throughout PySCF's PBC modules.` |
| `pyscf_pbc_lib_kpts_map_kpts_tuples` | `pyscf.pbc.lib.kpts.map_kpts_tuples` | `pyscf/pbc/lib/kpts.py` | `kpts_scaled: numpy.ndarray, ops: numpy.ndarray, ntuple: int = 2, tol: float = 1e-06` | `Find symmetry-related k-point tuples in the Brillouin zone for periodic boundary condition (PBC) electronic-structure calculations. This function is used in the PySCF periodic boundary-condition k-point infrastructure (pyscf.pbc.lib.kpts) to identify how k-point tuples are mapped onto one another under a set of rotation operators. It is typically used when constructing symmetry-adapted data structures (for example, when assembling integrals or mapping k-point-dependent quantities across the first Brillouin zone) so that operations on k-points account for symmetry and reciprocal-lattice translations.` |
| `pyscf_pbc_lib_kpts_dm_at_ref_cell` | `pyscf.pbc.lib.kpts.dm_at_ref_cell` | `pyscf/pbc/lib/kpts.py` | `kpts: int, dm_ibz: numpy.ndarray` | `pyscf.pbc.lib.kpts.dm_at_ref_cell computes the reference-cell (real-space cell at the origin) one-particle density matrix by transforming density matrices given for k-points in the irreducible Brillouin zone (IBZ) to the full Brillouin zone (BZ) and averaging over all k-points. This function is used in the PySCF periodic-boundary-condition (PBC) code path to obtain the real-space density matrix at the reference cell from k-resolved density matrices (for example, results of mean-field or correlated calculations performed with k-point sampling).` |
| `pyscf_pbc_lib_kpts_make_ktuples_ibz` | `pyscf.pbc.lib.kpts.make_ktuples_ibz` | `pyscf/pbc/lib/kpts.py` | `kpts: int, kpts_scaled: numpy.ndarray = None, ntuple: int = 2, tol: float = 1e-06` | `Construct k-point tuples in the irreducible Brillouin zone (IBZ) for periodic-boundary-condition electronic-structure calculations. This function is used in the PySCF PBC workflow to identify symmetry-unique ntuple combinations of k-points (for example pairs for two-point integrals) and to build mapping tables between the full Brillouin zone (BZ) of k-point tuples and the IBZ. The mappings and "stars" produced by this function are consumed by downstream routines that assemble symmetry-reduced sums over k-point tuples, compute weights for IBZ tuples, and apply point-group and time-reversal symmetry operations during k-point sampling.` |
| `pyscf_pbc_lib_kpts_transform_1e_operator` | `pyscf.pbc.lib.kpts.transform_1e_operator` | `pyscf/pbc/lib/kpts.py` | `kpts: int, fock_ibz: numpy.ndarray` | `pyscf.pbc.lib.kpts.transform_1e_operator Transform a 1-electron operator from the irreducible Brillouin zone (IBZ) representation to the full Brillouin zone (BZ) representation used in periodic electronic-structure calculations.` |
| `pyscf_pbc_lib_kpts_helper_check_kpt_antiperm_symmetry` | `pyscf.pbc.lib.kpts_helper.check_kpt_antiperm_symmetry` | `pyscf/pbc/lib/kpts_helper.py` | `array: numpy.ndarray, idx1: int, idx2: int, tolerance: float = 1e-08` | `pyscf.pbc.lib.kpts_helper.check_kpt_antiperm_symmetry checks antipermutational symmetry of a k-point indexed many-particle array by swapping the k-point and corresponding orbital indices of two particles and testing whether the array is antisymmetric under that swap.` |
| `pyscf_pbc_lib_linalg_helper_diagonalize_asymm` | `pyscf.pbc.lib.linalg_helper.diagonalize_asymm` | `pyscf/pbc/lib/linalg_helper.py` | `H: numpy.ndarray` | `Diagonalize a real, asymmetric matrix and return its eigenvalues and eigenvectors sorted by ascending eigenvalue real part. This helper is used in the PySCF periodic-boundary-condition (pbc) linear-algebra utilities to obtain eigenpairs of non-Hermitian operators that can arise in electronic-structure workflows; it wraps numpy.linalg.eig and provides a deterministic ordering of the output by the real part of the eigenvalues for downstream processing and comparisons.` |
| `pyscf_pbc_lib_kpts_helper_round_to_fbz` | `pyscf.pbc.lib.kpts_helper.round_to_fbz` | `pyscf/pbc/lib/kpts_helper.py` | `kpts: numpy.ndarray, wrap_around: bool = False, tol: float = 1e-06` | `Round scaled k-points to the first Brillouin zone used in PySCF periodic-boundary-condition (PBC) workflows.` |
| `pyscf_pbc_lib_kpts_helper_intersection` | `pyscf.pbc.lib.kpts_helper.intersection` | `pyscf/pbc/lib/kpts_helper.py` | `kpts1: numpy.ndarray, kpts2: numpy.ndarray` | `Return the indices of rows in kpts1 that match any row in kpts2 within the module tolerance KPT_DIFF_TOL. This function is used in the PySCF periodic-boundary-condition (pbc) workflows to identify common k-points between two k-point meshes or sets. In practice, it helps determine which sampling points in reciprocal space (k-points) from kpts1 also appear in kpts2 within a small floating-point tolerance, a common need when aligning k-point meshes for band-structure calculations, integral evaluations, or symmetry-related operations in PySCF.` |
| `pyscf_pbc_lib_kpts_helper_member` | `pyscf.pbc.lib.kpts_helper.member` | `pyscf/pbc/lib/kpts_helper.py` | `kpt: numpy.ndarray, kpts: numpy.ndarray` | `pyscf.pbc.lib.kpts_helper.member: Return the indices of k-points in a collection that coincide with a reference k-point within the module tolerance.` |
| `pyscf_pbc_lib_kpts_get_rotation_mat_for_mos` | `pyscf.pbc.lib.kpts.get_rotation_mat_for_mos` | `pyscf/pbc/lib/kpts.py` | `kpts: int, mo_coeff: numpy.ndarray, ovlp: numpy.ndarray, k1: list, k2: list, ops_id: list = None` | `Rotation matrices for rotating molecular orbitals (MOs) defined at k-points k1 to those at k-points k2 using the space-group symmetry operations available in a PySCF periodic KPoints object.` |
| `pyscf_pbc_lib_kpts_transform_dm` | `pyscf.pbc.lib.kpts.transform_dm` | `pyscf/pbc/lib/kpts.py` | `kpts: int, dm_ibz: numpy.ndarray` | `Transform density matrices from the irreducible Brillouin zone (IBZ) to the full Brillouin zone (BZ). This function is used in PySCF's periodic-boundary-condition (pbc) k-point utilities to expand density matrices computed only on symmetry-unique k-points (IBZ) into the full set of k-points in the BZ, applying the point-group symmetry operations and time-reversal as encoded by the provided KPoints object. The expanded density matrices are required for post-processing steps that assume explicit matrices for every k-point in the full BZ (for example, constructing k-point dependent observables, performing Fourier transforms across the full BZ, or feeding density matrices into integrals/electronic-structure routines that do not exploit IBZ symmetry).` |
| `pyscf_pbc_lib_kpts_helper_unique` | `pyscf.pbc.lib.kpts_helper.unique` | `pyscf/pbc/lib/kpts_helper.py` | `kpts: numpy.ndarray` | `pyscf.pbc.lib.kpts_helper.unique finds and returns the unique k-points from a list of k-point vectors used in periodic-boundary-condition (PBC) electronic-structure calculations. It is used in PySCF PBC workflows to identify redundant sampling points in the Brillouin zone (for example, when reducing k-point grids by symmetry or eliminating duplicate k-points produced by mesh generation). The function identifies unique rows of the input array within a numerical tolerance controlled by the global KPT_DIFF_TOL: when modern numpy is available it rounds coordinates to a precision derived from KPT_DIFF_TOL and uses numpy.unique on rows; for older numpy it compares rows by absolute difference with KPT_DIFF_TOL.` |
| `pyscf_pbc_lib_kpts_transform_mo_coeff_k` | `pyscf.pbc.lib.kpts.transform_mo_coeff_k` | `pyscf/pbc/lib/kpts.py` | `kpts: int, mo_coeff_ibz: numpy.ndarray, k: int` | `Get MO coefficients for a single k-point in the full Brillouin zone (BZ). This function is used in the PySCF periodic-boundary-conditions (pbc) k-point handling code to produce molecular-orbital (MO) coefficient matrices for a specified k-point index in the full BZ by mapping from MO coefficients provided for k-points in the irreducible Brillouin zone (IBZ). It examines the k-point bookkeeping stored in the provided KPoints object (mapping from full BZ to IBZ, symmetry operations, and time-reversal flags), applies the appropriate spatial symmetry operation using pyscf.pbc.lib.symm.transform_mo_coeff when required, and applies complex conjugation if the k-point is related to its IBZ representative by time-reversal symmetry. The returned array is suitable for subsequent band-structure, density, or post-HF/post-DFT operations that expect MO coefficients defined on the full BZ.` |
| `pyscf_pbc_scf_khf_get_grad` | `pyscf.pbc.scf.khf.get_grad` | `pyscf/pbc/scf/khf.py` | `mo_coeff_kpts: list, mo_occ_kpts: list, fock: list` | `Compute and return the concatenated one-dimensional orbital gradient for K-point Hartree‚ÄìFock (khf) calculations in the PySCF periodic-boundary-condition (pbc) framework. This function is used in periodic electronic-structure workflows to obtain the orbital-gradient vector needed for orbital optimization or response procedures; it delegates the per-k-point gradient computation to the molecular (non K-point) gradient routine (mol_hf.get_grad) and then concatenates the per-k-point gradients into a single 1D array so downstream optimizers or property evaluators can operate on a unified gradient vector.` |
| `pyscf_pbc_lib_kpts_transform_mo_coeff` | `pyscf.pbc.lib.kpts.transform_mo_coeff` | `pyscf/pbc/lib/kpts.py` | `kpts: int, mo_coeff_ibz: numpy.ndarray` | `pyscf.pbc.lib.kpts.transform_mo_coeff transforms molecular-orbital (MO) coefficient arrays defined for k-points in the irreducible Brillouin zone (IBZ) into MO coefficient arrays defined for the full Brillouin zone (BZ). This function is used in periodic-boundary-condition (PBC) electronic-structure workflows in PySCF to expand IBZ results (which exploit crystal symmetries to reduce computational effort) back to the full set of k-points needed for band-structure analysis, density reconstruction, and other post-processing that requires coefficients on every BZ k-point.` |
| `pyscf_pbc_scf_khf_make_rdm1` | `pyscf.pbc.scf.khf.make_rdm1` | `pyscf/pbc/scf/khf.py` | `mo_coeff_kpts: list, mo_occ_kpts: list, **kwargs` | `One-particle density matrices for all k-points in a periodic Hartree‚ÄìFock (k-point HF) calculation. This function constructs the atomic-orbital (AO) representation of the one-particle reduced density matrix (RDM-1) for each k-point by calling the molecular HF helper mol_hf.make_rdm1 for every k-point. In the context of PySCF's periodic electronic-structure calculations (pbc.scf.khf), these per-k-point density matrices are the fundamental objects used to evaluate electron density, expectation values of one-electron operators, and contributions to the Fock matrix across the Brillouin zone. The returned array is tagged with the input molecular-orbital coefficients and occupations so downstream routines can access that metadata without separate bookkeeping.` |
| `pyscf_pbc_scf_krohf_get_roothaan_fock` | `pyscf.pbc.scf.krohf.get_roothaan_fock` | `pyscf/pbc/scf/krohf.py` | `focka_fockb: tuple, dma_dmb: tuple, s: list` | `Compute the Roothaan effective Fock matrices for restricted open-shell Hartree‚ÄìFock (KROHF) in periodic boundary conditions (PBC) using per-k-point Fock and density matrices. This function implements the Roothaan prescription used in pyscf.pbc.scf.krohf to build an effective, Hermitian Fock operator from separate alpha (Fa) and beta (Fb) Fock matrices and the corresponding alpha (dma) and beta (dmb) one-particle density matrices for each k-point. The Roothaan effective Fock mixes Fa and Fb according to orbital occupation spaces: closed-shell orbitals use Fc = (Fa + Fb)/2, open-shell orbitals couple Fa and Fb through cross terms, and virtual orbitals use Fc again. Concretely, for each k-point the function forms three projectors on closed, open, and virtual subspaces using the input density matrices and the overlap matrix s[k]: pc = dmb[k] @ s[k] (closed-space projector), po = (dma[k] - dmb[k]) @ s[k] (open-space projector), pv = I - dma[k] @ s[k] (virtual-space projector), where I is the nao-by-nao identity and nao is the number of atomic orbitals inferred from s[0]. The effective Fock for each k-point is assembled from projected contributions of Fc and cross terms with Fa and Fb, and then Hermitianized by adding its conjugate transpose. The function returns one effective Fock matrix per k-point and tags the returned array with the original focka and fockb inputs (via lib.tag_array) so downstream code in the KROHF driver can access the source spin components. Behavior and side effects: - The number of k-points is determined as nkpts = len(s). The function expects focka_fockb and dma_dmb to contain per-k-point entries with the same nkpts; mismatched lengths or nonconformant matrix shapes will cause NumPy errors (IndexError, ValueError, or TypeError) during matrix operations. - Inputs are not modified in-place by this function; the result is a new array produced by np.asarray and wrapped with lib.tag_array, which attaches attributes .focka and .fockb referencing the input spin Fock sequences. - The function assumes each overlap matrix s[k] and each density/Fock matrix is a square matrix with the same dimension nao (nao = s[0].shape[0]); if s[0] is not square or the matrices do not conform, NumPy will raise an exception during the dot products. - The output matrices are Hermitian within numerical precision because the function explicitly adds the conjugate transpose of each assembled matrix. - No implicit units or scaling are applied; matrices are used as provided by the calling KROHF code. The function is intended to be called from the periodic KROHF SCF driver in PySCF and follows the Roothaan effective-Fock conventions used there.` |
| `pyscf_pbc_symm_space_group_transform_trans` | `pyscf.pbc.symm.space_group.transform_trans` | `pyscf/pbc/symm/space_group.py` | `op: numpy.ndarray, a: numpy.ndarray, b: numpy.ndarray` | `pyscf.pbc.symm.space_group.transform_trans transforms a translation operator given in one lattice-basis representation into the equivalent translation operator expressed in another lattice-basis representation used in periodic boundary-condition symmetry operations in PySCF.` |
| `pyscf_pbc_symm_symmetry_get_Dmat` | `pyscf.pbc.symm.symmetry.get_Dmat` | `pyscf/pbc/symm/symmetry.py` | `op: numpy.ndarray, l: int` | `pyscf.pbc.symm.symmetry.get_Dmat computes the Wigner D-matrix for a given 3√ó3 rotation operator and an angular momentum quantum number l. This D-matrix is the matrix representation of the rotation in the angular-momentum-l irreducible representation and is used in PySCF periodic-boundary-condition (PBC) symmetry routines to construct symmetry-adapted representations of rotational operations in electronic structure calculations.` |
| `pyscf_pbc_scf_kuhf_make_rdm1` | `pyscf.pbc.scf.kuhf.make_rdm1` | `pyscf/pbc/scf/kuhf.py` | `mo_coeff_kpts: list, mo_occ_kpts: list, **kwargs` | `Alpha and beta spin one-particle reduced density matrices (RDM1) for all k-points in a periodic unrestricted Kohn‚ÄìSham / Hartree‚ÄìFock calculation. This function is used in the pyscf.pbc.scf.kuhf module to construct the spin-resolved RDM1 in the atomic-orbital (AO) basis from molecular-orbital (MO) coefficients and MO occupation numbers for each k-point. The returned array is tagged with the input MO coefficients and occupations for downstream use in PySCF routines that expect these metadata (for example, computing electron density or expectation values over k-points).` |
| `pyscf_pbc_symm_space_group_transform_rot` | `pyscf.pbc.symm.space_group.transform_rot` | `pyscf/pbc/symm/space_group.py` | `op: numpy.ndarray, a: numpy.ndarray, b: numpy.ndarray, allow_non_integer: bool = False` | `pyscf.pbc.symm.space_group.transform_rot transforms a 3x3 rotation operator expressed in one lattice basis (a) into the equivalent rotation operator expressed in another lattice basis (b). This function is used inside the PySCF periodic-boundary-condition (pbc) symmetry utilities to convert point-group rotation operators when changing crystallographic coordinate systems or lattice basis representations, ensuring consistency of space-group symmetry operations across different basis choices.` |
| `pyscf_pbc_scf_krohf_make_rdm1` | `pyscf.pbc.scf.krohf.make_rdm1` | `pyscf/pbc/scf/krohf.py` | `mo_coeff_kpts: list, mo_occ_kpts: list, **kwargs` | `pyscf.pbc.scf.krohf.make_rdm1 builds the alpha and beta one-particle reduced density matrices (1-RDMs) for all k-points used in periodic (k-point) restricted open-shell Hartree-Fock calculations in the PySCF pbc.scf.krohf module. The function constructs spin-resolved 1-RDMs by selecting occupied molecular orbital (MO) columns from provided MO coefficient arrays according to the occupancy pattern and forming dma = C_a C_a^‚Ä† and dmb = C_b C_b^‚Ä† for each k-point. This is used in PySCF workflows to obtain per-k-point density matrices for energy evaluation, density-dependent property computations, and subsequent post-SCF analyses in periodic electronic structure calculations.` |
| `pyscf_pbc_tools_k2gamma_translation_map` | `pyscf.pbc.tools.k2gamma.translation_map` | `pyscf/pbc/tools/k2gamma.py` | `nk: int` | `pyscf.pbc.tools.k2gamma.translation_map generates a periodic translation index map used in PySCF periodic-boundary-condition (PBC) k-point utilities to map ordered pairs of k-point indices to a single k-point index according to modular subtraction. In the context of PySCF PBC k-point algorithms (see pyscf.pbc.tools.k2gamma), this mapping is used to find the relative k-point index associated with the difference between two k-points, which is necessary for enforcing momentum conservation and assembling k-point dependent integrals and tensors without explicit Python loops.` |
| `pyscf_pbc_tools_lattice_get_ase_diamond_cubic` | `pyscf.pbc.tools.lattice.get_ase_diamond_cubic` | `pyscf/pbc/tools/lattice.py` | `atom: str = "C"` | `Get the ASE atoms for a cubic (8-atom) diamond unit cell. This function constructs and returns an ASE Atoms object representing the conventional cubic diamond unit cell containing 8 atoms. It is intended for use in periodic-boundary-condition (PBC) workflows within the PySCF pbc.tools utilities where a standard diamond cubic unit cell (carbon or silicon) is required as an input geometry for electronic-structure calculations. The function builds the cell by instantiating ase.lattice.cubic.Diamond with the chemical symbol and a lattice constant expressed in Bohr (the source code multiplies the tabulated lattice constant in Angstrom by A2B). The returned ASE Atoms instance can be passed directly to ASE-based tooling or converted as needed for PySCF PBC cell construction and integrals.` |
| `pyscf_pbc_tools_lattice_get_ase_graphene` | `pyscf.pbc.tools.lattice.get_ase_graphene` | `pyscf/pbc/tools/lattice.py` | `vacuum: float = 5.0` | `Get the ASE atoms for the primitive (2-atom) graphene unit cell. This function constructs and returns an ASE Atoms object describing the primitive two-atom graphene unit cell (carbon atoms only) suitable for use with PySCF periodic-boundary-condition (pbc) workflows (for example, building a pyscf.pbc.Cell from an ASE Atoms object). The in-plane lattice constant 'a' is set to 2.46 (physical lattice constant for graphene) and the out-of-plane lattice constant 'c' is set from the vacuum parameter. Both lattice constants in the implementation are scaled by the module-level conversion factor A2B (the code multiplies values by A2B before passing to ASE), so the supplied vacuum value is interpreted as an Angstrom value and converted internally to Bohr for the ASE lattice constructor.` |
| `pyscf_pbc_tools_pbc_cutoff_to_gs` | `pyscf.pbc.tools.pbc.cutoff_to_gs` | `pyscf/pbc/tools/pbc.py` | `a: numpy.ndarray, cutoff: float` | `pyscf.pbc.tools.pbc.cutoff_to_gs ‚Äî Deprecated helper that maps a plane-wave kinetic-energy cutoff to half-sized integer mesh counts for periodic-boundary-condition (PBC) plane-wave/FFT routines. This function is retained for backward compatibility and is replaced by cutoff_to_mesh, which returns the full mesh sizes; cutoff_to_gs returns the integer half of each mesh component produced by cutoff_to_mesh.` |
| `pyscf_pbc_tools_pbc_gs_to_cutoff` | `pyscf.pbc.tools.pbc.gs_to_cutoff` | `pyscf/pbc/tools/pbc.py` | `a: numpy.ndarray, gs: list` | `pyscf.pbc.tools.pbc.gs_to_cutoff converts a grid-size specification given by gs into a mesh acceptable to mesh_to_cutoff and returns the corresponding plane-wave cutoff value for periodic boundary condition (PBC) calculations in PySCF. This function is deprecated and kept for backward compatibility; callers should use mesh_to_cutoff directly. In the context of PySCF, this function helps translate a coarse integer grid specification into the odd-valued mesh format expected by mesh_to_cutoff so the lattice vectors a (real-space cell) can be used to compute an equivalent plane-wave cutoff used by PBC electronic-structure routines.` |
| `pyscf_pbc_tools_k2gamma_double_translation_indices` | `pyscf.pbc.tools.k2gamma.double_translation_indices` | `pyscf/pbc/tools/k2gamma.py` | `kmesh: tuple` | `Compute an index array that maps k-point pair subscripts (two-dimensional indices for a matrix indexed by k-point labels) to one-dimensional indices that exploit translation symmetry in periodic boundary condition (PBC) calculations. In the PySCF PBC context, many two-index quantities D[M,N] depend only on the relative translation between k-points (for example the symmetry D[M,N] = D[N-M] noted in the original implementation). This function builds the integer index array that allows reconstructing the full 2D matrix from a compact 1D array of symmetry-unique translation values. The function uses translation_map for each Cartesian reciprocal-lattice direction (kx, ky, kz) to obtain a representative index per k-point under translation symmetry, then combines those representatives with numpy.ravel_multi_index to produce a single flat index for each ordered pair (M, N). The resulting index array is suitable for indexing a 1D array D1 of symmetry-unique translation-dependent values to produce the full 2D matrix D2 via D2 = D1[double_translation_indices(kmesh)].` |
| `pyscf_pbc_tools_pbc_fftk` | `pyscf.pbc.tools.pbc.fftk` | `pyscf/pbc/tools/pbc.py` | `f: numpy.ndarray, mesh: tuple, expmikr: numpy.ndarray` | `pyscf.pbc.tools.pbc.fftk computes the 3D discrete Fourier transform (FFT) of a real-space function defined on a periodic lattice after multiplying by a k-dependent phase factor. This routine is used in PySCF periodic-boundary-condition (PBC) workflows to obtain reciprocal-space coefficients fk(k+G) for a given k-point: fk(k+G) = sum_r fk(r) e^{-i(k+G)r} = sum_r [f(r) e^{-i k r}] e^{-i G r}. In practice, fftk multiplies the input real-space array f by the provided precomputed phase array expmikr and then calls the underlying fft routine with the specified FFT grid mesh to return the reciprocal-space representation used in k-point and G-vector operations (for example, evaluating plane-wave components of periodic functions, integrals, or potentials in PBC electronic-structure calculations).` |
| `pyscf_pbc_tools_lattice_get_ase_graphene_xxx` | `pyscf.pbc.tools.lattice.get_ase_graphene_xxx` | `pyscf/pbc/tools/lattice.py` | `vacuum: float = 5.0` | `pyscf.pbc.tools.lattice.get_ase_graphene_xxx: Create and return an ASE Atoms object representing the primitive (2-atom) graphene unit cell configured for use in PySCF periodic-boundary-condition workflows.` |
| `pyscf_pbc_tools_pbc_fft` | `pyscf.pbc.tools.pbc.fft` | `pyscf/pbc/tools/pbc.py` | `f: numpy.ndarray, mesh: numpy.ndarray` | `Perform the 3D FFT from real-space (R) grid to reciprocal-space (G) grid for periodic-boundary calculations in the pyscf.pbc.tools.pbc module. This function is used in the periodic (PBC) plane-wave / grid-based parts of PySCF to transform a real-space quantity sampled on a uniform 3D grid (for example a charge density or a component of a potential) into its representation on reciprocal lattice G-vectors. The output ordering of reciprocal-space indices follows the natural order used by numpy.fft and the Gv ordering produced by cartesian_prod. The FFT normalization factor is 1.0, consistent with the MH convention used elsewhere in PySCF and numpy.fft.` |
| `pyscf_pbc_tools_pbc_cutoff_to_mesh` | `pyscf.pbc.tools.pbc.cutoff_to_mesh` | `pyscf/pbc/tools/pbc.py` | `a: numpy.ndarray, cutoff: float` | `Convert kinetic-energy (KE) cutoff to a minimal FFT mesh suitable for periodic (boundary) plane-wave / FFT operations in PySCF. This function is used in PySCF's periodic-boundary-condition (PBC) tools to choose the number of grid points along each lattice direction so that plane-wave reciprocal vectors with kinetic energy up to the given cutoff are representable on the uniform FFT grid. The conversion assumes the kinetic energy KE = \|k\|^2/2 (atomic units) and the empirical relation between maximum wavevector and grid spacing (k_max ~ pi / grid_spacing). The routine computes the reciprocal lattice b = 2*pi * inv(a.T), determines the effective reciprocal-axis lengths via QR decompositions, calculates the required maximum reciprocal index Gmax = sqrt(2*cutoff)/\|r\| for each lattice direction, and returns an odd integer mesh mesh = ceil(Gmax)*2 + 1 to ensure symmetric sampling of positive and negative reciprocal vectors.` |
| `pyscf_pbc_tools_lattice_get_ase_diamond_primitive` | `pyscf.pbc.tools.lattice.get_ase_diamond_primitive` | `pyscf/pbc/tools/lattice.py` | `atom: str = "C"` | `pyscf.pbc.tools.lattice.get_ase_diamond_primitive: Construct and return an ASE Atoms object representing the primitive (2-atom) diamond unit cell for a specified elemental diamond crystal. This helper is used in the PySCF periodic-boundary-condition workflow to obtain a canonical primitive cell for diamond-structure materials which can then be used to build periodic lattices, run band-structure or plane-wave related tests, or convert between PySCF and ASE representations.` |
| `pyscf_pbc_tools_pbc_ifftk` | `pyscf.pbc.tools.pbc.ifftk` | `pyscf/pbc/tools/pbc.py` | `g: numpy.ndarray, mesh: tuple, expikr: numpy.ndarray` | `pyscf.pbc.tools.pbc.ifftk: Transform plane-wave Fourier coefficients f(k+G) into the real-space Bloch-like function fk(r) = (1/Ng) ‚àë_G f(k+G) e^{i(k+G)¬∑r} by computing the inverse FFT over reciprocal vectors G and multiplying by the phase factor e^{i k¬∑r}. Performs the 3D inverse fast Fourier transform (IFFT) of a set of plane-wave coefficients provided in g on an FFT grid specified by mesh, and then multiplies the IFFT result by the k-dependent phase factor expikr to produce the physical real-space function fk(r) that is periodic in the cell up to the e^{i k¬∑r} Bloch phase. This routine is used in the PySCF periodic-boundary-condition (PBC) tools to reconstruct k-point dependent real-space quantities (for example, density components or orbital values) from their plane-wave (k+G) representations when performing electronic-structure calculations in crystals.` |
| `pyscf_pbc_tools_pbc_ifft` | `pyscf.pbc.tools.pbc.ifft` | `pyscf/pbc/tools/pbc.py` | `g: numpy.ndarray, mesh: numpy.ndarray` | `Perform the 3D inverse FFT from reciprocal-space (G) to real-space (R) for periodic-boundary-condition (PBC) calculations. This function is used in the pyscf.pbc.tools.pbc module to convert data defined on G-vectors (reciprocal lattice vectors) to values on a real-space grid. In practical electronic-structure workflows within PySCF for periodic systems (crystals), the output can represent quantities such as electron density or potentials sampled on a uniform real-space grid. The inverse FFT uses the same normalization convention as numpy.fft (a factor of 1./N), which differs from some other conventions (for example, MH which uses a factor of 1.), and therefore affects amplitude scaling and Parseval-related properties of transformed quantities.` |
| `pyscf_pbc_tools_pbc_mesh_to_cutoff` | `pyscf.pbc.tools.pbc.mesh_to_cutoff` | `pyscf/pbc/tools/pbc.py` | `a: numpy.ndarray, mesh: tuple` | `pyscf.pbc.tools.pbc.mesh_to_cutoff converts a real-space grid mesh (number of grid points along each periodic lattice vector) into an approximate kinetic-energy (KE) cutoff for each spatial direction used in plane-wave / reciprocal-space treatments within PySCF's periodic-boundary-condition (PBC) tools. The function is used in PBC workflows to map a discrete mesh specification (mesh) into the maximum reciprocal-space G-vector magnitude per direction and then to the corresponding KE cutoff via ke = \|Gmax\|^2 / 2, enabling consistent selection of plane-wave or G-vector truncation thresholds from a simple mesh description.` |
| `pyscf_pbc_tools_pbc_round_to_cell0` | `pyscf.pbc.tools.pbc.round_to_cell0` | `pyscf/pbc/tools/pbc.py` | `r: numpy.ndarray, tol: float = 1e-06` | `pyscf.pbc.tools.pbc.round_to_cell0 rounds scaled (fractional) coordinates to a reference unit cell used in periodic-boundary-condition (PBC) calculations. This function is part of the PySCF PBC tools and is used to map coordinate values expressed in unit-cell (scaled/fractional) coordinates into a canonical reference cell by delegating to pyscf.pbc.lib.kpts_helper.round_to_fbz with wrap_around=False and the specified tolerance.` |
| `pyscf_scf_addons_canonical_orth_` | `pyscf.scf.addons.canonical_orth_` | `pyscf/scf/addons.py` | `S: numpy.ndarray, thr: float = 1e-07` | `pyscf.scf.addons.canonical_orth_: Compute L√∂wdin's canonical (symmetric) orthogonalization matrix for an atomic-orbital overlap matrix.` |
| `pyscf_scf_addons_partial_cholesky_orth_` | `pyscf.scf.addons.partial_cholesky_orth_` | `pyscf/scf/addons.py` | `S: numpy.ndarray, canthr: float = 1e-07, cholthr: float = 1e-09` | `Partial Cholesky orthogonalization for curing basis-set overcompleteness in atomic-orbital (AO) representations used in PySCF SCF workflows. This routine implements the procedure described by S. Lehtola to identify a numerically robust subset of AO basis functions via a pivoted Cholesky decomposition of a normalized overlap matrix and to orthogonalize that retained sub-basis using canonical orthogonalization. The resulting transformation is intended for use in self-consistent field (SCF) and related electronic-structure calculations where near-linear dependencies (overcompleteness) of the AO basis degrade numerical stability.` |
| `pyscf_qmmm_pbc_mm_mole_create_mm_cell` | `pyscf.qmmm.pbc.mm_mole.create_mm_cell` | `pyscf/qmmm/pbc/mm_mole.py` | `atoms_or_coords: numpy.ndarray, a: numpy.ndarray, charges: numpy.ndarray = None, radii: numpy.ndarray = None, rcut_ewald: float = None, rcut_hcore: float = None, unit: str = "Angstrom"` | `Create an MM Cell object for periodic QM/MM simulations (pyscf.qmmm.pbc.mm_mole.create_mm_cell). This factory function builds and returns a pyscf Cell configured to represent classical molecular-mechanics (MM) particles placed in a periodic lattice. It converts input coordinates and optional per-particle properties (charges, Gaussian radii) into the internal representations required by PySCF periodic modules, applies unit conversion to atomic units when needed, and forwards MM-related options (Ewald and hcore cutoffs) to the returned Cell. In the PySCF domain, this Cell is used to supply external classical charge distributions and cutoff parameters for periodic electrostatics and QM/MM coupling (e.g., Ewald summation and one-electron integrals in periodic boundary conditions).` |
| `pyscf_qmmm_mm_mole_create_mm_mol` | `pyscf.qmmm.mm_mole.create_mm_mol` | `pyscf/qmmm/mm_mole.py` | `atoms_or_coords: numpy.ndarray, charges: numpy.ndarray = None, radii: numpy.ndarray = None, unit: str = "Angstrom"` | `Create an MM (molecular mechanics) Mole object from coordinates and optional charges/radii for use in QM/MM simulations in PySCF. This function is used by the qmmm module to build a lightweight representation of the classical (MM) region: it accepts either raw Cartesian coordinates or a preformatted atom specification, normalizes the atom entries via gto.format_atom, converts Gaussian radii into the internal zeta parameter (1 / radius^2) in atomic units when provided, and returns a pyscf.gto.mole.Mole object that carries the MM atoms, their partial charges, and Gaussian width parameters for electrostatic embedding or other QM/MM interactions.` |
| `pyscf_scf_dhf_get_grad` | `pyscf.scf.dhf.get_grad` | `pyscf/scf/dhf.py` | `mo_coeff: numpy.ndarray, mo_occ: numpy.ndarray, fock_ao: numpy.ndarray` | `DHF gradients: compute the virtual-occupied block of the Dirac‚ÄìHartree‚ÄìFock (DHF) Fock operator in the molecular orbital basis and return it flattened.` |
| `pyscf_scf_ghf_guess_orbspin` | `pyscf.scf.ghf.guess_orbspin` | `pyscf/scf/ghf.py` | `mo_coeff: numpy.ndarray` | `pyscf.scf.ghf.guess_orbspin: Guess orbital spin assignments for generalized Hartree‚ÄëFock (GHF) orbital coefficients. Guesses whether each molecular orbital is spin-up (alpha, encoded 0), spin-down (beta, encoded 1), or undetermined (encoded -1) by inspecting the orbital coefficient blocks for alpha and beta atomic orbitals (AOs). This function is used in the PySCF GHF code path to provide an initial, per-orbital spin classification when orbitals are represented in a spin-blocked AO basis. The result informs downstream logic that needs to know which orbitals are effectively pure-alpha, pure-beta, or mixed/ambiguous (for example, when building occupation patterns or performing spin-resolved analyses).` |
| `pyscf_scf_addons_get_ghf_orbspin` | `pyscf.scf.addons.get_ghf_orbspin` | `pyscf/scf/addons.py` | `mo_energy: numpy.ndarray, mo_occ: numpy.ndarray, is_rhf: bool = None` | `Get the spin label for each generalized Hartree‚ÄìFock (GHF) spin-orbital produced when converting closed-shell RHF or spin-unrestricted UHF molecular orbitals into a GHF spin-orbital ordering. This helper is used in PySCF workflows that expand spatial molecular orbitals into spin-orbitals (two spin states per spatial orbital) and need a deterministic mapping from the original RHF/UHF occupation and energy information to a per-GHF-orbital spin label. Behavior summary: For RHF input the function interprets a single spatial orbital energy array and a single occupancy array and constructs an ordering that places occupied GHF spin-orbitals before virtual ones, breaking degeneracies and open-shell ordering according to the RHF convention used in PySCF (doubly occupied spatial orbitals produce alpha then beta spin-orbitals, open-shell singly occupied orbitals produce a final alpha spin-orbital in the occupied block, etc.). For UHF input the function treats separate alpha and beta energy/occupation arrays, sorts occupied and virtual orbitals by their energies (using rounding to 6 decimal places and a stable sort to avoid spurious reordering from numerical noise), and returns a combined sequence of alpha/beta labels that matches the energy-based ordering. The returned array is intended to accompany a 2*nmo-length GHF coefficient matrix that arises from expanding nmo spatial orbitals into spin-orbitals.` |
| `pyscf_scf_ghf_det_ovlp` | `pyscf.scf.ghf.det_ovlp` | `pyscf/scf/ghf.py` | `mo1: numpy.ndarray, mo2: numpy.ndarray, occ1: numpy.ndarray, occ2: numpy.ndarray, ovlp: numpy.ndarray` | `pyscf.scf.ghf.det_ovlp: Compute the overlap between two different Slater determinants represented by molecular orbital (MO) coefficient arrays and produce a matrix used to build an asymmetric density matrix in generalized Hartree‚ÄìFock (GHF) calculations. This function is used in PySCF to evaluate the scalar overlap (product of singular values) of the occupied-MO subspace of one determinant with that of another, and to return the U Lambda^{-1} V^H factor needed when forming asymmetric transition or coupling density matrices.` |
| `pyscf_scf_hf_Kgwh` | `pyscf.scf.hf.Kgwh` | `pyscf/scf/hf.py` | `Ei: float, Ej: float, updated_rule: bool = False` | `pyscf.scf.hf.Kgwh computes the generalized Wolfsberg‚ÄìHelmholtz (GWH) parameter used to scale off-diagonal Hamiltonian or resonance integrals in semiempirical and extended-H√ºckel-like approximations within the PySCF chemistry framework. This function returns a scalar floating-point parameter k_GWH derived from two input orbital-energy-like scalars Ei and Ej. The returned parameter is typically used when constructing approximate one-electron coupling (resonance) matrix elements between basis functions or atomic orbitals in semiempirical modules and HF/SCF-oriented helper code inside PySCF. By default the function returns a fixed baseline GWH value (k = 1.75) consistent with common practice; when updated_rule is set to True, it applies the modified scheme from J. Am. Chem. Soc. 100, 3686 (1978); doi:10.1021/ja00480a005, which makes the GWH parameter depend on the relative difference of Ei and Ej through a polynomial in Delta = (Ei - Ej)/(Ei + Ej).` |
| `pyscf_scf_diis_get_err_vec_orth` | `pyscf.scf.diis.get_err_vec_orth` | `pyscf/scf/diis.py` | `s: numpy.ndarray, d: numpy.ndarray, f: numpy.ndarray, Corth: numpy.ndarray` | `Compute the SCF DIIS error vector in an orthonormal molecular-orbital basis.` |
| `pyscf_scf_hf_eig` | `pyscf.scf.hf.eig` | `pyscf/scf/hf.py` | `h: numpy.ndarray, s: numpy.ndarray` | `pyscf.scf.hf.eig solves the generalized Hermitian eigenvalue problem HC = S C E used in Hartree‚ÄìFock / Roothaan-style electronic-structure calculations, where H is the one-electron (core or Fock) matrix in an atomic-orbital (AO) basis, S is the AO overlap matrix, C contains eigenvectors (molecular-orbital coefficients) as columns, and E is the diagonal matrix of eigenvalues. This function delegates the linear-algebra work to scipy.linalg.eigh and then enforces a deterministic sign convention on the returned eigenvectors to improve reproducibility in downstream PySCF workflows.` |
| `pyscf_scf_hf_dot_eri_dm` | `pyscf.scf.hf.dot_eri_dm` | `pyscf/scf/hf.py` | `eri: numpy.ndarray, dm: numpy.ndarray, hermi: int = 0, with_j: bool = True, with_k: bool = True` | `Compute Coulomb (J) and exchange (K) matrices from two-electron integrals and density matrix(es) for use in Hartree‚ÄìFock and related SCF procedures. This function is used in the PySCF SCF machinery to build the two-electron contribution to the Fock matrix: the Coulomb matrix J and the exchange matrix K. It accepts either a full 4-index eri array (reshaped to (N,N,N,N)) or an 8-fold compressed ERI representation handled by the internal _vhf.incore routine. The density matrix input may be a single density matrix or a stack/list of density matrices; the function returns J and K with matching layout and dtype to the input and computed integrals.` |
| `pyscf_scf_hf_unpack_uniq_var` | `pyscf.scf.hf.unpack_uniq_var` | `pyscf/scf/hf.py` | `dx: numpy.ndarray, mo_occ: numpy.ndarray` | `unpack_uniq_var fills the full orbital-gradients (orbital-rotation) matrix from a compact vector of unique variables used in self-consistent field (SCF) orbital optimization routines in the PySCF quantum chemistry framework.` |
| `pyscf_scf_hf_pack_uniq_var` | `pyscf.scf.hf.pack_uniq_var` | `pyscf/scf/hf.py` | `x: numpy.ndarray, mo_occ: numpy.ndarray` | `pyscf.scf.hf.pack_uniq_var extracts the independent (unique) variables from a full orbital-gradient or orbital-rotation array used in Hartree‚ÄìFock / self-consistent-field (SCF) orbital optimization. This function is used in PySCF's SCF/HF modules to reduce the number of parameters passed to optimizers or response routines by selecting only the non-redundant elements of an orbital-gradient or orbital-rotation representation. The selection of which elements are considered "unique" is determined from the molecular orbital occupation pattern (mo_occ) via the helper function uniq_var_indices(mo_occ). In practical computational-chemistry workflows, this reduction removes redundant rotations (for example, rotations that are symmetry- or occupation-related) so that downstream algorithms operate on the minimal set of independent orbital-rotation variables, improving efficiency and stability.` |
| `pyscf_scf_hf_uniq_var_indices` | `pyscf.scf.hf.uniq_var_indices` | `pyscf/scf/hf.py` | `mo_occ: numpy.ndarray` | `uniq_var_indices returns a boolean mask selecting the unique orbital-rotation variables (occupied‚Üívirtual rotations) used when forming orbital-gradients in the SCF code. This function is used in PySCF's self-consistent field (SCF) procedures to identify which matrix elements of the orbital-rotation (gradient) matrix correspond to independent rotation parameters for alpha and beta spin manifolds. In practical electronic-structure work within PySCF, the mask produced by this function is used to assemble and compress gradient and Hessian blocks by keeping only the unique occupied‚Üívirtual rotational degrees of freedom.` |
| `pyscf_scf_hf_get_grad` | `pyscf.scf.hf.get_grad` | `pyscf/scf/hf.py` | `mo_coeff: numpy.ndarray, mo_occ: numpy.ndarray, fock_ao: numpy.ndarray` | `Compute the restricted Hartree‚ÄìFock (RHF) orbital gradient vector in the molecular orbital (MO) basis for use in PySCF electronic structure routines. This function is part of the PySCF (Python-based Simulations of Chemistry Framework) toolset and is used to form the occupied‚Äìvirtual block of the Fock matrix in the MO representation for closed-shell RHF calculations. The output is commonly used by SCF response, orbital-rotation, and post-Hartree‚ÄìFock procedures that require the coupling between occupied and virtual spatial orbitals.` |
| `pyscf_scf_hf_level_shift` | `pyscf.scf.hf.level_shift` | `pyscf/scf/hf.py` | `s: numpy.ndarray, d: numpy.ndarray, f: numpy.ndarray, factor: float` | `pyscf.scf.hf.level_shift applies an energy level shift to virtual molecular orbitals in Hartree‚ÄìFock self-consistent-field (SCF) procedures to improve convergence by increasing the Fock matrix diagonal elements associated with virtual space. This routine constructs an operator that projects onto the virtual-space block in the atomic-orbital (AO) representation and adds a uniform energy offset Delta (the level shift) to that virtual-space block of the Fock matrix. In PySCF workflows this is used when performing SCF iterations to discourage occupation of virtual orbitals and to stabilize convergence in difficult cases (e.g., near-degeneracies or variational collapse). The implementation follows the algebraic form F_new = F + (S - S D S) * Delta, where S is the AO overlap matrix, D is the AO density matrix (occupied-space projector), and F is the current AO Fock matrix.` |
| `pyscf_scf_hf_make_rdm1` | `pyscf.scf.hf.make_rdm1` | `pyscf/scf/hf.py` | `mo_coeff: numpy.ndarray, mo_occ: numpy.ndarray, **kwargs` | `Construct the one-particle reduced density matrix (RDM1) in the atomic-orbital (AO) representation from molecular orbital coefficients and orbital occupancies. This function is used in PySCF SCF/Hartree‚ÄìFock workflows to obtain the AO-basis electron density matrix gamma = sum_i n_i \|phi_i><phi_i\|, which is consumed by energy and property evaluators elsewhere in the package.` |
| `pyscf_scf_ghf_spin_square` | `pyscf.scf.ghf.spin_square` | `pyscf/scf/ghf.py` | `mo: list, s: numpy.ndarray = 1` | `pyscf.scf.ghf.spin_square computes the expectation value of the total spin-squared operator S^2 and the corresponding spin multiplicity (2S+1) for a Generalized Hartree‚ÄìFock (GHF) / unrestricted HF (UHF) wavefunction described by occupied molecular orbitals. This function is used in PySCF to quantify the spin and spin-contamination of an electronic mean-field wavefunction constructed from occupied alpha and beta orbitals and an atomic-orbital (AO) overlap matrix, for example after an scf.UHF calculation. The implementation evaluates S^2 = 1/2 (S+ S- + S- S+) + Sz^2 by forming occupied-space overlap matrices for alpha and beta spin channels (saa, sbb) and the cross overlap (sab), then computing same-electron and two-electron contributions for S+S-, S-S+, and Sz^2. The returned values are suitable for diagnosing spin contamination and reporting the spin expectation and multiplicity in post-SCF analysis within the PySCF quantum-chemistry framework.` |
| `pyscf_scf_hf_symm_map_degeneracy` | `pyscf.scf.hf_symm.map_degeneracy` | `pyscf/scf/hf_symm.py` | `mo_energy: numpy.ndarray, orbsym: numpy.ndarray` | `Find degeneracy correspondence for cylindrical symmetry. This function is used in PySCF's symmetry-aware SCF procedures to identify and map pairs of molecular orbitals that are degenerate because of cylindrical (symmetry axis) point-group behavior (for example, the ex/ey pair for linear molecules). It compares orbital energies and symmetry labels to produce an index mapping that pairs each orbital with its degenerate partner when such a pair exists; orbitals not participating in the targeted degeneracies map to themselves. The resulting mapping is commonly used by downstream routines that need a consistent correspondence between components of degenerate orbital subspaces (for example, when performing symmetry-adapted rotations or when enforcing degeneracy constraints during orbital manipulations).` |
| `pyscf_scf_diis_get_err_vec_orig` | `pyscf.scf.diis.get_err_vec_orig` | `pyscf/scf/diis.py` | `s: numpy.ndarray, d: numpy.ndarray, f: numpy.ndarray` | `pyscf.scf.diis.get_err_vec_orig computes the DIIS (Direct Inversion in the Iterative Subspace) error vector used to accelerate Self-Consistent Field (SCF) convergence in PySCF by forming matrix products involving the AO overlap matrix S, the density matrix D, and the Fock matrix F. The original one-line docstring in the source reads "error vector = SDF - FDS", but the implemented routine forms S*D*F, then returns (SDF)‚Ä† - SDF (i.e., FDS - SDF) flattened into a one-dimensional numpy.ndarray. This function is used inside SCF DIIS infrastructure to produce the residuals whose linear combinations are optimized to reduce the SCF error and reach self-consistency.` |
| `pyscf_scf_hf_symm_so2ao_mo_coeff` | `pyscf.scf.hf_symm.so2ao_mo_coeff` | `pyscf/scf/hf_symm.py` | `so: list, irrep_mo_coeff: list` | `Transfer the basis of molecular orbital (MO) coefficient matrices from a symmetry-adapted block-diagonal representation (one block per irreducible representation) into the full atomic-orbital (AO) basis by applying the per-irrep transformation matrices and horizontally concatenating the results. This function is used in the PySCF symmetry-aware self-consistent-field (SCF) workflow (pyscf.scf.hf_symm) to reconstruct the complete AO-basis MO coefficient matrix from MO coefficients that are stored separately for each irreducible representation (irrep). The reconstructed AO-basis coefficient matrix is required for downstream steps such as density matrix construction, Fock matrix evaluation, integral transforms, and orbital-based analyses.` |
| `pyscf_scf_hf_make_rdm2` | `pyscf.scf.hf.make_rdm2` | `pyscf/scf/hf.py` | `mo_coeff: numpy.ndarray, mo_occ: numpy.ndarray, **kwargs` | `pyscf.scf.hf.make_rdm2: Construct the two-particle (2-body) reduced density matrix (2-RDM) in the atomic-orbital (AO) representation for a Hartree‚ÄìFock (HF) determinant. This function is used in the PySCF electronic structure framework to produce a 2-RDM consistent with the one-particle density matrix (1-RDM) returned by make_rdm1, so it can be used to evaluate HF energies, electron-electron expectation values, and to provide a reference 2-RDM for post-HF methods. The returned 2-RDM uses the index ordering dm2[p, q, r, s] = < q^+ s^+ r p >, and the HF energy can be formed using E = einsum('pq,qp', hcore, 1pdm) + einsum('pqrs,pqrs', eri, 2pdm) / 2, where h1[p,q] = <p\|h\|q> and eri[p,q,r,s] = (pq\|rs). The implementation constructs the 2-RDM from the 1-RDM (dm1) as dm2 = dm1 ‚äó dm1 - (swap dm1 ‚äó dm1)/2, which yields a 4D ndarray consistent with a single-determinant HF wavefunction.` |
| `pyscf_scf_rohf_get_roothaan_fock` | `pyscf.scf.rohf.get_roothaan_fock` | `pyscf/scf/rohf.py` | `focka_fockb: tuple, dma_dmb: tuple, s: numpy.ndarray` | `Roothaan effective Fock matrix for restricted open-shell Hartree‚ÄìFock (ROHF) calculations. This function constructs the Roothaan effective Fock operator described in the ROHF formalism (see Ross thesis reference in original implementation). It combines the alpha and beta Fock matrices and the alpha and beta density matrices to build projectors onto the closed (core), open-shell, and virtual subspaces in the atomic-orbital (AO) basis using the AO overlap matrix s. The resulting matrix is symmetrized to enforce Hermiticity and returned with metadata tags referencing the original alpha and beta Fock matrices. In practical PySCF ROHF workflows this effective Fock is used to represent the one-electron operator that reproduces ROHF block structure for subsequent diagonalization or orbital rotations.` |
| `pyscf_scf_rohf_get_grad` | `pyscf.scf.rohf.get_grad` | `pyscf/scf/rohf.py` | `mo_coeff: numpy.ndarray, mo_occ: numpy.ndarray, fock: numpy.ndarray` | `pyscf.scf.rohf.get_grad computes the ROHF orbital-rotation gradient vector for the unique off-diagonal MO blocks used in restricted open-shell Hartree‚ÄìFock (ROHF) response and orbital optimization procedures. The gradient returned corresponds to the combined off-diagonal blocks [co + cv + ov] (core-occupied, core-virtual, occupied-virtual) of the Fock operator expressed in the molecular orbital (MO) basis and is intended for use in orbital rotation/update routines that require only the independent rotation parameters for alpha and beta spin spaces. This function is used in the PySCF ROHF module to extract the independent gradient components that drive orbital rotations during SCF optimization or analytic gradient assembly. It projects the provided Fock operator into the MO basis using the supplied MO coefficients, selects the matrix elements that correspond to rotations between occupied and virtual orbitals for alpha and beta spins according to the occupation vector, and returns these elements as a flattened 1D array of the independent variables.` |
| `pyscf_scf_rohf_make_rdm1` | `pyscf.scf.rohf.make_rdm1` | `pyscf/scf/rohf.py` | `mo_coeff: numpy.ndarray, mo_occ: numpy.ndarray, **kwargs` | `One-particle (spin-separated) density matrix builder for restricted open-shell Hartree‚ÄìFock (ROHF) orbitals. This function constructs the alpha and beta one-particle density matrices in the atomic-orbital (AO) basis from molecular orbital coefficients and orbital occupancies. It is used in PySCF ROHF workflows (for energy evaluation, Fock matrix build, and property calculations) to represent the electronic density split into alpha and beta spin components consistent with ROHF conventions: singly occupied orbitals contribute only to the alpha density, while doubly occupied orbitals contribute to both alpha and beta densities.` |
| `pyscf_scf_uhf_make_rdm1` | `pyscf.scf.uhf.make_rdm1` | `pyscf/scf/uhf.py` | `mo_coeff: tuple, mo_occ: tuple, **kwargs` | `Compute the spin-separated one-particle reduced density matrices (RDM1) in the atomic-orbital (AO) representation for an unrestricted Hartree‚ÄìFock (UHF) wavefunction. This function is part of the PySCF (Python-based Simulations of Chemistry Framework) scf.uhf module and is used to convert molecular-orbital (MO) coefficients and their occupancies into AO-basis density matrices for alpha and beta spins. The returned density matrices are suitable for downstream property evaluations and post-SCF routines in PySCF.` |
| `pyscf_scf_uhf_make_rdm2` | `pyscf.scf.uhf.make_rdm2` | `pyscf/scf/uhf.py` | `mo_coeff: tuple, mo_occ: tuple` | `pyscf.scf.uhf.make_rdm2 computes the two-particle reduced density matrix (RDM2) in the atomic orbital (AO) representation for an unrestricted Hartree‚ÄìFock (UHF) determinant specified by molecular orbital coefficients and occupations. In the PySCF electronic-structure workflow this function is used to obtain the pair density needed to evaluate two-electron expectation values (for example, the Coulomb and exchange contributions to the electronic energy) and other two-body properties. The function constructs the RDM2 from the one-particle density matrices (RDM1) of the alpha and beta spin channels using outer products and the proper same-spin antisymmetrization required for a single-determinant UHF wavefunction.` |
| `pyscf_scf_uhf_make_asym_dm` | `pyscf.scf.uhf.make_asym_dm` | `pyscf/scf/uhf.py` | `mo1: numpy.ndarray, mo2: numpy.ndarray, occ1: numpy.ndarray, occ2: numpy.ndarray, x: numpy.ndarray` | `One-particle asymmetric density matrix for unrestricted Hartree‚ÄìFock (UHF) spinorbitals. This function constructs an asymmetric transition one-particle density matrix between two UHF wavefunctions (often produced by independent SCF runs) by projecting occupied molecular orbitals from the first determinant onto the occupied orbitals of the second determinant using the matrices x returned by det_ovlp. In practical PySCF workflows this is used to form the alpha and beta spin blocks of a transition (asymmetric) density matrix when comparing or coupling two different UHF solutions (for example, geometries or basis variants). The implementation selects occupied columns from the provided MO coefficient arrays and computes dm_alpha = mo1_alpha * x_alpha * mo2_alpha^H and dm_beta = mo1_beta * x_beta * mo2_beta^H using matrix multiplication (numpy.dot).` |
| `pyscf_scf_uhf_det_ovlp` | `pyscf.scf.uhf.det_ovlp` | `pyscf/scf/uhf.py` | `mo1: tuple, mo2: tuple, occ1: tuple, occ2: tuple, ovlp: numpy.ndarray` | `pyscf.scf.uhf.det_ovlp: Calculate the overlap between two unrestricted-Hartree-Fock (UHF) Slater determinants built from two different sets of molecular orbitals. In the PySCF domain this routine is used to evaluate the scalar overlap S_{12} = <Psi_A \| Psi_B> between determinant \|Psi_A> defined by (mo1, occ1) and determinant \|Psi_B> defined by (mo2, occ2). The overlap is computed as the product of the singular values of the alpha- and beta-spin molecular-orbital overlap matrices obtained from projecting occupied orbitals into the atomic-orbital (AO) basis with the provided AO overlap matrix ovlp; the routine also returns the matrices U Lambda^{-1} V^H (one per spin) that are useful in forming asymmetric transition density matrices between the two determinants.` |
| `pyscf_solvent_cosmors_get_sas_volume` | `pyscf.solvent.cosmors.get_sas_volume` | `pyscf/solvent/cosmors.py` | `surface: dict, step: float = 0.2` | `pyscf.solvent.cosmors.get_sas_volume computes the solvent-accessible surface (SAS) volume enclosed by a molecule and returns that volume in atomic units (a.u.). This function is used in PySCF's implicit solvation and solvent modeling workflows (e.g., mc.with_solvent.surface) to quantify the volume of space accessible to a solvent probe around a molecular structure; the computed SAS volume is commonly used in solvation energy models, surface-area/volume-based descriptors, and other continuum-solvent corrections.` |
| `pyscf_solvent_grad_pcm_grad_switch_h` | `pyscf.solvent.grad.pcm.grad_switch_h` | `pyscf/solvent/grad/pcm.py` | `x: numpy.ndarray` | `pyscf.solvent.grad.pcm.grad_switch_h computes the first derivative of the scalar switching function h(x) used in PySCF's polarizable continuum model (PCM) gradient routines. The implementation evaluates the polynomial derivative dy = 30.0*x**2 - 60.0*x**3 + 30.0*x**4 elementwise and enforces dy = 0.0 outside the switching interval [0, 1]. In the PCM context this derivative modulates how cavity/continuum coupling changes with a scalar switching coordinate x and is used during analytic solvent gradient assembly.` |
| `pyscf_scf_uhf_spin_square` | `pyscf.scf.uhf.spin_square` | `pyscf/scf/uhf.py` | `mo: list, s: numpy.ndarray = 1` | `pyscf.scf.uhf.spin_square computes the expectation value of the total spin-squared operator <S^2> and the corresponding spin multiplicity (2S+1) for an unrestricted Hartree‚ÄìFock (UHF) determinant. This function is used in the PySCF UHF code path to quantify spin contamination and to report the effective spin state of a UHF wavefunction given the occupied alpha and beta molecular orbitals and the atomic-orbital (AO) overlap matrix. The routine evaluates the operator S^2 = 1/2 (S_+ S_- + S_- S_+) + S_z^2 for a single-determinant UHF wavefunction by (1) forming the occupied-alpha vs occupied-beta MO overlap matrix in the MO basis, (2) computing cross-spin contributions from S_+S_- and S_-S_+, and (3) adding the S_z^2 contribution that depends on the difference in alpha and beta occupation numbers. The implementation follows the derivation used in PySCF UHF code and in the example usage shown in the project README and source examples.` |
| `pyscf_solvent_hessian_pcm_gradgrad_switch_h` | `pyscf.solvent.hessian.pcm.gradgrad_switch_h` | `pyscf/solvent/hessian/pcm.py` | `x: numpy.ndarray` | `Second derivative of the PCM switching function h(x) used in solvent Hessian calculations. This function evaluates the elementwise second derivative h''(x) of the smoothing/switching function h(x) that appears in pyscf.solvent.hessian.pcm. In the domain 0 <= x <= 1 the second derivative is computed from the cubic polynomial h''(x) = 60.0*x - 180.0*x**2 + 120.0*x**3, and values outside the closed interval [0, 1] are clamped to 0.0 (i.e., h''(x) = 0 for x < 0 or x > 1). The switching function h(x) is used in the polarizable continuum model (PCM) machinery to smoothly transition between regions (for example, between solvent-exposed and buried surface regions) when assembling analytic gradients and Hessians of solvation-related quantities; this routine supplies the curvature contribution (second derivative) of that switch, evaluated elementwise for array inputs. The operation is fully vectorized and has no side effects on input arrays.` |
| `pyscf_solvent_pcm_switch_h` | `pyscf.solvent.pcm.switch_h` | `pyscf/solvent/pcm.py` | `x: numpy.ndarray` | `switching polynomial used in the polarizable continuum model (PCM) code path of PySCF. This function implements the smooth switching function (Eq. 3.19) used to transition between regions (for example, across a cavity surface discretization) in continuum solvation treatments. The implementation follows the corrected polynomial form y = x**3 * (10.0 - 15.0*x + 6.0*x**2) and applies hard bounds outside the unit interval. Reference: J. Chem. Phys. 133, 244111 (2010) ‚Äî note that the original paper contains a typographical error in the printed formula; this function encodes the corrected form used in PySCF's PCM routines.` |
| `pyscf_solvent_grad_pcm_get_dD_dS` | `pyscf.solvent.grad.pcm.get_dD_dS` | `pyscf/solvent/grad/pcm.py` | `surface: dict, dF: numpy.ndarray, with_S: bool = True, with_D: bool = False` | `pyscf.solvent.grad.pcm.get_dD_dS computes derivatives of the PCM Coulomb interaction matrices with respect to surface grid coordinates used in polarizable continuum model (PCM) gradient evaluations. It returns the per-grid-coordinate derivatives of the non-symmetric D matrix and the symmetric S matrix, plus grid-local diagonal contributions assembled from a provided dF array. This routine is intended for use inside PySCF's PCM gradient code to assemble forces and energy derivatives arising from the solvent reaction field acting on a molecular solute.` |
| `pyscf_solvent_pcm_get_D_S` | `pyscf.solvent.pcm.get_D_S` | `pyscf/solvent/pcm.py` | `surface: dict, with_S: bool = True, with_D: bool = False` | `pyscf.solvent.pcm.get_D_S generates the PCM surface interaction matrices D and S used in the polarizable continuum model (PCM) formulation described in J. Chem. Phys. 133, 244111 (2010). It builds the pairwise Coulomb-like matrix S between surface tesserae represented by smeared Gaussian charge distributions and, optionally, the dipolar coupling matrix D that depends on surface normals. The function reads the required surface discretization data from the provided surface dictionary and returns (D, S) where S is always produced and D is produced only when requested.` |
| `pyscf_symm_addons_eigh` | `pyscf.symm.addons.eigh` | `pyscf/symm/addons.py` | `h: numpy.ndarray, orbsym: list` | `Solve the standard Hermitian (or real symmetric) eigenvalue problem by exploiting known symmetry labels of the basis to block-diagonalize the matrix before diagonalization. This function is a PySCF convenience wrapper used in the context of molecular electronic structure calculations (see the PySCF README). It delegates to pyscf.lib.linalg_helper.eigh_by_blocks to partition the input matrix into symmetry blocks defined by the orbital symmetry labels and then solves the eigenvalue problem block-wise. In practice this speeds up and clarifies diagonalization of operators represented in a basis (for example, one-electron integrals or Fock matrices transformed into a symmetry-adapted orbital basis) by returning eigenvalues and eigenvectors consistent with the supplied symmetry labeling.` |
| `pyscf_solvent_hessian_smd_experiment_atomic_surface_tension` | `pyscf.solvent.hessian.smd_experiment.atomic_surface_tension` | `pyscf/solvent/hessian/smd_experiment.py` | `symbols: list, coords: numpy.ndarray, n: float, alpha: float, beta: float, water: bool = True` | `Calculates per-atom contributions to the SMD "surface tension" Hessian used in the SMD implicit-solvent model experimental routine. This routine assembles atomic tension tensors from pairwise switching-function second derivatives and solvent-specific tension parameters so that downstream code in the pyscf.solvent.hessian.smd_experiment module can combine these atomic contributions into the solvent-related part of a molecular Hessian. The implementation follows the structure in the source: it iterates over the provided atomic symbol list, uses module-level tables (for example sigma_water, sigma_n, sigma_alpha, sigma_beta and r_zz) and switching-function helpers (swtich_function, hess_swtich_function, smd_grad.grad_switch_function) to compute per-atom tensor contributions. Coordinates are expected in Angstrom as used throughout the SMD implementation in this module.` |
| `pyscf_solvent_grad_pcm_get_dF_dA` | `pyscf.solvent.grad.pcm.get_dF_dA` | `pyscf/solvent/grad/pcm.py` | `surface: dict` | `pyscf.solvent.grad.pcm.get_dF_dA: Compute the Cartesian derivatives of the per-grid switching function F and the per-grid surface area A with respect to atomic coordinates for use in polarizable continuum model (PCM) solvent gradient assembly. This routine implements the discrete-surface expression given in J. Chem. Phys. 133, 244111 (2010), Appendix C, and is intended for use inside PySCF's PCM gradient codepath to propagate how changes in atomic positions change the switched surface contributions used in solvent reaction-field and forces.` |
| `pyscf_symm_Dmatrix_get_euler_angles` | `pyscf.symm.Dmatrix.get_euler_angles` | `pyscf/symm/Dmatrix.py` | `c1: numpy.ndarray, c2: numpy.ndarray` | `Find the three Euler angles (alpha, beta, gamma) in the z-y-z convention that rotate coordinates from frame c1 to frame c2. This function is used in PySCF's symmetry and rotation utilities (pyscf.symm.Dmatrix) to determine the intrinsic z-y-z Euler rotation that maps one coordinate frame or 3D point to another. In the context of quantum-chemistry workflows (see README), these Euler angles are commonly used to align molecular coordinate frames, rotate symmetry-adapted matrices, or construct rotation operators that transform basis functions and density matrices between frames. The implementation supports two input styles for backward compatibility: (a) 2D arrays that represent a right-handed orthonormal frame given by three axis vectors, and (b) 1D coordinate vectors representing single points in real space. Angles are returned in radians and follow numerical safeguards for near-parallel or antiparallel vectors.` |
| `pyscf_symm_addons_irrep_id2name` | `pyscf.symm.addons.irrep_id2name` | `pyscf/symm/addons.py` | `gpname: str, irrep_id: int` | `Convert an internal irreducible representation (irrep) identifier to the human-readable irrep symbol used by PySCF symmetry routines. This function is part of the pyscf.symm.addons utilities and is used throughout PySCF to translate numeric/internal irrep identifiers (the values recorded in IRREP_ID_TABLE in pyscf/symm/param.py) into standard irrep symbol strings (for example 'A1', 'B2u', etc.) for reporting, labeling orbitals, and interfacing with symmetry-aware routines. The function normalizes the provided point group name via std_symb and dispatches to specialized handlers for SO3 and linear-molecule groups (Dooh/Coov). For other point groups it maps the (possibly high-symmetry) integer id into the CHARACTER_TABLE entry for the normalized group, using the last digit of irrep_id when the id encodes high-symmetry information.` |
| `pyscf_solvent_smd_smd_radii` | `pyscf.solvent.smd.smd_radii` | `pyscf/solvent/smd.py` | `alpha: float` | `pyscf.solvent.smd.smd_radii returns an element-indexed array of atomic van-der-Waals radii used by the SMD (Solvation Model based on Density) implementation in PySCF. The function builds a radii table from the package's radii.VDW baseline values (which in PySCF encode SMD/Bondi/default fallbacks) and applies SMD-specific overrides for selected elements. The oxygen radius is adjusted according to the SMD parametrization (eq. (16) in the SMD literature) using the scalar solvent parameter alpha. These radii are intended for use when constructing molecular solvation cavities and related continuum-solvation quantities inside the PySCF solvent/SMD code paths.` |
| `pyscf_solvent_smd_experiment_atomic_surface_tension` | `pyscf.solvent.smd_experiment.atomic_surface_tension` | `pyscf/solvent/smd_experiment.py` | `symbols: list, coords: numpy.ndarray, n: float, alpha: float, beta: float, water: bool = True` | `pyscf.solvent.smd_experiment.atomic_surface_tension computes per-atom surface-tension contributions used by the SMD (Solvation Model based on Density) experiment code path in PySCF. It evaluates atom-centered contributions for a molecular solute given atomic types, Cartesian coordinates, and three scalar solvent descriptors, combining per-atom and pairwise bond descriptors from module-level lookup tables to produce a numpy.ndarray of tensions aligned with the input atom ordering. This function is used within the implicit-solvent SMD implementation to estimate how each atom of a solute contributes to the solute‚Äìsolvent surface tension term. It assembles contributions from (1) atom-type-specific base tensions and (2) pairwise bond/neighbor-dependent terms that are activated by interatomic distances and precomputed radius/switch parameters. The computation relies on module-level dictionaries and helper utilities defined elsewhere in the same module: sigma_water, sigma_n, sigma_alpha, sigma_beta, r_zz, and swtich_function. It also uses scipy.spatial.distance.cdist to form the NxN matrix of interatomic distances.` |
| `pyscf_symm_Dmatrix_dmatrix` | `pyscf.symm.Dmatrix.dmatrix` | `pyscf/symm/Dmatrix.py` | `l: int, beta: float, reorder_p: bool = False` | `Wigner small-d matrix (z-y-z convention). Computes the Wigner small-d matrix d^l(beta) for angular-momentum rank l and rotation angle beta using the z-y-z Euler-convention commonly used in quantum chemistry and angular-momentum algebra. In PySCF this function is used to construct rotation operators and symmetry-transformation matrices for spherical tensors, spherical harmonics, and spin-orbital block rotations that appear in symmetry-adapted electronic-structure calculations. For small l (0, 1, 2) the implementation uses closed-form expressions; for larger l it evaluates the standard factorial-based sum (vectorized with NumPy) that implements the conventional definition of the Wigner small-d matrix elements d^l_{m1,m2}(beta) = <l,m1\| e^{-i beta J_y} \|l,m2>.` |
| `pyscf_symm_addons_find_symmetric_mo` | `pyscf.symm.addons.find_symmetric_mo` | `pyscf/symm/addons.py` | `moso: numpy.ndarray, ovlpso: numpy.ndarray, thr: float = 1e-08` | `Find the molecular orbitals (MOs) that are symmetry-adapted to a given irreducible representation (irrep) in PySCF. This function is used in PySCF to identify which columns of a molecular orbital coefficient matrix transform purely within a symmetry-adapted atomic-orbital (AO) subspace (an irrep block). In practice, callers construct moso as the overlap between symmetry-adapted AOs and MOs (for example by reduce(numpy.dot, (csym.T.conj(), s, mo)), where csym comes from mol.symm_orb and s is the AO overlap matrix) and ovlpso as the overlap matrix of the symmetry-adapted AOs (for example by reduce(numpy.dot, (csym.T.conj(), s, csym))). The routine projects each MO into the symmetry-adapted AO block by solving ovlpso * x = moso[:, j] (via a Cholesky-based solver) and then computes the self-overlap diag = <moso[:, j] \| x>. MOs with diag numerically equal to 1 (within the tolerance thr) are considered to transform like that irrep and are selected.` |
| `pyscf_symm_Dmatrix_Dmatrix` | `pyscf.symm.Dmatrix.Dmatrix` | `pyscf/symm/Dmatrix.py` | `l: int, alpha: float, beta: float, gamma: float, reorder_p: bool = False` | `pyscf.symm.Dmatrix.Dmatrix returns the Wigner rotation D-matrix for angular momentum l and a rotation specified by Euler angles in the z-y-z convention. The matrix implements D_{m m'} = <l m \| R(alpha, beta, gamma) \| l m'> and is commonly used in PySCF for rotating spherical-harmonic angular-momentum basis functions (for example when transforming molecular orbital or integral representations under symmetry operations).` |
| `pyscf_symm_addons_irrep_name2id` | `pyscf.symm.addons.irrep_name2id` | `pyscf/symm/addons.py` | `gpname: str, symb: str` | `Convert an irreducible-representation (irrep) symbol used in molecular point-group symmetry to the internal integer irrep ID used throughout PySCF's symmetry machinery. This function is part of PySCF's symmetry utilities for quantum-chemistry calculations (see project README). It accepts human-readable point-group and irrep symbols, canonicalizes them with std_symb, and maps them to the internal integer identifier that PySCF uses to index symmetry blocks, orbitals, basis-function blocks, and other symmetry-dependent data structures. The mapping behavior depends on the canonicalized point group: SO3 irreps are handled by basis.so3_irrep_symb2id, linear-molecule groups Dooh/Coov are handled by basis.linearmole_irrep_symb2id, and all other groups are looked up in param.IRREP_ID_TABLE.` |
| `pyscf_symm_addons_std_symb` | `pyscf.symm.addons.std_symb` | `pyscf/symm/addons.py` | `gpname: str` | `pyscf.symm.addons.std_symb converts a point-group name string into the canonical capitalization format used by PySCF's symmetry handling routines. This function is used in the symmetry subsystem of the PySCF electronic structure framework to normalize user-provided or computed point-group identifiers so that downstream code (for example, symmetry-adapted basis generation, integral symmetry classification, and point-group specific algorithms) can rely on a consistent symbol format. The routine preserves a special-case symbol ('SO3') exactly as given by the caller; for all other non-empty strings it returns a new string with the first character capitalized and all remaining characters converted to lower-case, which matches common point-group notation such as D2h.` |
| `pyscf_symm_geom_alias_axes` | `pyscf.symm.geom.alias_axes` | `pyscf/symm/geom.py` | `axes: numpy.ndarray, ref: numpy.ndarray` | `pyscf.symm.geom.alias_axes renames/reorders a set of Cartesian axes so they are as close as possible to a reference axis frame and enforces a right-handed coordinate system.` |
| `pyscf_symm_geom_rotation_mat` | `pyscf.symm.geom.rotation_mat` | `pyscf/symm/geom.py` | `vec: numpy.ndarray, theta: float` | `pyscf.symm.geom.rotation_mat returns a 3x3 rotation matrix for rotating 3D Cartesian vectors by an angle theta about an axis specified by vec. The function is used throughout PySCF geometry and symmetry utilities to perform rigid-body rotations of atomic coordinates, molecular frames, and to construct rotation operators needed for point-group symmetry operations and coordinate transformations in electronic structure calculations.` |
| `pyscf_symm_geom_is_identical_geometry` | `pyscf.symm.geom.is_identical_geometry` | `pyscf/symm/geom.py` | `coords1: numpy.ndarray, coords2: numpy.ndarray, weights: numpy.ndarray` | `pyscf.symm.geom.is_identical_geometry: Fast check whether two molecular geometries are identical using Casimir tensors. Performs a computationally efficient comparison between two sets of atomic coordinates by computing Casimir tensor invariants (orders 1 through 3) for each geometry with the supplied per-atom weights and verifying that the maximum absolute difference for each tensor order is within the module's global tolerance. This function is intended for use inside the PySCF electronic structure framework to quickly determine whether two molecular geometries can be treated as the same geometry (for example, to avoid redundant symmetry analyses, integral rebuilds, or expensive reinitializations) before invoking more expensive routines.` |
| `pyscf_solvent_pcm_get_F_A` | `pyscf.solvent.pcm.get_F_A` | `pyscf/solvent/pcm.py` | `surface: dict` | `pyscf.solvent.pcm.get_F_A: Generate the F (switch function) and A matrices used by the polarizable continuum model (PCM) implementation in PySCF, following the formulation and notation in J. Chem. Phys. 133, 244111 (2010). This function extracts surface discretization data from the provided surface dictionary and computes the A matrix entrywise as A = weights * R_vdw**2 * switch_fun. In the PCM algorithm, the switch function modulates contributions of tesserae (surface elements) and acts as the F prefactor in linear equations for apparent surface charges; A combines the surface quadrature weights, the square of the van der Waals radius at each tessera, and that switch prefactor to produce the prefactor used in matrix assembly. The function performs only elementwise arithmetic and does not modify the input dictionary or any global state.` |
| `pyscf_symm_addons_route` | `pyscf.symm.addons.route` | `pyscf/symm/addons.py` | `target: int, nelec: int, orbsym: list` | `pyscf.symm.addons.route selects a combination of orbital indices that produce a Slater determinant with a desired overall point-group symmetry label. In the PySCF electronic-structure context, orbital symmetry labels (orbsym) are integer-encoded irreducible representations and are combined with a bitwise exclusive OR (XOR) to obtain the determinant symmetry; this function searches for nelec orbitals whose XOR equals the target symmetry and returns the corresponding 0-based indices.` |
| `pyscf_symm_basis_linearmole_symm_descent` | `pyscf.symm.basis.linearmole_symm_descent` | `pyscf/symm/basis.py` | `gpname: str, irrep_id: int` | `pyscf.symm.basis.linearmole_symm_descent maps an irreducible representation identifier from a linear-molecule point group encoding used elsewhere in PySCF down to the equivalent D2h or C2v irreducible representation identifier. This reduction is used in PySCF's symmetry handling for linear molecules so that routines which only implement D2h/C2v symmetry (for example, symmetry-aware integral evaluation, orbital labeling, and symmetry-adapted post-Hartree‚ÄìFock methods) can operate on representations originating from the higher-order linear groups.` |
| `pyscf_symm_sph_sph_real2pure` | `pyscf.symm.sph.sph_real2pure` | `pyscf/symm/sph.py` | `l: int, reorder_p: bool = True` | `sph_real2pure(l, reorder_p=True) Transformation matrix from real spherical harmonic functions to pure (complex) spherical harmonic functions. In the PySCF symmetry utilities this function is used to convert coefficients, integrals, or orbital representations expressed in a real-valued spherical-harmonic basis (commonly used to represent Cartesian-like atomic-orbital components such as p_x, p_y, p_z) into the pure (complex) spherical-harmonic basis labeled by magnetic quantum number m = -l,...,l. This conversion is required in quantum chemistry workflows (for example, symmetry-adapted integral transformations and angular momentum coupling) when code expects the standard complex spherical-harmonic convention. The implementation returns the Hermitian-conjugate (conjugate transpose) of sph_pure2real(l, reorder_p), which for the conventions used in PySCF is the matrix inverse of the pure-to-real transform.` |
| `pyscf_symm_sph_multipoles` | `pyscf.symm.sph.multipoles` | `pyscf/symm/sph.py` | `r: numpy.ndarray, lmax: int, reorder_dipole: bool = True` | `Compute all real multipole components up to a given angular momentum using PySCF conventions. This function is part of the PySCF quantum-chemistry framework (pyscf.symm.sph) and is used to evaluate multipole basis functions (r^l times spherical harmonic components) on a set of 3D grid points. It builds Cartesian monomials x^lx y^ly z^lz for each degree l and uses the internal libcint/cart2sph transformation (via pyscf.gto.cart2sph) to convert them to PySCF's spherical multipole components. The output is suitable for use in symmetry analysis, multipole moment evaluation, and other molecular property calculations within PySCF that expect spherical multipole components organized per angular momentum l.` |
| `pyscf_symm_sph_sph_pure2real` | `pyscf.symm.sph.sph_pure2real` | `pyscf/symm/sph.py` | `l: int, reorder_p: bool = True` | `pyscf.symm.sph.sph_pure2real: Construct the transformation matrix U that converts complex pure spherical harmonic functions Y_m (m = -l,...,l) into real spherical harmonic functions O_m used by PySCF for real-valued atomic/molecular basis functions and symmetry operations. This function is used in the PySCF symmetry and spherical-harmonic utilities to produce the unitary mapping between the complex spherical-harmonic basis (commonly produced by angular momentum theory) and the real-valued combinations (commonly used for real-valued basis functions such as Cartesian p/d/... orbitals). The matrix U implements the convention O_m = sum_{m'} Y_{m'} * U(m', m) with the array indexing convention described below, and it is returned as a 2D numpy array with complex dtype.` |
| `pyscf_symm_geom_symm_identical_atoms` | `pyscf.symm.geom.symm_identical_atoms` | `pyscf/symm/geom.py` | `gpname: str, atoms: list` | `Symmetry identical atoms Compute groups of symmetry-equivalent atom indices for a molecule in a specified point group. This function is used in the PySCF symmetry utilities to identify which atomic sites are mapped onto each other by the point group operations (for example to reduce integrals, label orbitals, and exploit symmetry in electronic structure calculations). The implementation applies the symmetry operation matrices provided by symm_ops and the operator ordering in OPERATOR_TABLE to the input Cartesian coordinates, compares sorted coordinate arrays using argsort_coords, and groups atom indices that are permuted into each other by all symmetry operations for the given point group.` |
| `pyscf_symm_cg_cg_spin` | `pyscf.symm.cg.cg_spin` | `pyscf/symm/cg.py` | `l: int, jdouble: int, mjdouble: int, spin: float` | `pyscf.symm.cg.cg_spin: Compute the Clebsch‚ÄìGordan coefficient <l,m,1/2,spin\|j,mj> for coupling an orbital angular momentum l with a spin-1/2 particle. This function is used in PySCF (Python-based Simulations of Chemistry Framework) wherever one needs the analytic closed-form Clebsch‚ÄìGordan coefficient for coupling an orbital angular momentum l and a spin-1/2 degree of freedom to form a total angular momentum j = l ¬± 1/2. In electronic-structure and symmetry routines (for example, constructing spin-adapted basis functions, spinor spherical harmonics, or transforming between product bases and total-j bases), callers supply integer "doubled" quantum numbers jdouble and mjdouble to avoid fractional representations, and a floating-point spin projection. The routine returns the real-valued coefficient according to the two allowed total-j branches (j = l + 1/2 or j = l - 1/2) and the sign convention implemented in the original PySCF code.` |
| `pyscf_symm_sph_real_sph_vec` | `pyscf.symm.sph.real_sph_vec` | `pyscf/symm/sph.py` | `r: numpy.ndarray, lmax: int, reorder_p: bool = False` | `Computes real (Cartesian) spherical harmonics evaluated on a set of 3D vectors for all angular momenta up to the specified maximum lmax. This function is used in PySCF to generate the angular basis functions (real spherical harmonics) that appear in multipole expansions and atomic-orbital-like angular components used across molecular integrals, multipole moment evaluation, and symmetry-adapted basis constructions. The implementation normalizes input Cartesian vectors to unit length (so the angular coordinates are taken on the unit sphere), converts the usual complex spherical harmonics to the real-valued linear combinations, and delegates to the internal multipoles helper to produce the final array layout. The returned data structure matches the convention used elsewhere in PySCF for angular-channel sampling (one entry per l from 0..lmax).` |
| `pyscf_symm_sph_cart2spinor` | `pyscf.symm.sph.cart2spinor` | `pyscf/symm/sph.py` | `l: int` | `pyscf.symm.sph.cart2spinor: Compute the transformation that maps Cartesian Gaussian basis functions of a given angular momentum to the spinor (spherical spin) basis used in PySCF.` |
| `pyscf_tdscf__lr_eig_VW_Gram_Schmidt_fill_holder` | `pyscf.tdscf._lr_eig.VW_Gram_Schmidt_fill_holder` | `pyscf/tdscf/_lr_eig.py` | `V_holder: numpy.ndarray, W_holder: numpy.ndarray, X_new: numpy.ndarray, Y_new: numpy.ndarray, lindep: float = 1e-12` | `VW_Gram_Schmidt_fill_holder performs a two-stage orthogonalization used in PySCF's linear-response eigenvalue (lr_eig) solvers: it first projects out components of the candidate vectors (X_new, Y_new) against an existing basis stored in V_holder and W_holder (a QR-like step), then performs a symmetric orthogonalization that produces a small set of mutually orthonormalized partner vectors for the X and Y blocks appropriate for time-dependent self-consistent-field (TD-SCF) linear-response problems. This function is used in PySCF to expand the iterative Krylov/subspace basis for solving the LR eigenproblem (e.g., TDHF/TDDFT) while controlling linear dependence and numerical stability.` |
| `pyscf_tdscf__lr_eig_TDDFT_subspace_eigen_solver` | `pyscf.tdscf._lr_eig.TDDFT_subspace_eigen_solver` | `pyscf/tdscf/_lr_eig.py` | `a: numpy.ndarray, b: numpy.ndarray, sigma: numpy.ndarray, pi: numpy.ndarray, nroots: int` | `TDDFT_subspace_eigen_solver solves the linear-response time-dependent density functional theory (TDDFT) subspace eigenproblem for excitation energies and excitation/de-excitation amplitude vectors using a structured transformation and standard dense linear algebra routines. This routine implements the block-eigenproblem algebra shown in the source comments: [ a b ] x - [ œÉ œÄ] x Œ© = 0 [ b a ] y [-œÄ -œÉ] y = 0 and returns excitation energies Œ© and corresponding x (excitation) and y (de-excitation) amplitude matrices computed by scaling with the diagonal of sigma, LU and Cholesky factorizations, and a Hermitian diagonalization of an auxiliary matrix M. In the PySCF TDDFT code path this function is used inside the linear-response solver to transform the generalized Casida-like eigenproblem into a standard Hermitian eigenproblem and to reconstruct physical amplitudes from the subspace eigenvectors.` |
| `pyscf_tools_chkfile_util_dump_mo` | `pyscf.tools.chkfile_util.dump_mo` | `pyscf/tools/chkfile_util.py` | `filename: str, key: str = "scf"` | `pyscf.tools.chkfile_util.dump_mo dumps molecular orbital coefficients stored in a PySCF checkpoint file. This function reads SCF or MCSCF orbital information from a PySCF checkpoint file (chkfile) and delegates formatting/output of the orbital coefficient matrix to pyscf.tools.dump_mat.dump_mo. It is intended for users and developers of the PySCF (Python-based Simulations of Chemistry Framework) library who need to inspect or export molecular orbital coefficients produced by self-consistent field (SCF) or multiconfigurational SCF (MCSCF) calculations. The function locates the orbital coefficient array in the checkpoint data, associates it with the molecular object loaded from the same file, and invokes the dump routine that produces a human-readable matrix representation of the orbitals for post-processing, debugging, or archival inspection.` |
| `pyscf_tools_chkfile_util_molden` | `pyscf.tools.chkfile_util.molden` | `pyscf/tools/chkfile_util.py` | `filename: str, key: str = "scf"` | `pyscf.tools.chkfile_util.molden: Read SCF or MC-SCF orbital information from a PySCF checkpoint file and write those orbitals in Molden format for visualization or interoperability with other quantum-chemistry tools. This convenience wrapper reads molecular orbital coefficients stored in a PySCF checkpoint file (chkfile) under the HDF5-like key path "<key>/mo_coeff" (where key is typically 'scf' for mean-field/self-consistent-field results or an MC-SCF block for multiconfigurational results). It then invokes pyscf.tools.molden.from_chkfile to create a Molden-format file that contains the orbital coefficients and header information required by visualization programs and other post-processing tools that accept the Molden format. The function is intended for users of the PySCF framework who want to export orbitals from an on-disk checkpoint into a widely supported text format for inspection, plotting, or interfacing with external software.` |
| `pyscf_tools_qcschema_load_qcschema_go_final_json` | `pyscf.tools.qcschema.load_qcschema_go_final_json` | `pyscf/tools/qcschema.py` | `file_name: str` | `pyscf.tools.qcschema.load_qcschema_go_final_json loads and returns the final optimized-geometry entry from a qcschema-format geometry-optimization (GO) JSON file used by PySCF.` |
| `pyscf_tools_qcschema_load_qcschema_hessian` | `pyscf.tools.qcschema.load_qcschema_hessian` | `pyscf/tools/qcschema.py` | `qcschema_dict: dict` | `Load a molecular Hessian from a QCSchema-formatted dictionary and return it as a 4D NumPy array suitable for PySCF vibrational and normal-mode workflows.` |
| `pyscf_tools_chkfile_util_mulliken` | `pyscf.tools.chkfile_util.mulliken` | `pyscf/tools/chkfile_util.py` | `filename: str, key: str = "scf"` | `pyscf.tools.chkfile_util.mulliken: Read SCF or MCSCF data from a PySCF checkpoint file and perform a Mulliken population analysis on the constructed one-particle density matrix. This function is intended for use within the PySCF (Python-based Simulations of Chemistry Framework) workflow to extract molecular and orbital data previously written to a PySCF checkpoint (chkfile) and to compute Mulliken populations from the resulting density matrix. It supports checkpoint entries produced by standard SCF calculations and by multiconfigurational SCF (mcscf) calculations.` |
| `pyscf_tools_qcschema_load_qcschema_json` | `pyscf.tools.qcschema.load_qcschema_json` | `pyscf/tools/qcschema.py` | `file_name: str` | `pyscf.tools.qcschema.load_qcschema_json loads a QCSchema-format JSON file and returns its contents as a Python dictionary for use in PySCF quantum chemistry workflows. This function is intended to read JSON files that follow the QCSchema convention (a machine-readable schema for quantum-chemistry calculation metadata and results) so that downstream PySCF tools can access calculation inputs, outputs, and metadata as native Python objects.` |
| `pyscf_tools_fcidump_from_integrals` | `pyscf.tools.fcidump.from_integrals` | `pyscf/tools/fcidump.py` | `filename: str, h1e: numpy.ndarray, h2e: numpy.ndarray, nmo: int, nelec: int, nuc: float = 0, ms: int = 0, orbsym: list = None, tol: float = 1e-15, float_format: str = " %.16g"` | `Convert the given one-electron and two-electron integrals into the FCIDUMP file format and write them to disk. This function is used in the PySCF quantum chemistry framework to export molecular-orbital representation integrals for interoperability with Full Configuration Interaction (FCI) programs and other post-Hartree‚ÄìFock tools that consume the FCIDUMP standard. It composes an FCIDUMP file by writing a header (orbital and symmetry metadata), the two-electron integrals (ERI), the one-electron (core) Hamiltonian integrals, and a final line containing the nuclear repulsion energy followed by four integer placeholders. The function opens filename for writing (overwriting any existing file at that path) and delegates integral formatting and thresholding to internal helpers write_head, write_eri, and write_hcore. The h1e and h2e arrays provided are forwarded to those helpers; any shape or content expectations enforced by those helpers (for example, matrix/tensor dimensionality or index ordering) will cause errors to be raised by the helpers if not satisfied.` |
| `pyscf_tools_fcidump_read` | `pyscf.tools.fcidump.read` | `pyscf/tools/fcidump.py` | `filename: str, molpro_orbsym: bool = False, verbose: bool = True` | `Parse an FCIDUMP-format file and return a dictionary of molecular integrals and metadata suitable for use in PySCF workflows (for example, to seed FCI, CI, or other post-Hartree‚ÄìFock calculations). This function reads the FCIDUMP header and integral records produced by quantum chemistry programs, converts header tokens to Python types, optionally converts orbital symmetry labels from the Molpro convention to the PySCF convention, and assembles the one-electron integrals, packed two-electron integrals, and scalar parameters into a single dictionary that downstream PySCF code expects.` |
| `pyscf_tools_mo_mapping_mo_1to1map` | `pyscf.tools.mo_mapping.mo_1to1map` | `pyscf/tools/mo_mapping.py` | `s: numpy.ndarray` | `Compute a one-to-one mapping from row indices i to column indices j using the absolute overlap matrix <i\|j>, typically used in PySCF (Python-based Simulations of Chemistry Framework) to associate molecular orbitals from one set (bras) to the closest matching orbitals in another set (kets). In the quantum chemistry workflow of PySCF, this function is used to produce a simple, greedy correspondence between two orbital bases (for example, when comparing orbitals from two calculations or projecting orbitals between different basis sets) by selecting the largest absolute overlap for each row and preventing reuse of the same column index until all columns are exhausted. The algorithm is greedy: for each row i (0..s.shape[0]-1) it selects the column index k with the largest absolute value in that row, records k as the match for i, and then sets that entire column to zero in an internal working copy so that subsequent rows prefer different columns. The input array is not modified; the function operates on an absolute-value copy of s. Because the method is greedy rather than globally optimal, it may produce suboptimal assignments in cases of strongly tied overlaps or when the number of rows exceeds the number of columns.` |
| `pyscf_tools_molden_load` | `pyscf.tools.molden.load` | `pyscf/tools/molden.py` | `moldenfile: str, verbose: int = 0` | `pyscf.tools.molden.load loads a molecular geometry and molecular orbital information from a Molden-format file into PySCF data structures for use in further electronic-structure computations or analysis. This function reads the text-based Molden file (a common quantum-chemistry interchange format for molecular geometries, basis sets and molecular orbitals) and returns a PySCF gto.Mole object plus the corresponding molecular orbital energies, coefficients, occupations, irreducible-representation labels, and spin labels as parsed from the file. The function updates the Mole.cart flag according to the angular-momentum section headers found in the Molden file, supports Molden files that encode either a single combined MO section (possibly containing spin orbitals) or separate MO sections for alpha and beta spins, and will build the returned Mole if it has not already been constructed. This loader is used within the PySCF framework (Python-based Simulations of Chemistry Framework) to import externally generated orbitals and geometry/basis information for visualization, analysis, or as inputs/initial guesses for PySCF calculations.` |
| `pyscf_tools_qcschema_recreate_mol_obj` | `pyscf.tools.qcschema.recreate_mol_obj` | `pyscf/tools/qcschema.py` | `qcschema_dict: dict, to_Angstrom: bool = False` | `Recreate a PySCF Mole object from a QCSchema-format dictionary. This function is used in the PySCF tools.qcschema module to translate a QCSchema-compliant molecular description (the JSON-like dictionary used across quantum chemistry tools and data exchange) into an instantiated pyscf.gto.Mole object that can be used for PySCF electronic structure calculations. The routine extracts molecular charge, multiplicity, basis information, basis Cartesian/pure flag, and the atomic geometry (via load_qcschema_molecule), converts units if requested, constructs the pyscf.gto.Mole using the extracted settings, and calls mol.build(False, False) to finalize internal data structures required by downstream PySCF routines.` |
| `pyscf_tools_qcschema_load_qcschema_molecule` | `pyscf.tools.qcschema.load_qcschema_molecule` | `pyscf/tools/qcschema.py` | `qcschema_dict: dict, to_Angstrom: bool = False, xyz: bool = False, mol_select: int = 1, step: int = 0` | `Loads a molecule description from a qcschema-format dictionary into a PySCF-friendly representation. This function is used in the PySCF (Python-based Simulations of Chemistry Framework) tools module pyscf.tools.qcschema to extract a single-point molecule or a specific geometry from a geometry optimization / trajectory result expressed as a qcschema dict. It reads element symbols and Cartesian coordinates from well-known qcschema keys, optionally converts coordinates from Bohr to Angstrom using the BOHR constant, reshapes the coordinate array into (N_atoms, 3), and returns either a Python list of (symbol, coordinates) pairs suitable for constructing a PySCF molecule or an xyz-format string for file output.` |
| `pyscf_tools_fcidump_from_chkfile` | `pyscf.tools.fcidump.from_chkfile` | `pyscf/tools/fcidump.py` | `filename: str, chkfile: str, tol: float = 1e-15, float_format: str = " %.16g", molpro_orbsym: bool = False, orbsym: list = None` | `Read SCF results from a PySCF checkpoint file (chkfile), transform the one-electron and two-electron integrals into the SCF molecular orbital (MO) basis defined in the checkpoint, and write the transformed integrals to an FCIDUMP-format file. This function is used in quantum chemistry workflows within the PySCF framework to convert SCF outputs into the FCIDUMP format required by many post-Hartree‚ÄìFock solvers (for example full configuration interaction or external codes that consume FCIDUMP). The function loads molecule and SCF records from the checkpoint (via scf.chkfile.load_scf), extracts MO coefficients, checks orbital orthonormality against the AO overlap integrals, optionally computes orbital symmetry labels if the molecule has symmetry, and delegates the integral transformation and file writing to pyscf.tools.fcidump.from_mo while passing the molecular spin (ms=mol.spin) to the writer.` |
| `pyscf_tools_qcschema_load_qcschema_scf_info` | `pyscf.tools.qcschema.load_qcschema_scf_info` | `pyscf/tools/qcschema.py` | `qcschema_dict: dict` | `Loads SCF (self-consistent field) result information from a QCSchema-format dictionary and returns a PySCF-style SCF information dictionary suitable for downstream use in the PySCF (Python-based Simulations of Chemistry Framework) codebase. This function is used when PySCF needs to import SCF results that were serialized with the QCSchema convention (a common JSON schema for quantum chemistry results) and convert those values and array shapes into the conventions PySCF expects for total energy, molecular orbital coefficients, occupations, and eigenvalues.` |

## ‚öñÔ∏è License

Original Code License: Apache-2.0

Wrapper Code & Documentation: Apache-2.0

*This file was automatically generated on February 26, 2026.*
