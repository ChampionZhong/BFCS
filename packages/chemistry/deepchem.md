# deepchem

[üîô Back to Main Repo](../../../README.md) | [üîó Original Repo](https://github.com/deepchem/deepchem)

![Tool Count](https://img.shields.io/badge/Agent_Tools-128-blue?style=flat-square)
![Category](https://img.shields.io/badge/Category-Chemistry-green?style=flat-square)
![Status](https://img.shields.io/badge/Import_Test-Passed-success?style=flat-square)

## üìñ Overview

DeepChem is an open-source Python toolkit for applying deep learning to chemistry and biology‚Äîproviding models and workflows for drug discovery, materials science, quantum chemistry, and related scientific machine-learning tasks.

> **Note**: This documentation lists the **agent-ready wrapper functions** generated for this package. These functions have been strictly typed, docstring-enhanced, and tested for import stability within a standardized Apptainer environment.

## üõ†Ô∏è Available Agent Tools

Below is the list of **128** functions optimized for LLM tool-use.

| **Tool Name (Wrapper)**   | **Source**          | **File Path**     | **Arguments (Type)**        | **Description**                |
| ------------------------- | ------------------- | ----------------- | --------------------------- | ------------------------------ |
| `deepchem_data_datasets_densify_features` | `deepchem.data.datasets.densify_features` | `deepchem/data/datasets.py` | `X_sparse: numpy.ndarray, num_features: int` | `Expands a sparse feature representation into a dense 2-D numpy array suitable for model input. This function is used in DeepChem data pipelines to reconstruct a dense feature matrix from a compact sparse representation that stores only nonzero feature indices and values per sample. In the context of molecular machine learning (see DeepChem README), this is typically used to convert sparse fingerprints, bag-of-words style encodings, or other sparse per-example feature encodings into a dense (n_samples, num_features) array that can be passed to models implemented with TensorFlow, PyTorch, or JAX. The function assumes the sparse representation came from a 2-D array of shape (n_samples, num_features) and therefore does not support reconstructing higher-dimensional dense arrays.` |
| `deepchem_data_datasets_pad_batch` | `deepchem.data.datasets.pad_batch` | `deepchem/data/datasets.py` | `batch_size: int, X_b: numpy.ndarray, y_b: numpy.ndarray, w_b: numpy.ndarray, ids_b: numpy.ndarray` | `Pads a minibatch of examples to exactly batch_size by repeating the provided examples in tiled fashion. This function is used by DeepChem data-loading and training code to ensure each minibatch passed to a model has a fixed size (batch_size) even when the dataset size or the last batch of an epoch is smaller. It takes arrays of features, labels, sample weights, and identifiers that all represent the same short batch (length <= batch_size) and produces new arrays of length batch_size suitable for input to neural network training or evaluation routines in molecular machine learning, drug discovery, materials science, and related life-science applications.` |
| `deepchem_data_datasets_pad_features` | `deepchem.data.datasets.pad_features` | `deepchem/data/datasets.py` | `batch_size: int, X_b: numpy.ndarray` | `Pads a batch of features to exactly the requested batch size by repeating (tiling) the input examples. This function is used in DeepChem's data pipeline for inference-time query processing when a model or runtime requires a fixed batch size. Given an input array of feature vectors X_b whose length is less than or equal to batch_size, pad_features constructs and returns a new numpy.ndarray of length exactly batch_size by tiling the rows (or elements) of X_b in order until the batch is full. The output preserves the dtype of X_b and the per-sample feature shape: if X_b is 1-D with shape (N,), the result has shape (batch_size,); if X_b is multi-dimensional with shape (N, ...) the result has shape (batch_size, ...). This function performs no operation on labels or weights and is intended for features-only padding (see similar utilities such as pad_batch for label/weight handling).` |
| `deepchem_data_datasets_sparsify_features` | `deepchem.data.datasets.sparsify_features` | `deepchem/data/datasets.py` | `X: numpy.ndarray` | `Extracts a sparse feature representation from a dense feature array used in DeepChem preprocessing. This function is used in DeepChem to convert dense per-sample feature vectors (for example, molecular fingerprints, descriptor vectors, or other per-compound feature arrays commonly encountered in drug discovery and materials science workflows) into a compact sparse representation. The sparse representation stores, for each sample, the indices of nonzero features and the corresponding nonzero values. This reduces memory and computational overhead when many features are zero and downstream code expects or can exploit sparse inputs.` |
| `deepchem_dock_binding_pocket_extract_active_site` | `deepchem.dock.binding_pocket.extract_active_site` | `deepchem/dock/binding_pocket.py` | `protein_file: str, ligand_file: str, cutoff: float = 4.0` | `Extracts an axis-aligned integer bounding box that encloses the protein active site (binding pocket) and returns the coordinates of the protein atoms that define that pocket. This function is used in the docking/featurization workflow in DeepChem to identify the region of a protein near a bound ligand that should be considered for grid-based featurization, docking, or other local analyses. Behavior: The function loads the protein and ligand from the provided file paths, loads the ligand with added hydrogens and computed partial charges, finds protein atoms that are within the given cutoff distance (in angstroms) of the ligand, and computes integer axis bounds by taking the floor of minima and the ceil of maxima of the pocket atom coordinates. It returns a CoordinateBox that covers the pocket region and a numpy.ndarray of the pocket atom coordinates in angstroms. The returned CoordinateBox uses integer bounding values computed from the floating point coordinates so it is suitable for creating voxel grids or integer-grid featurizers. Side effects and processing details: Calls load_molecule on each input file; ligand_file is loaded with add_hydrogens=True and calc_charges=True, while protein_file is loaded with add_hydrogens=False. Then calls get_contact_atom_indices with the specified cutoff to determine which protein atoms contact the ligand. The coordinate arrays used are taken directly from the loaded protein coordinates (units: angstroms). The box bounds are computed with numpy floor/ceil and converted to Python ints. Failure modes and errors: If the input files cannot be read or parsed (e.g., missing file, invalid PDB/ ligand format, or RDKit parsing errors), load_molecule will raise an I/O or parsing-related exception. If no protein atoms are found within the cutoff distance, pocket coordinate operations (np.amin or np.amax) will raise a ValueError; callers should catch this case if an empty pocket is possible. The function does not validate that the ligand is actually bound; it only finds protein atoms within cutoff angstroms of ligand atoms.` |
| `deepchem_dock_pose_scoring_cutoff_filter` | `deepchem.dock.pose_scoring.cutoff_filter` | `deepchem/dock/pose_scoring.py` | `d: numpy.ndarray, x: numpy.ndarray, cutoff: float = 8.0` | `deepchem.dock.pose_scoring.cutoff_filter applies a distance-based cutoff to a pairwise feature matrix used in molecular docking and pose scoring. In docking workflows within DeepChem, d typically encodes pairwise distances (for example atom‚Äìatom distances in Angstroms) and x encodes the corresponding per-pair contributions (for example interaction energies, contact indicators, or other features). This function zeroes out entries in x whose corresponding distance in d is greater than or equal to the cutoff, producing a filtered (N, M) array suitable for downstream scoring or featurization.` |
| `deepchem_dock_pose_scoring_pairwise_distances` | `deepchem.dock.pose_scoring.pairwise_distances` | `deepchem/dock/pose_scoring.py` | `coords1: numpy.ndarray, coords2: numpy.ndarray` | `Compute the matrix of pairwise Euclidean distances between two sets of 3D coordinates. This function is used in DeepChem's docking and pose-scoring workflows to measure inter-point distances (for example, distances between atoms in a ligand and atoms in a receptor), to build contact maps, apply distance-based cutoffs, or supply distance features to scoring functions.` |
| `deepchem_dock_pose_scoring_vina_energy_term` | `deepchem.dock.pose_scoring.vina_energy_term` | `deepchem/dock/pose_scoring.py` | `coords1: numpy.ndarray, coords2: numpy.ndarray, weights: numpy.ndarray, wrot: float, Nrot: int` | `Computes the AutoDock Vina-style energy score for two molecular conformations and returns the summed free energy used to rank docking poses in DeepChem's docking/pose-scoring workflow. This function is used in DeepChem's docking pipeline to evaluate the energetic compatibility between two sets of 3D coordinates (for example, a ligand pose and a receptor pocket or two molecular conformations). It computes pairwise inter-atomic distances, evaluates five interaction kernels (repulsion, hydrophobic, hydrogen-bonding, and two Gaussian attraction terms), forms a weighted linear combination of these kernels using the provided weights array, applies a distance cutoff filter, and then applies a nonlinearity that depends on the provided rotatable-bond penalty parameters. The final output is the sum of per-pair free-energy contributions computed by vina_nonlinearity and is typically used to rank or score docking poses.` |
| `deepchem_dock_pose_scoring_vina_gaussian_first` | `deepchem.dock.pose_scoring.vina_gaussian_first` | `deepchem/dock/pose_scoring.py` | `d: numpy.ndarray` | `Computes Autodock Vina's first Gaussian interaction term. This function implements the first Gaussian term from the Autodock Vina scoring function (Jain, 1996) that is commonly used in molecular docking to estimate a component of protein‚Äìligand binding affinity. The computation is performed elementwise as exp(-(d / 0.5)**2), where the constant 0.5 is the Gaussian width parameter used by Autodock Vina. In practical workflows within DeepChem, this function converts a matrix of surface distances between ligand and protein atoms or grid points into a matrix of Gaussian-shaped interaction contributions that can be summed or combined with other terms to produce a docking score.` |
| `deepchem_dock_pose_scoring_vina_gaussian_second` | `deepchem.dock.pose_scoring.vina_gaussian_second` | `deepchem/dock/pose_scoring.py` | `d: numpy.ndarray` | `Computes Autodock Vina's second Gaussian interaction term used in docking pose scoring. This function implements the second Gaussian term from the Autodock Vina scoring function (Jain 1996) and is intended for use within DeepChem's docking and pose_scoring utilities to model a short-range attractive component of protein-ligand noncovalent interactions. Given an array of surface distances d (as defined in the Vina formulation), the function applies the elementwise transformation exp(-((d - 3) / 2)**2) to produce the corresponding Gaussian interaction contributions that are later combined with other scoring terms to estimate binding affinity.` |
| `deepchem_dock_pose_scoring_vina_hbond` | `deepchem.dock.pose_scoring.vina_hbond` | `deepchem/dock/pose_scoring.py` | `d: numpy.ndarray` | `Computes AutoDock Vina's hydrogen bond interaction term for docking pose scoring. This function implements the piecewise linear hydrogen-bond term used by AutoDock Vina (Jain 1996) to convert inter-surface distances into a normalized interaction contribution used in scoring protein-ligand poses. In DeepChem's docking/pose-scoring pipeline this term is one component of the overall Vina-style scoring function and is applied to the set of surface distances computed between interacting atoms or molecular surfaces. The input d is expected to contain the surface distances as defined in the cited reference: negative values indicate overlapping/close contact (favorable for hydrogen bonding), and non-negative values indicate separated surfaces (no hydrogen-bond contribution). Behavior: for each element of d the function returns a value in the interval [0, 1] according to the following piecewise definition implemented in the source code: - If d < -0.7, the interaction term is saturated at 1. - If -0.7 <= d < 0, the interaction term increases linearly as (1.0 / 0.7) * (0 - d) (equivalently -d / 0.7), producing a smooth ramp from 1 at d = -0.7 to 0 at d = 0. - If d >= 0, the interaction term is 0. The function performs no in-place modification of its input and has no side effects beyond returning the computed array.` |
| `deepchem_dock_pose_scoring_vina_hydrophobic` | `deepchem.dock.pose_scoring.vina_hydrophobic` | `deepchem/dock/pose_scoring.py` | `d: numpy.ndarray` | `deepchem.dock.pose_scoring.vina_hydrophobic computes the Autodock Vina hydrophobic interaction term for a batch of surface-distance values used in molecular docking pose scoring. This function implements the piecewise linear hydrophobic term used in Vina-style scoring functions to approximate the contribution of close hydrophobic contacts between a ligand and a receptor to binding affinity. In the DeepChem docking/pose-scoring context (see the project README for the library's application to drug discovery and virtual screening), this term is applied elementwise to a matrix of surface distances to produce a matrix of hydrophobic interaction scores that can be combined with other terms for pose ranking. The distance matrix d is the set of surface distances as defined in the original Vina/Jain formulation [1].` |
| `deepchem_dock_pose_scoring_vina_nonlinearity` | `deepchem.dock.pose_scoring.vina_nonlinearity` | `deepchem/dock/pose_scoring.py` | `c: numpy.ndarray, w: float, Nrot: int` | `deepchem.dock.pose_scoring.vina_nonlinearity: Compute a Vina-inspired nonlinearity used in docking pose scoring to attenuate per-activation values according to molecular flexibility. This function implements a simple, elementwise nonlinearity used in DeepChem's docking/pose-scoring utilities. It divides every element of an input activation matrix by a scalar factor (1 + w * Nrot). In the context of molecular docking and drug-discovery workflows (see DeepChem README), this nonlinearity is used to penalize or scale pose scoring activations based on the number of rotatable bonds in a ligand: as the number of rotatable bonds increases, the denominator increases (for positive w) and activations are correspondingly reduced, reflecting increased conformational entropy and flexibility.` |
| `deepchem_dock_pose_scoring_vina_repulsion` | `deepchem.dock.pose_scoring.vina_repulsion` | `deepchem/dock/pose_scoring.py` | `d: numpy.ndarray` | `deepchem.dock.pose_scoring.vina_repulsion computes the Autodock Vina repulsion interaction term used in molecular docking pose scoring. In the docking domain this term penalizes steric overlaps between atoms: negative values in the input indicate overlap (distance deficit) and produce a positive quadratic repulsion penalty, whereas non-overlapping separations produce no repulsion contribution.` |
| `deepchem_dock_pose_scoring_weighted_linear_sum` | `deepchem.dock.pose_scoring.weighted_linear_sum` | `deepchem/dock/pose_scoring.py` | `w: numpy.ndarray, x: numpy.ndarray` | `deepchem.dock.pose_scoring.weighted_linear_sum computes a weighted linear sum by contracting a one-dimensional weight vector with the first axis of a three-dimensional feature tensor. In the DeepChem docking/pose-scoring context (drug discovery and molecular docking workflows described in the repository README), this function is used to combine N individual component scores or feature channels (for example, per-term energy contributions or per-feature model outputs) into final per-pose/per-output values that can be used for ranking or downstream evaluation.` |
| `deepchem_feat_complex_featurizers_complex_atomic_coordinates_compute_neighbor_list` | `deepchem.feat.complex_featurizers.complex_atomic_coordinates.compute_neighbor_list` | `deepchem/feat/complex_featurizers/complex_atomic_coordinates.py` | `coords: numpy.ndarray, neighbor_cutoff: float, max_num_neighbors: int, periodic_box_size: list` | `Computes a neighbor list from atom coordinates. This function constructs a mapping from each atom index to a list of neighbor atom indices that lie within a spherical cutoff radius. It is used in DeepChem complex featurizers to identify local atomic environments for tasks in drug discovery, materials science, and computational chemistry. The implementation relies on the mdtraj library to compute neighbor relationships and applies an optional periodic minimum-image correction when a periodic_box_size is provided. The function reshapes the provided coordinate array into an mdtraj Trajectory of shape (1, N, 3) where N is the number of atoms and returns integer indices that refer to the original order of atoms in coords.` |
| `deepchem_feat_complex_featurizers_splif_fingerprints_compute_splif_features_in_range` | `deepchem.feat.complex_featurizers.splif_fingerprints.compute_splif_features_in_range` | `deepchem/feat/complex_featurizers/splif_fingerprints.py` | `frag1: Tuple, frag2: Tuple, pairwise_distances: numpy.ndarray, contact_bin: List, ecfp_degree: int = 2` | `deepchem.feat.complex_featurizers.splif_fingerprints.compute_splif_features_in_range computes Structure-based Protein-Ligand Interaction Fingerprints (SPLIF) features for atom pairs in two molecular fragments whose pairwise distances fall strictly within a given range. This function is used in DeepChem to convert geometric proximity between two molecules (for example, a ligand and a protein residue or two fragments of a complex) into atom-level ECFP descriptors that serve as inputs for machine learning models in drug discovery and related molecular sciences.` |
| `deepchem_feat_complex_featurizers_splif_fingerprints_featurize_splif` | `deepchem.feat.complex_featurizers.splif_fingerprints.featurize_splif` | `deepchem/feat/complex_featurizers/splif_fingerprints.py` | `frag1: tuple, frag2: tuple, contact_bins: numpy.ndarray, pairwise_distances: numpy.ndarray, ecfp_degree: int` | `deepchem.feat.complex_featurizers.splif_fingerprints.featurize_splif computes Structural Protein-Ligand Interaction Fingerprint (SPLIF) features for fragment‚Äìfragment contacts in a binding pocket, returning one SPLIF dictionary per contact distance bin. This function iterates over the provided contact distance bins and, for each bin, collects fragment pairs whose pairwise distances fall into that bin and produces a mapping from fragment index pairs to the corresponding ECFP-derived fragment descriptors. The result is a list of SPLIF dictionaries, one dictionary per contact bin, preserving the order of contact_bins. This featurization is intended for downstream use by vectorize or voxelize routines in DeepChem that convert SPLIF dictionaries into fixed-size numerical inputs for machine learning models in molecular modeling and drug discovery workflows.` |
| `deepchem_feat_graph_features_features_to_id` | `deepchem.feat.graph_features.features_to_id` | `deepchem/feat/graph_features.py` | `features: list, intervals: list` | `Convert a list of discrete graph features into a single integer index used by DeepChem graph featurizers. This function is used in DeepChem's graph feature pipeline to map a vector of discrete, typically integer-valued features (for example atom or bond categorical/binned features returned by get_feature_list()) into a single linear index suitable for indexing into a flattened feature vector or lookup table. The mapping uses the provided spacings in intervals (as returned by get_intervals()) to perform a mixed-radix style encoding: each feature value is multiplied by the corresponding interval spacing and summed. The function then adds 1 to the result so that the integer 0 remains available to represent a reserved "null molecule" or absent feature in DeepChem's downstream data structures.` |
| `deepchem_feat_graph_features_get_intervals` | `deepchem.feat.graph_features.get_intervals` | `deepchem/feat/graph_features.py` | `l: list` | `deepchem.feat.graph_features.get_intervals computes multiplicative stride intervals for a list of discrete option lists used in DeepChem graph featurization. This function is used in DeepChem's graph feature utilities to compute cumulative product "intervals" (mixed-radix strides) when enumerating combinations of categorical choices across multiple feature slots (for example, different atom or edge feature option lists when flattening categorical feature combinations in molecular/graph featurization for drug discovery and related computational chemistry tasks). The implementation adds 1 to every inner list length to ensure an empty option list does not force a zero product; the first interval is initialized to 1 and subsequent intervals are produced by multiplying by (len(inner_list) + 1).` |
| `deepchem_feat_graph_features_id_to_features` | `deepchem.feat.graph_features.id_to_features` | `deepchem/feat/graph_features.py` | `id: int, intervals: list` | `deepchem.feat.graph_features.id_to_features converts a single flattened feature-vector index into the original set of discrete feature indices used by DeepChem graph featurizers. This function reverses the mixed-radix encoding produced when a multi-feature categorical state was flattened to a single integer index (for example, when enumerating or indexing combinations of atom/bond categorical features during featurization). It is typically used in DeepChem's molecular graph featurization pipeline to map an index back to the list of per-feature category indices as returned by get_feature_list().` |
| `deepchem_feat_mol_graphs_cumulative_sum` | `deepchem.feat.mol_graphs.cumulative_sum` | `deepchem/feat/mol_graphs.py` | `l: list, offset: int = 0` | `deepchem.feat.mol_graphs.cumulative_sum computes cumulative (prefix) sums for a sequence of integer counts and returns a one-dimensional numpy array whose first element corresponds to the zero-based start index (plus any supplied offset). This function is used in DeepChem's molecular graph featurization and batching code to produce reindexing pointers (for example, to compute per-molecule atom or edge start indices when concatenating variable-length segments into flat arrays). The returned array includes the final total (useful for range/search operations) and thus has length len(l) + 1.` |
| `deepchem_feat_mol_graphs_cumulative_sum_minus_last` | `deepchem.feat.mol_graphs.cumulative_sum_minus_last` | `deepchem/feat/mol_graphs.py` | `l: list, offset: int = 0` | `cumulative_sum_minus_last returns cumulative sums for a sequence of integer counts, omitting the final total. It is intended for reindexing tasks in molecular graph construction and other DeepChem workflows where per-item counts (for example, number of atoms or bonds per molecule) are converted into starting offsets into a flat concatenated array. This function computes the cumulative sum of the input list l with numpy dtype np.int32, inserts an initial 0 so that the first returned value is 0, removes the final element (the overall total), and then adds the integer offset value to every element. Practically, the returned values represent the starting index for each block when concatenating blocks of sizes given by l. Example: l = [3, 2, 4] -> cumulative sums [3, 5, 9], insert initial 0 -> [0, 3, 5, 9], drop last element -> [0, 3, 5], then add offset (default 0) -> [0, 3, 5].` |
| `deepchem_feat_molecule_featurizers_conformer_featurizer_safe_index` | `deepchem.feat.molecule_featurizers.conformer_featurizer.safe_index` | `deepchem/feat/molecule_featurizers/conformer_featurizer.py` | `feature_list: list, e: int` | `deepchem.feat.molecule_featurizers.conformer_featurizer.safe_index returns the index of a requested element within a feature vector used by DeepChem's conformer featurizer; if the requested element is not present, the function returns the index of the last element of the provided list instead of raising an exception. This helper is used in molecular featurization pipelines to robustly map an element identifier to a position in a feature_list without interrupting processing when a lookup fails.` |
| `deepchem_feat_molecule_featurizers_smiles_to_seq_create_char_to_idx` | `deepchem.feat.molecule_featurizers.smiles_to_seq.create_char_to_idx` | `deepchem/feat/molecule_featurizers/smiles_to_seq.py` | `filename: str, max_len: int = 250, smiles_field: str = "smiles"` | `Creates a character-to-index mapping from SMILES strings stored in a CSV file for use in sequence-based molecular featurization. This function is used in DeepChem's SMILES-to-sequence featurizers to build a vocabulary of characters that appear in SMILES (Simplified Molecular Input Line Entry System) strings. It reads a CSV file using pandas, extracts the column specified by smiles_field, collects all characters that occur in SMILES strings whose length is less than or equal to max_len, appends two special tokens (PAD_TOKEN and OUT_OF_VOCAB_TOKEN) to the vocabulary, and returns a dictionary that maps each character/token to a unique integer index. The resulting mapping is typically used to convert SMILES strings into integer sequences for embedding layers, one-hot encodings, or other model inputs in molecular machine learning workflows.` |
| `deepchem_feat_sequence_featurizers_position_frequency_matrix_featurizer_PFM_to_PPM` | `deepchem.feat.sequence_featurizers.position_frequency_matrix_featurizer.PFM_to_PPM` | `deepchem/feat/sequence_featurizers/position_frequency_matrix_featurizer.py` | `pfm: numpy.ndarray` | `deepchem.feat.sequence_featurizers.position_frequency_matrix_featurizer.PFM_to_PPM converts a position frequency matrix (PFM) into a position probability matrix (PPM) by normalizing each column so the entries per column represent relative probabilities. In the DeepChem sequence featurizers context, a PFM is typically a 2-D numpy.ndarray of counts (for example counts of nucleotides or amino acids at each alignment position) and the resulting PPM is used by downstream featurizers and models to represent motif or positional composition as probabilities rather than raw counts.` |
| `deepchem_metrics_genomic_metrics_get_pssm_scores` | `deepchem.metrics.genomic_metrics.get_pssm_scores` | `deepchem/metrics/genomic_metrics.py` | `encoded_sequences: numpy.ndarray, pssm: numpy.ndarray` | `Convolves a position-specific scoring matrix (PSSM) and its reverse complement with one-hot (or otherwise encoded per-base) nucleotide sequences and returns the per-position maximum score between the forward and reverse-complement orientations. This function is used in DeepChem genomic metrics to scan genomic sequences for motif matches (for example, scoring candidate transcription factor binding sites) by cross-correlating a PSSM with encoded sequences and selecting the best orientation at each sequence position.` |
| `deepchem_metrics_metric_from_one_hot` | `deepchem.metrics.metric.from_one_hot` | `deepchem/metrics/metric.py` | `y: numpy.ndarray, axis: int = 1` | `Converts one-hot encoded label vectors to integer class indices using numpy.argmax. This function, deepchem.metrics.metric.from_one_hot, is used in DeepChem preprocessing and metric computation pipelines (for example when evaluating classification models for molecular property prediction or bioactivity) to transform labels from a one-hot representation into a 1-D array of class IDs that downstream metrics and loss functions expect.` |
| `deepchem_metrics_metric_to_one_hot` | `deepchem.metrics.metric.to_one_hot` | `deepchem/metrics/metric.py` | `y: numpy.ndarray, n_classes: int = 2` | `deepchem.metrics.metric.to_one_hot converts integer class labels into a one-hot encoded 2D numpy array for use in classification tasks in DeepChem (for example, preparing label targets for training or computing classification metrics in molecular machine learning workflows such as drug discovery, materials science, or biology). The function turns a vector of class indices into an (N, n_classes) array where each row is a one-hot representation of the corresponding label. It is intended for integer class indices in the range 0..n_classes-1 and is commonly used by DeepChem components that expect dense one-hot labels for loss computation and metric evaluation.` |
| `deepchem_metrics_score_function_bedroc_score` | `deepchem.metrics.score_function.bedroc_score` | `deepchem/metrics/score_function.py` | `y_true: numpy.ndarray, y_pred: numpy.ndarray, alpha: float = 20.0` | `Compute the BEDROC (Boltzmann-enhanced discrimination of ROC) score for early recognition in virtual screening and ranked classification tasks. This function implements the BEDROC metric as described by Truchon and Bayley (2007). In the context of DeepChem and molecular virtual screening (drug discovery and cheminformatics workflows), BEDROC quantifies how well active compounds (positive class) are concentrated at the top of a ranked list produced by a model, with tunable emphasis on early recognition via the alpha parameter. The implementation delegates the final calculation to RDKit's CalcBEDROC and therefore requires RDKit to be installed.` |
| `deepchem_metrics_score_function_concordance_index` | `deepchem.metrics.score_function.concordance_index` | `deepchem/metrics/score_function.py` | `y_true: numpy.ndarray, y_pred: numpy.ndarray` | `deepchem.metrics.score_function.concordance_index computes the concordance index for a set of true target values and predicted scores, quantifying how well the predicted ranking matches the true ordering. This function is used in DeepChem for evaluating ranking quality in tasks such as survival analysis and regression-based predictions in drug discovery and computational biology: it reports the fraction of comparable instance pairs for which the predicted ordering agrees with the true ordering. The function sorts inputs by the true values, enumerates all comparable pairs (pairs with different true values), and accumulates a score where correctly ordered prediction pairs contribute 1, tied predictions contribute 0.5, and incorrectly ordered pairs contribute 0. The final concordance index is the ratio of accumulated correct score to the number of comparable pairs.` |
| `deepchem_metrics_score_function_jaccard_index` | `deepchem.metrics.score_function.jaccard_index` | `deepchem/metrics/score_function.py` | `y: numpy.ndarray, y_pred: numpy.ndarray` | `Computes the Jaccard Index (Intersection over Union) between a ground-truth label array and a predicted label array. This metric is commonly used in image segmentation tasks to quantify the overlap between predicted and reference masks, and within DeepChem workflows it can be used when evaluating predicted segmentation or set-like label outputs in applications across drug discovery, materials science, quantum chemistry, and biology. DEPRECATED: WILL BE REMOVED IN A FUTURE VERSION OF DEEPCHEM. Use jaccard_score instead. This function is a thin wrapper that delegates to jaccard_score and returns the same result.` |
| `deepchem_metrics_score_function_mae_score` | `deepchem.metrics.score_function.mae_score` | `deepchem/metrics/score_function.py` | `y_true: numpy.ndarray, y_pred: numpy.ndarray` | `deepchem.metrics.score_function.mae_score computes the mean absolute error (MAE) between provided ground-truth and predicted numeric arrays. This function is a small wrapper around sklearn.metrics.mean_absolute_error and is intended for use in DeepChem regression workflows (for example, evaluating models that predict molecular properties such as binding affinities, formation energies, or other continuous targets in drug discovery, materials science, quantum chemistry, and biology). The returned MAE is the average absolute difference between corresponding elements of y_true and y_pred and has the same units as the target values; lower values indicate better agreement between predictions and observations.` |
| `deepchem_metrics_score_function_pearson_r2_score` | `deepchem.metrics.score_function.pearson_r2_score` | `deepchem/metrics/score_function.py` | `y: numpy.ndarray, y_pred: numpy.ndarray` | `Computes the Pearson R^2 score: the square of the Pearson correlation coefficient between ground-truth and predicted continuous values. In the DeepChem context this is used as a simple regression-quality metric for tasks such as predicting molecular properties in drug discovery, materials science, quantum chemistry, and biology; it quantifies the strength of a linear relationship between true labels and model predictions and (under the usual assumptions) corresponds to the fraction of variance in y linearly explained by y_pred.` |
| `deepchem_metrics_score_function_pearsonr` | `deepchem.metrics.score_function.pearsonr` | `deepchem/metrics/score_function.py` | `y: numpy.ndarray, y_pred: numpy.ndarray` | `deepchem.metrics.score_function.pearsonr computes the Pearson correlation coefficient between a ground-truth array and a predicted array. This metric is commonly used in DeepChem to evaluate the linear agreement between model predictions and experimental or reference values in domains such as drug discovery, materials science, quantum chemistry, and biology. The function delegates computation to scipy.stats.pearsonr and returns only the correlation coefficient (the first element of scipy.stats.pearsonr), not the associated p-value.` |
| `deepchem_metrics_score_function_pixel_error` | `deepchem.metrics.score_function.pixel_error` | `deepchem/metrics/score_function.py` | `y: numpy.ndarray, y_pred: numpy.ndarray` | `deepchem.metrics.score_function.pixel_error computes a pixel-wise error metric for image-like arrays used in DeepChem image/segmentation evaluation tasks (for example comparing predicted segmentation masks from a model to ground-truth masks in biological microscopy or molecular imaging workflows). The metric is defined as 1 - f1_score(y, y_pred), where f1_score denotes the maximal pixel-wise F-score of similarity between the ground truth and prediction (the original implementation describes this as "1 - the maximal F-score of pixel similarity, or squared Euclidean distance between the original and the result labels"). This function is intended to quantify disagreement between two image-label arrays on a scale from 0 to 1, with lower values indicating better agreement.` |
| `deepchem_metrics_score_function_prc_auc_score` | `deepchem.metrics.score_function.prc_auc_score` | `deepchem/metrics/score_function.py` | `y: numpy.ndarray, y_pred: numpy.ndarray` | `deepchem.metrics.score_function.prc_auc_score computes the area under the precision-recall curve (AUPRC) for the positive class (class index 1) from true labels and predicted class probabilities. This function is used in DeepChem evaluation pipelines (for example in molecular machine learning and drug-discovery model assessment) to quantify classifier performance on imbalanced binary or multi-class tasks by summarizing precision and recall trade-offs into a single scalar between 0 and 1.` |
| `deepchem_metrics_score_function_rms_score` | `deepchem.metrics.score_function.rms_score` | `deepchem/metrics/score_function.py` | `y_true: numpy.ndarray, y_pred: numpy.ndarray` | `deepchem.metrics.score_function.rms_score computes the root-mean-square (RMS) error between true values and predictions. This function returns the square root of the mean squared error between y_true and y_pred and is typically used in DeepChem workflows to assess regression model performance in domains such as drug discovery, materials science, quantum chemistry, and biology. The RMS error is a single non-negative float that summarizes the typical magnitude of prediction errors in the same units as the target values; lower values indicate better agreement between predictions and observations. Implementation-wise, the function computes np.sqrt(mean_squared_error(y_true, y_pred)).` |
| `deepchem_models_losses_get_negative_expectation` | `deepchem.models.losses.get_negative_expectation` | `deepchem/models/losses.py` | `q_samples: torch.Tensor, measure: str = "JSD", average_loss: bool = True` | `Compute the negative component of a divergence or difference from per-sample critic scores. This function implements the "negative expectation" terms used in variational estimators of divergences and adversarial losses. It transforms a tensor of negative-sample critic outputs (q_samples) into the negative part of a chosen divergence/difference according to standard formulas used for GANs, f-divergences, and related objectives. In DeepChem, these terms are used as components of loss functions when training models (for example, adversarial discriminators or mutual-information estimators) in molecular machine learning, drug discovery, and other life-science deep-learning tasks. The function is pure (no side effects) and returns either a per-sample tensor of negative terms or their mean, depending on average_loss.` |
| `deepchem_models_losses_get_positive_expectation` | `deepchem.models.losses.get_positive_expectation` | `deepchem/models/losses.py` | `p_samples: torch.Tensor, measure: str = "JSD", average_loss: bool = True` | `Computes the positive part of a divergence or difference used in unsupervised losses. This function is used in DeepChem's unsupervised loss and divergence estimators (for example when implementing GAN losses or mutual-information estimators) to convert model outputs for positive samples into the "positive expectation" term of a chosen divergence measure. The input p_samples is expected to contain scalar scores or critic outputs for positive examples (for instance discriminator logits or critic values produced during training). The function supports several common measures and implements the exact per-measure transformations used in DeepChem's loss routines. By default it returns the mean over samples, which is suitable for use directly as a scalar loss term during optimization.` |
| `deepchem_models_losses_log_sum_exp` | `deepchem.models.losses.log_sum_exp` | `deepchem/models/losses.py` | `x: torch.Tensor, axis: int = None` | `deepchem.models.losses.log_sum_exp computes a numerically stable log-sum-exp reduction over a specified axis. This function is intended for use in DeepChem loss and model computations where one needs to aggregate scores or logits across a dimension (for example computing log-partition functions, stable denominators for softmax, or reductions used in cross-entropy and likelihood calculations in molecular machine learning tasks).` |
| `deepchem_molnet_dnasim_motif_density` | `deepchem.molnet.dnasim.motif_density` | `deepchem/molnet/dnasim.py` | `motif_name: str, seq_length: int, num_seqs: int, min_counts: int, max_counts: int, GC_fraction: float, central_bp: int = None` | `deepchem.molnet.dnasim.motif_density generates synthetic DNA sequences containing a specified motif at a controlled density and returns both the generated nucleotide sequences and their corresponding embedding metadata. This function uses the simdna library and the ENCODE motif collection (via simdna.ENCODE_MOTIFS_PATH) to sample motif instances, places a sampled number of motif occurrences into each sequence at positions chosen either uniformly or within a central region, and embeds these motifs into a zero-order background sequence whose nucleotide distribution is determined by the provided GC fraction. This is commonly used in DeepChem workflows for creating labeled synthetic genomic datasets for model training and evaluation in tasks such as motif detection and regulatory sequence modeling.` |
| `deepchem_molnet_dnasim_simple_motif_embedding` | `deepchem.molnet.dnasim.simple_motif_embedding` | `deepchem/molnet/dnasim.py` | `motif_name: str, seq_length: int, num_seqs: int, GC_fraction: float` | `deepchem.molnet.dnasim.simple_motif_embedding simulates DNA sequences and returns synthetic sequences together with their embedding metadata by embedding an ENCODE motif (or no motif) anywhere in each sequence. This function is used in DeepChem's molnet dnasim utilities to generate controlled, labeled synthetic datasets for sequence-based model development, benchmarking motif discovery methods, or testing classifiers that consume DNA sequence strings and known motif embeddings.` |
| `deepchem_molnet_dnasim_simulate_differential_accessibility` | `deepchem.molnet.dnasim.simulate_differential_accessibility` | `deepchem/molnet/dnasim.py` | `pos_motif_names: list, neg_motif_names: list, seq_length: int, min_num_motifs: int, max_num_motifs: int, num_pos: int, num_neg: int, GC_fraction: float` | `Generate simulated DNA sequences, binary labels, and motif-embedding objects for a differential accessibility binary classification task used in DeepChem's MolNet dnasim utilities. This function constructs two sets of simulated sequences (positive and negative) by embedding motifs named in pos_motif_names and neg_motif_names, respectively, using the helper simulate_multi_motif_embedding. The outputs are concatenated so that all positive examples appear first followed by all negative examples. These outputs are intended to be used as synthetic training or evaluation data for models studying regulatory DNA accessibility and motif-driven sequence signals.` |
| `deepchem_molnet_dnasim_simulate_heterodimer_grammar` | `deepchem.molnet.dnasim.simulate_heterodimer_grammar` | `deepchem/molnet/dnasim.py` | `motif1: str, motif2: str, seq_length: int, min_spacing: int, max_spacing: int, num_pos: int, num_neg: int, GC_fraction: float` | `deepchem.molnet.dnasim.simulate_heterodimer_grammar simulates a two-class DNA-sequence dataset used in DeepChem benchmarking and model development where the positive class follows a heterodimer grammar (two motifs placed with a constrained spacing) and the negative class contains the same motifs embedded independently (not forming the heterodimer grammar). This function constructs synthetic DNA sequences by loading ENCODE motifs via simdna, sampling motif instances for motif1 and motif2 (each with reverse-complement sampling enabled), embedding a paired motif arrangement for positive examples with an inter-motif separation drawn from the supplied spacing range, and embedding motif instances independently for negative examples using the helper simulate_multi_motif_embedding. The generated sequences, binary class labels, and per-sequence embedding metadata are returned for downstream training, evaluation, or analysis of sequence models.` |
| `deepchem_molnet_dnasim_simulate_motif_counting` | `deepchem.molnet.dnasim.simulate_motif_counting` | `deepchem/molnet/dnasim.py` | `motif_name: str, seq_length: int, pos_counts: list, neg_counts: list, num_pos: int, num_neg: int, GC_fraction: float` | `Generates a synthetic dataset for a DNA motif-counting classification task. This function is used in DeepChem's dnasim utilities to produce sequences, binary labels, and embedding objects suitable for training or evaluating models that count occurrences of a specific DNA motif in sequences (a common task in computational biology and regulatory genomics). The function builds a positive set where sequences contain motif counts sampled between pos_counts[0] and pos_counts[1] and a negative set where sequences contain motif counts sampled between neg_counts[0] and neg_counts[1], uses motif_density to synthesize sequences and associated embedding objects, concatenates the positive and negative sets, and returns the combined arrays for downstream model input or analysis. Note: the current implementation calls motif_density for both positive and negative sets using the same num_pos value for the number of sequences passed to motif_density; as a result, the number of generated negative sequences may not match num_neg unless num_pos == num_neg.` |
| `deepchem_molnet_dnasim_simulate_motif_density_localization` | `deepchem.molnet.dnasim.simulate_motif_density_localization` | `deepchem/molnet/dnasim.py` | `motif_name: str, seq_length: int, center_size: int, min_motif_counts: int, max_motif_counts: int, num_pos: int, num_neg: int, GC_fraction: float` | `Simulates two classes of DNA sequences used for benchmarking motif-detection and localization tasks. The function produces a set of "positive" sequences that contain multiple instances of a named motif concentrated inside the central region of each sequence, and a set of "negative" sequences that contain multiple instances of the same motif placed anywhere in the sequence. The number of motif instances placed in each sequence is sampled uniformly between the provided minimum and maximum motif counts. This routine is used by DeepChem's molnet dnasim utilities to generate synthetic datasets for model development and evaluation (for example, models that must detect motif presence and learn positional localization).` |
| `deepchem_molnet_dnasim_simulate_multi_motif_embedding` | `deepchem.molnet.dnasim.simulate_multi_motif_embedding` | `deepchem/molnet/dnasim.py` | `motif_names: list, seq_length: int, min_num_motifs: int, max_num_motifs: int, num_seqs: int, GC_fraction: float` | `Generates synthetic DNA sequences containing variable numbers of embedded motifs for use in multi-motif recognition experiments (a common supervised learning task in regulatory genomics). This function constructs sequences of length seq_length with a background nucleotide composition controlled by GC_fraction, embeds between min_num_motifs and max_num_motifs motifs sampled from the ENCODE motif collection via simdna, and returns the sequences, per-motif presence labels, and embedding metadata for downstream model training or evaluation.` |
| `deepchem_molnet_dnasim_simulate_single_motif_detection` | `deepchem.molnet.dnasim.simulate_single_motif_detection` | `deepchem/molnet/dnasim.py` | `motif_name: str, seq_length: int, num_pos: int, num_neg: int, GC_fraction: float` | `Simulates two classes of nucleotide sequences for single-motif binary classification experiments used in DNA motif detection benchmarking and synthetic dataset generation. This function produces a positive class of sequences that each contain a single occurrence of the named motif embedded at an arbitrary position in a background sequence, and a negative class of background sequences that do not contain the motif. The function is used to create labeled sequence arrays and corresponding embedding metadata that can be passed to downstream model training, evaluation, or visualization pipelines in DeepChem's motif-simulation utilities.` |
| `deepchem_molnet_load_function_factors_datasets_gen_factors` | `deepchem.molnet.load_function.factors_datasets.gen_factors` | `deepchem/molnet/load_function/factors_datasets.py` | `FACTORS_tasks: list, data_dir: str, train_dir: str, valid_dir: str, test_dir: str, shard_size: int = 2000` | `deepchem.molnet.load_function.factors_datasets.gen_factors loads and prepares the FACTORS molecular dataset for downstream modeling in DeepChem: it ensures raw CSV files are present (downloading them if necessary), featurizes molecules using the Merck descriptor set via a UserDefinedFeaturizer, removes missing entries, shuffles the training set, applies dataset transformers derived from the training data, and moves the resulting datasets into the specified target directories. This function is intended for molecular machine-learning workflows in drug discovery and cheminformatics where the FACTORS dataset's per-molecule tasks (labels) are used to train, validate, and test predictive models. It does not perform any train/test splitting because FACTORS is provided with predefined train/validation/test CSV files.` |
| `deepchem_molnet_load_function_kaggle_datasets_gen_kaggle` | `deepchem.molnet.load_function.kaggle_datasets.gen_kaggle` | `deepchem/molnet/load_function/kaggle_datasets.py` | `KAGGLE_tasks: list, train_dir: str, valid_dir: str, test_dir: str, data_dir: str, shard_size: int = 2000` | `deepchem.molnet.load_function.kaggle_datasets.gen_kaggle loads and prepares the KAGGLE molecular benchmarking datasets used by DeepChem for molecular machine learning (drug discovery, materials science, and related cheminformatics tasks). This function locates or downloads three compressed CSV files containing labeled molecular data, featurizes molecules using a predefined Merck descriptor set, removes missing entries, applies dataset transformers consistent with DeepChem preprocessing, shuffles the training set, and moves the resulting Dataset objects to the specified output directories. The function does not perform any train/test splitting because the KAGGLE files are provided as separate train/validation/test splits.` |
| `deepchem_molnet_load_function_uv_datasets_gen_uv` | `deepchem.molnet.load_function.uv_datasets.gen_uv` | `deepchem/molnet/load_function/uv_datasets.py` | `UV_tasks: list, data_dir: str, train_dir: str, valid_dir: str, test_dir: str, shard_size: int = 2000` | `gen_uv loads and preprocesses the UV dataset for molecular property modeling: it ensures raw CSV splits exist (downloads them if missing), featurizes molecules using a Merck descriptor UserDefinedFeaturizer, removes missing entries, shuffles and transforms datasets, and writes processed shards to the provided output directories. This function is used in DeepChem's MolNet data-loading pipeline for experiments in molecular machine learning (e.g., prediction tasks in drug discovery and chemistry) and does not perform any additional train/validation/test splitting beyond the splits present in the source CSV files.` |
| `deepchem_molnet_run_benchmark_load_dataset` | `deepchem.molnet.run_benchmark.load_dataset` | `deepchem/molnet/run_benchmark.py` | `dataset: str, featurizer: str, split: str = "random"` | `deepchem.molnet.run_benchmark.load_dataset: Load a predefined molecular benchmark dataset, its train/validation/test splits, and the data transformers used for preprocessing so they can be used in DeepChem benchmarking and model evaluation workflows. This convenience function selects and invokes a dataset-specific loader from deepchem.molnet, prints basic progress to standard output, and returns the loader's outputs. It is used in DeepChem benchmarking scripts to obtain standardized datasets and preprocessing pipelines for tasks in drug discovery, materials science, quantum chemistry, and related molecular ML domains. The function may trigger network downloads or local caching when a requested dataset is not already available locally, and it delegates featurization and splitting behavior to the underlying loader function.` |
| `deepchem_molnet_run_benchmark_run_benchmark` | `deepchem.molnet.run_benchmark.run_benchmark` | `deepchem/molnet/run_benchmark.py` | `datasets: list, model: str, split: str = None, metric: str = None, direction: bool = True, featurizer: str = None, n_features: int = 0, out_path: str = ".", hyper_parameters: dict = None, hyper_param_search: bool = False, max_iter: int = 20, search_range: float = 2, test: bool = False, reload: bool = True, seed: int = 123` | `deepchem.molnet.run_benchmark.run_benchmark runs end-to-end benchmarking for one or more MolNet datasets using either DeepChem-provided model implementations or a user-supplied model. This function automates dataset loading (via deepchem.molnet loaders), featurization assignment, optional hyperparameter optimization using a Gaussian process optimizer, model training/evaluation on train/validation/(optional) test splits, and persistent logging of results to a CSV file. It is intended for practitioners in molecular machine learning and drug discovery who want reproducible comparisons of models and featurizers across standard DeepChem datasets described in the DeepChem README (e.g., bace_c, bbbp, hiv, qm9, tox21, etc.).` |
| `deepchem_molnet_run_benchmark_models_benchmark_classification` | `deepchem.molnet.run_benchmark_models.benchmark_classification` | `deepchem/molnet/run_benchmark_models.py` | `train_dataset: str, valid_dataset: str, test_dataset: str, tasks: list, transformers: str, n_features: int, metric: list, model: str, test: bool = False, hyper_parameters: dict = None, seed: int = 123` | `Calculate performance of a specified classification model on given DeepChem datasets and tasks, fit the model, and return evaluation results for training, validation, and optionally test sets. This function is used in the DeepChem Molnet benchmarking workflow (deepchem.molnet.run_benchmark_models) to compare different model architectures and configurations on tasks relevant to drug discovery, materials science, and computational biology; it constructs the requested model, applies dataset transformations required by some architectures (for example IRV or DAG preprocessing), fits the model, and evaluates performance using provided metrics.` |
| `deepchem_molnet_run_benchmark_models_benchmark_regression` | `deepchem.molnet.run_benchmark_models.benchmark_regression` | `deepchem/molnet/run_benchmark_models.py` | `train_dataset: str, valid_dataset: str, test_dataset: str, tasks: list, transformers: str, n_features: int, metric: list, model: str, test: bool = False, hyper_parameters: dict = None, seed: int = 123` | `deepchem.molnet.run_benchmark_models.benchmark_regression Calculate regression benchmark performance for a specified DeepChem dataset and a selected model. This function is used by DeepChem benchmarking and example scripts to construct a model (one of several supported regression architectures), fit it to a provided training dataset, and evaluate performance on training, validation, and optional test datasets. It automates model construction from preset or user-provided hyper-parameters, applies dataset-specific transformers (for e.g., DAG, ANI, or Coulomb fit preprocessing), and returns per-model evaluation scores (commonly R^2 or other regression metrics) for use in model comparison, hyperparameter tuning, or reporting in molecular machine learning workflows such as drug discovery, quantum chemistry, and materials science.` |
| `deepchem_splits_task_splitter_merge_fold_datasets` | `deepchem.splits.task_splitter.merge_fold_datasets` | `deepchem/splits/task_splitter.py` | `fold_datasets: list` | `Merges a sequence of fold datasets produced by k_fold_split into a single NumpyDataset that preserves features and identifiers and concatenates task/label and weight columns from each fold. This function is intended for use in DeepChem workflows (for example, molecular machine learning, drug discovery, or other chemistry/biology ML pipelines) after performing a k-fold split of a dataset. It assumes each element of fold_datasets was produced by deepchem.splits.k_fold_split and therefore represents the same set of datapoints in the same ordering, but with different label/weight columns for each fold. The returned dataset reuses the feature matrix (X) and identifiers (ids) from the first fold and constructs new label (y) and weight (w) arrays by concatenating the corresponding arrays from each fold along axis 1, so that columns in the returned y and w correspond to the concatenated fold outputs in the order given by fold_datasets.` |
| `deepchem_trans_transformers_get_cdf_values` | `deepchem.trans.transformers.get_cdf_values` | `deepchem/trans/transformers.py` | `array: numpy.ndarray, bins: int` | `get_cdf_values computes per-column empirical cumulative distribution function (CDF) quantile values for a 1D or 2D numeric array. This helper is used in DeepChem transformer code to map raw feature values (rows = examples, columns = features) to discretized CDF-like values by splitting the sorted data into a fixed number of bins and assigning each sample a bin-based quantile. It is intended for preprocessing and normalization steps in molecular machine-learning workflows where consistent, column-wise percentile mapping is required.` |
| `deepchem_trans_transformers_undo_grad_transforms` | `deepchem.trans.transformers.undo_grad_transforms` | `deepchem/trans/transformers.py` | `grad: numpy.ndarray, tasks: list, transformers: list` | `undo_grad_transforms(grad, tasks, transformers) Performs the inverse of output-gradient modifications applied by a sequence of DeepChem transformers and returns the restored gradient array. This function was historically used to undo per-task output transforms when computing gradients (for example, when converting model output gradients back into physical force contributions in molecular modeling workflows). It walks the provided transformers in reverse application order (last-applied transform undone first) and calls each transformer's untransform_grad method when that transformer declared it modified outputs (transform_y is truthy). NOTE: This function is DEPRECATED and will be removed in a future DeepChem release; callers should manually implement the necessary untransformation logic for force/gradient calculations as recommended by the library.` |
| `deepchem_utils_batch_utils_batch_coulomb_matrix_features` | `deepchem.utils.batch_utils.batch_coulomb_matrix_features` | `deepchem/utils/batch_utils.py` | `X_b: numpy.ndarray, distance_max: float = -1, distance_min: float = 18, n_distance: int = 100` | `Computes per-batch Coulomb-matrix-derived features used by models such as the DTNN (Deep Tensor Neural Network). This helper converts a batch of Coulomb matrices into atomic identifiers and a Gaussian-expanded pairwise distance representation that downstream models consume as input features. The function expects a 3-D NumPy array of Coulomb matrices (a batch), infers the number of atoms per molecule from nonzero entries, recovers approximate atomic numbers from Coulomb-matrix diagonals, computes interatomic distances by inverting the Coulomb interaction entries, and projects those distances onto a fixed set of Gaussian basis functions (distance bins). The outputs encode atom identity, pairwise distance features at specified granularity, per-atom molecule membership, and flattened pair-index mappings required by graph- or tensor-based molecular models.` |
| `deepchem_utils_coordinate_box_utils_get_face_boxes` | `deepchem.utils.coordinate_box_utils.get_face_boxes` | `deepchem/utils/coordinate_box_utils.py` | `coords: numpy.ndarray, pad: float = 5.0` | `Get coordinate-space bounding boxes for each triangular face of the convex hull of a molecular coordinate set. For a macromolecule represented by a set of 3D atomic coordinates, the convex hull procedure identifies exterior triangular faces that describe the outer surface of the structure. For each triangular face, this function computes axis-aligned bounding intervals (x, y, z) that enclose the three vertices of the triangle, expands those intervals by an additive padding value, and returns a CoordinateBox for each face. These per-face boxes serve as crude geometric approximations of local exterior regions of the molecule (for example, to define candidate binding/interacting regions, to generate local grids for featurization, or to filter points by spatial locality). The algorithm uses simple geometry (floor/ceil of vertex coordinates followed by padding) and therefore is fast and interpretable but may be a coarse approximation of the true pocket geometry.` |
| `deepchem_utils_coordinate_box_utils_intersect_interval` | `deepchem.utils.coordinate_box_utils.intersect_interval` | `deepchem/utils/coordinate_box_utils.py` | `interval1: Tuple[float, float], interval2: Tuple[float, float]` | `deepchem.utils.coordinate_box_utils.intersect_interval computes the intersection of two one-dimensional closed intervals. This function is used in DeepChem codepaths that manipulate coordinate-aligned bounding boxes or 1D coordinate ranges (for example, computing overlap along a single axis when intersecting molecular or atom-centered boxes in drug discovery, materials science, quantum chemistry, and biology workflows). The function returns a tuple representing the overlapping interval or a sentinel representing an empty intersection.` |
| `deepchem_utils_data_utils_load_dataset_from_disk` | `deepchem.utils.data_utils.load_dataset_from_disk` | `deepchem/utils/data_utils.py` | `save_dir: str` | `deepchem.utils.data_utils.load_dataset_from_disk loads MoleculeNet train/valid/test DiskDataset objects and their saved preprocessing transformers from disk for downstream model training, validation, and testing in DeepChem workflows (e.g., drug discovery, materials, or biology tasks). This function expects data saved using save_dataset_to_disk and a specific directory layout under save_dir. It checks for the presence of three subdirectories named "train_dir", "valid_dir", and "test_dir" and a serialized transformers file (loaded via load_transformers). If any of the three dataset subdirectories is missing, the function returns immediately with a failure indicator and does not attempt to construct DiskDataset objects. On successful load, it instantiates dc.data.DiskDataset for each split using the corresponding subdirectory, sets a memory cache size on the train DiskDataset as a side effect (train.memory_cache_size = 40 * (1 << 20), i.e., 40 MB) to optimize small-batch access patterns, and loads transformers via load_transformers(save_dir). Errors raised by dc.data.DiskDataset constructors or load_transformers (for example due to corrupted files or permission errors) are not caught by this function and will propagate to the caller.` |
| `deepchem_utils_data_utils_load_from_disk` | `deepchem.utils.data_utils.load_from_disk` | `deepchem/utils/data_utils.py` | `filename: str` | `deepchem.utils.data_utils.load_from_disk loads a dataset or arbitrary serialized object from a file on disk and returns the in-memory Python object appropriate for use with DeepChem workflows (for example, datasets used in drug discovery, materials science, quantum chemistry, and biology model training and evaluation). This function inspects the file extension (with special handling for gzip-compressed files ending in ".gz") to select a loader that reconstructs Python objects from common serialization formats used in DeepChem examples and pipelines. It is intended to be used wherever code needs to restore a saved dataset or object from disk for downstream model training, evaluation, or analysis in the DeepChem ecosystem.` |
| `deepchem_utils_data_utils_load_image_files` | `deepchem.utils.data_utils.load_image_files` | `deepchem/utils/data_utils.py` | `input_files: List[str]` | `deepchem.utils.data_utils.load_image_files loads a set of image files from disk into a numpy array suitable for downstream model input or preprocessing in DeepChem workflows. This function reads image files from the filesystem and returns them as a single numpy array with one entry per input file. It is intended for use in DeepChem pipelines that require loading small to moderate collections of PNG or TIF images (for example microscopy or assay images used in machine-learning models in drug discovery, materials science, or biology). The function determines how to read each file by its file extension (case-insensitive) and uses the Pillow (PIL) library to open image files. All files are read into memory; therefore the caller should ensure sufficient RAM is available for the total size of all images. The function makes no preprocessing beyond converting images to numpy arrays (no resizing, normalization, or channel reordering).` |
| `deepchem_utils_data_utils_load_pickle_file` | `deepchem.utils.data_utils.load_pickle_file` | `deepchem/utils/data_utils.py` | `input_file: str` | `deepchem.utils.data_utils.load_pickle_file loads a Python object from a single pickle file on disk, automatically handling files that are gzip-compressed when the filename contains the substring ".gz". This utility is used throughout DeepChem data pipelines and tutorials to restore saved artifacts such as featurized datasets, cached preprocessing outputs, NumPy arrays, model checkpoints, and other Python objects that were serialized with pickle.` |
| `deepchem_utils_data_utils_load_pickle_files` | `deepchem.utils.data_utils.load_pickle_files` | `deepchem/utils/data_utils.py` | `input_files: List[str]` | `Load objects from a sequence of pickle files and yield them one at a time. This function is used in DeepChem workflows to load serialized Python objects that represent datasets or other artifacts used in molecular machine learning, drug discovery, materials science, quantum chemistry, and biology. Given a list of file paths, it opens each file (supporting plain pickle files and gzipped pickle files like XXXX.pkl.gz), delegates the actual file deserialization to the module-level helper load_pickle_file, and yields the deserialized top-level Python object for each file in the same order as the input list. Because it yields results as an iterator, this function enables lazy loading of potentially large dataset objects so the caller can avoid loading all files into memory at once.` |
| `deepchem_utils_data_utils_load_transformers` | `deepchem.utils.data_utils.load_transformers` | `deepchem/utils/data_utils.py` | `save_dir: str` | `Load the transformers for a MoleculeNet dataset from disk. This function reads a pickle file named "transformers.pkl" from the provided directory and returns the list of Transformer objects that were previously saved for a DeepChem MoleculeNet dataset. In DeepChem workflows (used for molecular machine learning in domains such as drug discovery, materials science, quantum chemistry, and biology) transformers implement preprocessing and postprocessing steps (for example feature scaling, normalization, label transforms, or other dataset-specific conversions) that must be reapplied consistently at training and inference time. Calling this function lets users restore the exact preprocessing pipeline that was used when a dataset or model was saved so subsequent model evaluation, retraining, or deployment uses identical transforms.` |
| `deepchem_utils_debug_utils_set_max_print_size` | `deepchem.utils.debug_utils.set_max_print_size` | `deepchem/utils/debug_utils.py` | `max_print_size: int` | `deepchem.utils.debug_utils.set_max_print_size sets the maximum dataset size at which a dataset's ids will be included in its string representation. This function is used within DeepChem (a library for deep learning in the life sciences) to avoid very slow or extremely verbose string representations of Dataset objects when their self.ids arrays are large. Many DeepChem workflows print or log datasets during data loading, model debugging, or tutorial examples; when a Dataset contains a large number of entries, including the full ids list in repr()/str() can severely degrade performance and readability. Calling this function updates a module-level configuration value that caller code checks to decide whether to include ids in printed representations.` |
| `deepchem_utils_debug_utils_set_print_threshold` | `deepchem.utils.debug_utils.set_print_threshold` | `deepchem/utils/debug_utils.py` | `threshold: int` | `deepchem.utils.debug_utils.set_print_threshold sets the module-level print threshold that controls how many elements of dataset identifiers and task labels are shown when printing or obtaining string representations of DeepChem Dataset objects. This function is used in DeepChem (a library for deep learning in drug discovery, materials science, quantum chemistry, and biology) to limit or expand the amount of dataset metadata shown in logs, REPL sessions, and debugging output so that users can avoid excessively long prints for large datasets or show more detail when inspecting small datasets.` |
| `deepchem_utils_dft_utils_grid_radial_grid_get_xw_integration` | `deepchem.utils.dft_utils.grid.radial_grid.get_xw_integration` | `deepchem/utils/dft_utils/grid/radial_grid.py` | `n: int, s0: str` | `Return n quadrature points and corresponding integration weights on the interval [-1, 1] using a chosen one-dimensional quadrature rule. This function is used by DeepChem's DFT utilities (deepchem.utils.dft_utils.grid.radial_grid) to build one-dimensional quadrature rules that serve as the radial component of numerical integration grids in quantum chemistry and density functional theory workflows. The produced points and weights are suitable for numerically approximating integrals of functions defined on [-1, 1], for example the radial part of atomic orbitals or density components after a coordinate transformation. Three integrator choices are provided: two Chebyshev-based nonuniform grids (useful for concentrating points near boundaries) and a uniform/trapezoidal grid (simple, evenly spaced points).` |
| `deepchem_utils_differentiation_utils_misc_assert_runtime` | `deepchem.utils.differentiation_utils.misc.assert_runtime` | `deepchem/utils/differentiation_utils/misc.py` | `cond: bool, msg: str = ""` | `deepchem.utils.differentiation_utils.misc.assert_runtime asserts a boolean condition at runtime and aborts execution by raising a RuntimeError with a provided message when the condition is not met. This utility is used throughout DeepChem, including in differentiation utilities, model construction, and data processing pipelines, to enforce invariants and signal unrecoverable runtime errors during workflows in drug discovery, materials science, quantum chemistry, and biology.` |
| `deepchem_utils_differentiation_utils_misc_get_and_pop_keys` | `deepchem.utils.differentiation_utils.misc.get_and_pop_keys` | `deepchem/utils/differentiation_utils/misc.py` | `dct: Dict, keys: List` | `Get and pop keys from a dictionary. This utility extracts the values for the specified keys from the provided dictionary and removes those entries from the original dictionary. It is primarily used in DeepChem's differentiation utilities and related preprocessing code to extract and remove selected configuration entries, intermediate tensors, or auxiliary values from a parameter or metadata dictionary before further processing (for example, removing gradient-related entries prior to a numerical routine). The function returns a new dictionary mapping each requested key to its popped value while mutating the input dictionary in-place.` |
| `deepchem_utils_differentiation_utils_misc_set_default_option` | `deepchem.utils.differentiation_utils.misc.set_default_option` | `deepchem/utils/differentiation_utils/misc.py` | `defopt: Dict, opt: Dict` | `deepchem.utils.differentiation_utils.misc.set_default_option returns a merged options dictionary by taking a shallow copy of a dictionary of default options and updating it with user-provided options so that keys in opt override those in defopt. This function is used in DeepChem (a library for deep learning in drug discovery, materials science, quantum chemistry, and biology) to construct concrete configuration dictionaries for components such as models, training loops, data preprocessors, and differentiation utilities where sensible defaults must be combined with user overrides. This function makes a shallow copy of defopt to detach the returned mapping object from the original default mapping, then updates that copy in-place with opt. Because the copy is shallow, mutable values stored in defopt (for example lists, dicts, or objects representing hyperparameters or preprocessors) remain the same objects in the returned dictionary unless they are overridden by entries in opt. Keys present in opt will replace the corresponding keys from defopt; keys absent from opt will retain the values from defopt.` |
| `deepchem_utils_docking_utils_load_docked_ligands` | `deepchem.utils.docking_utils.load_docked_ligands` | `deepchem/utils/docking_utils.py` | `pdbqt_output: str` | `Load ligands docked by AutoDock Vina from a PDBQT output file and return a list of RDKit molecule objects and the associated Vina scores. This utility is used in docking workflows (for example, in DeepChem-based drug-discovery pipelines) to read the multi-pose PDBQT files that AutoDock Vina writes to disk. AutoDock Vina writes one or more MODEL/ENDMDL blocks into the same PDBQT file, and includes a single "REMARK VINA RESULT:" line per model that contains the numerical score for that pose. This function parses that file, extracts the text block for each MODEL, converts each block to a PDB block using the module-local pdbqt_to_pdb helper, and then converts the PDB block to an RDKit molecule using rdkit.Chem.MolFromPDBBlock. The returned molecules preserve 3D coordinates and retain explicit hydrogens because the conversion is called with sanitize=False and removeHs=False. Callers typically use the returned molecules and scores for downstream tasks such as featurization, pose selection, rescoring, or building machine-learning datasets in ligand-protein docking studies.` |
| `deepchem_utils_docking_utils_read_gnina_log` | `deepchem.utils.docking_utils.read_gnina_log` | `deepchem/utils/docking_utils.py` | `log_file: str` | `Read GNINA logfile and extract per-mode docking scores used in structure-based drug discovery workflows. This function is used in DeepChem pipelines that consume GNINA docking output to produce numerical labels or features for machine learning models in drug discovery. It opens and reads the GNINA-generated logfile, locates the section containing per-mode score entries, parses numeric values for each binding mode, and returns them as a numpy.ndarray suitable for downstream analysis (for example, training or evaluating models that predict binding affinity or pose quality).` |
| `deepchem_utils_equivariance_utils_so3_generators` | `deepchem.utils.equivariance_utils.so3_generators` | `deepchem/utils/equivariance_utils.py` | `k: int` | `deepchem.utils.equivariance_utils.so3_generators constructs the three matrix generators of the SO(3) Lie algebra for a given representation index k used to represent angular momentum (quantum spin) in rotation-equivariant computations. This function is used in DeepChem's equivariance utilities when constructing rotation-equivariant operators or representations (for example, in physics-informed or molecular models where three-dimensional rotations and angular momentum operators appear). Internally it obtains SU(2) generators for the representation index k via su2_generators(k), obtains the change-of-basis matrix from real to complex spherical harmonics via change_basis_real_to_complex(k), performs the similarity transform X <- conj(Q.T) @ X @ Q to move the SU(2) generators into the SO(3) (complex spherical harmonic) basis, and then returns the real part of the resulting matrices so the final SO(3) generators are purely real-valued.` |
| `deepchem_utils_equivariance_utils_su2_generators` | `deepchem.utils.equivariance_utils.su2_generators` | `deepchem/utils/equivariance_utils.py` | `k: int` | `Generate the three matrix generators of the special unitary group SU(2) for the representation indexed by k. This function constructs the standard angular-momentum (SU(2)) generators used in quantum mechanics and symmetry analysis for a representation of order k. In physics terms, k corresponds to the spin quantum number j (here restricted to integer values by the function signature), and the representation dimension is 2*k + 1. The function builds the ladder (raising and lowering) operators from closed-form matrix elements sqrt(k*(k+1) - m*(m¬±1)), forms the J_x, J_y, and J_z operators using the usual linear combinations of ladder operators, and stacks them into a single torch.Tensor. These generators are commonly used to represent infinitesimal rotations, compute commutators, construct representation matrices for rotational symmetry, and test equivariance properties in machine-learning models that exploit SU(2) symmetry (as used elsewhere in DeepChem for physically informed modeling).` |
| `deepchem_utils_evaluate_output_statistics` | `deepchem.utils.evaluate.output_statistics` | `deepchem/utils/evaluate.py` | `scores: Dict[str, float], stats_out: str` | `deepchem.utils.evaluate.output_statistics writes evaluation metric scores to a plain text file. This function is a small utility used in DeepChem evaluation pipelines to persist a mapping of metric names to numeric scores produced by model evaluation routines (for example during model validation or testing in drug discovery, materials science, quantum chemistry, or biological modeling workflows). It emits a deprecation warning via the module logger and then opens the specified output file in write mode, truncating any existing contents, and writes the Python string representation of the scores mapping followed by a newline. Because the function writes the raw str() form of the mapping, the output is intended for simple human inspection or quick experiment logging rather than robust machine parsing; for structured, machine-readable outputs consider using experiment tracking integrations (for example, Weights & Biases) or writing JSON externally. Typical failure modes include file system permission errors or other I/O errors raised when opening/writing the file.` |
| `deepchem_utils_evaluate_relative_difference` | `deepchem.utils.evaluate.relative_difference` | `deepchem/utils/evaluate.py` | `x: numpy.ndarray, y: numpy.ndarray` | `Compute the elementwise relative difference between two numpy arrays as (x - y) / abs(y). This function is used in DeepChem for numerical comparison of two arrays, for example to measure relative error between model predictions and reference values in drug discovery, materials science, quantum chemistry, and biology workflows described in the project README. The operation is performed elementwise and returns a numpy.ndarray that contains the relative difference for each corresponding element pair from x and y.` |
| `deepchem_utils_fake_data_generator_generate_edge_index` | `deepchem.utils.fake_data_generator.generate_edge_index` | `deepchem/utils/fake_data_generator.py` | `n_nodes: int, avg_degree: int, remove_loops: bool = True` | `Generate a random edge index array containing source and destination node indices for synthetic graphs used in DeepChem utilities, tests, and examples. The function draws n_nodes * avg_degree random directed edges (as integer node indices) using NumPy and optionally removes self-loops.` |
| `deepchem_utils_fake_data_generator_remove_self_loops` | `deepchem.utils.fake_data_generator.remove_self_loops` | `deepchem/utils/fake_data_generator.py` | `edge_index: numpy.ndarray` | `Removes self-loops from an edge list represented as a 2-row numpy array. This function is used in DeepChem's graph utilities and fake data generation to filter out self-loop edges (edges that start and end on the same node) from an edge index representation. In the context of molecular and biological graph data used throughout DeepChem, self-loops typically do not represent meaningful chemical or structural relationships, so they are removed prior to downstream processing (e.g., graph neural network input preparation or dataset sanitization). The function scans each column (edge) and retains only those columns where the source node index differs from the target node index.` |
| `deepchem_utils_genomics_utils_encode_bio_sequence` | `deepchem.utils.genomics_utils.encode_bio_sequence` | `deepchem/utils/genomics_utils.py` | `fname: str, file_type: str = "fasta", letters: str = "ATCGN"` | `deepchem.utils.genomics_utils.encode_bio_sequence: Load a biological sequence file (FASTA/FASTQ) and return a one-hot encoded numpy array suitable for use in genomics-focused deep learning workflows. This function is part of DeepChem's genomics utilities and is used to convert sequence files into a numerical representation (one-hot encoding) that downstream models (for example convolutional neural networks or other sequence models) can consume. It uses BioPython's SeqIO.parse to read the sequence file specified by fname and then passes the parsed sequence records to seq_one_hot_encode to produce the final array. The ordering of letters controls the order of channels in the output and the default includes the common DNA alphabet with an ambiguity character ('N'). This function performs file I/O (reads the file at fname) and depends on BioPython being installed; if BioPython is not present an ImportError is raised. File reading or parsing errors from BioPython (for example FileNotFoundError or parsing of a malformed file) will propagate to the caller.` |
| `deepchem_utils_genomics_utils_seq_one_hot_encode` | `deepchem.utils.genomics_utils.seq_one_hot_encode` | `deepchem/utils/genomics_utils.py` | `sequences: numpy.ndarray, letters: str = "ATCGN"` | `One-hot encodes a collection of genomic sequences into an image-like NumPy array for use in convolutional or other models that expect channeled image inputs in genomics and computational biology workflows (for example, converting DNA sequences to inputs for CNNs used in regulatory element prediction or sequence-based models in drug discovery). The function maps each character in the input sequences to a channel index according to the provided letters string and returns a 4D array where the second axis indexes letters and the final axis is a singleton channel dimension so the result can be treated as an image with one color channel.` |
| `deepchem_utils_geometry_utils_angle_between` | `deepchem.utils.geometry_utils.angle_between` | `deepchem/utils/geometry_utils.py` | `vector_i: numpy.ndarray, vector_j: numpy.ndarray` | `deepchem.utils.geometry_utils.angle_between returns the smaller angle (in radians) between two 3-dimensional vectors. This function is used in geometric calculations common in DeepChem workflows (for example, computing bond angles or relative orientations of atomic displacement vectors in molecular and materials modelling) and returns a scalar float value in the range [0, pi].` |
| `deepchem_utils_geometry_utils_compute_centroid` | `deepchem.utils.geometry_utils.compute_centroid` | `deepchem/utils/geometry_utils.py` | `coordinates: numpy.ndarray` | `Compute the (x, y, z) centroid of the provided atomic coordinates. This utility computes the arithmetic mean position (centroid) over the set of 3D coordinates supplied. In the DeepChem molecular machine-learning context (drug discovery, materials science, quantum chemistry, biology), this centroid is commonly used as the geometric center of a molecule's atom positions for preprocessing tasks such as translating a molecule to the origin, centering coordinate-based features, or as a reference point for alignment and distance calculations. This function computes the center of geometry (simple mean of coordinates) and is distinct from a mass-weighted center of mass.` |
| `deepchem_utils_geometry_utils_compute_pairwise_distances` | `deepchem.utils.geometry_utils.compute_pairwise_distances` | `deepchem/utils/geometry_utils.py` | `first_coordinate: numpy.ndarray, second_coordinate: numpy.ndarray` | `Computes pairwise Euclidean distances between atoms of two molecules. This function is used in DeepChem workflows (for example in drug discovery, materials science, quantum chemistry, and computational biology) to build distance matrices, contact maps, and geometric descriptors from 3D atomic coordinates. Given two sets of 3D coordinates representing two molecules (or two fragments/ensembles of atoms), it returns an m-by-n array where the entry at (i, j) is the Euclidean distance (in Angstroms) between the i-th atom in the first set and the j-th atom in the second set. The function delegates the numeric computation to an optimized pairwise distance routine and performs no in-place modification of its inputs.` |
| `deepchem_utils_geometry_utils_compute_protein_range` | `deepchem.utils.geometry_utils.compute_protein_range` | `deepchem/utils/geometry_utils.py` | `coordinates: numpy.ndarray` | `Compute the protein range of provided coordinates. This function computes the axis-aligned extent (size) of a protein (or any set of atoms) along the three Cartesian axes by taking the element-wise difference between the maximum and minimum coordinates across all atoms. In DeepChem workflows (for example, preparing inputs for voxelization, bounding-box cropping, or spatial featurizers in drug discovery and structural biology), this range vector is used to determine the size of the protein along x, y, and z and to guide grid sizing, padding, or scale normalization. The returned values are in the same units as the input coordinates (typically Angstroms when coordinates are read from PDB files).` |
| `deepchem_utils_geometry_utils_is_angle_within_cutoff` | `deepchem.utils.geometry_utils.is_angle_within_cutoff` | `deepchem/utils/geometry_utils.py` | `vector_i: numpy.ndarray, vector_j: numpy.ndarray, angle_cutoff: float` | `deepchem.utils.geometry_utils.is_angle_within_cutoff: Determine whether two 3-D vectors are within a specified angular deviation (in degrees) of being exactly 180 degrees apart. This function is used in DeepChem geometry utilities to detect anti-parallel or nearly anti-parallel directions (for example, opposing bond directions or opposite normals) by computing the angle between vectors in degrees and testing whether that angle lies strictly within the symmetric interval (180 - angle_cutoff, 180 + angle_cutoff).` |
| `deepchem_utils_geometry_utils_rotate_molecules` | `deepchem.utils.geometry_utils.rotate_molecules` | `deepchem/utils/geometry_utils.py` | `mol_coordinates_list: list` | `deepchem.utils.geometry_utils.rotate_molecules rotates a collection of molecular Cartesian coordinate sets by a single random 3D rotation matrix. Rotates each molecule's 3D atomic coordinates by generating one random rotation matrix via generate_random_rotation_matrix() and applying that same rotation to every molecule in mol_coordinates_list. This is typically used in DeepChem workflows for molecular machine learning and data augmentation in drug discovery, materials science, and computational chemistry to produce rotated variants of molecular geometries while preserving interatomic distances and overall molecular shape. The random rotation matrix is drawn so that applying it to a 3-vector uniformly samples orientations on the sphere of radius equal to the vector norm, as implemented by generate_random_rotation_matrix(). The function performs a deep copy of each input coordinate array before applying the rotation, so the input objects are not modified.` |
| `deepchem_utils_geometry_utils_subtract_centroid` | `deepchem.utils.geometry_utils.subtract_centroid` | `deepchem/utils/geometry_utils.py` | `coordinates: numpy.ndarray, centroid: numpy.ndarray` | `deepchem.utils.geometry_utils.subtract_centroid subtracts a 3-D centroid vector from every atom coordinate in a molecular coordinate array, centering the molecule at the origin for downstream geometric or machine-learning tasks (for example, preparing inputs for models in DeepChem used in drug discovery and computational chemistry). This function performs an in-place, componentwise subtraction of the provided centroid (x, y, z) from each row of the coordinates array. It is intended for preprocessing molecular geometries represented as NumPy arrays, making coordinate sets translation-invariant for algorithms that assume centered inputs. The operation mutates the input coordinates array and also returns it for convenience; no new array is allocated by this function beyond NumPy's in-place update.` |
| `deepchem_utils_geometry_utils_unit_vector` | `deepchem.utils.geometry_utils.unit_vector` | `deepchem/utils/geometry_utils.py` | `vector: numpy.ndarray` | `deepchem.utils.geometry_utils.unit_vector returns the unit (normalized) vector of a three-dimensional Cartesian vector. This utility is part of DeepChem's geometry utilities used in molecular machine learning and computational chemistry workflows (for example, to normalize bond direction vectors, compute molecular orientation axes, or prepare direction features for models).` |
| `deepchem_utils_graph_utils_aggregate_max` | `deepchem.utils.graph_utils.aggregate_max` | `deepchem/utils/graph_utils.py` | `h: torch.Tensor, **kwargs` | `aggregate_max Computes the element-wise maximum of a tensor along its second-to-last dimension. This function is part of DeepChem's graph utilities and is used to perform a max-aggregation (max pooling) operation across the second-to-last axis of a feature tensor. In graph and molecular machine learning workflows (as in DeepChem), this operation is commonly used to aggregate node or neighbor feature information into a summary representation by taking the maximum value across that axis. The function returns only the maximum values for each element across that axis (it does not return the indices of the maxima).` |
| `deepchem_utils_graph_utils_aggregate_mean` | `deepchem.utils.graph_utils.aggregate_mean` | `deepchem/utils/graph_utils.py` | `h: torch.Tensor, **kwargs` | `deepchem.utils.graph_utils.aggregate_mean computes the arithmetic mean of an input PyTorch tensor over its second-to-last dimension. This function is provided in DeepChem's graph utilities and is commonly used in graph neural network (GNN) code paths within DeepChem to aggregate features across a neighbor or atom dimension when building models for drug discovery, materials science, quantum chemistry, and biology. This operation is a pure, functional tensor reduction: it does not modify the input tensor in-place and yields a new torch.Tensor. The operation is differentiable through PyTorch's autograd, so it can be used in model forward passes and participate in gradient-based optimization.` |
| `deepchem_utils_graph_utils_aggregate_min` | `deepchem.utils.graph_utils.aggregate_min` | `deepchem/utils/graph_utils.py` | `h: torch.Tensor, **kwargs` | `Compute the elementwise minimum of the input tensor along its second-to-last dimension.` |
| `deepchem_utils_graph_utils_aggregate_moment` | `deepchem.utils.graph_utils.aggregate_moment` | `deepchem/utils/graph_utils.py` | `h: torch.Tensor, n: int = 3, **kwargs` | `Compute the n-th central moment aggregated along the second-to-last dimension of a tensor and return its signed n-th root. This function is used in DeepChem's graph utilities to aggregate feature tensors (for example, node feature arrays in molecular/graph representations) into higher-order distributional descriptors that capture variance/skewness/kurtosis-like information. Concretely, for an input tensor h the function computes h_mean = mean(h, dim=-2, keepdim=True), then h_n = mean((h - h_mean)**n, dim=-2), and finally returns sign(h_n) * (abs(h_n) + EPS)**(1.0 / n). EPS is a small, module-level constant added to the absolute value before taking the n-th root to improve numerical stability. The second-to-last dimension of h is reduced (aggregated) by this operation; the returned tensor has that dimension removed.` |
| `deepchem_utils_graph_utils_aggregate_std` | `deepchem.utils.graph_utils.aggregate_std` | `deepchem/utils/graph_utils.py` | `h: torch.Tensor, **kwargs` | `deepchem.utils.graph_utils.aggregate_std computes the standard deviation of the input tensor along its second-to-last dimension and returns that per-position measure of variability. This function is provided in DeepChem's graph utilities and is typically used in graph neural network feature aggregation (for example, computing per-feature variability across nodes in a molecular graph) in DeepChem workflows for drug discovery, materials science, quantum chemistry, and biology.` |
| `deepchem_utils_graph_utils_aggregate_sum` | `deepchem.utils.graph_utils.aggregate_sum` | `deepchem/utils/graph_utils.py` | `h: torch.Tensor, **kwargs` | `Compute the sum of the input tensor along the second-to-last dimension. This function is a small utility used by DeepChem graph utilities to perform a common aggregation operation in graph neural networks: summing feature vectors across a neighborhood axis (for example, summing messages from neighbors for each node). In the context of DeepChem's application domains (drug discovery, materials science, quantum chemistry, and biology), this operation is typically used to aggregate per-edge or per-neighbor feature tensors into per-node feature representations during message-passing or readout steps. The implementation delegates to torch.sum with dim=-2 and does not modify the input tensor in place.` |
| `deepchem_utils_graph_utils_aggregate_var` | `deepchem.utils.graph_utils.aggregate_var` | `deepchem/utils/graph_utils.py` | `h: torch.Tensor, **kwargs` | `Compute the variance of the input tensor along its second-to-last dimension. This function is used in DeepChem's graph utilities (deepchem.utils.graph_utils) to produce a per-feature variance aggregated over an axis that commonly represents neighbors or messages in graph neural network pipelines (for example, computing the variance of node features across neighboring nodes or the variance of message vectors across incoming edges). The implementation computes E[x^2] - (E[x])^2 along dim=-2 and applies a ReLU clamp to guard against small negative values that can arise from floating-point rounding. The operation is implemented with standard PyTorch ops (torch.mean, elementwise multiplication, torch.relu) and preserves autograd flow (except for ReLU's subgradient behavior at zero).` |
| `deepchem_utils_graph_utils_fourier_encode_dist` | `deepchem.utils.graph_utils.fourier_encode_dist` | `deepchem/utils/graph_utils.py` | `x: torch.Tensor, num_encodings: int = 4, include_self: bool = True` | `deepchem.utils.graph_utils.fourier_encode_dist performs a Fourier-style encoding of a tensor of scalar values (typically inter-node or inter-atomic distances used in graph-based molecular models) by applying sinusoidal basis functions at multiple scales. The function divides the input values by powers-of-two scales (2**i for i in range(num_encodings)), computes sine and cosine for each scaled value, and concatenates these trigonometric features. Optionally, the original input values can be appended to the encoded features to preserve the absolute magnitude information. This encoding is commonly used in graph neural networks and other geometric deep learning models within DeepChem to provide models with multi-scale, periodic features that help represent distance-based relationships in molecules and materials.` |
| `deepchem_utils_graph_utils_scale_amplification` | `deepchem.utils.graph_utils.scale_amplification` | `deepchem/utils/graph_utils.py` | `h: torch.Tensor, D: torch.Tensor, avg_d: dict` | `deepchem.utils.graph_utils.scale_amplification: Compute a degree-based amplification scaling factor and apply it to an input tensor h. This function implements the scaling used in graph neural network preprocessing or message-passing layers to normalize or amplify node feature activations according to node degree statistics computed on the training set. It is intended for use in DeepChem workflows for molecular machine learning tasks such as drug discovery, materials science, quantum chemistry, and biology where graph degree statistics are used to stabilize learning across nodes of varying connectivity.` |
| `deepchem_utils_graph_utils_scale_attenuation` | `deepchem.utils.graph_utils.scale_attenuation` | `deepchem/utils/graph_utils.py` | `h: torch.Tensor, D: torch.Tensor, avg_d: dict` | `deepchem.utils.graph_utils.scale_attenuation scales node feature tensors by a degree-dependent attenuation factor computed from training-set averages. This function implements the elementwise operation h * (avg_d["log"] / np.log(D + 1)), which realizes the attenuation described in the source as (log(D + 1))^-1 re-scaled by the training-set average of (log(D + 1))^-1. In DeepChem this is used to normalize attention or message-passing updates in graph neural network models for molecular and biological graphs so that nodes with different connectivity (degree) are attenuated according to statistics observed during training.` |
| `deepchem_utils_graph_utils_scale_identity` | `deepchem.utils.graph_utils.scale_identity` | `deepchem/utils/graph_utils.py` | `h: torch.Tensor, D: torch.Tensor = None, avg_d: dict = None` | `deepchem.utils.graph_utils.scale_identity returns the input tensor unchanged and is intended as the "no-op" scaling function used in DeepChem graph utilities when node- or graph-level features should not be rescaled. In the DeepChem context (molecular machine learning, graph neural networks for drug discovery, materials science, and biology), this function serves as a placeholder or default scaling strategy in preprocessing or in model forward passes where other scaling functions (which may use node degree information or dataset averages) would normally be applied.` |
| `deepchem_utils_hash_utils_hash_ecfp` | `deepchem.utils.hash_utils.hash_ecfp` | `deepchem/utils/hash_utils.py` | `ecfp: str, size: int = 1024` | `deepchem.utils.hash_utils.hash_ecfp returns a deterministic integer index in the range [0, size) computed from an input ECFP fragment string; it is used by DeepChem to fold arbitrary-length ECFP fragment identifiers into fixed-size integer indices for constructing ECFP-based fingerprint vectors used in molecular machine learning and chemoinformatics pipelines. This function encodes the input string using UTF-8, computes an MD5 digest, converts that digest to a base-16 integer, and reduces it modulo the provided size to produce a stable, platform-independent index. It is intended to map ECFP fragment identifiers (typically produced by RDKit or similar cheminformatics tools) into bit positions of a fixed-length fingerprint array so that downstream models in DeepChem can consume consistent, bounded-length feature vectors.` |
| `deepchem_utils_hash_utils_hash_ecfp_pair` | `deepchem.utils.hash_utils.hash_ecfp_pair` | `deepchem/utils/hash_utils.py` | `ecfp_pair: Tuple[str, str], size: int = 1024` | `Compute a deterministic integer hash in the range [0, size) that represents a pair of ECFP (Extended-Connectivity Fingerprint) fragment strings. This function is used by DeepChem spatial contact featurizers to map a pair of fragment identifiers (for example, a protein fragment and a ligand fragment that are in close spatial contact) to a single integer index. The resulting index can be used as an entry in a fixed-length fingerprint vector or as a bucket identifier in featurization pipelines. The function constructs a single string from the two fragments using the comma separator "%s,%s", encodes it with UTF-8, computes the MD5 digest, interprets the digest as a base-16 integer, and reduces it modulo size to produce the final integer. The default size of 1024 corresponds to a common fingerprint length used in DeepChem examples and featurizers.` |
| `deepchem_utils_misc_utils_indent` | `deepchem.utils.misc_utils.indent` | `deepchem/utils/misc_utils.py` | `s: str, nspace: int` | `deepchem.utils.misc_utils.indent indents every line after the first by a fixed number of spaces to produce a multi-line string suitable for readable string representations of DeepChem objects. This function is used to format the string representation of objects in DeepChem (for example LinearOperator and other composite objects) where the human-readable repr or str contains multiple lines. It preserves the first line exactly and prefixes the second and subsequent lines with a block of spaces so that nested or multi-line contents align visually in logs, model summaries, and debugging output.` |
| `deepchem_utils_misc_utils_shape2str` | `deepchem.utils.misc_utils.shape2str` | `deepchem/utils/misc_utils.py` | `shape: tuple` | `deepchem.utils.misc_utils.shape2str converts a shape tuple into a concise, human-readable string. This function is intended for use in DeepChem logging, error messages, and user-facing text where a compact, readable representation of array/tensor shapes (for example NumPy arrays or model tensors) is required.` |
| `deepchem_utils_noncovalent_utils_compute_hbonds_in_range` | `deepchem.utils.noncovalent_utils.compute_hbonds_in_range` | `deepchem/utils/noncovalent_utils.py` | `frag1: tuple, frag2: tuple, pairwise_distances: numpy.ndarray, hbond_dist_bin: tuple, hbond_angle_cutoff: list` | `Compute all atom-index pairs between two molecular fragments that satisfy a hydrogen-bond distance bin and angle cutoff. This function is part of DeepChem's noncovalent interaction utilities used in drug discovery and molecular modeling workflows (see DeepChem README). It examines a precomputed matrix of pairwise inter-atomic distances between two fragments and returns those atom-index pairs that both fall inside an exclusive distance window (hbond_dist_bin) and pass an angular test implemented by the helper is_hydrogen_bond. The function treats input fragments as tuples (containing coordinates and an RDKit molecule object or a MolecularFragment object) and is typically used when featurizing or scoring noncovalent interactions (hydrogen bonds) between ligand and receptor fragments for machine learning or analysis pipelines.` |
| `deepchem_utils_noncovalent_utils_compute_hydrogen_bonds` | `deepchem.utils.noncovalent_utils.compute_hydrogen_bonds` | `deepchem/utils/noncovalent_utils.py` | `frag1: tuple, frag2: tuple, pairwise_distances: numpy.ndarray, hbond_dist_bins: list, hbond_angle_cutoffs: list` | `Computes hydrogen bonds between two molecular fragments (typically a protein and a ligand) and groups the detected contacts by distance bin. This function is used in DeepChem molecular featurization and interaction analysis to identify candidate hydrogen-bonding atom pairs for downstream tasks in drug discovery, molecular modeling, and structure-based feature engineering. The routine delegates per-bin detection to compute_hbonds_in_range and returns a list where each element corresponds to the hydrogen-bond contacts found for a single distance range (bin).` |
| `deepchem_utils_noncovalent_utils_is_cation_pi` | `deepchem.utils.noncovalent_utils.is_cation_pi` | `deepchem/utils/noncovalent_utils.py` | `cation_position: numpy.ndarray, ring_center: numpy.ndarray, ring_normal: numpy.ndarray, dist_cutoff: float = 6.5, angle_cutoff: float = 30.0` | `Determine whether a cation and an aromatic ring form a cation‚ÄìœÄ contact using geometric criteria (distance and angular alignment). This function is used in DeepChem's noncovalent interaction utilities to detect cation‚ÄìœÄ interactions commonly important in protein‚Äìligand recognition, molecular binding, and drug discovery workflows.` |
| `deepchem_utils_noncovalent_utils_is_hydrogen_bond` | `deepchem.utils.noncovalent_utils.is_hydrogen_bond` | `deepchem/utils/noncovalent_utils.py` | `frag1: tuple, frag2: tuple, contact: tuple, hbond_distance_cutoff: float = 4.0, hbond_angle_cutoff: float = 40.0` | `Determine whether a specified atom pair contact between two molecular fragments represents a hydrogen bond in the context of noncovalent interaction analysis used by DeepChem for molecular machine learning and computational chemistry tasks. This function inspects the two fragments provided as tuples of (coords, molecule) where coords are the atomic coordinates and molecule is an RDKit Mol or DeepChem MolecularFragment. It checks that the two contact atoms are potential hydrogen-bond participants (nitrogen or oxygen, atomic numbers 7 or 8), collects nearby hydrogen atom positions that appear covalently bonded to those heavy atoms (using a 1.3 √Ö threshold for O‚ÄìH / N‚ÄìH detection), and then evaluates the geometric angle formed by the hydrogen, donor, and acceptor to decide whether the geometry is consistent with a hydrogen bond. The function returns True if a qualifying hydrogen and geometry are found, otherwise False. Note that although a hbond_distance_cutoff parameter exists with a default of 4.0, the current implementation does not use that cutoff; hydrogen detection uses an internal 1.3 √Ö bond-length filter and angle checking is performed via is_angle_within_cutoff against the hbond_angle_cutoff.` |
| `deepchem_utils_noncovalent_utils_is_pi_parallel` | `deepchem.utils.noncovalent_utils.is_pi_parallel` | `deepchem/utils/noncovalent_utils.py` | `ring1_center: numpy.ndarray, ring1_normal: numpy.ndarray, ring2_center: numpy.ndarray, ring2_normal: numpy.ndarray, dist_cutoff: float = 8.0, angle_cutoff: float = 30.0` | `Check whether two aromatic rings form a parallel pi‚Äìpi contact used in noncovalent interaction detection for molecular modelling and drug discovery. This function is used in DeepChem to identify parallel stacking between aromatic rings, a common noncovalent interaction relevant to ligand binding, molecular recognition, and conformational analysis. It compares the Euclidean distance between ring centers and the angle between ring normal vectors against user-provided cutoffs to decide whether the rings are in a parallel pi‚Äìpi arrangement. The ring center and normal vectors can be produced with helper utilities such as compute_ring_center and compute_ring_normal; the angle is computed via angle_between and converted from radians to degrees.` |
| `deepchem_utils_noncovalent_utils_is_pi_t` | `deepchem.utils.noncovalent_utils.is_pi_t` | `deepchem/utils/noncovalent_utils.py` | `ring1_center: numpy.ndarray, ring1_normal: numpy.ndarray, ring2_center: numpy.ndarray, ring2_normal: numpy.ndarray, dist_cutoff: float = 5.5, angle_cutoff: float = 30.0` | `Check whether two aromatic ring planes form a T-shaped (perpendicular) pi‚Äìpi contact used in noncovalent interaction analysis. This function is used in DeepChem's noncovalent interaction utilities to identify T-shaped aromatic pi‚Äìpi contacts between two rings, a common motif important for molecular recognition in drug discovery, materials science, and computational chemistry. The function compares the Euclidean distance between the two ring centers and the angle between their plane normals (converted to degrees) against the supplied cutoffs. It expects ring centers and normals to be provided (for example, computed with compute_ring_center and compute_ring_normal utilities in this module). The decision logic uses a strict angle test (angle must lie strictly between the bounds) and a strict distance test (distance must be strictly less than dist_cutoff).` |
| `deepchem_utils_periodic_table_utils_get_atom_mass` | `deepchem.utils.periodic_table_utils.get_atom_mass` | `deepchem/utils/periodic_table_utils.py` | `atom_z: int` | `Return the atomic mass for the element with the given atomic number, expressed in atomic units (electron mass units). This function is used in DeepChem's quantum-chemistry and molecular modeling utilities to supply nuclear masses in the unit system expected by certain electronic-structure and differentiable DFT code (for example, code derived from the referenced DQC implementation). It looks up a canonical atomic mass (stored in the module-level atom_masses mapping) and converts that mass from atomic mass units (unified atomic mass unit, u) to atomic units of mass by multiplying by 1822.888486209 (the conversion factor from u to electron masses).` |
| `deepchem_utils_periodic_table_utils_get_period` | `deepchem.utils.periodic_table_utils.get_period` | `deepchem/utils/periodic_table_utils.py` | `atom_z: int` | `get_period returns the chemical period (row) in the periodic table for a given atomic number. This function maps a nuclear charge (atomic number) to the corresponding period index used in periodic-table based features and analyses. In DeepChem this is used when converting elemental identity into simple periodic descriptors for tasks in drug discovery, materials science, quantum chemistry, and molecular machine learning (for example, featurizers or models that rely on period-based grouping of elements). The implementation uses fixed atomic-number cutoffs that correspond to the standard periods 1 through 7 of the modern periodic table.` |
| `deepchem_utils_pytorch_utils_tallqr` | `deepchem.utils.pytorch_utils.tallqr` | `deepchem/utils/pytorch_utils.py` | `V: torch.Tensor, MV: torch.Tensor = None` | `deepchem.utils.pytorch_utils.tallqr: Compute a QR-like decomposition for tall-and-skinny matrices using PyTorch, producing an orthogonal factor Q and an upper-triangular factor R. This function is implemented in DeepChem's PyTorch utilities and is used to orthonormalize column bases that arise in linear-algebra subroutines common in molecular machine learning, quantum chemistry, and other scientific applications supported by DeepChem. For the common case MV is None, tallqr performs a standard thin QR for a tall-and-skinny V; when MV is provided, the routine produces a Q that is orthogonal with respect to the metric defined by MV (an "M-orthogonal" basis), which is useful when orthonormality must be measured against a nontrivial inner product or preconditioner. This implementation computes V^T @ MV, forms a Cholesky factorization of the resulting small Gram matrix, and obtains R from that factorization. It then computes Q = V @ R^{-1}. The routine is optimized for the case where V has many more rows than columns ("tall and skinny") and operates on PyTorch tensors without modifying the inputs in-place.` |
| `deepchem_utils_pytorch_utils_to_fortran_order` | `deepchem.utils.pytorch_utils.to_fortran_order` | `deepchem/utils/pytorch_utils.py` | `V: torch.Tensor` | `Convert a PyTorch tensor so that its last two dimensions use Fortran (column-major) memory ordering. This utility is used in DeepChem's PyTorch integration to ensure matrices (the last two dimensions of a tensor) have column-major layout required by some linear-algebra code paths and external libraries that expect Fortran-order arrays (for example, BLAS/LAPACK-style routines). The function operates only on the final two dimensions of V and preserves the tensor's shape, dtype, and device while adjusting memory layout. It is useful when preparing 2-D matrices or batches of matrices for operations that rely on column-major memory layout in the life-sciences and molecular machine-learning workflows supported by DeepChem.` |
| `deepchem_utils_rdkit_utils_get_contact_atom_indices` | `deepchem.utils.rdkit_utils.get_contact_atom_indices` | `deepchem/utils/rdkit_utils.py` | `fragments: List, cutoff: float = 4.5` | `deepchem.utils.rdkit_utils.get_contact_atom_indices computes which atom indices in each fragment are within a spatial contact region relative to atoms in other fragments in a molecular complex. This function is used in DeepChem workflows (for example in molecular machine learning and drug discovery pipelines) to trim large molecular complexes by keeping only atoms that are close to inter-molecular contact regions. Trimming reduces memory and compute cost for downstream calculations (feature generation, scoring, or model inputs). The function iterates over all unordered pairs of fragments, computes pairwise distances between the coordinate arrays of the two fragments using compute_pairwise_distances, and marks any atom in either fragment as a contact atom if it lies within cutoff angstroms of any atom in the other fragment. The final output is, for each fragment, the sorted list of 0-based atom indices that should be retained for subsequent contact-based analyses.` |
| `deepchem_utils_rdkit_utils_load_molecule` | `deepchem.utils.rdkit_utils.load_molecule` | `deepchem/utils/rdkit_utils.py` | `molecule_file: str, add_hydrogens: bool = True, calc_charges: bool = True, sanitize: bool = True, is_protein: bool = False` | `deepchem.utils.rdkit_utils.load_molecule converts a molecular file on disk into a pair of (xyz coordinates, RDKit Mol) suitable for use in DeepChem preprocessing and modeling pipelines in drug discovery, materials science, quantum chemistry, and biology. This function reads common molecular file formats and returns the molecule's 3D coordinates (as produced by get_xyz_from_mol) together with an rdkit.Chem.Mol object representing the same molecule. It is used by DeepChem code that requires both geometric coordinates and an RDKit molecule object for further featurization, charge assignment, and downstream modeling.` |
| `deepchem_utils_rdkit_utils_merge_molecules` | `deepchem.utils.rdkit_utils.merge_molecules` | `deepchem/utils/rdkit_utils.py` | `molecules: list` | `Merge a list of RDKit molecule objects into a single RDKit molecule by concatenating their molecular graphs. This helper is used in DeepChem preprocessing and dataset construction for tasks in drug discovery, materials science, quantum chemistry, and biology (for example, building a single molecule representation from multiple fragments or components prior to featurization or model input).` |
| `deepchem_utils_rdkit_utils_merge_molecules_xyz` | `deepchem.utils.rdkit_utils.merge_molecules_xyz` | `deepchem/utils/rdkit_utils.py` | `xyzs: list` | `Merges coordinates of multiple molecules into a single contiguous coordinate matrix. This function is a small utility used by DeepChem's RDKit integration and featurization pipelines to combine per-molecule atomic coordinate arrays into one consolidated array suitable for downstream tasks such as constructing molecular graphs, batching molecules for model input, or performing geometry-based descriptors and quantum-chemistry workflows. It takes a Python list of per-molecule coordinate arrays (each describing the 3D positions of atoms in one molecule) and returns a single NumPy array containing all atom coordinates stacked along the first (row) dimension.` |
| `deepchem_utils_rdkit_utils_reduce_molecular_complex_to_contacts` | `deepchem.utils.rdkit_utils.reduce_molecular_complex_to_contacts` | `deepchem/utils/rdkit_utils.py` | `fragments: List, cutoff: float = 4.5` | `Reduce a molecular complex to only the atoms that participate in inter-fragment contacts. This utility function deepchem.utils.rdkit_utils.reduce_molecular_complex_to_contacts is used in DeepChem preprocessing and featurization pipelines (for example, when preparing protein‚Äìligand complexes for machine learning models in drug discovery and computational chemistry). Large molecular complexes can contain many atoms that are far from any contact interface; removing those atoms reduces memory usage and speeds up downstream computations (distance-based features, scoring functions, graph construction, etc.). The function identifies contact atoms by calling get_contact_atom_indices with the supplied cutoff (in angstroms) and then constructs a new, trimmed complex for each fragment by calling get_mol_subset. The input list order is preserved and a new list is returned; the input fragments are not modified in-place.` |
| `deepchem_utils_sequence_utils_MSA_to_dataset` | `deepchem.utils.sequence_utils.MSA_to_dataset` | `deepchem/utils/sequence_utils.py` | `msa_path: str` | `deepchem.utils.sequence_utils.MSA_to_dataset converts a multiple sequence alignment file into a DeepChem NumpyDataset suitable for downstream processing in DeepChem workflows for computational biology and life-science tasks. This function reads an MSA stored in FASTA format, extracts sequence identifiers and per-residue characters using Biopython's SeqIO, and packages the resulting sequences and ids into a deepchem.data.datasets.NumpyDataset instance so the alignment can be consumed by DeepChem featurizers, models, or dataset utilities. The function opens the file at msa_path for reading, parses records with SeqIO.parse(..., 'fasta'), appends each record.id to the ids list, and for each record iterates over the record to build a sequence as a list of residues (each residue is the element yielded by Biopython when iterating a SeqRecord, typically single-character strings). The function then constructs and returns NumpyDataset(X=sequences, ids=ids). NumpyDataset is imported inside the function implementation to avoid a circular import with DeepChem utilities. Behavior details, side effects, and failure modes: the function performs a file read and returns a new NumpyDataset; it does not write to disk or modify the input file. The file is opened using a with statement and will be closed on return or on exception. The function does not perform validation beyond FASTA parsing: it does not enforce that sequences are all the same length (though MSAs are generally expected to be aligned and of equal length), does not convert residues to numeric encodings, and does not remove or specially treat gap characters ‚Äî any characters present in the FASTA sequences are preserved in the per-residue lists. If msa_path does not point to a readable file, an IOError or FileNotFoundError will be raised by the open call; if the file is not valid FASTA, Bio.SeqIO.parse may raise an exception such as ValueError or yield no records, resulting in an empty dataset. Downstream DeepChem components may expect numeric feature arrays rather than lists of characters; users should apply appropriate featurization after calling this function.` |
| `deepchem_utils_sequence_utils_hhblits` | `deepchem.utils.sequence_utils.hhblits` | `deepchem/utils/sequence_utils.py` | `dataset_path: str, database: str = None, data_dir: str = None, evalue: float = 0.001, num_iterations: int = 2, num_threads: int = 4` | `deepchem.utils.sequence_utils.hhblits runs an HH-suite sequence search (as implemented in the repository by calling the hhsearch/hhblits binaries) to build a multiple-sequence alignment (MSA) for a protein sequence or an existing MSA and returns the path to the produced .a3m file. This function is used in the DeepChem toolchain to generate profile/MSA inputs for downstream protein modeling and bioinformatics workflows (for example, preparing inputs for structure prediction or feature generation in molecular machine learning). The function requires HH-suite binaries (hhsearch or hhblits) to be installed and available on the system PATH and requires a Hidden Markov Model (HMM) reference database. If data_dir is not provided, the function reads the DEEPCHEM_DATA_DIR environment variable to locate the database. The function constructs and executes an external command (via system_call) that writes a results.a3m file into the same directory as dataset_path.` |
| `deepchem_utils_sequence_utils_hhsearch` | `deepchem.utils.sequence_utils.hhsearch` | `deepchem/utils/sequence_utils.py` | `dataset_path: str, database: str = None, data_dir: str = None, evalue: float = 0.001, num_iterations: int = 2, num_threads: int = 4` | `deepchem.utils.sequence_utils.hhsearch runs an HH-suite hhsearch multisequence alignment search for a given sequence dataset and returns the path to the produced multiple sequence alignment (MSA) file. Within the DeepChem project (which provides tools for machine learning in biology and chemistry), this function is used to search a Hidden Markov Model (HMM) reference database to obtain an MSA for protein sequence analysis, feature generation, or downstream modeling workflows. This function invokes an external hhsearch/hh-suite binary on the host system and therefore performs filesystem and external-process side effects described below.` |
| `deepchem_utils_sequence_utils_system_call` | `deepchem.utils.sequence_utils.system_call` | `deepchem/utils/sequence_utils.py` | `command: str` | `Execute a shell command and return its captured standard output as raw bytes. This function is a minimal wrapper around subprocess.Popen used by deepchem.utils.sequence_utils to run system-level commands from Python code. In the DeepChem project (which provides tools for deep learning in drug discovery, materials science, quantum chemistry, and biology), this utility is intended to let sequence-processing code invoke external executables or shell utilities as part of data preparation or pipeline steps. The implementation calls subprocess.Popen([command], stdout=subprocess.PIPE, shell=True) and then reads the entire stdout stream via p.stdout.read(), returning the raw bytes produced by the child process. Behavior and side effects: - Spawns a new shell process and executes the provided command string. Because shell=True is used, the command is interpreted by the system shell. - The function captures only the child process's standard output (stdout) and returns it as bytes. Standard error (stderr) is not captured and will be directed to the parent process's stderr by default. - The call blocks while reading stdout and will wait until the child process closes its stdout pipe; there is no timeout or asynchronous behavior. - The entire stdout content is read into memory before being returned; commands that produce very large output may consume significant memory. - No exit status or return code is checked or returned; the function does not surface nonzero exit codes. Exceptions raised by subprocess.Popen (for example, OSError if the shell cannot be spawned) are not caught and will propagate to the caller. - Because the command string is executed through a shell, passing untrusted input as command can lead to shell injection vulnerabilities; callers must sanitize or avoid passing untrusted data.` |
| `deepchem_utils_voxel_utils_convert_atom_pair_to_voxel` | `deepchem.utils.voxel_utils.convert_atom_pair_to_voxel` | `deepchem/utils/voxel_utils.py` | `coordinates_tuple: Tuple[numpy.ndarray, numpy.ndarray], atom_index_pair: Tuple[int, int], box_width: float, voxel_width: float` | `Converts a pair of atoms (one from each of two molecules) into voxel grid indices (i, j, k) suitable for voxel-based 3D representations used in molecular machine learning and structure-aware models in DeepChem (for example, inputs to 3D convolutional networks or voxel featurizers used in drug discovery and materials modeling).` |
| `deepchem_utils_voxel_utils_convert_atom_to_voxel` | `deepchem.utils.voxel_utils.convert_atom_to_voxel` | `deepchem/utils/voxel_utils.py` | `coordinates: numpy.ndarray, atom_index: int, box_width: float, voxel_width: float` | `Converts a single atom's 3D Cartesian coordinates into integer voxel grid indices (i, j, k) by shifting coordinates into a box origin and discretizing by the voxel size. This is used in DeepChem featurizers that build 3D voxel grids (for example, inputs to 3D convolutional neural networks in molecular machine learning and computational chemistry) to determine which voxel a particular atom occupies. The function offsets the atom coordinates by (box_width/2, box_width/2, box_width/2) so that the box center is treated as the origin at index (0,0,0) after discretization, divides the shifted coordinates by voxel_width, applies a floor operation to map continuous positions to integer voxel indices, and casts the result to integers using numpy.floor and astype(int). No in-place modification of inputs occurs.` |

## ‚öñÔ∏è License

Original Code License: MIT

Wrapper Code & Documentation: Apache-2.0

*This file was automatically generated on February 26, 2026.*
