# rdkit

[ðŸ”™ Back to Main Repo](../../../README.md) | [ðŸ”— Original Repo](https://github.com/rdkit/rdkit)

![Tool Count](https://img.shields.io/badge/Agent_Tools-110-blue?style=flat-square)
![Category](https://img.shields.io/badge/Category-Chemistry-green?style=flat-square)
![Status](https://img.shields.io/badge/Import_Test-Passed-success?style=flat-square)

## ðŸ“– Overview

RDKit is an open-source cheminformatics toolkit for working with molecular structures in Python, providing 2D/3D molecule operations plus descriptor and fingerprint generation for tasks like similarity search and machine learning.

> **Note**: This documentation lists the **agent-ready wrapper functions** generated for this package. These functions have been strictly typed, docstring-enhanced, and tested for import stability within a standardized Apptainer environment.

## ðŸ› ï¸ Available Agent Tools

Below is the list of **110** functions optimized for LLM tool-use.

| **Tool Name (Wrapper)**   | **Source**          | **File Path**     | **Arguments (Type)**        | **Description**                |
| ------------------------- | ------------------- | ----------------- | --------------------------- | ------------------------------ |
| `rdkit_Chem_CanonSmiles` | `rdkit.Chem.CanonSmiles` | `rdkit/Chem/__init__.py` | `smi: str, useChiral: bool = 1` | `rdkit.Chem.CanonSmiles: Return a canonical SMILES string for a molecule represented by an input SMILES. This convenience function is part of the RDKit cheminformatics toolkit and is used to produce a deterministic, canonical SMILES string for a molecule given an input SMILES representation. Canonical SMILES are useful in cheminformatics workflows (for example: deduplication of compound lists, database keys, fingerprinting and descriptor generation for machine learning, and reproducible serialization of molecular structures). The function parses the input SMILES into an RDKit Mol object using MolFromSmiles and then generates a canonical SMILES with MolToSmiles. The useChiral parameter controls whether stereochemical/chiral information is preserved in the output canonicalization.` |
| `rdkit_Chem_QuickSmartsMatch` | `rdkit.Chem.QuickSmartsMatch` | `rdkit/Chem/__init__.py` | `smi: str, sma: str, unique: bool = True, display: bool = False` | `rdkit.Chem.QuickSmartsMatch quickly matches a SMARTS substructure pattern against a SMILES molecule string and returns the atom index matches found in the molecule.` |
| `rdkit_Chem_SupplierFromFilename` | `rdkit.Chem.SupplierFromFilename` | `rdkit/Chem/__init__.py` | `fileN: str, delim: str = "", **kwargs` | `rdkit.Chem.SupplierFromFilename creates and returns an RDKit molecule supplier object selected by the input filename extension. This convenience factory inspects the filename extension and constructs one of the RDKit supplier classes (SDMolSupplier, SmilesMolSupplier, or TDTMolSupplier) so callers can iterate over or access molecules stored in common cheminformatics file formats for downstream tasks such as descriptor and fingerprint generation, substructure/similarity searching, or bulk database loading.` |
| `rdkit_Chem_AtomPairs_Pairs_ExplainPairScore` | `rdkit.Chem.AtomPairs.Pairs.ExplainPairScore` | `rdkit/Chem/AtomPairs/Pairs.py` | `score: int, includeChirality: bool = False` | `rdkit.Chem.AtomPairs.Pairs.ExplainPairScore decodes an integer "score" value produced by RDKit Atom Pairs encoding into the three logical components used by atom-pair fingerprints: the first atom code, the topological distance (path length) between the two atoms, and the second atom code. This function is used in cheminformatics workflows to interpret and human-readably explain the compact integer representation generated by pyScorePair and AtomPairs fingerprint encoders so that users can see which atom environments and what inter-atomic distance the integer encodes. The function interprets the integer by applying bit masks and shifts. It computes a code size from rdMolDescriptors.AtomPairsParameters.codeSize and, if includeChirality is True, adds rdMolDescriptors.AtomPairsParameters.numChiralBits to account for chiral information. A path mask based on the module-level numPathBits is used to extract the distance (path length) encoded in the low-order bits. The remaining bits are split into two atom codes; each atom code is decoded by calling Utils.ExplainAtomCode(..., includeChirality=includeChirality). No mutation of inputs or global state occurs.` |
| `rdkit_Chem_AtomPairs_Torsions_ExplainPathScore` | `rdkit.Chem.AtomPairs.Torsions.ExplainPathScore` | `rdkit/Chem/AtomPairs/Torsions.py` | `score: int, size: int = 4` | `rdkit.Chem.AtomPairs.Torsions.ExplainPathScore decodes an encoded integer path score (the integer produced by the AtomPairs torsion scoring code such as pyScorePath) into a per-atom explanation useful for human inspection and cheminformatics debugging. The function is used in RDKit to recover, for each atom along a scored path, the atom symbol, an adjusted branch/substituent count used by the torsion scoring routine, and the number of pi-electrons/features that were encoded for that atom.` |
| `rdkit_Chem_AtomPairs_Utils_BitsInCommon` | `rdkit.Chem.AtomPairs.Utils.BitsInCommon` | `rdkit/Chem/AtomPairs/Utils.py` | `v1: tuple, v2: tuple` | `Compute the number of bit identifiers that occur in common between two sorted bitâ€‘id vectors used as molecular fingerprints. This function is part of RDKit's AtomPairs.Utils utilities and is used in cheminformatics tasks that compare fingerprint-like representations of molecules. Each input vector represents the positions (IDs) of set bits in a fingerprint; the function counts how many bit IDs are shared between the two vectors. In practical use within RDKit this count can serve as the numerator for similarity measures (for example, the intersection used when computing Tanimoto similarity) or as a fast overlap check between atom-pair/fingerprint bit lists.` |
| `rdkit_Chem_AtomPairs_Utils_CosineSimilarity` | `rdkit.Chem.AtomPairs.Utils.CosineSimilarity` | `rdkit/Chem/AtomPairs/Utils.py` | `v1: tuple, v2: tuple` | `rdkit.Chem.AtomPairs.Utils.CosineSimilarity computes the cosine similarity between two fingerprint vectors represented as sorted tuples of bit identifiers. This function implements the metric recommended in the LaSSI paper and is intended for comparing molecular fingerprints or other non-negative integer bit-id encodings used in RDKit for similarity searching, clustering, and descriptor-based machine learning.` |
| `rdkit_Chem_AtomPairs_Utils_DiceSimilarity` | `rdkit.Chem.AtomPairs.Utils.DiceSimilarity` | `rdkit/Chem/AtomPairs/Utils.py` | `v1: tuple, v2: tuple, bounds: float = None` | `rdkit.Chem.AtomPairs.Utils.DiceSimilarity computes the DICE similarity coefficient for two fingerprint-like vectors of bit identifiers used in RDKit atom-pair and topological-torsion fingerprinting. This function implements the metric recommended in the Topological Torsions and Atom Pairs papers and is intended for comparing molecular fingerprints for similarity searching, clustering, and descriptor-based machine-learning workflows in cheminformatics.` |
| `rdkit_Chem_AtomPairs_Utils_Dot` | `rdkit.Chem.AtomPairs.Utils.Dot` | `rdkit/Chem/AtomPairs/Utils.py` | `v1: tuple, v2: tuple` | `rdkit.Chem.AtomPairs.Utils.Dot computes the dot product between two sorted integer vectors of bit identifiers used in RDKit fingerprint-like representations. Computes a specialized integer "dot product" between two sequences of bit IDs (sparse fingerprint vectors) that are stored as tuples of integers. In the AtomPairs/fingerprints domain of RDKit (cheminformatics and molecular descriptors), these tuples represent the indices of bits set in a fingerprint; this function determines a weighted count of shared bit indices while accounting for duplicate occurrences. The implementation uses a single-pass, merge-like algorithm over the two sorted input tuples so it runs in linear time relative to the sum of the input lengths.` |
| `rdkit_Chem_AtomPairs_Utils_ExplainAtomCode` | `rdkit.Chem.AtomPairs.Utils.ExplainAtomCode` | `rdkit/Chem/AtomPairs/Utils.py` | `code: int, branchSubtract: int = 0, includeChirality: bool = False` | `ExplainAtomCode returns a human-readable breakdown of an integer atom code used by RDKit's Atom Pairs / topological torsions encoding. It decodes the packed bitfields (type index, branch count, pi-related count, and optionally chirality) using the bit widths and type table defined in rdMolDescriptors.AtomPairsParameters, and maps the atom type index to an element symbol using RDKit's periodic table. This function is intended for diagnostics and interpretation of atom codes produced by GetAtomCode or equivalent Atom Pairs encoding routines in cheminformatics workflows (for example when inspecting atom features used in fingerprint or descriptor calculations).` |
| `rdkit_Chem_BRICS_BRICSBuild` | `rdkit.Chem.BRICS.BRICSBuild` | `rdkit/Chem/BRICS.py` | `fragments: list, onlyCompleteMols: bool = True, seeds: list = None, uniquify: bool = True, scrambleReagents: bool = True, maxDepth: int = 3` | `rdkit.Chem.BRICS.BRICSBuild builds new RDKit molecules by iteratively reconnecting BRICS fragments using the BRICS reverse reactions. This function is part of RDKit's cheminformatics toolkit and is used to enumerate candidate molecules by matching fragment attachment-point patterns, running the corresponding reverse BRICS reactions to join fragments, and optionally recursing to extend assemblies up to a specified depth.` |
| `rdkit_Chem_BuildFragmentCatalog_CalcGainsFromFps` | `rdkit.Chem.BuildFragmentCatalog.CalcGainsFromFps` | `rdkit/Chem/BuildFragmentCatalog.py` | `suppl: list, fps: list, topN: int = -1, actName: str = "", acts: list = None, nActs: int = 2, reportFreq: int = 10, biasList: list = None` | `rdkit.Chem.BuildFragmentCatalog.CalcGainsFromFps calculates information gains for fingerprint bits from a collection of molecules and their corresponding fingerprint vectors, using RDKit's InfoTheory.InfoBitRanker. This function is used in cheminformatics workflows (for example, when building fragment catalogs or selecting discriminative fingerprint bits/descriptors for machine learning) to rank fingerprint bit positions by how informative they are with respect to an activity/label.` |
| `rdkit_Chem_ChemUtils_DescriptorUtilities_setDescriptorVersion` | `rdkit.Chem.ChemUtils.DescriptorUtilities.setDescriptorVersion` | `rdkit/Chem/ChemUtils/DescriptorUtilities.py` | `version: str = "1.0.0"` | `rdkit.Chem.ChemUtils.DescriptorUtilities.setDescriptorVersion sets a version string on a descriptor function and returns a decorator that applies that metadata to the function. This is intended for use in the RDKit cheminformatics library to annotate descriptor-calculation callables (functions used to compute molecular descriptors and features for machine learning and database storage) with a stable version identifier that can be inspected by downstream tooling, descriptor registries, or serialization/database cartridges.` |
| `rdkit_Chem_ChemUtils_SDFToCSV_existingFile` | `rdkit.Chem.ChemUtils.SDFToCSV.existingFile` | `rdkit/Chem/ChemUtils/SDFToCSV.py` | `filename: str` | `rdkit.Chem.ChemUtils.SDFToCSV.existingFile: Validate that a filesystem path refers to an existing filesystem entry and return it unchanged. This function is intended to be used as the "type" callable for argparse when validating command-line filenames in RDKit utilities (for example SDF-to-CSV conversion scripts); it ensures a provided filename exists before downstream RDKit file-processing code is invoked.` |
| `rdkit_Chem_Draw_MolsMatrixToGridImage` | `rdkit.Chem.Draw.MolsMatrixToGridImage` | `rdkit/Chem/Draw/__init__.py` | `molsMatrix: list, subImgSize: tuple = (200, 200), legendsMatrix: list = None, highlightAtomListsMatrix: list = None, highlightBondListsMatrix: list = None, useSVG: bool = False, returnPNG: bool = False, **kwargs` | `Creates a grid image of molecules from a nested (matrix-like) Python list, where each inner list represents a row. This function is part of RDKit's cheminformatics drawing utilities and is used to assemble per-row molecular layouts (for example, generations in a fragmentation tree) into a single image by padding rows to the length of the longest row and delegating rendering to MolsToGridImage.` |
| `rdkit_Chem_Draw_MolsToImage` | `rdkit.Chem.Draw.MolsToImage` | `rdkit/Chem/Draw/__init__.py` | `mols: list, subImgSize: tuple = (200, 200), legends: list = None, **kwargs` | `rdkit.Chem.Draw.MolsToImage renders a sequence of RDKit molecule objects into a single horizontal composite image by creating a fixed-size subimage for each molecule and pasting them side-by-side into an RGBA canvas. This function is typically used in cheminformatics workflows (see RDKit) to create quick visual summaries of multiple molecules (for example, for reports, notebooks, or GUI displays) by delegating per-molecule rendering to MolToImage and composing the results.` |
| `rdkit_Chem_Draw_SimilarityMaps_GetStandardizedWeights` | `rdkit.Chem.Draw.SimilarityMaps.GetStandardizedWeights` | `rdkit/Chem/Draw/SimilarityMaps.py` | `weights: list` | `GetStandardizedWeights normalizes a sequence of per-atom weights so that the largest absolute weight becomes 1.0. This function is used in the cheminformatics context of rdkit.Chem.Draw.SimilarityMaps to prepare atomic contribution values (weights) for visualization and comparison across molecules or views. Given a list of numeric atomic weights (for example, per-atom similarity contributions or feature importances used when drawing similarity maps), the function rescales every weight by the maximum absolute weight found in the list so that the absolute maximum after scaling equals 1.0. This makes color/size mappings and cross-molecule comparisons meaningful and stable when rendering 2D similarity maps or other atom-level visual representations.` |
| `rdkit_Chem_EState_AtomTypes_BuildPatts` | `rdkit.Chem.EState.AtomTypes.BuildPatts` | `rdkit/Chem/EState/AtomTypes.py` | `rawV: list = None` | `BuildPatts compiles SMARTS patterns into RDKit Mol pattern objects and stores them in the module-level esPatterns list used by the EState atom-typing routines. This function is part of RDKit's cheminformatics EState (electrotopological state) machinery and is intended for internal use: it translates a sequence of named SMARTS pattern specifications into RDKit molecule pattern objects (Chem.Mol) that other EState code uses to match atom types. If rawV is omitted, the function reads the pattern specifications from the module-level _rawD. The function has no return value; instead it updates the global esPatterns variable to a list with the same length as rawV where each element is either None (if compilation failed or the pattern was skipped) or a tuple (name, patt) with patt being the RDKit Mol object produced by Chem.MolFromSmarts(sma). On SMARTS compilation failures the function writes a warning message to sys.stderr and leaves the corresponding esPatterns entry as None. Typical callers are other EState descriptor/atom-typing routines that expect esPatterns to contain compiled patterns for matching against molecule atoms.` |
| `rdkit_Chem_EState_EState_GetPrincipleQuantumNumber` | `rdkit.Chem.EState.EState.GetPrincipleQuantumNumber` | `rdkit/Chem/EState/EState.py` | `atNum: int` | `rdkit.Chem.EState.EState.GetPrincipleQuantumNumber maps an atomic number to the corresponding principal quantum number used by RDKit's EState (electrotopological state) calculations. This function is a small utility in the EState module that converts an element's atomic number (Z) into the principal quantum number (n) that represents the electron shell level used in descriptor calculations.` |
| `rdkit_Chem_FeatFinderCLI_existingFile` | `rdkit.Chem.FeatFinderCLI.existingFile` | `rdkit/Chem/FeatFinderCLI.py` | `filename: str` | `rdkit.Chem.FeatFinderCLI.existingFile: Type callable intended for use with argparse that verifies a provided filesystem path exists before the RDKit FeatFinder CLI proceeds to use it. In the RDKit cheminformatics CLI context this function is used to validate command-line arguments that are expected to be paths to existing files (for example input molecule files or feature definition files) so the program can fail early with a clear error instead of later encountering IO errors when opening or reading the file.` |
| `rdkit_Chem_Features_FeatDirUtilsRD_findNeighbors` | `rdkit.Chem.Features.FeatDirUtilsRD.findNeighbors` | `rdkit/Chem/Features/FeatDirUtilsRD.py` | `atomId: int, adjMat: list` | `Find the IDs of atoms that are directly bonded to a given atom in a molecular adjacency matrix. This function is used in RDKit's cheminformatics context to obtain the neighbor atom indices for graph-based operations (for example, building neighbor lists for traversals, computing local descriptors, feature detection, or preparing inputs for fingerprint and descriptor calculations). It inspects the adjacency matrix row for the atom of interest and returns the indices of entries that indicate a bond (any numeric entry >= 1 is treated as a bond presence). The function performs no modification of its inputs and returns a new list.` |
| `rdkit_Chem_MCS_FindMCS` | `rdkit.Chem.MCS.FindMCS` | `rdkit/Chem/MCS.py` | `mols: list, minNumAtoms: int = 2, maximize: str = "bonds", atomCompare: str = "elements", bondCompare: str = "bondtypes", matchValences: bool = False, ringMatchesRingOnly: bool = False, completeRingsOnly: bool = False, timeout: float = None, threshold: float = None` | `Find the maximum common substructure (MCS) of a set of molecules and return an MCSResult describing that substructure. This function is part of RDKit's cheminformatics toolkit and implements an exhaustive MCS search over the provided molecules. Note that this module is deprecated: a DeprecationWarning is issued and users are directed to use rdkit.Chem.rdFMCS for new code. The function is typically used in cheminformatics workflows to identify common scaffolds or subgraphs among multiple rdkit.Chem.Mol objects, for tasks such as scaffold analysis, clustering, or feature extraction for machine learning.` |
| `rdkit_Chem_MolKey_MolKey_ErrorBitsToText` | `rdkit.Chem.MolKey.MolKey.ErrorBitsToText` | `rdkit/Chem/MolKey/MolKey.py` | `err: int` | `Concise translator of MolKey error-bit integer codes into human-readable error labels used by RDKit MolKey routines.` |
| `rdkit_Chem_MolKey_MolKey_GetInchiForCTAB` | `rdkit.Chem.MolKey.MolKey.GetInchiForCTAB` | `rdkit/Chem/MolKey/MolKey.py` | `ctab: str` | `Get an InChI string and status information for a molecule provided as a CTAB (MolBlock) string. This function is part of RDKit's MolKey utilities and is used in cheminformatics workflows to convert a CTAB/MolBlock representation of a molecule into its standardized InChI identifier while validating and, where possible, fixing structural problems in the input CTAB. The routine performs a structural check using CheckCTAB(ctab, False), attempts to parse the (possibly fixed) MolBlock into an RDKit Mol without full sanitization, and then requests InChI generation using Chem.MolToInchi with options '/FixedH /SUU'. The returned result preserves any warnings or errors discovered during structural checking and combines them with any conversion or InChI-related errors into a single status bitmask.` |
| `rdkit_Chem_PandasTools_RGroupDecompositionToFrame` | `rdkit.Chem.PandasTools.RGroupDecompositionToFrame` | `rdkit/Chem/PandasTools.py` | `groups: dict, mols: list, include_core: bool = False, redraw_sidechains: bool = False` | `rdkit.Chem.PandasTools.RGroupDecompositionToFrame returns a pandas.DataFrame that organizes the results of an RDKit R-group decomposition into a table suitable for analysis and notebook display. It is used in cheminformatics workflows (see RDKit) to take the output of rdRGroupDecomposition.RGroupDecompose and produce a DataFrame whose rows correspond to input molecules and whose columns contain the original molecule and the extracted R-group fragments (and optionally the decomposition core).` |
| `rdkit_Chem_PandasTools_RenderImagesInAllDataFrames` | `rdkit.Chem.PandasTools.RenderImagesInAllDataFrames` | `rdkit/Chem/PandasTools.py` | `images: bool = True` | `rdkit.Chem.PandasTools.RenderImagesInAllDataFrames changes the global pandas DataFrame HTML rendering behavior so that HTML is not escaped and inline images (for example RDKit-generated molecule depictions) can be displayed in every DataFrame rendered in the current Python session.` |
| `rdkit_Chem_Pharm2D_Utils_BinsTriangleInequality` | `rdkit.Chem.Pharm2D.Utils.BinsTriangleInequality` | `rdkit/Chem/Pharm2D/Utils.py` | `d1: tuple, d2: tuple, d3: tuple` | `rdkit.Chem.Pharm2D.Utils.BinsTriangleInequality checks whether three binned distance intervals satisfy a conservative form of the triangle inequality used in Pharm2D pharmacophore/fingerprint calculations. This function is used when working with binned distance representations (distance bins) of pairwise feature separations in 2D pharmacophore or fingerprint generation. Each input tuple represents a bin as a (lower, upper) interval for a single pairwise distance. The check is conservative: it uses the upper bounds of two bins and the lower bound of the third to ensure that no combination of values drawn from the bins can violate the standard triangle inequality. This conservative test is useful for pruning impossible triplets of feature distances early in descriptor/fingerprint generation, improving performance and correctness of downstream cheminformatics algorithms.` |
| `rdkit_Chem_Pharm2D_Utils_CountUpTo` | `rdkit.Chem.Pharm2D.Utils.CountUpTo` | `rdkit/Chem/Pharm2D/Utils.py` | `nItems: int, nSlots: int, vs: list, idx: int = 0, startAt: int = 0` | `CountUpTo computes the zero-based rank (the count of preceding combinations) of a given combination of slot indices within the combinatorial enumeration produced by the Pharm2D index-combination generator (_GetIndexCombinations_). This function is part of RDKit's Chem.Pharm2D utilities used when enumerating combinations for descriptor/fingerprint generation in cheminformatics workflows (see RDKit documentation). It traverses the combination space using recursion and combinatorial counts (via NumCombinations) and uses a global cache to speed repeated queries.` |
| `rdkit_Chem_Pharm2D_Utils_GetAllCombinations` | `rdkit.Chem.Pharm2D.Utils.GetAllCombinations` | `rdkit/Chem/Pharm2D/Utils.py` | `choices: list, noDups: int = 1, which: int = 0` | `rdkit.Chem.Pharm2D.Utils.GetAllCombinations enumerates all possible combinations formed by picking one element from each sequence in a list of sequences. In the context of RDKit (a cheminformatics library) and the Pharm2D utilities, this function is used to generate all possible tuples of pharmacophoric/feature choices when constructing 2D pharmacophore descriptors or fingerprints; these enumerated combinations are the raw candidate feature vectors that downstream code will score or encode into descriptors.` |
| `rdkit_Chem_Pharm2D_Utils_GetIndexCombinations` | `rdkit.Chem.Pharm2D.Utils.GetIndexCombinations` | `rdkit/Chem/Pharm2D/Utils.py` | `nItems: int, nSlots: int, slot: int = 0, lastItemVal: int = 0` | `rdkit.Chem.Pharm2D.Utils.GetIndexCombinations generates all ordered index combinations used by Pharm2D utilities in RDKit for distributing a fixed number of items into a fixed number of slots without producing duplicate permutations. It is commonly used in RDKit pharmacophore/descriptor and fingerprint construction code to enumerate index tuples (for example, atom or feature indices) that represent combinations with repetition where the order of slots is fixed and permutations are suppressed.` |
| `rdkit_Chem_Pharm2D_Utils_GetPossibleScaffolds` | `rdkit.Chem.Pharm2D.Utils.GetPossibleScaffolds` | `rdkit/Chem/Pharm2D/Utils.py` | `nPts: int, bins: list, useTriangleInequality: bool = True` | `GetPossibleScaffolds returns all candidate pharmacophore scaffolds (distance-bin assignments) for a specified number of pharmacophore points, optionally filtering them to only those that satisfy the triangle inequality. In the RDKit Pharm2D context this function is used to enumerate all realizable assignments of inter-point distance bins (as used by Pharm2D fingerprinting and scaffold matching) given the discretized distance bins available.` |
| `rdkit_Chem_Pharm2D_Utils_GetTriangles` | `rdkit.Chem.Pharm2D.Utils.GetTriangles` | `rdkit/Chem/Pharm2D/Utils.py` | `nPts: int` | `rdkit.Chem.Pharm2D.Utils.GetTriangles returns the index triples that define the set of triangles used to represent an nPts-pharmacophore in RDKit's Pharm2D utilities. This function is used by the Pharm2D pharmacophore/fingerprint code to enumerate the combinations of three distance positions (points) that form the triangular features used in 3-point pharmacophore representations and downstream fingerprint calculations. The function computes a sliding-window set of triangles starting from the triple (0, 1, nPts-1) and incrementing each index in lock-step until the first index reaches nPts-2. The computed result is cached in the module-level dictionary _trianglesInPharmacophore to avoid recomputation for the same nPts on subsequent calls.` |
| `rdkit_Chem_Pharm2D_Utils_GetUniqueCombinations` | `rdkit.Chem.Pharm2D.Utils.GetUniqueCombinations` | `rdkit/Chem/Pharm2D/Utils.py` | `choices: list, classes: list` | `rdkit.Chem.Pharm2D.Utils.GetUniqueCombinations returns the set of unique, deterministic mappings between provided class identifiers and one selected item from each corresponding choices list while avoiding selections that reuse the same item across multiple class positions. In the RDKit Pharm2D context this utility is used when generating combinatorial assignments of pharmacophore or feature labels (classes) to candidate feature instances (choices) for descriptor/fingerprint enumeration, ensuring each returned combination maps each class to a distinct feature and that equivalent assignments are deduplicated and returned in a stable order.` |
| `rdkit_Chem_Pharm2D_Utils_NumCombinations` | `rdkit.Chem.Pharm2D.Utils.NumCombinations` | `rdkit/Chem/Pharm2D/Utils.py` | `nItems: int, nSlots: int` | `rdkit.Chem.Pharm2D.Utils.NumCombinations: Compute the number of unordered combinations with repetition for placing a set of items into a fixed number of slots. This function implements the "stars and bars" combinatorial formula used in RDKit's Pharm2D utilities to count how many distinct multisets of size nSlots can be formed from nItems types (for example, counting ways to assign pharmacophore feature types to fingerprint slots when order does not matter and repeats are allowed).` |
| `rdkit_Chem_Pharm2D_Utils_OrderTriangle` | `rdkit.Chem.Pharm2D.Utils.OrderTriangle` | `rdkit/Chem/Pharm2D/Utils.py` | `featIndices: list, dists: list` | `rdkit.Chem.Pharm2D.Utils.OrderTriangle canonicalizes the ordering of a triangle of pharmacophore feature indices and their associated pairwise distances so that the same geometric/feature triangle is represented consistently for fingerprinting, indexing, and comparison tasks in RDKit's Pharm2D utilities.` |
| `rdkit_Chem_Pharm2D_Utils_ScaffoldPasses` | `rdkit.Chem.Pharm2D.Utils.ScaffoldPasses` | `rdkit/Chem/Pharm2D/Utils.py` | `combo: list, bins: list = None` | `rdkit.Chem.Pharm2D.Utils.ScaffoldPasses checks whether a pharmacophore scaffold encoding (combo) is geometrically consistent by verifying that every contributing triangle of binned distances satisfies the triangle inequality. This function is used in the RDKit Pharm2D fingerprinting and pharmacophore-scaffold validation workflow to reject scaffold encodings that cannot correspond to a valid set of Euclidean distances for the pharmacophore points. Checks the scaffold encoded in combo (a list of binned distance indices) by retrieving all triangle index triples for the pharmacophore point count (via nDistPointDict and GetTriangles) and testing each triangle's three distances (looked up in bins) with BinsTriangleInequality. If any triangle fails the inequality, the scaffold is treated as invalid and the function returns False; if all triangles pass, it returns True.` |
| `rdkit_Chem_Pharm2D_Utils_UniquifyCombinations` | `rdkit.Chem.Pharm2D.Utils.UniquifyCombinations` | `rdkit/Chem/Pharm2D/Utils.py` | `combos: list` | `UniquifyCombinations in rdkit.Chem.Pharm2D.Utils deduplicates a list of combinations by treating each inner combination as an unordered set of elements. This utility is useful in the RDKit Pharm2D context (cheminformatics/pharmacophore 2D utilities) when generating or comparing sets of pharmacophore point combinations or other element combinations where element order does not matter: it returns one representative tuple for each unique collection of elements regardless of their order in the input.` |
| `rdkit_Chem_Pharm3D_EmbedLib_AddExcludedVolumes` | `rdkit.Chem.Pharm3D.EmbedLib.AddExcludedVolumes` | `rdkit/Chem/Pharm3D/EmbedLib.py` | `bm: numpy.ndarray, excludedVolumes: list, smoothIt: bool = True` | `Adds a set of excluded volumes to a bounds matrix used by RDKit's Pharm3D embedding routines. This function is used in pharmacophore modeling and 3D embedding workflows (RDKit Pharm3D) to extend an existing bounds matrix that encodes pairwise distance bounds between features/atoms so that one or more "excluded volume" objects (regions where a ligand atom must not occupy) are represented as additional rows/columns. The returned matrix is a new numpy.ndarray with dtype numpy.float64 and size increased by the number of excluded volumes; the original bm matrix is not modified. This function also assigns the computed matrix index to each ExcludedVolume object by setting its index attribute, and optionally applies triangle smoothing to the resulting bounds matrix to improve consistency for embedding algorithms.` |
| `rdkit_Chem_Pharm3D_EmbedLib_CombiEnum` | `rdkit.Chem.Pharm3D.EmbedLib.CombiEnum` | `rdkit/Chem/Pharm3D/EmbedLib.py` | `sequence: tuple` | `rdkit.Chem.Pharm3D.EmbedLib.CombiEnum generates all combinations that pick one element from each subsequence in a tuple of subsequences. This generator is a small utility used in RDKit's Pharm3D embedding and pharmacophore-related code to enumerate alternative assignments (for example, alternative placements or feature choices) without materializing the full Cartesian product in memory; it yields each combination as a list in the same order as the input subsequences.` |
| `rdkit_Chem_Pharm3D_EmbedLib_DownsampleBoundsMatrix` | `rdkit.Chem.Pharm3D.EmbedLib.DownsampleBoundsMatrix` | `rdkit/Chem/Pharm3D/EmbedLib.py` | `bm: numpy.ndarray, indices: tuple, maxThresh: float = 4.0` | `DownsampleBoundsMatrix removes rows and corresponding columns from a bounds matrix that represent points (typically atom indices or pharmacophore feature indices) that are all farther than a given threshold from a supplied set of reference indices. This function is used in the RDKit Pharm3D embedding pipeline to reduce the size of the pairwise bounds matrix before an O(N^3) bounds-smoothing step, improving performance by excluding atoms/features unlikely to be part of the pharmacophore of interest. This function expects bm to be a 2D square NumPy array containing pairwise distance bounds (for example, upper bounds on inter-atomic distances used in pharmacophore embedding). The indices argument supplies the one or more "core" atomic/feature indices to which distances are compared: any point with at least one bound strictly less than maxThresh to any of these indices is retained; all specified indices are always retained. The threshold comparison uses a strict less-than (<) comparison. The input matrix is not modified in-place: when no rows/columns are removed a copy of bm is returned, and when rows/columns are removed a new reduced NumPy array is returned. The function preserves the dtype of the input bm (it will not implicitly upcast to float64).` |
| `rdkit_Chem_Pharm3D_EmbedLib_ReplaceGroup` | `rdkit.Chem.Pharm3D.EmbedLib.ReplaceGroup` | `rdkit/Chem/Pharm3D/EmbedLib.py` | `match: list, bounds: numpy.ndarray, slop: float = 0.01, useDirs: bool = False, dirLength: float = 2.0` | `ReplaceGroup adds a new point representing the geometric center of a multi-point pharmacophore feature to a copy of an existing bounds matrix and returns the augmented bounds matrix and the index of the inserted center point. This function is used in the Pharm3D embedding utilities of RDKit to convert a feature defined by multiple equivalent points (for example, a ring or symmetric pharmacophore feature) into a single representative point for distance-based embedding and matching. The routine assumes the feature points form a regular polygon and are listed in neighbor order (point i adjacent to i+1 and the last adjacent to the first); it computes an approximate center-to-point and point-to-center distance range from the supplied pairwise bounds, expands those bounds by a fractional slop, applies a geometric scale factor for the polygon-to-center conversion, and writes the resulting distances into a newly allocated bounds matrix. If useDirs is True, an additional â€œdirectionâ€ point is appended after the center point and its pairwise bounds with the center and original points are set using dirLength and slop.` |
| `rdkit_Chem_Pharm3D_EmbedLib_isNaN` | `rdkit.Chem.Pharm3D.EmbedLib.isNaN` | `rdkit/Chem/Pharm3D/EmbedLib.py` | `v: float` | `Detect whether a floating-point value is a NaN (not-a-number) produced by the RDKit C++ layer, using platform-specific heuristics. This function exists to provide an OS-independent interface for detecting NaNs that originate on the C++ side of RDKit (for example, from numerical routines in Chem.Pharm3D embedding code). In RDKit workflows NaNs can indicate failed or invalid numerical results (such as failed 3D coordinate or energy computations) and must be detected so downstream Python code can handle or discard those values. Because Python itself raises a ZeroDivisionError for 1/0 and does not produce the same raw IEEE NaN objects the C++ layer can return, this function applies simple, historically observed checks that differ on Windows and non-Windows platforms to recognize C++-sourced NaNs. Behavior: - On Windows (sys.platform == 'win32') the function returns True when v != v, exploiting the IEEE property that NaN is not equal to itself; otherwise it falls through to return False. - On non-Windows platforms the function returns True when both comparisons v == 0 and v == 1 evaluate to True; this is a platform-specific heuristic present in the original implementation to detect certain C++->Python converted NaN values. If neither platform-specific test matches, the function returns False. - The function performs no mutation and has no side effects other than reading sys.platform and evaluating the given value using Python comparison operators. It does not attempt to construct NaNs in Python; it is intended to inspect values produced by the C++ side of RDKit. - If v is not a Python float, Python's normal comparison semantics apply; comparisons may succeed, return False, or raise exceptions (e.g., TypeError) which will propagate to the caller.` |
| `rdkit_Chem_Scaffolds_MurckoScaffold_MurckoScaffoldSmilesFromSmiles` | `rdkit.Chem.Scaffolds.MurckoScaffold.MurckoScaffoldSmilesFromSmiles` | `rdkit/Chem/Scaffolds/MurckoScaffold.py` | `smiles: str, includeChirality: bool = False` | `rdkit.Chem.Scaffolds.MurckoScaffold.MurckoScaffoldSmilesFromSmiles: Return the Bemis-Murcko scaffold as a SMILES string derived from an input SMILES. This function is part of the RDKit cheminformatics toolkit and is used to extract the Murcko (Bemis-Murcko) scaffold â€” the core ring systems and linker framework of a molecule without side-chain substituents â€” expressed as a SMILES string. It is commonly used in scaffold-based analysis workflows such as scaffold clustering, scaffold-based train/test splitting for machine learning on molecular datasets, and medicinal chemistry analyses where the core topology of molecules is compared. The implementation delegates to MurckoScaffoldSmiles(smiles=smiles, includeChirality=includeChirality), so behavior, performance characteristics, and error propagation follow that underlying routine.` |
| `rdkit_Chem_TorsionFingerprints_CalculateTFD` | `rdkit.Chem.TorsionFingerprints.CalculateTFD` | `rdkit/Chem/TorsionFingerprints.py` | `torsions1: list, torsions2: list, weights: list = None` | `Calculate the torsion deviation fingerprint (TFD) between two sets of torsion angles for conformer comparison. This function is used in the RDKit cheminformatics context to quantify how different two molecular conformations are in terms of their torsion (dihedral) angles. It computes, for each corresponding torsion, the minimal circular angular difference (in degrees) between any representative angles for that torsion in the two conformers, normalizes that difference by a per-torsion normalization factor, and returns an average (or weighted average) of these normalized deviations. This metric can be used as a descriptor/fingerprint for comparing 3D molecular conformations in similarity searches, clustering, or as an input feature for machine-learning models.` |
| `rdkit_Chem_UnitTestPandasTools_getStreamIO` | `rdkit.Chem.UnitTestPandasTools.getStreamIO` | `rdkit/Chem/UnitTestPandasTools.py` | `sdfString: str` | `rdkit.Chem.UnitTestPandasTools.getStreamIO returns an in-memory binary stream (BytesIO) containing the UTF-8 encoded bytes of an SDF (Structure-Data File) string. This helper is used in RDKit unit tests and utility code (for example in UnitTestPandasTools) to provide a file-like binary object that RDKit readers and other code that expect a binary stream can consume without writing to disk.` |
| `rdkit_Chem_UnitTestSurf_readRegressionData` | `rdkit.Chem.UnitTestSurf.readRegressionData` | `rdkit/Chem/UnitTestSurf.py` | `filename: str, col: int` | `Return entries from a regression dataset file bundled with RDKit and used by RDKit unit tests. This generator function opens the file named by filename located in the repository source tree under RDConfig.RDCodeDir/Chem/test_data, reads it line by line, and for each non-comment line yields a _TestData tuple containing the 1-based line number, the SMILES string, the parsed RDKit molecule, and the expected numeric value parsed from column col. It is intended for use in RDKit's unit/regression testing workflows to feed expected values (floats) and molecules (Chem.Mol) into test code that compares computed properties against baseline values stored in the test_data files.` |
| `rdkit_Chem_inchi_InchiToInchiKey` | `rdkit.Chem.inchi.InchiToInchiKey` | `rdkit/Chem/inchi.py` | `inchi: str` | `rdkit.Chem.inchi.InchiToInchiKey: Return the InChIKey for a given InChI string. This function is a thin RDKit Python wrapper around the underlying rdinchi binding that converts a text InChI (IUPAC International Chemical Identifier) into its corresponding InChIKey, a compact hashed identifier commonly used in cheminformatics for indexing, deduplication, database keys, and fast exact matching of chemical structures. The function performs no modification of the input string; it delegates conversion to the rdinchi.InchiToInchiKey implementation and returns its result if the conversion is successful.` |
| `rdkit_Chem_inchi_MolBlockToInchiAndAuxInfo` | `rdkit.Chem.inchi.MolBlockToInchiAndAuxInfo` | `rdkit/Chem/inchi.py` | `molblock: str, options: str = "", logLevel: int = None, treatWarningAsError: bool = False` | `Returns the standard InChI string and the InChI auxInfo for a molecule supplied as an MDL molfile (mol block). This function wraps the rdinchi.MolBlockToInchi call from the RDKit InChI interface to produce a machine-readable chemical identifier (InChI) and the InChI auxInfo (auxiliary layered information used for atom ordering, stereochemistry layers, and other mapping details), which are commonly used in cheminformatics workflows for canonical representation, searching, and interoperability.` |
| `rdkit_Chem_inchi_MolFromInchi` | `rdkit.Chem.inchi.MolFromInchi` | `rdkit/Chem/inchi.py` | `inchi: str, sanitize: bool = True, removeHs: bool = True, logLevel: int = None, treatWarningAsError: bool = False` | `Construct an RDKit molecule (rdkit.Chem.rdchem.Mol) from an InChI string using the RDKit InChI API.` |
| `rdkit_Dbase_DbUtils_GetTypeStrings` | `rdkit.Dbase.DbUtils.GetTypeStrings` | `rdkit/Dbase/DbUtils.py` | `colHeadings: list, colTypes: list, keyCol: str = None` | `rdkit.Dbase.DbUtils.GetTypeStrings returns a list of SQL column type declaration strings constructed from parallel lists of column headings and type descriptors. This function is used by RDKit database utilities (for example, when generating CREATE TABLE column specifications for the RDKit PostgreSQL cartridge and other code that needs textual SQL column definitions). It maps Python type markers in colTypes to SQL type keywords: float -> "double precision", int -> "integer", and any other marker -> "varchar(n)" where n is supplied in the type descriptor.` |
| `rdkit_Dbase_StorageUtils_IndexToRDId` | `rdkit.Dbase.StorageUtils.IndexToRDId` | `rdkit/Dbase/StorageUtils.py` | `idx: int, leadText: str = "RDCmpd"` | `rdkit.Dbase.StorageUtils.IndexToRDId converts an integer index into a canonical RDId string used by RDKit storage utilities and database cartridges to label compounds or records. The function produces a human-readable, fixed-format identifier string with zero-padded 3-digit blocks and a trailing checksum digit; this identifier is suitable for use in cheminformatics workflows (for example, when generating displayable compound IDs or storing/retrieving records in RDKit-backed molecular databases). The format produced is: leadText-xxx-xxx-xxx-y where each "xxx" is a zero-padded three-digit block derived from the integer index and "y" is a single checksum digit computed as the sum of the decimal digits of idx modulo 10. If the index has a nonzero millions component (idx >= 1_000_000), an additional leading millions block (also zero-padded to three digits) is included so the overall identifier can represent values in the millions while preserving the same block semantics.` |
| `rdkit_Dbase_StorageUtils_RDIdToInt` | `rdkit.Dbase.StorageUtils.RDIdToInt` | `rdkit/Dbase/StorageUtils.py` | `ID: str, validate: bool = 1` | `rdkit.Dbase.StorageUtils.RDIdToInt converts a canonical RDId string used in RDKit storage utilities into the integer index that RDKit uses for internal indexing, database keys, and compact numeric representations in molecular storage and retrieval workflows. This function is used in RDKit's database/storage utilities (for example, the molecular database cartridge and other persistence layers) to map human-readable RDId identifiers like "RDCmpd-009-000-009-8" or "RDData_000_009_9" to a single integer index. The conversion treats the components between the first and last dash (or underscore, which is normalized to a dash) as fixed-width 3-digit blocks that form a base-1000 little-endian number: the rightmost interior block is the least significant block (multiplied by 1000^0), the next block to the left is multiplied by 1000^1, and so on. Algorithmic steps: if validation is enabled the function calls ValidateRDId(ID) and raises ValueError("Bad RD Id") if validation fails; underscores are replaced with hyphens; the ID is split on '-' and the tokens between the first and last are parsed in reverse order as decimal integers; the final integer is the sum of term_int * (1000**position) for each term. Typical practical significance: the returned integer is suitable for compact storage, numeric comparisons, indexing, and as a deterministic numeric key derived from the RDId string.` |
| `rdkit_Dbase_StorageUtils_ValidateRDId` | `rdkit.Dbase.StorageUtils.ValidateRDId` | `rdkit/Dbase/StorageUtils.py` | `ID: str` | `rdkit.Dbase.StorageUtils.ValidateRDId validates an RDId string used by RDKit storage/database utilities by checking format and a single-digit checksum (CRC). This function is intended for use in RDKit's cheminformatics and molecular database workflows (for example, the RDKit molecular database cartridge and compound identifiers such as "RDCmpd-000-009-9") to determine whether an identifier conforms to the expected segment structure and checksum rule.` |
| `rdkit_ML_Cluster_Murtagh_ClusterData` | `rdkit.ML.Cluster.Murtagh.ClusterData` | `rdkit/ML/Cluster/Murtagh.py` | `data: list, nPts: int, method: str, isDistData: bool = 0` | `rdkit.ML.Cluster.Murtagh.ClusterData clusters the input data and returns a hierarchical cluster tree used by RDKit for cheminformatics and machine-learning workflows (for example clustering molecular descriptor or fingerprint vectors or clustering by pairwise distances).` |
| `rdkit_ML_Cluster_Resemblance_FindMinValInList` | `rdkit.ML.Cluster.Resemblance.FindMinValInList` | `rdkit/ML/Cluster/Resemblance.py` | `mat: numpy.ndarray, nObjs: int, minIdx: int = None` | `Finds the minimum value in a condensed metric matrix and returns the zero-based pair indices and the minimum value. This function is used in the RDKit ML clustering/ressemblance code to locate the smallest pairwise distance (or resemblance score) when the pairwise values for nObjs objects are stored in a condensed 1-D numpy array (upper-triangle excluding the diagonal). It is typically used during agglomerative clustering or similarity search steps to pick the closest pair of objects (for example, molecules or descriptors) as described by the RDKit ML Cluster Resemblance utilities. The implementation decodes a linear index in the condensed representation into a (row, column) pair with row < column.` |
| `rdkit_ML_Cluster_Resemblance_ShowMetricMat` | `rdkit.ML.Cluster.Resemblance.ShowMetricMat` | `rdkit/ML/Cluster/Resemblance.py` | `metricMat: list, nObjs: int` | `rdkit.ML.Cluster.Resemblance.ShowMetricMat: display a condensed upper-triangular metric matrix as a formatted nObjs-by-nObjs table on standard output. This function is used in the RDKit ML/Clustering Resemblance code to visualize pairwise distances or similarity values computed for nObjs objects during clustering or analysis workflows; it reconstructs the full symmetric display from the condensed 1D storage used by the clustering routines and prints it for human inspection.` |
| `rdkit_ML_Cluster_Standardize_StdDev` | `rdkit.ML.Cluster.Standardize.StdDev` | `rdkit/ML/Cluster/Standardize.py` | `mat: numpy.ndarray` | `rdkit.ML.Cluster.Standardize.StdDev computes a standardized version of an input data array by delegating to the internal statistics routine ML.Data.Stats.StandardizeMatrix. This function is intended for use in RDKit cheminformatics machine-learning and clustering workflows (for example, normalizing descriptor or fingerprint feature matrices prior to clustering or model fitting) and acts as a thin wrapper that forwards the provided numpy.ndarray to the Stats.StandardizeMatrix implementation.` |
| `rdkit_ML_Data_DataUtils_BuildDataSet` | `rdkit.ML.Data.DataUtils.BuildDataSet` | `rdkit/ML/Data/DataUtils.py` | `fileName: str` | `rdkit.ML.Data.DataUtils.BuildDataSet builds an MLData.MLDataSet instance by reading a RDKit-style ".dat" file and parsing the variable metadata and example records needed for cheminformatics machine-learning workflows. The function is intended for use within RDKit's ML utilities to prepare datasets (examples and associated metadata such as variable names, quantile bounds, and point names) for downstream tasks such as descriptor-based modeling, training classifiers/regressors, or similarity analyses.` |
| `rdkit_ML_Data_DataUtils_BuildQuantDataSet` | `rdkit.ML.Data.DataUtils.BuildQuantDataSet` | `rdkit/ML/Data/DataUtils.py` | `fileName: str` | `BuildQuantDataSet constructs an RDKit quantitative machine-learning dataset (MLQuantDataSet) from a .qdat file.` |
| `rdkit_ML_Data_DataUtils_CalcNPossibleUsingMap` | `rdkit.ML.Data.DataUtils.CalcNPossibleUsingMap` | `rdkit/ML/Data/DataUtils.py` | `data: list, order: list, qBounds: list, nQBounds: list = None, silent: bool = True` | `rdkit.ML.Data.DataUtils.CalcNPossibleUsingMap: calculate the number of possible discrete values for each variable in a dataset, using an ordering map and optional quantization bounds. This function is used in RDKit machine-learning and descriptor-processing workflows to determine how many discrete categories each variable can take, either by reading provided quantization bounds or by scanning integer-valued data. The result is commonly used when preparing molecular descriptors or other features for algorithms that require knowledge of categorical cardinality (for example, encoder sizing, histogram binning, or discrete-feature models). This function examines each variable index defined by the ordering map and returns a list of counts corresponding to the number of possible values for that variable. For variables that have an entry in qBounds (a list of quantization buckets), the function uses the length of that entry as the count. For variables without qBounds, the function inspects the dataset values (accessed according to order) and, if all observed values for that variable are integer-valued numbers of one of the recognized numeric types, computes the count as max_integer_value_seen + 1 (interpreting integer values as zero-based categories). Variables that are declared non-quantized via nQBounds (non-zero entry) are excluded from computation and yield the sentinel count produced by the function logic. The function can print diagnostic information when silent is False.` |
| `rdkit_ML_Data_DataUtils_CountResults` | `rdkit.ML.Data.DataUtils.CountResults` | `rdkit/ML/Data/DataUtils.py` | `inData: list, col: int = -1, bounds: list = None` | `rdkit.ML.Data.DataUtils.CountResults counts occurrences of either raw values or binned values taken from a specified column of a tabular dataset. This utility is part of RDKit's ML data utilities and is typically used when preparing descriptor or fingerprint data for machine-learning workflows (for example, computing class/histogram counts of a label column or discretizing a continuous property into bins for model input or analysis).` |
| `rdkit_ML_Data_DataUtils_FilterData` | `rdkit.ML.Data.DataUtils.FilterData` | `rdkit/ML/Data/DataUtils.py` | `inData: list, val: int, frac: float, col: int = -1, indicesToUse: list = None, indicesOnly: bool = 0` | `FilterData filters a dataset to produce a subset in which the fraction of rows whose value in a specified column equals a given target value is approximately equal to a requested fraction. This function is part of RDKit's ML DataUtils and is typically used in cheminformatics machine-learning workflows to balance training or evaluation datasets (for example, balancing active/inactive labels from descriptor or fingerprint tables) by randomly selecting which rows to keep so that a specified class fraction is achieved as closely as possible.` |
| `rdkit_ML_Data_DataUtils_InitRandomNumbers` | `rdkit.ML.Data.DataUtils.InitRandomNumbers` | `rdkit/ML/Data/DataUtils.py` | `seed: tuple` | `rdkit.ML.Data.DataUtils.InitRandomNumbers seeds RDKit's and Python's pseudo-random number generators to produce reproducible stochastic behavior in RDKit's cheminformatics and machine-learning workflows (for example, descriptor and fingerprint generation, conformer generation, 2D/3D molecular operations, and other routines that rely on randomness). This function applies a numeric seed to two global RNG implementations used within RDKit: the RDRandom generator provided by rdkit.RDRandom and the standard library random module. Seeding these global RNGs changes their internal state and therefore affects all subsequent calls that rely on either generator in the current Python process.` |
| `rdkit_ML_Data_DataUtils_TakeEnsemble` | `rdkit.ML.Data.DataUtils.TakeEnsemble` | `rdkit/ML/Data/DataUtils.py` | `vect: list, ensembleIds: tuple, isDataVect: bool = False` | `rdkit.ML.Data.DataUtils.TakeEnsemble extracts a subset of elements from a sequence (vect) according to ensemble member indices (ensembleIds). This utility is used in RDKit's machine-learning data handling to select predictions, feature values, or ensemble member outputs for further processing, evaluation, or storage. When vect is a "data vector" (isDataVect=True) that contains metadata at the first and last positions (for example a molecule identifier or label), those sentinel elements are preserved and the ensemble indices are adjusted to account for the metadata layout.` |
| `rdkit_ML_Data_DataUtils_TextToData` | `rdkit.ML.Data.DataUtils.TextToData` | `rdkit/ML/Data/DataUtils.py` | `reader: list, ignoreCols: list = [], onlyCols: list = None` | `rdkit.ML.Data.DataUtils.TextToData constructs an RDKit MLData.MLDataSet from rows of text, typically produced by a CSV reader or similar line-oriented iterator. This function is used in RDKit's cheminformatics and machine-learning workflows to convert tabular text data (for example, molecular identifiers plus descriptor or target columns produced during descriptor/fingerprint generation) into an MLData.MLDataSet that downstream RDKit ML utilities expect.` |
| `rdkit_ML_Data_Quantize_FindVarMultQuantBounds` | `rdkit.ML.Data.Quantize.FindVarMultQuantBounds` | `rdkit/ML/Data/Quantize.py` | `vals: list, nBounds: int, results: list, nPossibleRes: int` | `FindVarMultQuantBounds finds multiple quantization bounds (cut points) for a single continuous variable so as to maximize information gain for a discrete target. This function is used in RDKit's ML/Data routines when discretizing continuous descriptor or feature values (for example descriptor values computed from molecules) into bins that are informative for a discrete result variable. The routine sorts the input variable together with its associated result codes, identifies valid cut start points, adjusts the requested number of bounds if there are too few candidate boundaries, and searches (via internal helpers) for the set of cuts that yields the highest information gain for the given number of result categories.` |
| `rdkit_ML_Data_Quantize_FindVarQuantBound` | `rdkit.ML.Data.Quantize.FindVarQuantBound` | `rdkit/ML/Data/Quantize.py` | `vals: list, results: list, nPossibleRes: int` | `FindVarQuantBound finds a single-variable quantization boundary and its associated gain by delegating to FindVarMultQuantBounds with a multiplicity of 1. This function is a thin, historical wrapper kept for backwards compatibility in RDKit's ML data quantization utilities; it is used when converting continuous descriptor or feature values (vals) into a single discrete cut (one quantization boundary) for downstream machine-learning tasks such as descriptor binning, simple decision splits, or preprocessing of molecular descriptors.` |
| `rdkit_ML_Data_Quantize_feq` | `rdkit.ML.Data.Quantize.feq` | `rdkit/ML/Data/Quantize.py` | `v1: float, v2: float, tol: float = 1e-08` | `rdkit.ML.Data.Quantize.feq tests whether two floating-point values are equal within a specified absolute tolerance. This routine is used in RDKit's machine-learning and data-quantization code paths to guard against floating-point round-off when comparing descriptor, fingerprint, or other computed scalar feature values.` |
| `rdkit_ML_Data_SplitData_SplitDataSet` | `rdkit.ML.Data.SplitData.SplitDataSet` | `rdkit/ML/Data/SplitData.py` | `data: list, frac: float, silent: int = 0` | `SplitDataSet splits a dataset into two subsets (training and hold-out) for machine-learning workflows in RDKit, typically used when preparing molecular descriptor or fingerprint example lists for model training and evaluation. This function takes a sequence of examples (for example, RDKit-calculated descriptors, fingerprints, or any per-molecule feature objects used in cheminformatics machine learning) and delegates the computation of integer indices to SplitIndices to partition the full index range [0, len(data)). The first returned list contains the examples selected for the "first" partition (commonly used as the training set) and the second returned list contains the remaining examples (commonly used as the hold-out/test set). SplitDataSet preserves the element selection order defined by the index lists returned from SplitIndices. SplitDataSet also emits a short summary message to standard output unless printing is suppressed via the silent parameter.` |
| `rdkit_ML_Data_SplitData_SplitIndices` | `rdkit.ML.Data.SplitData.SplitIndices` | `rdkit/ML/Data/SplitData.py` | `nPts: int, frac: float, silent: bool = 1, legacy: bool = 0, replacement: bool = 0` | `rdkit.ML.Data.SplitData.SplitIndices: Split a set of integer indices (0..nPts-1) representing a dataset into two subsets according to a specified fraction. In RDKit machine-learning workflows this function is used to produce a primary set (commonly used as the training set) and a secondary hold-out set (commonly used as the test/validation set). The function supports three selection modes: (1) default: random permutation then split, (2) legacy: per-index Bernoulli selection using a random float, and (3) replacement: sampling the primary set with replacement.` |
| `rdkit_ML_Data_Stats_FormCorrelationMatrix` | `rdkit.ML.Data.Stats.FormCorrelationMatrix` | `rdkit/ML/Data/Stats.py` | `mat: numpy.ndarray` | `rdkit.ML.Data.Stats.FormCorrelationMatrix forms and returns the Pearson correlation matrix for variables encoded as columns in a 2-D data array. This function is intended for use in RDKit machine-learning and cheminformatics workflows (for example, descriptor or fingerprint analysis and feature-selection preprocessing). Given a 2-D numpy.ndarray where each row is an observation and each column is a variable (descriptor), the function computes the pairwise Pearson correlation coefficient for every variable pair using a direct-sum formula equivalent to the covariance-based Pearson correlation. The implementation computes nVars = len(mat[0]) (number of variables/columns) and N = len(mat) (number of observations/rows), forms an N-by-nVars view of each column and computes sums, sums of squares, and cross-products to produce a symmetric nVars-by-nVars correlation matrix. Diagonal entries will be 1.0 in the absence of zero variance; if a variable has zero sample variance the corresponding correlations (including the diagonal) are set to 0 by this implementation.` |
| `rdkit_ML_Data_Stats_FormCovarianceMatrix` | `rdkit.ML.Data.Stats.FormCovarianceMatrix` | `rdkit/ML/Data/Stats.py` | `mat: numpy.ndarray` | `FormCovarianceMatrix forms and returns the sample covariance matrix for a set of observations represented as a NumPy array. This function is used in RDKit's machine-learning and descriptor workflows to compute covariances between features (for example prior to PCA, feature whitening, or other statistical analyses of molecular descriptors and fingerprints). The implementation centers the input data by subtracting the per-column means (computed over rows/observations) and then computes the unbiased covariance estimator by multiplying the transposed centered data with the centered data and dividing by (nPts - 1).` |
| `rdkit_ML_Data_Stats_MeanAndDev` | `rdkit.ML.Data.Stats.MeanAndDev` | `rdkit/ML/Data/Stats.py` | `vect: list, sampleSD: bool = 1` | `rdkit.ML.Data.Stats.MeanAndDev computes the arithmetic mean and standard deviation of a numeric vector. This function is intended for use in RDKit workflows (for example when processing descriptor or fingerprint vectors for machine learning and normalization tasks) and implements the standard formulas used when summarizing a list of numeric descriptor values.` |
| `rdkit_ML_Data_Stats_PrincipalComponents` | `rdkit.ML.Data.Stats.PrincipalComponents` | `rdkit/ML/Data/Stats.py` | `mat: numpy.ndarray, reverseOrder: bool = 1` | `rdkit.ML.Data.Stats.PrincipalComponents performs a principal components analysis (PCA) on a numeric data matrix by forming a correlation matrix from the input data, computing its eigenvalue decomposition, and returning the eigenvalues and corresponding eigenvectors ordered by magnitude. In the RDKit cheminformatics and machine-learning context described in the project README, this function is intended for use with molecular descriptor or fingerprint matrices to identify dominant variance directions for dimensionality reduction, feature analysis, or as a preprocessing step for downstream ML models.` |
| `rdkit_ML_Data_Stats_R2` | `rdkit.ML.Data.Stats.R2` | `rdkit/ML/Data/Stats.py` | `orig: numpy.ndarray, residSum: float` | `rdkit.ML.Data.Stats.R2 computes the coefficient of determination (RÂ²) for a set of predictions relative to observed target values. In the RDKit machine-learning context (for example when evaluating regression models built from molecular descriptors or fingerprints), this function quantifies the fraction of variance in the observed values that is explained by the model: it implements the common formula RÂ² = 1 - RSS / TSS where RSS is the provided residual sum and TSS is the total sum of squares of the observed values around their mean.` |
| `rdkit_ML_Data_Stats_StandardizeMatrix` | `rdkit.ML.Data.Stats.StandardizeMatrix` | `rdkit/ML/Data/Stats.py` | `mat: numpy.ndarray` | `StandardizeMatrix standardizes a numeric observation-by-feature matrix by subtracting the column-wise means and dividing by the column-wise sample standard deviations. This function is used in RDKit's machine-learning and descriptor-processing workflows (for example, preparing descriptor or fingerprint matrices for downstream modeling) to center each feature (column) to zero mean and scale it to unit variance so that features contribute comparably to distance- or variance-based algorithms.` |
| `rdkit_ML_Data_Stats_TransformPoints` | `rdkit.ML.Data.Stats.TransformPoints` | `rdkit/ML/Data/Stats.py` | `tFormMat: numpy.ndarray, pts: list` | `rdkit.ML.Data.Stats.TransformPoints transforms a set of numeric point vectors by centering them on their centroid and applying a linear transformation matrix. This function is intended for machine-learning and cheminformatics workflows in RDKit (for example, operating on 2D/3D atomic coordinate sets used when computing descriptors or aligning molecular point sets) where a set of points must be zero-centered and multiplied by a transformation matrix.` |
| `rdkit_ML_Descriptors_CompoundDescriptors_GetAllDescriptorNames` | `rdkit.ML.Descriptors.CompoundDescriptors.GetAllDescriptorNames` | `rdkit/ML/Descriptors/CompoundDescriptors.py` | `db: str, tbl1: str, tbl2: str, user: str = "sysdba", password: str = "masterkey"` | `Gets possible descriptor names and their human-readable descriptions from a relational database for use with RDKit machine-learning descriptor workflows. This function connects to a database using rdkit.Dbase.DbConnection.DbConnect and queries two tables: tbl1, which is treated as the source of columns that represent descriptor values (the feature columns used in ML models), and tbl2, which is treated as a lookup table that contains descriptor metadata (columns named 'property' and 'notes' are assumed to exist in tbl2 and are used to form descriptor names and descriptions respectively). The returned values can be used by downstream RDKit descriptor- and fingerprint-based machine-learning pipelines to build feature lists and accompanying documentation for each descriptor.` |
| `rdkit_ML_Descriptors_Parser_AVG` | `rdkit.ML.Descriptors.Parser.AVG` | `rdkit/ML/Descriptors/Parser.py` | `strArg: str, composList: list, atomDict: dict` | `rdkit.ML.Descriptors.Parser.AVG calculates the average (mean) value of a molecular descriptor expression across a supplied composition vector. In the RDKit machine-learning and descriptor generation context, this function is used to convert per-atom descriptor expressions into a single scalar feature for a molecule by weighting per-atom descriptor values by atom counts from a composition list and returning the count-weighted mean. The function expects the descriptor expression to contain the placeholder token "DEADBEEF" which will be replaced by each atom symbol from the composition during evaluation.` |
| `rdkit_ML_Descriptors_Parser_CalcMultipleCompoundsDescriptor` | `rdkit.ML.Descriptors.Parser.CalcMultipleCompoundsDescriptor` | `rdkit/ML/Descriptors/Parser.py` | `composVect: list, argVect: tuple, atomDict: dict, propDictList: list` | `Calculates the numeric value of a user-specified descriptor expression for a list of compounds using per-atom and per-compound descriptor data.` |
| `rdkit_ML_Descriptors_Parser_CalcSingleCompoundDescriptor` | `rdkit.ML.Descriptors.Parser.CalcSingleCompoundDescriptor` | `rdkit/ML/Descriptors/Parser.py` | `compos: tuple, argVect: tuple, atomDict: dict, propDict: list` | `CalcSingleCompoundDescriptor calculates the descriptor value for a single compound by substituting atomic and compound variables into a user-provided expression and evaluating that expression. This function is part of RDKit's ML.Descriptors.Parser pipeline used to generate numeric descriptors for machine-learning workflows (see RDKit descriptors documentation). It expects a composition description, a descriptor specification tuple, a dictionary of per-atom descriptor dictionaries, and a list of per-compound properties, and it returns the evaluated numeric descriptor value for that composition.` |
| `rdkit_ML_Descriptors_Parser_DEV` | `rdkit.ML.Descriptors.Parser.DEV` | `rdkit/ML/Descriptors/Parser.py` | `strArg: str, composList: list, atomDict: dict` | `rdkit.ML.Descriptors.Parser.DEV: calculate the composition-weighted mean absolute deviation of a descriptor expression across a molecular composition. This function computes the average deviation (mean absolute deviation) of a descriptor value defined by a Python expression string across a composition vector. It is intended for use in cheminformatics descriptor generation (RDKit descriptors and fingerprint features for machine learning). The routine first computes the composition-weighted mean by calling MEAN(strArg, composList, atomDict) and then computes the sum over composition entries of the absolute difference between each per-atom descriptor value and that mean, weighted by the atom counts, divided by the total number of atoms in the composition. The descriptor expression is evaluated with Python's eval after substituting the placeholder token 'DEADBEEF' with an atomic symbol from the composition; therefore the expression must evaluate to a numeric value for each atom symbol.` |
| `rdkit_ML_Descriptors_Parser_HAS` | `rdkit.ML.Descriptors.Parser.HAS` | `rdkit/ML/Descriptors/Parser.py` | `strArg: str, composList: list, atomDict: dict` | `rdkit.ML.Descriptors.Parser.HAS determines whether a parsed, atom-substituted expression is present in a composition vector used by RDKit descriptor parsing and machine-learning descriptor generation.` |
| `rdkit_ML_Descriptors_Parser_MAX` | `rdkit.ML.Descriptors.Parser.MAX` | `rdkit/ML/Descriptors/Parser.py` | `strArg: str, composList: list, atomDict: dict` | `rdkit.ML.Descriptors.Parser.MAX computes the maximum value of a per-atom descriptor expression across a molecular composition. This function is used by RDKit descriptor parsing machinery to evaluate a textual descriptor expression for each atom in a supplied composition and return the largest numeric result, which is useful when generating descriptors or features for machine-learning workflows that require an aggregate (maximum) per-molecule value.` |
| `rdkit_ML_Descriptors_Parser_MIN` | `rdkit.ML.Descriptors.Parser.MIN` | `rdkit/ML/Descriptors/Parser.py` | `strArg: str, composList: list, atomDict: dict` | `rdkit.ML.Descriptors.Parser.MIN calculates the minimum numeric value of a descriptor expression across the atoms present in a molecular composition. It is used in the RDKit descriptors/fingerprint generation context to evaluate a per-atom expression for each entry in a composition vector and return the smallest resulting numeric value; this can serve as a feature or descriptor value for machine-learning workflows described in the RDKit README. This function evaluates a Python expression provided as a string for each atom in composList. The expression must include the literal placeholder DEADBEEF which will be replaced by the atom symbol (string) from composList before evaluation. The evaluated results are collected and the minimum of those results is returned. The function relies on Python's eval() to compute the expression, so the expression may reference names available in the current evaluation environment (for example, atomDict if the expression uses that name), and the expression may perform arbitrary computation permitted by eval.` |
| `rdkit_ML_Descriptors_Parser_SUM` | `rdkit.ML.Descriptors.Parser.SUM` | `rdkit/ML/Descriptors/Parser.py` | `strArg: str, composList: list, atomDict: dict` | `rdkit.ML.Descriptors.Parser.SUM: Compute the weighted sum of an evaluated per-atom descriptor expression over a composition vector used in RDKit descriptor generation and machine-learning feature preparation.` |
| `rdkit_ML_InfoTheory_BitRank_AnalyzeSparseVects` | `rdkit.ML.InfoTheory.BitRank.AnalyzeSparseVects` | `rdkit/ML/InfoTheory/BitRank.py` | `bitVects: list, actVals: list` | `AnalyzeSparseVects computes information gains for sparse bit-vector features (SBVs) relative to binary activity labels, returning a per-bit ranking and the list of gain values. This function is used in the RDKit cheminformatics/ML context to score fingerprint bits (sparse bit vectors commonly produced for molecular descriptors) by how informative each bit is for predicting a binary activity, making it useful for feature selection and bit ranking in classification tasks.` |
| `rdkit_ML_InfoTheory_BitRank_CalcInfoGains` | `rdkit.ML.InfoTheory.BitRank.CalcInfoGains` | `rdkit/ML/InfoTheory/BitRank.py` | `bitVects: list, actVals: list, nPossibleActs: int, nPossibleBitVals: int = 2` | `Calculates the information gain for each bit (feature) across a set of samples with associated activity values. This function is part of RDKit's ML.InfoTheory.BitRank utilities and is used in cheminformatics and machine-learning workflows (for example, QSAR and classification on molecular fingerprints) to quantify how much information each fingerprint bit provides about the activity labels. For each bit position shared by the IntVector-like entries in bitVects, the function computes a single numeric information-gain score that can be used for feature ranking or selection.` |
| `rdkit_ML_InfoTheory_BitRank_FormCounts` | `rdkit.ML.InfoTheory.BitRank.FormCounts` | `rdkit/ML/InfoTheory/BitRank.py` | `bitVects: list, actVals: list, whichBit: int, nPossibleActs: int, nPossibleBitVals: int = 2` | `rdkit.ML.InfoTheory.BitRank.FormCounts generates a counts (contingency) matrix for a single fingerprint bit across activity classes; it is used by RDKit's machine-learning/InfoTheory/BitRank utilities to summarize how many occurrences of each bit value co-occur with each activity value when analyzing fingerprint-like integer vectors (IntVectors) for descriptor and fingerprint-based models. This function constructs a 2-D counts matrix with shape (nPossibleBitVals, nPossibleActs) where rows correspond to possible values of the selected bit and columns correspond to possible activity classes. The resulting matrix is typically used for information-theoretic scoring or ranking of fingerprint bits in cheminformatics and machine-learning workflows within RDKit (for example, to compute mutual information or other statistics between bit presence/values and activity labels).` |
| `rdkit_ML_InfoTheory_entropy_PyInfoEntropy` | `rdkit.ML.InfoTheory.entropy.PyInfoEntropy` | `rdkit/ML/InfoTheory/entropy.py` | `results: numpy.ndarray` | `rdkit.ML.InfoTheory.entropy.PyInfoEntropy computes the information-theoretic (Shannon) entropy in bits for a discrete empirical distribution defined by observed counts. This function is part of RDKit's machine-learning/info-theory utilities and is used to quantify the uncertainty or information content of a categorical outcome distribution derived from observed frequencies (for example, when evaluating the distribution of fingerprint hits, descriptor value categories, or class label counts in cheminformatics ML tasks).` |
| `rdkit_ML_InfoTheory_entropy_PyInfoGain` | `rdkit.ML.InfoTheory.entropy.PyInfoGain` | `rdkit/ML/InfoTheory/entropy.py` | `varMat: numpy.ndarray` | `rdkit.ML.InfoTheory.entropy.PyInfoGain computes the information gain (expected reduction in Shannon entropy) for a single discrete variable given a contingency table of observed counts. In the RDKit machine-learning and information-theory utilities this function is used to evaluate how much knowing the value of a chemical descriptor or discrete feature (the variable) reduces uncertainty about an outcome or class label (the result), e.g., during feature selection or decision-tree split evaluation on molecular descriptor/fingerprint data.` |
| `rdkit_ML_MLUtils_VoteImg_BuildVoteImage` | `rdkit.ML.MLUtils.VoteImg.BuildVoteImage` | `rdkit/ML/MLUtils/VoteImg.py` | `nModels: int, data: list, values: list, trueValues: list = [], sortTrueVals: int = 0, xScale: int = 10, yScale: int = 2, addLine: int = 1` | `rdkit.ML.MLUtils.VoteImg.BuildVoteImage constructs a visualization image that encodes the per-model â€œvotesâ€ (outputs) for a set of examples produced by an ensemble of models in RDKit's machine-learning utilities. This function is intended for use in RDKit ML workflows to inspect and present how each model in a composite votes across examples: rows correspond to examples, columns correspond to models, pixel intensities encode vote strengths, and an optional purple vertical separator can mark the model/example boundary. The resulting image is produced using PIL (Pillow) and numpy and is suitable for visual debugging, reporting, or inclusion in ML result summaries.` |
| `rdkit_ML_MLUtils_VoteImg_VoteAndBuildImage` | `rdkit.ML.MLUtils.VoteImg.VoteAndBuildImage` | `rdkit/ML/MLUtils/VoteImg.py` | `composite: list, data: list, badOnly: int = 0, sortTrueVals: int = 0, xScale: int = 10, yScale: int = 2, addLine: int = 1` | `VoteAndBuildImage constructs a visual representation (PIL image) of ensemble voting results produced by a composite model over a set of examples. This function is intended for use in RDKit-based cheminformatics and machine-learning workflows where inspecting how multiple submodels (an ensemble) vote on molecular examples (for example, classification based on descriptors or fingerprints) helps diagnose model behavior, visualize consensus, and identify misclassified examples. The function collects votes from the provided composite model using CollectVotes, prints summary information about the number of models and misclassifications to standard output, and then constructs an image with BuildVoteImage that lays out votes and example labels according to pixel scaling parameters and optional sorting/separation behavior.` |
| `rdkit_ML_SLT_Risk_BurgesRiskBound` | `rdkit.ML.SLT.Risk.BurgesRiskBound` | `rdkit/ML/SLT/Risk.py` | `VCDim: int, nData: int, nWrong: int, conf: float` | `rdkit.ML.SLT.Risk.BurgesRiskBound calculates Burges's formulation of the risk bound (Eqn. 3 in Burges, "A Tutorial on Support Vector Machines for Pattern Recognition", Data Mining and Knowledge Discovery, 1998) and returns an upper bound on the true misclassification risk used in machine-learning analyses (for example SVMs) within the RDKit ML/SLT workflow. This function combines an empirical error term (fraction of misclassified training examples) with a structural risk term derived from the VC-dimension to produce a single scalar risk bound. It is intended for use in statistical learning evaluations (binary classification scenarios, as noted in the original implementation) when one wants a theoretically motivated upper bound on generalization error for a hypothesis class characterized by its VC dimension.` |
| `rdkit_ML_SLT_Risk_CherkasskyRiskBound` | `rdkit.ML.SLT.Risk.CherkasskyRiskBound` | `rdkit/ML/SLT/Risk.py` | `VCDim: int, nData: int, nWrong: int, conf: float, a1: float = 1.0, a2: float = 2.0` | `rdkit.ML.SLT.Risk.CherkasskyRiskBound computes a provable upper bound on the true (generalization) risk of a classifier using the Cherkassky & Mulier formulation (Equations 4.22 and 4.23, Learning From Data, Wiley 1998). This implementation is intended for use in the RDKit ML/SLT risk-bounding utilities to support model evaluation and selection where the VC dimension of a hypothesis class is known or estimated.` |
| `rdkit_ML_SLT_Risk_CristianiRiskBound` | `rdkit.ML.SLT.Risk.CristianiRiskBound` | `rdkit/ML/SLT/Risk.py` | `VCDim: int, nData: int, nWrong: int, conf: float` | `Compute the Cristiani & Shawe-Taylor VC-theory-based risk bound (Theorem 4.6 in "An Introduction to Support Vector Machines" by Cristiani and Shawe-Taylor, Cambridge University Press, 2000). This function implements the same notation used in the book and returns an upper bound on the true classification risk (probability of misclassification on new examples) as the sum of an empirical risk term and a structural (capacity) term derived from the VC dimension.` |
| `rdkit_ML_Scoring_Scoring_CalcAUC` | `rdkit.ML.Scoring.Scoring.CalcAUC` | `rdkit/ML/Scoring/Scoring.py` | `scores: list, col: int` | `Calculates the area under the receiver operating characteristic (ROC) curve (AUC) for a set of scored molecules. This function is part of RDKit's ML/scoring utilities and is used to quantify the performance of a ranking or binary scoring produced for molecules (for example, scores coming from descriptor- or fingerprint-based models). It delegates to CalcROC(scores, col) to compute the ROC curve (an object expected to expose FPR and TPR sequences), then numerically integrates the ROC curve using the trapezoidal rule over false positive rate (FPR) to produce the AUC value. The AUC summarizes classifier performance: higher values indicate better separation between positive and negative classes in the scored list.` |
| `rdkit_ML_Scoring_Scoring_CalcBEDROC` | `rdkit.ML.Scoring.Scoring.CalcBEDROC` | `rdkit/ML/Scoring/Scoring.py` | `scores: list, col: int, alpha: float` | `rdkit.ML.Scoring.Scoring.CalcBEDROC computes the BEDROC (Boltzmann-enhanced discrimination of ROC) score used to quantify "early recognition" performance in virtual screening campaigns, following Truchon & Bayly, J. Chem. Inf. Model. 47, 488-508 (2007). This function expects a ranked list of samples (e.g., molecules) with per-sample data and a column indicating which samples are considered "active" (true positives). It uses an internal RIE (Robust Initial Enhancement) helper to compute the unnormalized enrichment and then normalizes that value to produce the BEDROC score. BEDROC emphasizes retrieval of active compounds at the top of a ranked list and is commonly used in cheminformatics and machine-learning workflows within RDKit to evaluate virtual screening and ranking algorithms.` |
| `rdkit_ML_Scoring_Scoring_CalcEnrichment` | `rdkit.ML.Scoring.Scoring.CalcEnrichment` | `rdkit/ML/Scoring/Scoring.py` | `scores: list, col: int, fractions: list` | `rdkit.ML.Scoring.Scoring.CalcEnrichment determines enrichment factors for ranked scoring results produced in cheminformatics / virtual screening workflows (as used in RDKit machine-learning and scoring contexts). The function computes, for each requested top fraction of the ranked list, the fold-enrichment of actives recovered in that top fraction relative to the expectation from random selection. This is typically used to quantify early-recovery performance of scoring functions or virtual screening models when a boolean active/inactive indicator is stored in a specific column of each score record.` |
| `rdkit_ML_Scoring_Scoring_CalcRIE` | `rdkit.ML.Scoring.Scoring.CalcRIE` | `rdkit/ML/Scoring/Scoring.py` | `scores: list, col: int, alpha: float` | `rdkit.ML.Scoring.Scoring.CalcRIE computes the Robust Initial Enhancement (RIE) enrichment metric used to quantify early-recognition performance of ranking/scoring methods in virtual screening (original definition: Sheridan et al., J. Chem. Inf. Comput. Sci. 2001). The function is part of RDKit's ML/Scoring utilities and is used to evaluate how well a scoring list prioritizes â€œactiveâ€ entries near the top of a ranked list.` |
| `rdkit_ML_Scoring_Scoring_CalcROC` | `rdkit.ML.Scoring.Scoring.CalcROC` | `rdkit/ML/Scoring/Scoring.py` | `scores: list, col: int` | `rdkit.ML.Scoring.Scoring.CalcROC: Compute a Receiver Operating Characteristic (ROC) curve from a list of scored records, producing cumulative true positive and false positive rates at each position in the provided list. This function is intended for use in cheminformatics and ML workflows with RDKit (for example virtual screening or classifier evaluation) where a list of scored samples and a column index indicating active/inactive labels are available; it returns the cumulative TPR and FPR vectors that can be plotted or used to compute AUC.` |
| `rdkit_sping_PDF_pdfdoc_MakeFontDictionary` | `rdkit.sping.PDF.pdfdoc.MakeFontDictionary` | `rdkit/sping/PDF/pdfdoc.py` | `startpos: int, count: int` | `rdkit.sping.PDF.pdfdoc.MakeFontDictionary: Construct and return a PDF font dictionary fragment that maps standard PDF font resource names (/F1, /F2, ...) to PDF indirect object references. This function is used by RDKit's PDF assembly code (sping.PDF.pdfdoc) when generating PDF output for molecular images or other RDKit-generated graphics; it assumes that the font objects already exist in the PDF file as consecutive indirect objects beginning at the given start object number.` |
| `rdkit_sping_PDF_pdfgeom_bezierArc` | `rdkit.sping.PDF.pdfgeom.bezierArc` | `rdkit/sping/PDF/pdfgeom.py` | `x1: float, y1: float, x2: float, y2: float, startAng: float = 0, extent: float = 90` | `rdkit.sping.PDF.pdfgeom.bezierArc: Compute cubic Bezier control points that approximate an elliptical arc inscribed in the rectangle defined by two corner points. This function is used by RDKit's PDF/graphics geometry routines to convert an arc (used when rendering 2D molecular diagrams and other vector graphics) into one or more cubic Bezier segments suitable for PDF or other vector backends that represent curves with Bezier control points. The function interprets (x1, y1) and (x2, y2) as opposite corners of the enclosing rectangle and normalizes them so the returned ellipse fits that rectangle. The coordinate system assumed by the algorithm has X increasing to the right and Y increasing downwards (typical raster/PDF coordinate orientation used by RDKit PDF geometry code). Angles are expressed in degrees, with 0 degrees pointing to the right (positive X axis) and angles increasing counter-clockwise. The arc starts at startAng and spans extent degrees; a negative extent produces a clockwise sweep. For extents whose absolute value exceeds 90 degrees the arc is subdivided into multiple cubic Bezier segments (each covering at most 90 degrees) to maintain the standard approximation accuracy used in RDKit's PDF geometry code. The returned list contains one tuple per cubic Bezier segment; each tuple has eight floats (x1, y1, x2, y2, x3, y3, x4, y4) representing the start point, the two control points, and the end point of that segment in that order. These coordinates are in the same coordinate system used by the inputs and are ready to be consumed by RDKit's PDF drawing routines or any other renderer that accepts cubic Bezier segments.` |
| `rdkit_sping_PDF_pdfmetrics_parseAFMfile` | `rdkit.sping.PDF.pdfmetrics.parseAFMfile` | `rdkit/sping/PDF/pdfmetrics.py` | `filename: str` | `rdkit.sping.PDF.pdfmetrics.parseAFMfile parses an Adobe Font Metrics (AFM) file and returns a fixed-size array of character widths used by RDKit's PDF generation code to measure and lay out text. This is an ultra-crude, permissive parser intended to extract numeric widths from the "StartCharMetrics" / "EndCharMetrics" section of an AFM file so higher-level PDF routines can compute text extents when creating PDF output.` |
| `rdkit_sping_PDF_pdfutils_cacheImageFile` | `rdkit.sping.PDF.pdfutils.cacheImageFile` | `rdkit/sping/PDF/pdfutils.py` | `filename: str` | `Processes an image file for PDF embedding and writes a cached, Flate-compressed, Ascii85-encoded image file alongside the original image file. This function is part of RDKit's sping.PDF.pdfutils utilities and is used to prepare image data for inclusion in PDF content streams. It opens the image at the given filename using the Python Imaging Library (PIL), converts the image to RGB, extracts raw image bytes, compresses them with zlib (Flate), encodes the compressed bytes with an Ascii Base85 encoder, formats simple PDF inline image tokens (BI, ID, EI) and a minimal image dictionary (/W, /H, /BPC, /CS, /F) and writes the result to a sidecar file with the same base name and an ".a85" extension. The produced .a85 file is intended as a cached representation that can be embedded into PDF streams by other pdfutils code to avoid repeated reprocessing of the original image.` |
| `rdkit_sping_PDF_pdfutils_cachedImageExists` | `rdkit.sping.PDF.pdfutils.cachedImageExists` | `rdkit/sping/PDF/pdfutils.py` | `filename: str` | `rdkit.sping.PDF.pdfutils.cachedImageExists determines whether a cached ASCII85-encoded image file (.a85) exists for a given file and whether that cached file is at least as new as the original file. This function is used by RDKit's PDF utilities (sping.PDF.pdfutils) to avoid regenerating embedded images when a previously created, encoded cache is available and up-to-date for PDF composition of cheminformatics visualizations. The function derives the cache file path by replacing the original file's extension with ".a85" (using os.path.splitext) and checks the filesystem for that cached file. It compares modification timestamps (os.stat(...)[8], the st_mtime field in the os.stat_result sequence) of the original and cached files. The function performs only read/query operations on the filesystem (no writes) and therefore has no side effects beyond filesystem access. Typical failure modes are that os.stat on the original filename will raise an OSError (for example if the original file does not exist or permissions prevent access); such exceptions are not caught within this function and will propagate to the caller. If the cached file is absent, the function returns 0.` |
| `rdkit_utils_chemutils_ConfigToNumElectrons` | `rdkit.utils.chemutils.ConfigToNumElectrons` | `rdkit/utils/chemutils.py` | `config: str, ignoreFullD: bool = 0, ignoreFullF: bool = 0` | `Counts the number of electrons appearing in an electronic configuration string used in RDKit cheminformatics utilities. This function is used in RDKit code paths that need a simple integer count of valence electrons extracted from an electronic configuration string (for example in heuristics for valence checking, bonding, or charge handling). The implementation parses a space-separated configuration string, sums integer superscript counts from each orbital token after the first token, and optionally ignores full d or f shells when those shells appear and meet the exact fullness criteria used in the code. There are no external side effects; the function returns an integer electron count computed from the input string.` |
| `rdkit_utils_chemutils_GetAtomicData` | `rdkit.utils.chemutils.GetAtomicData` | `rdkit/utils/chemutils.py` | `atomDict: dict, descriptorsDesired: list, dBase: str = "/opt/conda/share/RDKit/Data/atomdb.gdb", table: str = "atomic_data", where: str = "", user: str = "sysdba", password: str = "masterkey", includeElCounts: int = 0` | `GetAtomicData pulls atomic property descriptors from an RDKit atomic database and populates a provided dictionary with per-atom descriptor dictionaries keyed by atomic name. This function is used within the RDKit cheminformatics library to load atomic data (for example, electronic configuration strings and numeric descriptors) from a local database file into an in-memory mapping that downstream code (descriptor calculators, fingerprint generators, machine-learning featurizers) can query. The function connects to a database using rdkit.Dbase.DbModule.connect, issues a SQL SELECT for the requested descriptor columns, and for each row creates a dictionary of descriptor-name: value entries which it stores into the supplied atomDict under the atom NAME. If includeElCounts is nonzero, additional valence electron count fields (NVAL, NVAL_NO_FULL_F, NVAL_NO_FULL_D, NVAL_NO_FULL) are computed from the atomic CONFIG string using ConfigToNumElectrons and added to each atom entry.` |
| `rdkit_utils_chemutils_SplitComposition` | `rdkit.utils.chemutils.SplitComposition` | `rdkit/utils/chemutils.py` | `compStr: str` | `SplitComposition parses a simple chemical composition string into an ordered list of element/count pairs suitable for lightweight stoichiometry and descriptor preprocessing in cheminformatics workflows (RDKit context). The function is intended for very simple, flat composition strings (for example 'Fe3Al') and returns a sequence of element symbols with their associated counts that can be consumed by code that computes elemental contributions, simple composition-based descriptors, or stoichiometric checks. This parser uses a fixed regular expression that recognizes an uppercase letter followed by an optional lowercase letter as the element symbol and an optional numeric portion (digits and optional decimal point) as the count. The numeric portion, when present, is converted to a floating-point value; when absent the count is reported as the integer 1. The method does not modify external state and returns a new list; it is not intended to parse complex chemical formula syntax such as parentheses, hydration/dot notation, charges, isotopic labels, nested groups, or other annotations.` |
| `rdkit_utils_listutils_CompactListRepr` | `rdkit.utils.listutils.CompactListRepr` | `rdkit/utils/listutils.py` | `lst: list` | `CompactListRepr provides a compact, human-readable string representation of a sequence by collapsing consecutive identical elements into run-length notation. This function is part of rdkit.utils.listutils and is intended as a small utility within the RDKit cheminformatics toolkit to make lists that frequently occur in cheminformatics workflows (for example, atom index lists, fingerprint bit arrays, or descriptor sequences) easier to inspect in logs, debugging output, or textual summaries.` |

## âš–ï¸ License

Original Code License: BSD-3-Clause

Wrapper Code & Documentation: Apache-2.0

*This file was automatically generated on February 26, 2026.*
