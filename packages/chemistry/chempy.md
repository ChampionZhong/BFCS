# chempy

[üîô Back to Main Repo](../../../README.md) | [üîó Original Repo](https://github.com/bjodah/chempy)

![Tool Count](https://img.shields.io/badge/Agent_Tools-45-blue?style=flat-square)
![Category](https://img.shields.io/badge/Category-Chemistry-green?style=flat-square)
![Status](https://img.shields.io/badge/Import_Test-Passed-success?style=flat-square)

## üìñ Overview

ChemPy is a Python library for physical/inorganic/analytical chemistry that provides tools to model chemical kinetics and equilibria (including multiphase systems), evaluate common physical-chemistry relations, and compute literature-based thermophysical properties.

> **Note**: This documentation lists the **agent-ready wrapper functions** generated for this package. These functions have been strictly typed, docstring-enhanced, and tested for import stability within a standardized Apptainer environment.

## üõ†Ô∏è Available Agent Tools

Below is the list of **45** functions optimized for LLM tool-use.

| **Tool Name (Wrapper)**   | **Source**          | **File Path**     | **Arguments (Type)**        | **Description**                |
| ------------------------- | ------------------- | ----------------- | --------------------------- | ------------------------------ |
| `chempy__util_intdiv` | `chempy._util.intdiv` | `chempy/_util.py` | `p: int, q: int` | `Integer division which rounds toward zero. Performs integer division of two integers p (numerator) and q (denominator) and returns the integer quotient with truncation toward zero. This differs from Python's floor division operator (//), which rounds toward negative infinity for negative operands; intdiv corrects that behavior so that results are the mathematical truncation of the exact quotient. In the ChemPy codebase this function is useful in contexts that require integer arithmetic with truncation semantics, for example when scaling or normalizing integer stoichiometric coefficients, distributing discrete counts, or computing signed integer indices where rounding toward zero is the intended domain behavior. The function has no side effects and its result is deterministic and constant-time for typical Python integer operations.` |
| `chempy__util_prodpow` | `chempy._util.prodpow` | `chempy/_util.py` | `bases: list, exponents: numpy.ndarray` | `chempy._util.prodpow computes the elementwise product of several numeric bases raised to corresponding exponents. In the context of ChemPy this is typically used to form mass-action style products such as ‚àè_i [A_i]^{ŒΩ_i} encountered in equilibrium expressions and rate laws, where "bases" are the factors (for example concentrations or activity coefficients) and "exponents" are the stoichiometric or power coefficients. This function converts the provided exponents to a NumPy array and then computes bases ** exponents using NumPy broadcasting rules, finally multiplying along the last axis. For example, prodpow([2, 3], np.array([[0, 1], [1, 2]])) yields array([3, 18]) corresponding to [2**0 * 3**1, 2**1 * 3**2].` |
| `chempy_chemistry_equilibrium_quotient` | `chempy.chemistry.equilibrium_quotient` | `chempy/chemistry.py` | `concs: numpy.ndarray, stoich: list` | `chempy.chemistry.equilibrium_quotient: Calculate the equilibrium quotient Q for a chemical equilibrium from per-substance concentrations and stoichiometric coefficients. In chemical equilibrium modeling (see ChemPy README examples for equilibria and pH calculations), the equilibrium quotient is the product of each species concentration raised to its stoichiometric coefficient; this function computes that product for a single concentration vector or for multiple concentration sets (batched) and is therefore used when evaluating reaction quotients, comparing to equilibrium constants K, or computing pH and speciation. This function accepts a numpy.ndarray of concentrations or any object with a 1-D semantics (no ndim attribute or ndim == 1) representing a single set of per-substance concentrations. If a 2-D numpy.ndarray is provided, it is interpreted as a collection of independent concentration sets with shape (n_sets, n_substances) and the function returns a numpy.ndarray of length n_sets with the quotient for each set. The stoichiometric coefficients are applied elementwise: each concentration is raised to the power given by the corresponding stoichiometric coefficient and all terms are multiplied together. No in-place modification of inputs is performed.` |
| `chempy_kinetics_arrhenius_fit_arrhenius_equation` | `chempy.kinetics.arrhenius.fit_arrhenius_equation` | `chempy/kinetics/arrhenius.py` | `T: float, k: numpy.ndarray, kerr: numpy.ndarray = None, linearized: bool = False, constants: dict = None, units: dict = None` | `Curve fitting of the Arrhenius equation to measured rate-constant data. This function is used within chemical kinetics workflows to estimate the Arrhenius parameters for a reaction from measured rate constants at given temperatures. In the domain of physical chemistry (see README: "Arrhenius & Eyring equation"), the Arrhenius equation is k(T) = A * exp(-Ea / (R * T)), where A is the pre-exponential factor and Ea is the activation energy. fit_arrhenius_equation calls an internal fitter (_fit) with the Arrhenius model and provides transforms so that the fitted parameter vector p corresponds to the linearized model coefficients p[0] = ln(A) and p[1] = -Ea / R. The provided parameter transforms convert the fitted p into physically meaningful Arrhenius parameters: A = exp(p[0]) and Ea = -p[1] * R, where R is obtained via _get_R(constants, units).` |
| `chempy_kinetics_eyring_fit_eyring_equation` | `chempy.kinetics.eyring.fit_eyring_equation` | `chempy/kinetics/eyring.py` | `T: float, k: numpy.ndarray, kerr: numpy.ndarray = None, linearized: bool = False, constants: dict = None, units: dict = None` | `Curve fit of the Eyring equation to experimental rate-constant data to obtain linear-fit parameters and derived activation parameters used in chemical kinetics (activation enthalpy and entropy). This function is used in physical/chemical kinetics contexts (see ChemPy README section "Arrhenius & Eyring equation") to fit the Eyring form k(T) = (kB T / h) exp(DeltaS‚Ä°/R) exp(-DeltaH‚Ä°/(R T)) to measured rate constants and to provide the correspondence between the fitted linear model and the thermochemical parameters.` |
| `chempy_kinetics_integrated_binary_irrev` | `chempy.kinetics.integrated.binary_irrev` | `chempy/kinetics/integrated.py` | `t: numpy.ndarray, kf: float, prod: float, major: float, minor: float, backend: str = None` | `chempy.kinetics.integrated.binary_irrev: Analytic product transient for an irreversible 2-to-1 bimolecular reaction. Computes the time-dependent concentration of the product for an irreversible second-order reaction where two reactant molecules (one major and one minor species) form a single product. This function implements the closed-form integrated rate expression used in the chempy kinetics utilities and integrated-rate fitting routines. The implementation uses a backend arithmetic library obtained via get_backend(backend) (defaulting to the numpy backend when backend is None) so the result can be numeric (array-like or scalar) or symbolic (e.g. when using a SymPy backend) depending on the inputs and backend.` |
| `chempy_kinetics_integrated_binary_irrev_cstr` | `chempy.kinetics.integrated.binary_irrev_cstr` | `chempy/kinetics/integrated.py` | `t: numpy.ndarray, k: float, r: float, p: float, fr: float, fp: float, fv: float, n: int = 1, backend: str = None` | `Analytic solution for the transient concentrations in a continuous stirred-tank reactor (CSTR) undergoing the irreversible bimolecular reaction 2 A -> n B. This function evaluates a closed-form (analytic) solution of the ordinary differential equations that describe a CSTR with a feed and perfect mixing for the reaction 2 A -> n B. The solution is useful when you need rapid, direct evaluation of the time-dependent concentrations of the reactant A and product B without performing numerical integration. The implementation follows the symbolic derivation (see comments in source) and returns concentrations evaluated at the supplied times using the chosen numeric/symbolic backend.` |
| `chempy_kinetics_integrated_binary_rev` | `chempy.kinetics.integrated.binary_rev` | `chempy/kinetics/integrated.py` | `t: float, kf: float, kb: float, prod: float, major: float, minor: float, backend: str = None` | `chempy.kinetics.integrated.binary_rev computes the analytic time-dependent concentration of the product (complex) for a reversible 2-to-1 reaction (A + B <-> AB) using the closed-form solution derived for second-order forward (bimolecular) association and first-order backward (unimolecular) dissociation kinetics. This function is used in chemical kinetics modeling and data analysis (for example when comparing to transient experimental measurements or when supplying an analytic integrated rate expression to fitting routines). It evaluates the same symbolic expression used for derivations in the project (see _integrated.ipynb) but dispatches arithmetic to a numeric or symbolic backend via get_backend(backend), enabling both numeric evaluation (e.g. with NumPy) and symbolic algebra (e.g. with SymPy).` |
| `chempy_kinetics_integrated_pseudo_irrev` | `chempy.kinetics.integrated.pseudo_irrev` | `chempy/kinetics/integrated.py` | `t: float, kf: float, prod: float, major: float, minor: float, backend: str = None` | `chempy.kinetics.integrated.pseudo_irrev: Analytic product transient for an irreversible pseudo first-order reaction used in ChemPy's integrated kinetics utilities. Computes the time-dependent product concentration for an irreversible, bimolecular ‚Üí unimolecular reaction treated under the pseudo-first-order approximation. In this approximation the more abundant reactant (major) is assumed to remain effectively constant, so the bimolecular forward reaction with rate constant kf reduces to first-order kinetics with an effective rate k_eff = major * kf. The function returns the analytic expression prod + minor * (1 - exp(-major * kf * t)), which represents the product (or complex) concentration at time t given the initial concentrations and rate constant. This closed-form expression is useful in kinetics modeling, parameter estimation and fitting of integrated rate laws as described in the ChemPy README's kinetics examples.` |
| `chempy_kinetics_integrated_pseudo_rev` | `chempy.kinetics.integrated.pseudo_rev` | `chempy/kinetics/integrated.py` | `t: numpy.ndarray, kf: float, kb: float, prod: float, major: float, minor: float, backend: str = None` | `Analytic product transient for a reversible pseudo-first-order reaction. Computes the time-dependent concentration of the product/complex for a reversible bimolecular forward and unimolecular backward reaction under the pseudo-first-order assumption (one reactant, "major", is present in large excess and treated as constant). This routine is used in ChemPy's kinetics/integrated rate expressions to produce an explicit analytic expression that can be evaluated for numeric time arrays (e.g. for plotting or fitting) or as a symbolic expression when a symbolic backend is selected. The expression returned corresponds to the solution of A + B <-> C with forward rate kf (bimolecular) and backward rate kb (unimolecular) when [A] ~ major (constant).` |
| `chempy_kinetics_integrated_unary_irrev_cstr` | `chempy.kinetics.integrated.unary_irrev_cstr` | `chempy/kinetics/integrated.py` | `t: numpy.ndarray, k: float, r: float, p: float, fr: float, fp: float, fv: float, backend: str = None` | `chempy.kinetics.integrated.unary_irrev_cstr: Analytic solution for a first-order irreversible reaction A -> B in a continuously stirred tank reactor (CSTR). This function returns the time-dependent, closed-form concentrations for the reactant (A) and product (B) for the first-order irreversible reaction A -> B in a CSTR. It is intended for chemical kinetics modelling, analytical validation of ODE solver results, parameter estimation or integrated rate expression evaluation described in the ChemPy kinetics utilities. The implementation uses a small set of algebraic combinations and exponentials so that the result can be produced either numerically (default numpy backend) or symbolically (e.g., sympy) by supplying a compatible backend.` |
| `chempy_printing_numbers_roman` | `chempy.printing.numbers.roman` | `chempy/printing/numbers.py` | `num: int` | `chempy.printing.numbers.roman converts a positive Python integer to its canonical uppercase Roman numeral representation using common subtractive notation (e.g., 4 -> "IV", 9 -> "IX"). This utility is used by the chempy printing/formatting utilities when a human-readable Roman numeral label is required (for example, in generated text or simple labels in documentation and output related to chemical data). The implementation iterates over fixed Roman tokens and corresponding integer values (M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I) and greedily consumes the input integer to build the output string. The function is pure (no side effects), deterministic, and returns a new string.` |
| `chempy_symmetry_representations_print_header` | `chempy.symmetry.representations.print_header` | `chempy/symmetry/representations.py` | `group: str` | `Print the header line for a character table corresponding to a molecular point group. This function is used in the chempy.symmetry.representations module to produce the header row of a character table for a given point group in Schoenflies notation (used broadly in molecular symmetry, group theory in physical/inorganic chemistry, and representation theory). The header lists the symmetry operation classes in the order required by the character table and prefixes operation symbols with their multiplicity when the class contains more than one equivalent operation (for example, an entry with multiplicity 2 will be rendered as "2X" if the symbol for that class is "X"). The function obtains the operation symbols and multiplicities from the module-level lookup tables headers and column_coeffs using the lowercase form of the provided group key.` |
| `chempy_symmetry_representations_print_mulliken` | `chempy.symmetry.representations.print_mulliken` | `chempy/symmetry/representations.py` | `group: str` | `Print Mulliken symbols of the irreducible representations for a molecular point group. This function is part of ChemPy's symmetry utilities and is used to display the Mulliken notation labels for irreducible representations associated with a point group given in Schoenflies notation (for example, "C2v"). Mulliken symbols are the standard labels used in molecular symmetry and group theory to identify irreducible representations; they are commonly used in spectroscopy, vibrational analysis, and quantum-chemical point-group classification to determine mode symmetries and selection rules. The function looks up a module-level mapping named "mulliken" keyed by lower-cased Schoenflies strings and prints the symbols in the order stored in that mapping.` |
| `chempy_symmetry_representations_print_table` | `chempy.symmetry.representations.print_table` | `chempy/symmetry/representations.py` | `group: str` | `chempy.symmetry.representations.print_table prints a formatted character table for a molecular point group given in Schoenflies notation. This function is used in the ChemPy symmetry utilities to display the character table (symmetry operation headers and Mulliken irreducible-representation labels with their characters) for a point group commonly encountered in molecular and inorganic chemistry. The output is intended for human inspection (e.g., in interactive sessions, documentation, or debugging) and helps chemists and computational chemistry users reason about orbital symmetries, selection rules, and spectroscopic transitions. The function looks up pre-defined module-level dictionaries (headers, mulliken, column_coeffs, row_coeffs, tables) to build the printed table.` |
| `chempy_symmetry_salcs_calc_salcs_func` | `chempy.symmetry.salcs.calc_salcs_func` | `chempy/symmetry/salcs.py` | `ligands: list, group: str, symbols: list, mode: str = "vector", to_dict: bool = False` | `chempy.symmetry.salcs.calc_salcs_func calculates symmetry-adapted linear combinations (SALCs) for a set of ligand atomic orbitals using the symmetry functions from a point group's character table. This function is used in molecular and ligand-field symmetry analysis (as provided by the ChemPy package) to convert geometric information about ligands or outer atoms into symbolic linear combinations of atomic-orbital contributions that transform according to the symmetry functions of a specified point group. The computed SALCs are useful when constructing molecular orbitals, assigning orbital symmetry labels, and analyzing how ligand positions couple to central-atom orbitals in group-theoretical treatments of molecules and crystals. Internally the function optionally converts angle pairs to Cartesian vectors, evaluates each symmetry function from an internal character-table lookup, normalizes the resulting weights, and maps numeric weights onto the supplied SymPy symbols to produce symbolic expressions.` |
| `chempy_symmetry_salcs_calc_salcs_projection` | `chempy.symmetry.salcs.calc_salcs_projection` | `chempy/symmetry/salcs.py` | `projection: list, group: str, to_dict: bool = False` | `Return SALCs (symmetry-adapted linear combinations) using the projection operator method for a specified molecular point group. This function implements the standard projection-operator approach used in molecular symmetry analysis (as in the ChemPy README examples and symmetry utilities). Given the results of applying each symmetry operation to a set of atomic or ligand orbitals (represented by SymPy symbols), calc_salcs_projection constructs the SALCs for every irreducible representation of the specified point group. The practical use is to transform a set of orbital basis functions (one symbol per ligand/outer atom) into linear combinations that transform according to irreducible representations, which is a common step when building molecular orbital models, assigning basis functions in ligand field theory, or setting up symmetry-adapted basis sets for chemical kinetics or equilibrium calculations. Behavior summary: - Expects projection to be the sequence of orbital images produced by applying the group's symmetry operations to a single orbital (one result per group operation), where each element is a SymPy symbol representing a ligand/outer-atom orbital. - Uses the internal character/table data for the point group (Schoenflies notation, case-insensitive) to form projection-operator sums for each irreducible representation, multiplies those characters by the provided projection entries, and sums to produce each SALC. - Calls an internal normalization routine (_normalize_salcs_expr) before returning results so the returned SALC expressions have been put into the expected simplified/normalized form used by the rest of the symmetry module. - If to_dict is True the function returns a mapping from irreducible-representation labels (strings like 'A1', 'E', etc., drawn from the group's table) to the corresponding SALC expression; otherwise it returns the SALCs in the irreducible-representation iteration order used by the group's internal table. - Note: for certain high-symmetry point groups mentioned in the original domain documentation, the projection operator method can produce only one SALC for some representations (for example E and T point groups the canonical projection yields a single SALC entry); this is preserved by the implementation.` |
| `chempy_units_concatenate` | `chempy.units.concatenate` | `chempy/units.py` | `arrays: list, **kwargs` | `chempy.units.concatenate concatenates multiple arrays that carry a unit (quantities) while preserving and returning a single array with the unit of the first input. This function is a patched version of numpy.concatenate adapted for the chempy.units module (which wraps the quantities package). It is intended for chemical-domain workflows where arrays represent measured or computed physical quantities (e.g., time series in seconds, concentration arrays in molar) and it makes it convenient and safe to join such arrays without losing or mismatching units. Behavior: the unit of arrays[0] is taken as the target unit; every element in arrays is converted to that unit using chempy.units.to_unitless before the numeric concatenation is performed with numpy.concatenate. The numeric result is then re-attached to the chosen unit and returned. The original input objects are not modified.` |
| `chempy_units_format_string` | `chempy.units.format_string` | `chempy/units.py` | `value: float, precision: str = "%.5g", tex: bool = False` | `Format a scalar with an associated unit into two strings: a formatted numeric value and a unit representation suitable for display or LaTeX rendering.` |
| `chempy_units_get_derived_unit` | `chempy.units.get_derived_unit` | `chempy/units.py` | `registry: dict, key: str` | `Get the unit for a derived physical quantity from a provided unit registry. This function is part of chempy.units, the small units layer used in ChemPy to check and manipulate units for chemical calculations (kinetics, equilibria, concentration/density handling, radiolytic dose calculations, etc.). It accepts a registry that maps base physical dimensions to unit objects (for example, mapping 'length' to a meter unit, 'mass' to a kilogram unit, and so on) and returns a unit expression for a requested derived quantity (for example, diffusivity -> length**2/time, concentration -> amount/length**3). If registry is None the function returns 1.0 to indicate a unitless context (useful when units are intentionally disabled or unavailable).` |
| `chempy_units_linspace` | `chempy.units.linspace` | `chempy/units.py` | `start: float, stop: float, num: int = 50` | `chempy.units.linspace generates an array of evenly spaced numeric values between two scalar endpoints while preserving and returning the unit associated with the start value. It is analogous to numpy.linspace but integrated with ChemPy's units subsystem (which wraps the quantities package) so the returned array carries the same physical unit as the start argument. This function is useful in chemical modelling workflows (for example creating time grids, temperature ramps, concentration sequences, or other evenly spaced parameter sweeps where units must be tracked consistently).` |
| `chempy_units_logspace_from_lin` | `chempy.units.logspace_from_lin` | `chempy/units.py` | `start: float, stop: float, num: int = 50` | `Logarithmically spaced data points with units preserved. This function is part of chempy.units, which wraps the quantities package for unit-aware numerical work in chemistry (e.g. concentrations, amounts, rates). logspace_from_lin produces an array of values that are evenly spaced in base-2 logarithmic space between two endpoint values. The unit of the returned array is taken from start; stop is converted to that unit before computing the logarithmic spacing. This is useful when sampling a physical quantity (for example, concentration, activity, or pressure) across orders of magnitude while keeping the values' units consistent with the rest of a chempy workflow.` |
| `chempy_units_tile` | `chempy.units.tile` | `chempy/units.py` | `array: numpy.ndarray, *args, **kwargs` | `chempy.units.tile: Tile a numpy.ndarray while preserving and propagating physical units. This function is a patched replacement for numpy.tile that is aware of the units used in chempy.units (the units/wrapping provided around the quantities package referenced in the README). It is used in chemical computations where arrays of values carry an associated physical unit (for example concentration arrays, rate constants, or other property arrays) and a repeated/tiled copy of the array is required while keeping the original unit attached. The function determines the unit from the first element of the input array, converts the entire array to unitless numbers with respect to that unit, performs numpy.tile using the supplied positional and keyword arguments, and finally re-attaches the inferred unit to the tiled numeric result.` |
| `chempy_units_uniform` | `chempy.units.uniform` | `chempy/units.py` | `container: dict` | `Convert a container of quantities with mixed units into a container whose values all share the same unit. This function is part of chempy.units, the units-handling utilities used throughout ChemPy (for example when preparing concentration vectors for kinetics solvers, comparing equilibrium constants, or checking unit consistency for reactions). uniform chooses the unit of the first element in the provided container and converts every element to that unit. The conversion uses the local helpers unit_of(...) to determine the unit of an item and to_unitless(..., unit) to extract a unitless magnitude relative to that unit before reattaching the chosen unit. The function intentionally preserves the mapping/sequence type for dict inputs (it constructs and returns an instance of the original dict-like class) and does not modify the input in place.` |
| `chempy_units_unit_registry_from_human_readable` | `chempy.units.unit_registry_from_human_readable` | `chempy/units.py` | `unit_registry: dict` | `chempy.units.unit_registry_from_human_readable: Deserialize a human-readable unit registry into the internal unit-quantity mapping used by chempy.units. This function is used by ChemPy's units subsystem (which wraps the quantities package) to reconstruct runtime unit objects from a serialized representation suitable for human inspection or storage (for example JSON-like dicts produced when saving configuration or exchanging unit settings). The resulting registry maps SI base keys (the keys iterated from SI_base_registry) to unit quantities used for unit consistency checks and conversions in chemical computations (kinetics, equilibria, properties) as described in the project README.` |
| `chempy_units_unit_registry_to_human_readable` | `chempy.units.unit_registry_to_human_readable` | `chempy/units.py` | `unit_registry: dict` | `chempy.units.unit_registry_to_human_readable converts an internal unit registry used by ChemPy's units subsystem into a human-readable, serializable mapping suitable for JSON-style storage or display. It is used when persisting or inspecting the set of base unit definitions (the SI base keys listed in the module-level SI_base_registry) so that numeric multipliers and unit symbols can be represented as simple Python primitives.` |
| `chempy_util__aqueous_ions_from_formula` | `chempy.util._aqueous.ions_from_formula` | `chempy/util/_aqueous.py` | `formula: str` | `ions_from_formula Parse a chemical formula string to (eventually) produce the constituent ionic species and their stoichiometric counts for use in aqueous/ionic chemistry workflows. This utility is intended for use in ChemPy code paths that need to convert a chemical formula (as typically found in the README examples and in Substance.from_formula) into the ions that the formula represents so that functions working with equilibria, ionic strength, or reaction balancing can operate on ionic species (for example, mapping 'NaCl' -> {'Na+': 1, 'Cl-': 1} or 'Fe(NO3)3' -> {'Fe+3': 1, 'NO3-': 3}). The current source implementation is a placeholder (the function body contains only pass) and therefore does not perform parsing; the docstring documents both the intended behavior and the current behavior so callers understand practical significance and limitations.` |
| `chempy_util__expr_create_Piecewise` | `chempy.util._expr.create_Piecewise` | `chempy/util/_expr.py` | `parameter_name: str, nan_fallback: bool = False` | `create_Piecewise creates a parameterized piecewise expression factory for use in ChemPy expression trees and symbolic/numeric backends. This function returns an Expr factory (produced by Expr.from_callback) that constructs a piecewise expression which selects one of several sub-expressions based on the value of a single runtime parameter. It is intended for use in ChemPy contexts where expressions depend on a single named parameter (for example 'x' in concentration- or position-dependent expressions used in kinetics, equilibria, or property functions). The factory expects a specific sequence encoding alternating interval bounds and expressions (see behavior below). The implementation supports two execution modes: if the provided backend exposes a Piecewise constructor (e.g. a symbolic backend such as SymPy) a symbolic backend.Piecewise expression is returned (with evaluate=False to avoid eager simplification); otherwise a simple numeric selection is performed by iterating the supplied bounds and returning the matching expression. If the runtime parameter is a quantity, bounds are converted to unitless values using the parameter's unit so comparisons are meaningful in unit-aware contexts.` |
| `chempy_util__expr_create_Poly` | `chempy.util._expr.create_Poly` | `chempy/util/_expr.py` | `parameter_name: str, reciprocal: bool = False, shift: str = None, name: str = None` | `Create a polynomial Expression factory for a single scalar parameter. This function is used in ChemPy to build Expr objects (chempy.util._expr.Expr) that evaluate polynomials in a single named scalar parameter ‚Äî for example to represent temperature-dependent empirical fits or other scalar-parameter-dependent property approximations that occur throughout the ChemPy codebase (see README examples for temperature-dependent properties and kinetics). The returned Expr implements a callback that, when called with a sequence of arguments and a mapping of parameter values, evaluates the polynomial sum_{n=0}^{N-1} coeff_n * x0^{n}, where x0 is either the parameter value or a shifted / reciprocal transform of it as specified by the arguments below. The implementation uses successive multiplication (or division for reciprocal polynomials) to build powers efficiently.` |
| `chempy_util__quantities_format_units_html` | `chempy.util._quantities.format_units_html` | `chempy/util/_quantities.py` | `udict: dict, font: str = "%s", mult: str = "&sdot;", paren: bool = False` | `format_units_html returns an HTML-formatted string representation of the units described by the udict mapping. This function is used in ChemPy's units/markup code paths (for example when rendering Substance.html_name or other human-readable HTML output) to convert a units description produced/accepted by the quantities.markup.format_units helper into a small piece of HTML suitable for display in notebooks, web pages, or other HTML-rendering contexts. The conversion preserves semantics of the units (multiplication, exponentiation, compound grouping) while replacing plain-text markers with HTML constructs: exponentiation like m**2 becomes m<sup>2</sup>, the ASCII multiplication operator '*' is replaced by the HTML symbol provided via mult, and an optional wrapper format (font) is applied last. The function depends on quantities.markup.format_units to produce the initial unit string and then post-processes that string with regular-expression replacements.` |
| `chempy_util_parsing_formula_to_composition` | `chempy.util.parsing.formula_to_composition` | `chempy/util/parsing.py` | `formula: str, prefixes: list = None, suffixes: tuple = ('(s)', '(l)', '(g)', '(aq)')` | `Parse a chemical formula string and return its composition as a mapping from atomic number to multiplicity. This function is used in ChemPy to convert human-readable chemical formulae (as found in the README examples and reaction/solution specifications) into a machine-friendly composition dictionary. The composition keys are integer atomic numbers (0 reserved for net charge) and the values are numeric multiplicities aggregated across possible dot-separated parts (hydrates, adducts). The parser ignores specified textual prefixes and physical-state suffixes, supports both the Unicode middle dot (¬∑, U+00B7) and the legacy double-dot ("..") hydrate notation, and handles leading integer multipliers on subsequent parts (e.g., "Na2CO3..7H2O" treats "7" as a multiplier for the water part).` |
| `chempy_util_parsing_formula_to_html` | `chempy.util.parsing.formula_to_html` | `chempy/util/parsing.py` | `formula: str, prefixes: dict = None, infixes: dict = None, **kwargs` | `Convert a chemical formula string into an HTML string representation suitable for display in HTML contexts (for example, in Jupyter notebooks or web pages showing parsed Substance names as in the README). This function is used in ChemPy to render parsed chemical formulas (such as those produced by Substance.from_formula) into readable HTML where stoichiometric numbers are wrapped in <sub> tags and charges in <sup> tags, and where certain textual prefixes/infixes (for example greek letter names or a leading dot) are replaced by HTML entities. Typical use in the project is to produce Substance.html_name or to present formulas in documentation and user interfaces.` |
| `chempy_util_parsing_formula_to_latex` | `chempy.util.parsing.formula_to_latex` | `chempy/util/parsing.py` | `formula: str, prefixes: dict = None, infixes: dict = None, **kwargs` | `Convert a chemical formula string into a LaTeX-ready string fragment suitable for use in reports, notebooks, or publication-quality renderings. This function is used by higher-level ChemPy utilities that present chemical substances (for example Substance.latex_name) and by examples in the README to render molecular formulas with numeric subscripts, charge superscripts, and common textual prefixes/infixes (greek letters, bullets, etc.) while preserving common suffixes such as phase indicators.` |
| `chempy_util_parsing_formula_to_unicode` | `chempy.util.parsing.formula_to_unicode` | `chempy/util/parsing.py` | `formula: str, prefixes: dict = None, infixes: dict = None, **kwargs` | `Convert a chemical formula string into a Unicode-rendered formula suitable for human-readable display. This function takes a chemical formula (for example, 'H2O', 'Fe+3', 'Cl-') and returns a Unicode string where numeric counts are rendered as subscripts, charge signs and magnitudes as superscripts, and known textual prefixes/infixes (such as "alpha" or "." for a middle dot) are replaced by their Unicode equivalents. In the ChemPy codebase this utility is used when generating human-friendly names for parsed substances (for example Substance.unicode_name) and when printing or rendering formulas in logs, UIs, or reports so that chemical notation appears correctly (e.g., 'NH4+' -> 'NH‚ÇÑ‚Å∫', 'Fe(CN)6+2(aq)' -> 'Fe(CN)‚ÇÜ¬≤‚Å∫(aq)').` |
| `chempy_util_periodic_atomic_number` | `chempy.util.periodic.atomic_number` | `chempy/util/periodic.py` | `name: str` | `chempy.util.periodic.atomic_number: Return the atomic number (Z) for a given element specified by name or chemical symbol.` |
| `chempy_util_periodic_mass_from_composition` | `chempy.util.periodic.mass_from_composition` | `chempy/util/periodic.py` | `composition: dict` | `chempy.util.periodic.mass_from_composition: Calculate the molecular mass (molecular weight) from a composition mapping that relates atomic numbers to integer stoichiometric coefficients. This utility is used in ChemPy for tasks that require a molecular weight computed from a parsed or programmatic composition (for example, computing mass fractions, reporting Substance.mass or balancing stoichiometry in reaction systems as shown in the project README).` |
| `chempy_util_pyutil_defaultnamedtuple` | `chempy.util.pyutil.defaultnamedtuple` | `chempy/util/pyutil.py` | `typename: str, field_names: str, defaults: tuple = ()` | `Generates and returns a new named tuple subclass (a lightweight immutable record type) with configurable default values for its trailing fields. This helper wraps collections.namedtuple and then adjusts the generated class's __new__.__defaults__ so that instances can be created with omitted trailing fields supplied from defaults. In the ChemPy codebase this is useful for defining compact, tuple-backed data containers used in chemical modelling (for example, simple spatial/property records such as the Body example in the original docstring: Body(x, y, z, density)), where some attributes commonly have sensible defaults (e.g., density).` |
| `chempy_util_regression_avg_params` | `chempy.util.regression.avg_params` | `chempy/util/regression.py` | `opt_params: numpy.ndarray, cov_params: numpy.ndarray` | `chempy.util.regression.avg_params computes an inverse-variance weighted average of parameter vectors obtained from multiple regression fits and returns both the weighted mean parameters and an estimate of the variance of those averaged parameters. This function is intended for post-processing results from repeated fits (for example, fitting integrated rate expressions or kinetic rate constants across replicate experiments or bootstrap samples) where each fit yields a parameter vector and an associated parameter covariance matrix.` |
| `chempy_util_regression_irls_units` | `chempy.util.regression.irls_units` | `chempy/util/regression.py` | `x: numpy.ndarray, y: numpy.ndarray, **kwargs` | `chempy.util.regression.irls_units is a units-aware wrapper around chempy.util.regression.irls. It accepts numeric data arrays that may carry units (quantities as used in ChemPy's units support), converts them to unitless numbers for the core iterative reweighted least squares fit, and then re-attaches appropriate units to the returned regression coefficients so the results are directly meaningful in chemical/physical applications (for example when x and y represent concentrations, pressures, temperatures, or rates).` |
| `chempy_util_regression_least_squares` | `chempy.util.regression.least_squares` | `chempy/util/regression.py` | `x: numpy.ndarray, y: numpy.ndarray, w: numpy.ndarray = 1` | `chempy.util.regression.least_squares performs a linear least-squares regression (ordinary or weighted) on paired data (x, y) and returns the parameter estimates (intercept and slope), their estimated 2x2 variance-covariance matrix, and the coefficient of determination R2. In the context of ChemPy (see README) this function is a convenience fitting routine that can be used for tasks such as fitting integrated rate expressions or calibrations where a linear relation is appropriate; when measurement variances are known or suspected to be heteroscedastic, the weighting argument w enables weighted least squares (WLS) for more reliable parameter estimates.` |
| `chempy_util_regression_least_squares_units` | `chempy.util.regression.least_squares_units` | `chempy/util/regression.py` | `x: numpy.ndarray, y: numpy.ndarray, w: numpy.ndarray = 1` | `Units-aware least-squares fit for a data series, returning unit-aware parameter estimates, the variance-covariance matrix, and the coefficient of determination. This function is intended for chemistry-related numeric fitting tasks (for example fitting concentration vs time, integrated rate laws, or other measured quantities from the README examples) where the input arrays may carry physical units. The implementation first extracts units from x, y, and optional weights w, converts the numeric data to unitless values for the underlying numerical least-squares solver, and then re-attaches appropriate units to the fitted parameters before returning them. The function validates compatibility between the units of y and the units of w when explicit weights are provided.` |
| `chempy_util_stoich_decompose_yields` | `chempy.util.stoich.decompose_yields` | `chempy/util/stoich.py` | `yields: dict, rxns: list, atol: float = 1e-10` | `Decomposes a target vector of product yields into a linear combination of provided mass-action reactions. This function is used in stoichiometric/kinetic modelling (as in ChemPy) to express a desired production pattern (yields) for a set of chemical species as a linear combination of the net stoichiometric vectors of given Reaction instances. Mathematically it formulates A k = y, where A is the net-stoichiometry matrix (n_species x n_reactions), k is the vector of effective rate coefficients (unknowns), and y is the target yields vector. The computation is performed in a least-squares sense using numpy.linalg.lstsq and returns the effective coefficients that, when combined with the provided reactions, reproduce the yields within a specified absolute tolerance. This is useful when converting non-integer or composite product distributions into contributions from discrete production reactions for downstream kinetic or mass-balance modelling.` |
| `chempy_util_stoich_get_coeff_mtx` | `chempy.util.stoich.get_coeff_mtx` | `chempy/util/stoich.py` | `substances: list, stoichs: list` | `chempy.util.stoich.get_coeff_mtx computes the net stoichiometry coefficient matrix for a set of chemical reactions. It converts a sequence of reaction stoichiometries (each given as a pair of reactant and product dictionaries mapping substance keys to stoichiometric coefficients) into a 2-D integer NumPy array where each row corresponds to a substance and each column corresponds to a reaction. This matrix is the standard coefficient matrix used in balancing stoichiometric equations and in forming linear systems for chemical-equilibrium and reaction-network calculations (for example, as an intermediate in balance_stoichiometry and related routines in ChemPy).` |
| `chempy_util_table_render_tex_to_pdf` | `chempy.util.table.render_tex_to_pdf` | `chempy/util/table.py` | `contents: str, texfname: str, pdffname: str, output_dir: str, save: bool` | `Generates a PDF file by writing LaTeX source to a .tex file and invoking the external pdflatex program twice. This utility is used in ChemPy (for example in table rendering, documentation/examples and generating figures for notebooks or reports) to convert LaTeX-formatted contents into a PDF file using the system pdflatex executable. The function writes the provided LaTeX source to a file named texfname inside output_dir (or a temporary directory if output_dir is None), runs pdflatex two times in batch mode while capturing stdout/stderr to a logfile, and returns the filesystem path to the generated PDF. It also implements configurable post-processing behavior via save to either remove temporary files, keep them, or copy the PDF to another location.` |
| `chempy_util_terminal_limit_logging` | `chempy.util.terminal.limit_logging` | `../../../../../opt/conda/lib/python3.10/contextlib.py` | `max_lvl: int = 50` | `chempy.util.terminal.limit_logging provides a context manager that temporarily raises the global logging threshold to suppress logging messages up to and including a specified numeric level. It is intended for use in ChemPy workflows where noisy log output from numerical integrators, equilibrium solvers, or optional backend libraries (see README: ODE solver front-end, equilibria solvers, and optional backends) should be silenced for clarity during tests, example runs, or user scripts.` |

## ‚öñÔ∏è License

Original Code License: BSD-2-Clause

Wrapper Code & Documentation: Apache-2.0

*This file was automatically generated on February 26, 2026.*
