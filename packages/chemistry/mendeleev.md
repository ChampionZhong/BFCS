# mendeleev

[üîô Back to Main Repo](../../../README.md) | [üîó Original Repo](https://github.com/lmmentel/mendeleev)

![Tool Count](https://img.shields.io/badge/Agent_Tools-23-blue?style=flat-square)
![Category](https://img.shields.io/badge/Category-Chemistry-green?style=flat-square)
![Status](https://img.shields.io/badge/Import_Test-Passed-success?style=flat-square)

## üìñ Overview

`mendeleev` provides a Pythonic API (and optional CLI) for querying the periodic table, letting you access rich data and properties for chemical elements, ions, and isotopes.

> **Note**: This documentation lists the **agent-ready wrapper functions** generated for this package. These functions have been strictly typed, docstring-enhanced, and tested for import stability within a standardized Apptainer environment.

## üõ†Ô∏è Available Agent Tools

Below is the list of **23** functions optimized for LLM tool-use.

| **Tool Name (Wrapper)**   | **Source**          | **File Path**     | **Arguments (Type)**        | **Description**                |
| ------------------------- | ------------------- | ----------------- | --------------------------- | ------------------------------ |
| `mendeleev_econf_get_l` | `mendeleev.econf.get_l` | `mendeleev/econf.py` | `subshell: str` | `Return the orbital angular momentum quantum number for a given subshell label. This function is part of the electronic configuration utilities in the mendeleev.econf module and is used when converting spectroscopic subshell labels (used throughout the package and its electronic configuration tutorials) into the corresponding orbital angular momentum quantum number l. The implementation performs a case-insensitive membership check against the module-level ORBITALS sequence and returns the index of the matching label; this index is the integer l used in electronic-structure related computations, selection-rule checks, and when constructing or parsing electronic configurations.` |
| `mendeleev_econf_get_spin_strings` | `mendeleev.econf.get_spin_strings` | `mendeleev/econf.py` | `sodict: dict, average: bool = True` | `Get per-spin occupation strings for valence subshells. Constructs two parallel sequences that represent the occupation of individual spin-orbitals (alpha and beta spins) across the valence subshells described in sodict. This function is intended for use in mendeleev's electronic-configuration utilities when generating per-spin occupation patterns for valence electrons, for example when preparing data for display, further processing of element electronic configurations, or converting to array form for numerical routines. This should be called for valence only; the function expands each subshell according to its degeneracy as returned by the subshell_degeneracy helper.` |
| `mendeleev_econf_print_spin_occupations` | `mendeleev.econf.print_spin_occupations` | `mendeleev/econf.py` | `sodict: dict, average: bool = True` | `Pretty-print spin occupations for electronic configurations. This function formats and prints the spin-resolved electron occupations for each subshell/orbital given a mapping of occupations. It is intended for use in the electronic-configuration tools of the mendeleev package (see the "Electronic Configuration" tutorial in the README) where human-readable representations of alpha and beta spin occupations are needed for elements, ions, or computed configurations. The function uses subshell degeneracy information (via subshell_degeneracy) to expand or average occupations across degenerate orbitals and prints a one-line alpha and one-line beta representation for each orbital. It also returns the formatted strings so callers can capture the same formatted output programmatically (for example, to build tables or further visualizations).` |
| `mendeleev_econf_shell_capactity` | `mendeleev.econf.shell_capactity` | `mendeleev/econf.py` | `shell: str` | `mendeleev.econf.shell_capactity: Compute the maximum number of electrons that can occupy a named atomic shell label used in electronic configuration calculations. This function is part of the econf (electronic configuration) utilities in the mendeleev package, which provides a Pythonic API for periodic table data and assists in building electronic configurations for atoms and ions (see README tutorials on electronic configuration). The capacity is computed from the principal quantum number n using the physical rule N = 2 * n**2, where n is the shell number (1 for K, 2 for L, etc.). The principal quantum number n is determined by locating the provided shell label in the module-level SHELLS list and using its index (n = SHELLS.index(shell.upper()) + 1). The function accepts case-insensitive shell labels such as "K", "L", "M", ... and returns an integer electron capacity for that shell.` |
| `mendeleev_econf_subshell_capacity` | `mendeleev.econf.subshell_capacity` | `mendeleev/econf.py` | `subshell: str` | `mendeleev.econf.subshell_capacity: Return the maximum number of electrons that can occupy a specified electronic subshell. This function accepts a subshell label string (as used in electronic configuration notation in the mendeleev package, e.g. the subshells that appear in strings like "[Ne] 3s2 3p2") and returns the integer electron capacity of that subshell. The capacity is computed as twice the subshell degeneracy (2 * degeneracy), where "degeneracy" corresponds to the number of distinct magnetic quantum states (m_l orbitals) in the subshell. This value is used throughout the mendeleev package when constructing, validating, or manipulating electronic configurations for elements and ions in the periodic table API.` |
| `mendeleev_econf_subshell_degeneracy` | `mendeleev.econf.subshell_degeneracy` | `mendeleev/econf.py` | `subshell: str` | `mendeleev.econf.subshell_degeneracy returns the degeneracy (number of magnetic sublevels/orbitals) associated with an atomic electronic subshell label. This utility is used in the mendeleev package when working with electronic configurations (see the project's electronic configuration tutorials and API). Internally it obtains the azimuthal quantum number l for the provided subshell label (by calling get_l) and computes the degeneracy as 2*l + 1, which corresponds to the number of distinct magnetic quantum number (m_l) values and therefore the number of orbitals in that subshell. This value is commonly used when parsing or validating electronic configurations, building periodic-table visualizations of orbital occupancy, or computing the maximum number of electrons that a subshell can hold (which is 2 * degeneracy when spin is included).` |
| `mendeleev_electronegativity_allred_rochow` | `mendeleev.electronegativity.allred_rochow` | `mendeleev/electronegativity.py` | `zeff: float, radius: float` | `Calculate the electronegativity of an atom according to the Allred and Rochow definition. This function implements the mathematical core of the Allred & Rochow electronegativity scale as used in the mendeleev package's "Electronegativity scales" utilities. The returned value is the proportional Allred‚ÄìRochow electronegativity computed as zeff / radius**2. In the context of mendeleev, zeff is typically derived from nuclear screening constants or other effective nuclear charge estimates available in the package data tables, and radius should be a corresponding atomic-size value (for example an atomic or covalent radius drawn from the size-related properties in mendeleev). The numerical value and its comparability to literature Allred‚ÄìRochow numbers depend on using consistent radius values and units with the source of zeff.` |
| `mendeleev_electronegativity_cottrell_sutton` | `mendeleev.electronegativity.cottrell_sutton` | `mendeleev/electronegativity.py` | `zeff: float, radius: float` | `mendeleev.electronegativity.cottrell_sutton computes the Cottrell‚ÄìSutton electronegativity (the Allred & Rochow style) for an atom from an effective nuclear charge and an atomic radius. This function is part of the mendeleev package electronegativity scales (Cottrell & Sutton entry) and is used to derive a scalar electronegativity value for comparing elements, visualizing periodic trends, and supplying computed properties for the periodic table API.` |
| `mendeleev_electronegativity_generic` | `mendeleev.electronegativity.generic` | `mendeleev/electronegativity.py` | `zeff: float, radius: float, rpow: float = 1, apow: float = 1` | `mendeleev.electronegativity.generic: Calculate an element's electronegativity using a general power-law formula that combines an effective nuclear charge and an atomic radius. This function implements the formula chi = (Z_eff / r**rpow)**apow where Z_eff is the effective nuclear charge and r is a radius (typically a covalent radius from the mendeleev data tables). It is used within the mendeleev package to derive electronegativity-like, dimensionless indices from elemental properties and can be applied when implementing or comparing different electronegativity scales that depend on effective charge and size.` |
| `mendeleev_electronegativity_gordy` | `mendeleev.electronegativity.gordy` | `mendeleev/electronegativity.py` | `zeff: float, radius: float` | `mendeleev.electronegativity.gordy: Compute the Gordy electronegativity of an atom using effective nuclear charge and atomic radius. Computes a simple Gordy-style electronegativity estimate by dividing the effective nuclear charge by a radius value. This function is part of the mendeleev package electronegativity implementations (see the README electronegativity scales entry for Gordy) and is used by higher-level code and visualizations to produce an electronegativity value for comparing elements and illustrating periodic trends. The result is a scalar float proportional to zeff/radius; the function performs a direct numeric division and does not modify inputs or external state. Users must ensure the radius supplied corresponds to the same radius convention and units used elsewhere in their analysis (for example one of the atomic radius values available in mendeleev data); inconsistent radius units will change the numerical scale of the returned electronegativity.` |
| `mendeleev_electronegativity_interpolate_property` | `mendeleev.electronegativity.interpolate_property` | `mendeleev/electronegativity.py` | `x: int, x_ref: List[int], y_ref: List[float], poly_deg: int = 1` | `Interpolate or extrapolate a numeric property for an element using reference element indices and property values.` |
| `mendeleev_electronegativity_li_xue` | `mendeleev.electronegativity.li_xue` | `mendeleev/electronegativity.py` | `ionization_energy: float, radius: float, valence_pqn: int` | `mendeleev.electronegativity.li_xue computes the electronegativity of an atom or ion according to the Li & Xue definition used in the mendeleev package. It implements the formula used in the source code: n_effective(valence_pqn, source="zhang") * sqrt(ionization_energy / RY) * 100.0 / radius, where RY is the Rydberg energy constant imported in this module and n_effective(...) is computed with the "zhang" prescription.` |
| `mendeleev_electronegativity_martynov_batsanov` | `mendeleev.electronegativity.martynov_batsanov` | `mendeleev/electronegativity.py` | `ionization_energies: List[float]` | `mendeleev.electronegativity.martynov_batsanov: Compute the Martynov & Batsanov electronegativity value (œá_MB) for an element by taking the square root of the arithmetic mean of its valence ionization energies. This implementation is used within the mendeleev package as one of the available electronegativity scales (see the package electronegativity scales including "Martynov & Batsanov" in the README) and is intended to consume the same ionization energy data that the library exposes (for example the element.ionization_energies property). The function implements the formula œá_MB = sqrt((1 / n_v) * sum_{k=1..n_v} I_k) where n_v is the number of valence electrons (the length of the provided list) and I_k are the ionization energies provided in ionization_energies.` |
| `mendeleev_electronegativity_mulliken` | `mendeleev.electronegativity.mulliken` | `mendeleev/electronegativity.py` | `ionization_energy: float, electron_affinity: float` | `mendeleev.electronegativity.mulliken computes the absolute (Mulliken) electronegativity for an element or species by averaging its ionization energy and electron affinity. This function is used in the mendeleev package to provide one of the standardized electronegativity scales (Mulliken) described in the project README and is useful for comparing tendencies of elements to attract electrons when analyzing periodic trends, generating periodic table visualizations, or computing derived chemical descriptors.` |
| `mendeleev_electronegativity_n_effective` | `mendeleev.electronegativity.n_effective` | `mendeleev/electronegativity.py` | `n: int, source: str = "slater"` | `mendeleev.electronegativity.n_effective returns the effective principal quantum number (n*) used by the mendeleev package for approximate atomic orbital and electronegativity calculations. This scalar value is taken from published parameter sets (Slater or Zhang) and is used in empirical formulas that require an effective principal quantum number to represent screening and orbital contraction effects in atoms and ions. This function looks up a published effective principal quantum number for a given principal quantum number and source. The implementation currently supports two named sources: 'slater' and 'zhang'. Slater values are taken from J. A. Pople and D. L. Beveridge, "Approximate Molecular Orbital Theory", McGraw-Hill, 1970. Zhang values are taken from Zhang, Y. (1982). Electronegativities of elements in valence states and their applications. Inorganic Chemistry, 21(11), 3886‚Äì3889. The function performs no I/O and has no side effects beyond returning a numeric value or None; it will raise an exception if an unknown source is requested.` |
| `mendeleev_electronegativity_nagle` | `mendeleev.electronegativity.nagle` | `mendeleev/electronegativity.py` | `nvalence: int, polarizability: float` | `mendeleev.electronegativity.nagle: Compute the Nagle electronegativity from valence electron count and dipole polarizability. This function implements the Nagle definition of electronegativity used in the mendeleev package's collection of electronegativity scales. It is used to derive an element's electronegativity value from two elemental descriptors: the number of valence electrons and the dipole polarizability. The returned scalar is suitable for comparing relative electronegativities across elements in periodic trends, data tables, visualizations, and downstream analyses provided by mendeleev.` |
| `mendeleev_electronegativity_sanderson` | `mendeleev.electronegativity.sanderson` | `mendeleev/electronegativity.py` | `radius: float, noble_gas_radius: float` | `mendeleev.electronegativity.sanderson computes Sanderson's electronegativity for an element using the ratio of a hypothetical noble-gas radius and the element's radius raised to the third power; this function is part of the mendeleev package's set of electronegativity scales used to analyse periodic trends and to supply values for visualization and data tables described in the project's README.` |
| `mendeleev_fetch_fetch_ionic_radii` | `mendeleev.fetch.fetch_ionic_radii` | `mendeleev/fetch.py` | `radius: str = "ionic_radius"` | `Fetch a pandas.DataFrame of ionic radii for all elements and ions available in the package data. This function, mendeleev.fetch.fetch_ionic_radii, is used by the mendeleev package to retrieve size-related properties (ionic radii and crystal radii) from the internal "ionicradii" data table (part of the mendeleev data assets). It is intended for downstream analysis and visualization of element and ion size trends (for example, comparing radii across coordination numbers or plotting periodic trends) and returns a pivoted table keyed by atomic number and ionic charge with coordination numbers as columns.` |
| `mendeleev_mendeleev_get_attribute_for_all_elements` | `mendeleev.mendeleev.get_attribute_for_all_elements` | `mendeleev/mendeleev.py` | `attribute: str` | `Return a list of values for a single attribute for all elements stored in the mendeleev element database. This function is used within the mendeleev package (a Pythonic periodic table of elements) to extract one column of element data (for example "atomic_number", "name", "atomic_weight", "thermal_conductivity" or any other property documented in the README data sections) from the underlying SQL-backed element table and return those values in a simple Python list ordered by increasing atomic number. Practical uses include preparing a column of values for bulk analysis, plotting periodic trends, building custom periodic-table visualizations, or exporting a single property for all elements.` |
| `mendeleev_mendeleev_ids_to_attr` | `mendeleev.mendeleev.ids_to_attr` | `mendeleev/mendeleev.py` | `ids: list, attr: str = "atomic_number"` | `Convert element identifiers (atomic numbers, atomic symbols, or English element names) to a list of attribute values for the corresponding Element objects from the mendeleev periodic-table API. This function is used in the mendeleev package to map user-supplied element identifiers into concrete element properties that are commonly used when accessing the periodic table data programmatically (for example in the CLI, tutorials, or when preparing data for pandas/bokeh visualizations). It resolves identifiers via the package's element() helper, obtains the requested attribute from each resolved Element using getattr, and returns the attribute values in a list preserving the input order. The default attribute is "atomic_number", which yields a list of atomic numbers for the provided identifiers.` |
| `mendeleev_models_fetch_by_group` | `mendeleev.models.fetch_by_group` | `mendeleev/models.py` | `properties: List[str], group: int = 18` | `mendeleev.models.fetch_by_group retrieves specified Element attributes for every element in a given periodic-table group.` |
| `mendeleev_models_with_uncertainty` | `mendeleev.models.with_uncertainty` | `mendeleev/models.py` | `value: float, uncertainty: float, digits: int = 5` | `mendeleev.models.with_uncertainty formats a numeric value together with its measurement uncertainty into a human-readable string using scientific notation conventions commonly used in the mendeleev package (for printing element properties, isotope masses, atomic weights and other numeric material/chemical properties in CLI, tables and web views).` |
| `mendeleev_utils_coeffs` | `mendeleev.utils.coeffs` | `mendeleev/utils.py` | `a: int, b: int = 2` | `mendeleev.utils.coeffs: Compute integer stoichiometric coefficients for a binary compound from two oxidation states. Computes the smallest integer ratio of atoms for two elements (or ions) required to balance their charges when forming a binary compound. This function is used within the mendeleev package to convert integer oxidation states (as found in element data and periodic-table-based computations) into stoichiometric coefficients by computing the least common multiple (LCM) of the two oxidation states and dividing by each oxidation state. The implementation uses lcm = abs(a * b) // math.gcd(a, b) and returns lcm // a, lcm // b. The returned pair corresponds to the multiplicities of the first and second element, in that order, as determined directly from the provided oxidation states.` |

## ‚öñÔ∏è License

Original Code License: MIT

Wrapper Code & Documentation: Apache-2.0

*This file was automatically generated on February 26, 2026.*
